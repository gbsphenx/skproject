#include <string.h> // memset

#include <ints.h>
#include <uikeybd.h>

#include <dm2debug.h>

// ########
// KEYBOARD
// ########

 // from Allegro KEY to index - table 511:46e

i16 keytab[128] = {

  0x0,

  // 0x1...0x19 = A - Z

  0x1e, 0x30, 0x2e, 0x20, 0x12, 0x21, 0x22,
  0x23, 0x17, 0x24, 0x25, 0x26, 0x32, 0x31,
  0x18, 0x19, 0x10, 0x13, 0x1f, 0x14, 0x16,
  0x2f, 0x11, 0x2d, 0x15, 0x2c,

  // 0x1b...0x24 = 0 - 9
  0xb, 2, 3, 4, 5, 6, 7, 8, 9, 0xa,

  // 0x25...0x2e
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // 0x2f...0x3a  F1 - F12
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  // 0x3b ESC
  0x1,

  // 0x3c...0x4b
  0, 0, 0,

  // 0x3f backspace
  0xe,

  // 0x40...0x4b
  0, 0, 0,

  // 0x43 ENTER
  0x1c,

  // 0x44...0x4b
  0, 0, 0, 0, 0, 0, 0, 0,

  // 0x4c ins
  0x124b,
  // 0x4d del
  0x124d,
  // 0x4e...0x51
  0, 0, 0, 0,

  // 0x52 cursor left
  0x104b,
  // 0x53 cursor right
  0x104d,
  // 0x54 cursor up
  0x1048,
  // 0x55 cursor down
  0x1050,

  // 0x56...0x5f
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// #################################################################

c_keybd dm2keybd;

void c_keybd::init(void)
{
	SPX_DEBUG_PRINT("KEYBD:INIT\n");
  queueidx_in = 0;
  queueidx_out = 0;
  queuecnt = 0;

  memset(kbdqueue, sizeof(kbdqueue), 0);
}

// was sub_3249 driver_kbdqueue_pop
i16 c_keybd::getkey(void)
{
  while (queuecnt == 0); // loops!!!
  i16 key = kbdqueue[queueidx_out];
  queueidx_out = (queueidx_out + 1) % KBD_QUEUE_LENGTH;
  queuecnt--;
  return key;
}

// was driver sub_31DC, driver_keyboardint_T1
// was calling sub_2E61 which called sub_2E33.
// both are obsolete now, code direct implemented here.
void c_keybd::putkey(i16 keycode)
{
  keycode = keytab[keycode & wcon(0x7f)]; // added

  if (queuecnt < KBD_QUEUE_LENGTH)
  {
    kbdqueue[queueidx_in] = keycode;
    queueidx_in = (queueidx_in + 1) % KBD_QUEUE_LENGTH;
    queuecnt++;
  }
}

// #################################################################

// was DM2_keybd_476d_05a9 TODO tell SPX new name
bool DM2_HAS_KEY(void)
{
// was driver-function 2 only, calling driver_forceint2d()
// Note: because there is still nothing that sets DRVb_timer_disabled,
// the condition is ever false
  return dm2keybd.queuecnt != 0;
}

// was DM2_keybd_476d_050e TODO tell SPX new name
i16 DM2_GETKEY_TRANSLATED(void)
{
  while (!DM2_HAS_KEY());

  // driver function 1 bridged here
  i16 wval = dm2keybd.getkey();

  if (wval < wcon(0x104d))
  {
    if (wval < wcon(0x1048))
      return wval;
    else if (wval == wcon(0x1048))
      return 0x4c;
    if (wval == lcon(0x104b))
      return 0x4b;
    return wval;
  }
  else if (wval == wcon(0x104d))
    return 0x4d;
  else if (wval < wcon(0x124b))
  {
    if (wval == lcon(0x1050))
      return 0x50;
    return wval;
  }
  else if (wval == wcon(0x124b))
    return 0x4f;
  else if (wval == wcon(0x124d))
    return 0x51;
  return wval;
}

i8 DRVB_table1[0x80] = {
0x00, 0x1b, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x2d, 0x3d, 0x08, 0x09,
0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6f, 0x70, 0x5b, 0x5d, 0x0d, 0x00, 0x61, 0x73,
0x64, 0x66, 0x67, 0x68, 0x6a, 0x6b, 0x6c, 0x3b, 0x27, 0x60, 0x00, 0x5c, 0x7a, 0x78, 0x63, 0x76,
0x62, 0x6e, 0x6d, 0x2c, 0x2e, 0x2f, 0x00, 0x2a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2d, 0x34, 0x35, 0x36, 0x2b, 0x31,
0x32, 0x33, 0x30, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}; // 0x46e

i8 DRVB_table2[0x80] = {
0x00, 0x1b, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5e, 0x26, 0x2a, 0x28, 0x29, 0x5f, 0x2b, 0x08, 0x09,
0x51, 0x57, 0x45, 0x52, 0x54, 0x59, 0x55, 0x49, 0x4f, 0x50, 0x7b, 0x7d, 0x0d, 0x00, 0x41, 0x53,
0x44, 0x46, 0x47, 0x48, 0x4a, 0x4b, 0x4c, 0x3a, 0x22, 0x7e, 0x00, 0x7c, 0x5a, 0x58, 0x43, 0x56,
0x42, 0x4e, 0x4d, 0x3c, 0x3e, 0x3f, 0x00, 0x2a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2d, 0x34, 0x35, 0x36, 0x2b, 0x31,
0x32, 0x33, 0x30, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
}; // 0x4ee

// pulled driver function 0x1b (sub_32AF) request_keycode
i16 DM2_keybd_476d_05b6(i16 wn)
{
  if ((wn & 0x1000) != 0)
    wn = 0;

  i8 bn = (wn & wcon(0x200)) == 0 ? DRVB_table1[wn & wcon(0x7f)] : DRVB_table2[wn & wcon(0x7f)];
  ui16 uw = mkuw(bn);

  if (uw != 0 && (wn & 0x400) != 0)
    uw &= 0x1f;
  return uw;
}
