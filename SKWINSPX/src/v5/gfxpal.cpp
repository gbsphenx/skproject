#include <skwinapp.h>
//#include <skalegro.H>
#include <sktypes5.h>
#include <util.h>
#include <gfxpal.h>

#include <stdio.h>

#ifdef __DJGPP__
#undef outportb
#include <dos.h>
#endif // __DJGPP__

// NEEDS: TODO
void wait_for_vsync(void); // -> addon.h TODO

//extern DM2_COLOR mypal[256];
DM2_COLOR mypal[256];

#define DMFCOL   (255.0 / 63.0)  // factor from 6bit to 8bit - color

c_palettedata paldat;

void color_to_palettecolor(t_palette* pal, e_color c) { pal->c = c; }
void ui8_to_palettecolor(t_palette* pal, ui8 c) { pal->c.p = c; }
ui8 palettecolor_to_ui8(t_palette pal) { return pixel_to_ui8(pal.c); }
c_pixel256 palettecolor_to_pixel(t_palette pal) { c_pixel256 pix; pix = pal.c; return pix; }

void t_palette::conv(const t_colconv* colconv)
{
  ui8_to_palettecolor(this, colconv[c.mkidx()].p);
}

i8 DMPAL[3 * 256] = {
0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x07, 0x04, 0x00, 0x0a, 0x06, 0x00, 0x0e, 0x08, 0x01, 0x11,
0x0a, 0x01, 0x15, 0x0c, 0x01, 0x18, 0x0e, 0x02, 0x1d, 0x12, 0x04, 0x21, 0x16, 0x06, 0x26, 0x19,
0x08, 0x2a, 0x1d, 0x0a, 0x2e, 0x21, 0x0c, 0x32, 0x25, 0x0e, 0x36, 0x29, 0x10, 0x3b, 0x2d, 0x12,
0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x05, 0x02, 0x06, 0x07, 0x03, 0x09, 0x0a, 0x04, 0x0c, 0x0d,
0x05, 0x0f, 0x0f, 0x06, 0x12, 0x12, 0x08, 0x16, 0x16, 0x09, 0x1b, 0x1b, 0x0b, 0x20, 0x1f, 0x0c,
0x25, 0x24, 0x0e, 0x2a, 0x28, 0x10, 0x30, 0x2d, 0x11, 0x35, 0x31, 0x13, 0x3a, 0x36, 0x15, 0x3f,
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x09, 0x00, 0x00, 0x0c, 0x00,
0x00, 0x0f, 0x00, 0x00, 0x12, 0x00, 0x00, 0x15, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x1f, 0x00, 0x00,
0x25, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x35, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x3f,
0x00, 0x00, 0x00, 0x01, 0x01, 0x04, 0x02, 0x03, 0x08, 0x04, 0x05, 0x0c, 0x05, 0x07, 0x10, 0x07,
0x09, 0x14, 0x08, 0x0b, 0x19, 0x0a, 0x0d, 0x1d, 0x09, 0x13, 0x21, 0x07, 0x1a, 0x25, 0x06, 0x20,
0x2a, 0x05, 0x26, 0x2e, 0x04, 0x2c, 0x32, 0x02, 0x33, 0x37, 0x01, 0x39, 0x3b, 0x00, 0x3f, 0x3f,
0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x08, 0x07, 0x05, 0x0d, 0x0b, 0x07, 0x11, 0x0f, 0x0a, 0x16,
0x13, 0x0d, 0x1a, 0x17, 0x0f, 0x1e, 0x1b, 0x12, 0x23, 0x1f, 0x15, 0x27, 0x23, 0x17, 0x2d, 0x2b,
0x1b, 0x33, 0x32, 0x1e, 0x36, 0x35, 0x23, 0x39, 0x37, 0x27, 0x3c, 0x3a, 0x2c, 0x3f, 0x3c, 0x31,
0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x04, 0x07, 0x04, 0x06, 0x0b, 0x06, 0x08, 0x0f, 0x08, 0x0a,
0x12, 0x0a, 0x0c, 0x16, 0x0c, 0x0e, 0x1a, 0x0e, 0x11, 0x1e, 0x11, 0x14, 0x23, 0x14, 0x18, 0x27,
0x18, 0x1c, 0x2c, 0x1c, 0x20, 0x31, 0x20, 0x24, 0x36, 0x24, 0x27, 0x3a, 0x27, 0x2b, 0x3f, 0x2b,
0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x02, 0x05, 0x02, 0x03, 0x08, 0x03, 0x04, 0x0b, 0x04, 0x05,
0x0e, 0x05, 0x08, 0x14, 0x08, 0x05, 0x18, 0x08, 0x02, 0x1c, 0x08, 0x00, 0x20, 0x08, 0x01, 0x22,
0x0e, 0x02, 0x25, 0x15, 0x04, 0x28, 0x1c, 0x0b, 0x2d, 0x1f, 0x12, 0x32, 0x22, 0x19, 0x37, 0x26,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00, 0x00, 0x09, 0x00, 0x00,
0x0b, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x12, 0x00, 0x00, 0x16, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x1f,
0x00, 0x00, 0x24, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x34, 0x00, 0x00, 0x39, 0x00, 0x00, 0x3f, 0x00,
0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x08, 0x08, 0x00, 0x0c, 0x0c, 0x00, 0x11, 0x11, 0x00, 0x15,
0x15, 0x00, 0x19, 0x19, 0x00, 0x1d, 0x1d, 0x00, 0x22, 0x22, 0x00, 0x26, 0x26, 0x00, 0x2a, 0x2a,
0x00, 0x2e, 0x2e, 0x00, 0x33, 0x33, 0x00, 0x37, 0x37, 0x00, 0x3b, 0x3b, 0x00, 0x3f, 0x3f, 0x00,
0x00, 0x00, 0x00, 0x04, 0x03, 0x00, 0x08, 0x06, 0x00, 0x0c, 0x09, 0x00, 0x11, 0x0c, 0x00, 0x15,
0x0f, 0x00, 0x19, 0x12, 0x00, 0x1d, 0x15, 0x00, 0x22, 0x18, 0x00, 0x26, 0x1c, 0x00, 0x2a, 0x1f,
0x00, 0x2e, 0x22, 0x00, 0x33, 0x25, 0x00, 0x37, 0x28, 0x00, 0x3b, 0x2b, 0x00, 0x3f, 0x2e, 0x00,
0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x08, 0x04, 0x00, 0x0c, 0x06, 0x00, 0x11, 0x09, 0x00, 0x15,
0x0b, 0x00, 0x19, 0x0d, 0x00, 0x1d, 0x0f, 0x00, 0x22, 0x12, 0x00, 0x26, 0x14, 0x00, 0x2a, 0x16,
0x00, 0x2e, 0x18, 0x00, 0x33, 0x1b, 0x00, 0x37, 0x1d, 0x00, 0x3b, 0x1f, 0x00, 0x3f, 0x22, 0x00,
0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x08, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x11, 0x00, 0x00, 0x15,
0x00, 0x00, 0x19, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x22, 0x00, 0x00, 0x26, 0x00, 0x00, 0x2a, 0x00,
0x00, 0x2e, 0x00, 0x00, 0x33, 0x00, 0x00, 0x37, 0x00, 0x00, 0x3b, 0x00, 0x00, 0x3f, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0x01, 0x00, 0x04, 0x02, 0x00, 0x06, 0x03, 0x00, 0x08,
0x03, 0x00, 0x0b, 0x05, 0x01, 0x0d, 0x06, 0x01, 0x10, 0x07, 0x01, 0x13, 0x08, 0x02, 0x16, 0x0a,
0x02, 0x19, 0x0c, 0x04, 0x1b, 0x0e, 0x05, 0x1e, 0x11, 0x07, 0x21, 0x13, 0x08, 0x24, 0x15, 0x0a,
0x00, 0x00, 0x00, 0x04, 0x03, 0x02, 0x08, 0x06, 0x04, 0x0d, 0x09, 0x07, 0x11, 0x0c, 0x09, 0x15,
0x0f, 0x0b, 0x1a, 0x12, 0x0e, 0x1e, 0x15, 0x10, 0x22, 0x18, 0x12, 0x27, 0x1b, 0x15, 0x2b, 0x1e,
0x17, 0x2f, 0x21, 0x19, 0x34, 0x24, 0x1c, 0x37, 0x29, 0x1f, 0x3b, 0x2e, 0x22, 0x3f, 0x33, 0x26,
0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x05, 0x05, 0x04, 0x08, 0x08, 0x06, 0x0b, 0x0b, 0x09, 0x0e,
0x0e, 0x0b, 0x11, 0x11, 0x0d, 0x14, 0x14, 0x10, 0x18, 0x18, 0x14, 0x1c, 0x1c, 0x18, 0x20, 0x20,
0x1c, 0x24, 0x24, 0x20, 0x28, 0x28, 0x24, 0x2c, 0x2c, 0x28, 0x30, 0x30, 0x2c, 0x34, 0x34, 0x30,
0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x07, 0x07, 0x07, 0x0a, 0x0a, 0x0a, 0x0d,
0x0d, 0x0d, 0x0f, 0x0f, 0x0f, 0x14, 0x14, 0x14, 0x18, 0x18, 0x18, 0x1c, 0x1c, 0x1c, 0x24, 0x24,
0x24, 0x28, 0x28, 0x28, 0x2c, 0x2c, 0x2c, 0x32, 0x32, 0x32, 0x39, 0x39, 0x39, 0x3f, 0x3f, 0x3f
};

void c_palettedata::init(void)
{
  palette = NULL;
  pal16to256ptr = NULL;
  for (int i = 0; i < PAL16; i++)
    color_to_palettecolor(&small_palette[i], E_COL00);
  glbl_pal1 = NULL;
  glbl_pal2 = NULL;
  DRVb_immediate_colors = true; // byte_at(ADR511B(0xfc)) != 0;
}

// was sub_2372
// from DM - palette to screencolors.
// conversion from 6 to 8 bit components
void driver_setcolors(void)
{
  DM2_COLOR mcol[PAL256];

  i8* bptr = DMPAL;

//	printf("driver_setcolors mcol %08X / %08X / mypal %08X\n", mcol, bptr, mypal);	

  for (i16 wi = 0; wi < PAL256; wi++)
  {
    mcol[wi].r = *bptr++ * DMFCOL;
    mcol[wi].g = *bptr++ * DMFCOL;
    mcol[wi].b = *bptr++ * DMFCOL;
  }

  for (int k = 0; k < 1000; k++) // fade to new palette
  {
    for (i16 wi = 0; wi < PAL256; wi++)
    {
      mypal[wi].r = mcol[wi].r * k / 1000.0;
      mypal[wi].g = mcol[wi].g * k / 1000.0;
      mypal[wi].b = mcol[wi].b * k / 1000.0;
    }
    wait_for_vsync();
  }
}

// was SKW_44c8_1baf, TODO: tell SPX new name
// driver subroutine exploded:
// copies the selected palette to DMPAL
// DM2 shifts the 8 - bit - colors of an alpha - palette >> 2 to the DM - palette
void DM2_CONVERT_DRIVERPALETTE(ui8* pb)
{
  i8* bptr = DMPAL;

//	printf("DM2_CONVERT_DRIVERPALETTE %08X / %08X\n", pb, bptr);

  for (i16 wi = 0; wi < PAL256; wi++)
  {
    pb++; // alphabyte

    ui8 ubcol = *pb++;
    ubcol >>= 2;
    *bptr++ = ubcol;

    ubcol = *pb++;
    ubcol >>= 2;
    *bptr++ = ubcol;

    ubcol = *pb++;
    ubcol >>= 2;
    *bptr++ = ubcol;
  }

  if (paldat.DRVb_immediate_colors)
    driver_setcolors();

  // ddat.v1e0080 = 1;
  // did return ddat.v1e0080
}

extern SkWinApp* skWinApplication;	// in GFXMAIN.cpp
// set = 0 or 1
void DM2_SELECT_PALETTE_SET(i16 set)
{
  DM2_COLOR mcol[PAL256];
  int i = 0;

  i8 bmode = mkb(set);

  /// SPX
  X8 xPalWin[256][3];


  printf("DM2_SELECT_PALETTE_SET mode = %d / mypal = %08X\n", bmode, mypal);
  if (bmode == 0)
  {
    for ( i = 0; i < PAL256; i++) // backup palette
      mcol[i] = mypal[i];

    for (int k = 1000; k > 0; k--) // fade to black
    {
      for ( i = 0; i < PAL256; i++)
      {
        mypal[i].r = mcol[i].r * k / 1000.0;
        mypal[i].g = mcol[i].g * k / 1000.0;
        mypal[i].b = mcol[i].b * k / 1000.0;

      }
      wait_for_vsync();
      wait_for_vsync();

	  // SPX
  	  for ( i = 0; i < PAL256; i++)
	  {
		xPalWin[i][0] = mcol[i].r;
		xPalWin[i][1] = mcol[i].g;
		xPalWin[i][2] = mcol[i].b;

	  }

	}
  }
  else if (bmode == 1) {
    driver_setcolors();

		// SPX
	  for ( i = 0; i < PAL256; i++)
	  {
		xPalWin[i][0] = mypal[i].r;
		xPalWin[i][1] = mypal[i].g;
		xPalWin[i][2] = mypal[i].b;

	  }

  }

//  printf("SET VRAM PALETTE :: DM2 PAL = %08X\n", xPalWin);
  skWinApplication->setRGBPalette((X8*)xPalWin);
#ifdef __DJGPP__
	outportb(0x03c8, 0);
	for (int i = 0; i < PAL256; i++)
	{
		outportb(0x03c9, ((unsigned char)mcol[i].r)>>2);
		outportb(0x03c9, ((unsigned char)mcol[i].g)>>2);
		outportb(0x03c9, ((unsigned char)mcol[i].b)>>2);

//		outportb(0x03c9, ((unsigned char)mcol[i].r));
//		outportb(0x03c9, ((unsigned char)mcol[i].g));
//		outportb(0x03c9, ((unsigned char)mcol[i].b));
	
	}
#endif

  paldat.DRVb_immediate_colors = bmode == 1;
}

void DM2_UPDATE_BLIT_PALETTE(t_palette* palette)
{
  paldat.pal16to256ptr = palette;
}

// this one is extracted from another routine
t_palette* DM2_xlat_palette(t_palette* palette, const t_colconv* convtable, i16& colors)
{
  i16 n = colors;
  if (n > 0)
  {
    while (--n >= 0)
      palette[n].conv(convtable);
  }
  else
  {
    colors = PAL256;
    DM2_COPY_LARGE_PALETTE(palette, convtable);
  }
  return palette;
}
