#include <StdAfx.h>	// Required for MVC6 compilation

#include <SkCodeParam.h>
#include <SkWinDebug.h>
#include <SkGlobal.h>
#include <SkWinCore.h>
#include <SkWinMIDI.h>

//--- Common part with A.cpp
#define UseAltic 1

using namespace DMEncyclopaedia;
using namespace DM2Internal;
using namespace kkBitBlt;

#if defined(_USE_MFC80) || defined(_USE_MFC60)
#include "SkWinMFC.h"
#include "resource.h"
#endif // defined(_USE_MFC80) || defined(_USE_MFC60)


#ifdef _USE_SDL
#include "SkwinSDL.h"
#endif // _USE_SDL

#include "allegro5/allegro5.h"
#include "allegro5/allegro_audio.h"
#include "allegro5/allegro_acodec.h"

#include <_4976_03a2.h>	// for dAITableGenuine (hard coded AI table)
//--- Common part with A.cpp

#if DM2_EXTENDED_MODE == 1
	#define CREATURE_AI_TAB_SIZE	64
#else
	#define CREATURE_AI_TAB_SIZE	42
#endif // DM2_EXTENDED_MODE



// SPX: Functions supposed for MIDI playing from SKWIN_DM2_PCDOS
/*
#define MIDIPATHNAME "./DATA/%02x.hmp.mid"

void c_midi::do_music(i16 nr)
{
  char songname[30];
  sprintf(songname, MIDIPATHNAME, nr);
  thesong = load_midi(songname);
  if (thesong)
    play_midi(thesong, true); // true means: looped
}

void c_midi::stop_music(void)
{
  if (thesong)
  {
    destroy_midi(thesong);
    thesong = NULL;
  }
}

void c_midi::set_midi_volume(i16 v)
{
  set_volume(-1, v);
}

void c_midi::init_midi(void)
{
  allegro_init();
  if (install_sound(-1, MIDI_AUTODETECT, NULL) != 0)
    throw(THROW_DMABORT);
  set_midi_volume(128);
}

static void R_4FF39(x16 eaxw)
{
  if (eaxw < con(0x8))
  {
    ddata.v1da374[eaxw].w4 = con(0x0);
    ddata.v1da374[eaxw].l0 = con(0x0);
  }
}

static void DM2DOS_R_B65(void)
{
  if (ddata.v1d14c2 && ddata.v1d14d0)
  {
    // R_50012(ddata.v1dff2c); // DM's MIDI extracted
    DM2DOS_R_4FF39(ddata.v1dff2c);
    ddata.v1d14d0 = false;
    ddata.v1d14cc = false;
    ddata.v1d14ca = con(0x0);
  }
}

static void DM2DOS_R_A0E(x8 eaxb)
{
  x8 vb_00;

  vb_00 = eaxb;
  if (ddata.v1d14c2 && vb_00 != 0 && ddata.v1dff86 > con(0x0))
  {
    DM2DOS_R_B65();
    if (dm2sound.sndptr6 == NULL)
      return;
    x32 longrg1 = SKW_QUERY_GDAT_ENTRY_IF_LOADABLE(con(0x4), CUTLX8(con(0x3)), con(0x0), vb_00) ? 1 : 0;
#if 1 // TODO
    dm2sound.stop_music();
#endif
    if (longrg1 == con(0x0))
      return;
#if 1 // TODO
    dm2sound.do_music(unsignedword(vb_00));
    return;
#else
  $  x32 longrg6 = unsignedlong(SKW_QUERY_GDAT_ENTRY_DATA_LENGTH(con(0x4), con(0x3), con(0x0), vb_00));
  $  SKW_COPY_MEMORY(SKW_QUERY_GDAT_ENTRY_DATA_PTR(con(0x4), con(0x3), con(0x0), vb_00), longrg6, dm2sound.sndptr6);
  $  ddata.v1dfea8 = DSZERO;
  $  ddata.v1dfea4 = dm2sound.sndptr6;
  $  ddata.v1dfeb0 = con(0x0);
  $  ddata.v1dfeac = con(0x0);
  $  parl01 = DSZERO;
  $  parp00 = &ddata.v1dff2c;
  $  RG2P = ddata.v1d1378;
  $  RG1P = &ddata.v1dfea4;
  $  RG1L = con(0x0); // was calling R_4F75E, result 0x0 or 0xe
  $  ddata.v1dff34 = RG1L;
  $  if (RG1L != con(0x0)) return;
  $  RG1L = ddata.v1dff2c;
  $  RG1L = con(0x0); // TODO old call of R_4FF83, result can be con(0xb) to, removed, MIDI!!
  $  ddata.v1dff34 = RG1L;
  $  if (RG1L != con(0x0)) return;
  $  RG1L = ddata.v1dff2c;
  $  // R_520C3(RG1L, con(0x7f)); // DM's MIDI stuff extracted
  $  RG1L = ddata.v1dff2c;
  $  // R_51F94(RG1L); // DM's MIDI stuff extracted
  $  ddata.v1d14d4 = true;
  $  ddata.v1d14d0 = true;
#endif
  }
//M_B27:
#if 0
$  ddata.v1d14d8 = unsignedword(vb_00);
#endif
//M_A05:
}

void DM2DOS_R_BA7(x16 eaxw)
{
  if (!ddata.v1d14c2 || !ddata.v1d14da)
    return;
  if (ddata.v1d14cc)
  {
    // DM2DOS_R_51D42(ddata.v1dff2c);  DM's MIDI stuff extracted. TODO: check what it wants to do here
    ddata.v1d14cc = false;
  }
  x32 longrg1 = signedlong(ddata.v1d14ca);
  if (longrg1 <= con(0x1))
  {
    if (longrg1 == con(0x1))
    {
      ddata.v1d1512 = ddata.v1dff8a;
      DM2DOS_R_A0E(ddata.v1d1512);
      ddata.v1d14ca = con(0x0);
      return;
    }
  }
  else
  {
    // DM2DOS_R_520C3(ddata.v1dff2c, unsignedlong(CUTX8(ddata.v1d14ca)); // DM's MIDI stuff extracted TODO: check what it wants to do here
    ddata.v1d14ca--;
  }
  ddata.v1dff8a = table1410ec[eaxw];
  if (ddata.v1d1512 != ddata.v1dff8a)
  {
    if (!ddata.v1d14d0 || ddata.v1d14ca != con(0x0))
      DM2DOS_R_A0E(ddata.v1dff8a);
    else
      ddata.v1d14ca = con(0x7f);
    ddata.v1d1512 = ddata.v1dff8a;
  }
}
*/

// SPX: New procedures here

X16
SkWinCore::EXTENDED_LOAD_SPELLS_DEFINITION(void)
{
//#if DM2_EXTENDED_MODE == 1
	if (SkCodeParam::bUseDM2ExtendedMode)
	{
		U8 di = 0;
		U8 index = 0;
		U8 category = GDAT_CATEGORY_SPELL_DEF;
		for (index = 0; index < MAXSPELL_CUSTOM-1; index++)	// MAXSPELL_CUSTOM = 255, but the value 255 is kept for the default.
		{
			U8 spellname[0x80];
			di = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x01); // Test if RUNE01 is used
			if (di != 0)
			{
				U8 *rc = QUERY_GDAT_TEXT(category, index, 0x18, spellname);
				U8 rune2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x02);
				U8 rune3 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x03);
				dSpellsTableCustom[index].dw0 = (MkssymVal(di, rune2, rune3));
				dSpellsTableCustom[index].difficulty = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x04);
				dSpellsTableCustom[index].requiredSkill = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x05);
				U8 type = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x06);
				U8 result = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0x07);
				dSpellsTableCustom[index].w6 = 0x0000 + (type & 0x0F) + ((result & 0x3F)<<4);

				dSpellsTableCustom[index].spellValue = result;

				SkD((DLV_TWEET, "Tweet: Loading spell %d (%02X) with %s (t:%s, d:%d, s:%s, v:%d)\n", index, index, spellname,
					getSpellTypeName(type), dSpellsTableCustom[index].difficulty, getSkillName(dSpellsTableCustom[index].requiredSkill),
					dSpellsTableCustom[index].SpellCastIndex()));
				
			}
		}
		//--- Note: Due to extended structure of SpellDefinition in extended mode, the original spell tables must be adapted to this value
		for (index = 0; index < MAXSPELL_ORIGINAL-1; index++)
		{
			dSpellsTable[index].spellValue = U8((dSpellsTable[index].w6 >> 4)&0x3f);
		}
		return 1;
	}
//#endif
	return 0;
}


X16 SkWinCore::EXTENDED_LOAD_AI_DEFINITION(void)
{
	int rc = 0;
	U8 index = 0;
	// SPX: If not extended, load the default table from static data / OR if dungeon selected is skullkeep (security because AI is not in GDAT currently)
	if (!SkCodeParam::bUseDM2ExtendedMode || skwin.dung == 4 || skwin.dung == 5)
	{
		//&_4976_03a2[res * 0x0024]
		//memcpy(dAITable, _4976_03a2, 62 * 36);
		memcpy(dAITable, dAITableGenuine, MAXAI * 36);

		//int r = memcmp(_4976_03a2, dAITableGenuine, 36 * 62);
		//ATLASSERT(r == 0);
		rc = 0;

		// SPX: Add the cast FIREBALL to the Amplifier AI
		if (SkCodeParam::bUseFixedMode)
		{
			dAITable[51].AttacksSpells |= AI_ATTACK_FLAGS__FIREBALL;
			//dAITable[51].w0 = 0x40;
			// Amplifier must remain static object, or it loses its moveable ability.
		}

	}
	else if (SkCodeParam::bUseDM2ExtendedMode)
	{
		U16 value = 0;
		U8 category = GDAT_CATEGORY_CREATURE_AI;
		Bit8u text[128] = {0};

		// Do the default init -- until all data is put into GDAT.
		//memcpy(dAITable, _4976_03a2, 62 * 36);
		//memcpy(dAITable, dAITableGenuine, 62 * 36);

		for (index = 0; index < 254; index++)
		{
			// SPX : TODO => COMPLETE LOADING OF VALUES HERE
			value = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, GDAT_AI_STAT_HIT_POINTS);	// Test HP
			if (value != 0)	
			{
				U8	byte1;
				U8	byte2;
				QUERY_GDAT_TEXT(GDAT_CATEGORY_CREATURE_AI
								,index
								,0x18
								,text);
				// Bunch load
				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 0);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 1);
				dAITable[index].w0AIFlags = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 2);
				dAITable[index].ArmorClass = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 3);
				dAITable[index].b3 = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 4);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 5);
				dAITable[index].BaseHP = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 6);
				dAITable[index].AttackStrength = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 7);
				dAITable[index].PoisonDamage = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 8);
				dAITable[index].Defense = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 9);
				dAITable[index].b9x = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 10);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 11);
				dAITable[index].w10 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 12);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 13);
				dAITable[index].w12 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 14);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 15);
				dAITable[index].AttacksSpells = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 16);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 17);
				dAITable[index].w16 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 18);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 19);
				dAITable[index].w18 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 20);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 21);
				dAITable[index].w20 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 22);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 23);
				dAITable[index].w22 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 24);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 25);
				dAITable[index].w24 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 26);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 27);
				dAITable[index].w26 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 28);
				dAITable[index].b28 = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 29);
				dAITable[index].Weight = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 30);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 31);
				dAITable[index].w30 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 32);
				byte2 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 33);
				dAITable[index].w32 = byte1 + byte2*256;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 34);
				dAITable[index].b34 = byte1;

				byte1 = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, 35);
				dAITable[index].b35 = byte1;

				// Flags (w0)
				dAITable[index].ArmorClass = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, GDAT_AI_STAT_ARMOR_CLASS);
				//b3
				dAITable[index].BaseHP = value;

				// Is there more than just attack here ?
				dAITable[index].AttackStrength = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, GDAT_AI_STAT_ATTACK_STRENGTH);

				dAITable[index].PoisonDamage = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, GDAT_AI_STAT_ATTACK_POISON);
				dAITable[index].Defense = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, GDAT_AI_STAT_DEFENSE);
				//b9
				//dAITable[index].b9x = QUERY_GDAT_ENTRY_DATA_INDEX(category, index, dtWordValue, GDAT_AI_STAT_FLAGS_B9);
				// attack commands & spell commands
				// can switch triggers
				// fire resistance
				// poison resistance
				// weight (push resistance)
				SkD((DLV_TWEET, "Tweet: Loading AI %d (%02X) named %s (hp:%d, ac:%d, def:%d, str:%d, ps:%d)\n", index, index
					,text
					,dAITable[index].BaseHP
					,dAITable[index].ArmorClass
					,dAITable[index].Defense
					,dAITable[index].AttackStrength
					,dAITable[index].PoisonDamage));
			}
		}
		rc = 1;
	}

	//--- Write info about AI values
	if (0) // write log or not
	{
		Write2LOGX("CREATURE/OBJECT AI INFO:\nNumber of AI : %d", MAXAI);
		for (index = 0; index < MAXAI; index++)
		{
			Write2LOGX("#%03d) <%24s>\n\tHit Points: %4d",
				index,
				getAIName(index),
				dAITable[index].BaseHP);
			if (dAITable[index].ArmorClass == 255)
				Write2LOGX("\tArmor: Indestructible (255)");	
			else
				Write2LOGX("\tArmor: %d", dAITable[index].ArmorClass);	
			if (dAITable[index].Defense != 0)
				Write2LOGX("\tDefense: %d", dAITable[index].Defense);	
			if (dAITable[index].AttackStrength != 0)
				Write2LOGX("\tAttack Strength: %d", dAITable[index].AttackStrength);	
			if (dAITable[index].PoisonDamage != 0)
				Write2LOGX("\tPoison Damage: %d", dAITable[index].PoisonDamage);	

			if (dAITable[index].AttacksSpells != 0)
			{
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__PUSH_BACK)
					Write2LOGX("\tCan knock back.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__MELEE)
					Write2LOGX("\tCan do melee attack.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__STEAL)
					Write2LOGX("\tCan steal.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__FIREBALL)
					Write2LOGX("\tCan cast Fireball.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__DISPELL)
					Write2LOGX("\tCan cast Dispell.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__LIGHTNING)
					Write2LOGX("\tCan cast Lightning.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__POISON_CLOUD)
					Write2LOGX("\tCan cast Poison Cloud.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__POISON_BOLT)
					Write2LOGX("\tCan cast Poison Bolt.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__PUSH_SPELL)
					Write2LOGX("\tCan cast Push.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__PULL_SPELL)
					Write2LOGX("\tCan cast Pull.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__POISON_BLOB)
					Write2LOGX("\tCan can Poison Blob.");	
				if (dAITable[index].AttacksSpells & AI_ATTACK_FLAGS__SHOOT)
					Write2LOGX("\tCan shoot items.");	
			}


			Write2LOGX("\n");
		}
	}

	return rc;
}
// SPX: End of new procedures

//{{DEBUG_HELPER
const char *SkWinCore::getXActrName(int x)
{
	if (x == xactrNeedReset) return "xactrNeedReset";
	if (x == xactrYes) return "xactrYes";
	if (x == xactrNo) return "xactrNo";
	if (x == xactrAgain) return "xactrAgain";
	return "?";
}

// SPX: Name of spell type
CString SkWinCore::getSpellTypeName(U8 spelltype)
{
	Bit8u text[128] = {0};
	if (spelltype == SPELL_TYPE_POTION) return "POTION";
	if (spelltype == SPELL_TYPE_MISSILE) return "MISSILE";
	if (spelltype == SPELL_TYPE_GENERAL) return "ENCHANTMENT";
	if (spelltype == SPELL_TYPE_SUMMON) return "SUMMON";
	if (text[0] != 0)
		return (LPCSTR)text;
	return "Unknown";
}

// SPX: Name of skill
CString SkWinCore::getSkillName(U8 skill)
{
	Bit8u text[128] = {0};
	if (skill == SKILL_FIGHTER_GLOBAL) return "FIGHTER";
	if (skill == SKILL_NINJA_GLOBAL) return "NINJA";
	if (skill == SKILL_PRIEST_GLOBAL) return "PRIEST";
	if (skill == SKILL_WIZARD_GLOBAL) return "WIZARD";
	if (skill == SKILL_FIGHTER_SWING) return "(F1)SWING";
	if (skill == SKILL_FIGHTER_THRUST) return "(F2)THRUST";
	if (skill == SKILL_FIGHTER_BLUNT) return "(F3)BLUNT";
	if (skill == SKILL_FIGHTER_PARRY) return "(F4)PARRY";
	if (skill == SKILL_NINJA_STEAL) return "(N1)STEAL";
	if (skill == SKILL_NINJA_FIGHT) return "(N2)FIGHT";
	if (skill == SKILL_NINJA_THROW) return "(N3)THROW";
	if (skill == SKILL_NINJA_SHOOT) return "(N4)SHOOT";
	if (skill == SKILL_PRIEST_IDENTIFY) return "(P1)IDENTIFY";
	if (skill == SKILL_PRIEST_HEAL) return "(P2)HEAL";
	if (skill == SKILL_PRIEST_INFLUENCE) return "(P3)INFLUENCE";
	if (skill == SKILL_PRIEST_DEFEND) return "(P4)DEFEND";
	if (skill == SKILL_WIZARD_FIRE) return "(W1)FIRE";
	if (skill == SKILL_WIZARD_AIR) return "(W2)AIR";
	if (skill == SKILL_WIZARD_EARTH) return "(W3)EARTH";
	if (skill == SKILL_WIZARD_WATER) return "(W4)WATER";
	if (text[0] != 0)
		return (LPCSTR)text;
	return "UNKNOWN";
}

// SPX: Name of bonus
CString SkWinCore::getStatBonusName(U8 bonus)
{
	Bit8u text[128] = {0};
	if (bonus == GDAT_ITEM_STATS_WEIGHT)			return "WEIGHT";
	if (bonus == GDAT_ITEM_STATS_MONEY_VALUE)		return "MONEY";
	if (bonus == GDAT_ITEM_STATS_FOOD_VALUE)		return "FOOD";
	if (bonus == GDAT_ITEM_WEAPON_MELEE_STRENGTH)	return "MELEE STRENGTH";
	if (bonus == GDAT_ITEM_WEAPON_THROW_STRENGTH)	return "THROW STRENGTH";
	if (bonus == GDAT_ITEM_WEAPON_ACCURACY)			return "ACCURACY";
	if (bonus == GDAT_ITEM_STATS_ARMOR_CLASS)		return "ARMOR CLASS";
	if (bonus == GDAT_ITEM_STATS_0x0C)				return "X0C";
	if (bonus == GDAT_ITEM_STATS_POISONOUS)			return "POISON";
	if (bonus == GDAT_ITEM_BONUS_0x13)				return "X13";
	if (bonus == GDAT_ITEM_BONUS_MANA)				return "MANA";
	if (bonus == GDAT_ITEM_BONUS_LUCK)				return "LUCK";
	if (bonus == GDAT_ITEM_BONUS_STRENGTH)			return "STRENGTH";
	if (bonus == GDAT_ITEM_BONUS_DEXTERITY)			return "DEXTERITY";
	if (bonus == GDAT_ITEM_BONUS_WISDOM)			return "WISDOM";
	if (bonus == GDAT_ITEM_BONUS_VITALITY)			return "VITALITY";
	if (bonus == GDAT_ITEM_BONUS_ANTI_MAGIC)		return "ANTI-MAGIC";
	if (bonus == GDAT_ITEM_BONUS_ANTI_FIRE)			return "ANTI-FIRE";

	if (bonus == GDAT_ITEM_BONUS_FIGHTER)			return "FIGHTER";
	if (bonus == GDAT_ITEM_BONUS_NINJA)				return "NINJA";
	if (bonus == GDAT_ITEM_BONUS_PRIEST)			return "PRIEST";
	if (bonus == GDAT_ITEM_BONUS_WIZARD)			return "WIZARD";
	if (bonus == GDAT_ITEM_BONUS_FGT_SWING)			return "(F1)SWING";
	if (bonus == GDAT_ITEM_BONUS_FGT_THRUST)		return "(F2)THRUST";
	if (bonus == GDAT_ITEM_BONUS_FGT_BLUNT)			return "(F3)BLUNT";
	if (bonus == GDAT_ITEM_BONUS_FGT_PARRY)			return "(F4)PARRY";
	if (bonus == GDAT_ITEM_BONUS_NJA_STEAL)			return "(N1)STEAL";
	if (bonus == GDAT_ITEM_BONUS_NJA_FIGHT)			return "(N2)FIGHT";
	if (bonus == GDAT_ITEM_BONUS_NJA_THROW)			return "(N3)THROW";
	if (bonus == GDAT_ITEM_BONUS_NJA_SHOOT)			return "(N4)SHOOT";
	if (bonus == GDAT_ITEM_BONUS_PRS_IDENTIFY)		return "(P1)IDENTIFY";
	if (bonus == GDAT_ITEM_BONUS_PRS_HEAL)			return "(P2)HEAL";
	if (bonus == GDAT_ITEM_BONUS_PRS_INFLUENCE)		return "(P3)INFLUENCE";
	if (bonus == GDAT_ITEM_BONUS_PRS_DEFEND)		return "(P4)DEFEND";
	if (bonus == GDAT_ITEM_BONUS_WIZ_FIRE)			return "(W1)FIRE";
	if (bonus == GDAT_ITEM_BONUS_WIZ_AIR)			return "(W2)AIR";
	if (bonus == GDAT_ITEM_BONUS_WIZ_EARTH)			return "(W3)EARTH";
	if (bonus == GDAT_ITEM_BONUS_WIZ_WATER)			return "(W4)WATER";

	if (bonus == GDAT_ITEM_BONUS_LIGHT)				return "LIGHT";
	if (bonus == GDAT_ITEM_BONUS_WALK_SPEED)		return "SPEED";
	if (bonus == GDAT_ITEM_STATS_MAX_CHARGES)		return "MAX CHARGES";
	if (bonus == GDAT_ITEM_BONUS_MONEY_PER_CHARGE)	return "MONEY/CHARGE";
	if (bonus == GDAT_ITEM_STATS_WATER_VALUE)		return "WATER";
	if (bonus == GDAT_ITEM_STATS_MISSILE_SPELL)		return "SPELL";
	if (text[0] != 0)
		return (LPCSTR)text;
	return "UNKNOWN";
}

// SPX: Name of UI Event
CString SkWinCore::getUIEventName(U8 event)
{
	Bit8u text[128] = {0};

// 0x00
	if (event == UI_EVENTCODE_TURN_LEFT) return "TURN LEFT";
	if (event == UI_EVENTCODE_TURN_RIGHT) return "TURN RIGHT";
	if (event == UI_EVENTCODE_MOVE_FORWARD) return "MOVE FORWARD";
	if (event == UI_EVENTCODE_MOVE_RIGHT) return "MOVE RIGHT";
	if (event == UI_EVENTCODE_MOVE_BACK) return "MOVE BACK";
	if (event == UI_EVENTCODE_MOVE_LEFT) return "MOVE LEFT";

	if (event == UI_EVENTCODE_VIEW_CHAMPION_1) return "CHAMPION INVENTORY 1";
	if (event == UI_EVENTCODE_VIEW_CHAMPION_2) return "CHAMPION INVENTORY 2";
	if (event == UI_EVENTCODE_VIEW_CHAMPION_3) return "CHAMPION INVENTORY 3";
	if (event == UI_EVENTCODE_VIEW_CHAMPION_4) return "CHAMPION INVENTORY 4";
	if (event == UI_EVENTCODE_RETURN_VIEWPORT) return "BACK TO VIEWPORT";

// 0x10
	if (event == UI_EVENTCODE_CHAMPION_1_HAND_RIGHT) return "CHAMPION 1 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION_1_HAND_LEFT) return "CHAMPION 1 LEFT HAND";
	if (event == UI_EVENTCODE_CHAMPION_2_HAND_RIGHT) return "CHAMPION 2 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION_2_HAND_LEFT) return "CHAMPION 2 LEFT HAND";
	if (event == UI_EVENTCODE_CHAMPION_3_HAND_RIGHT) return "CHAMPION 3 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION_3_HAND_LEFT) return "CHAMPION 3 LEFT HAND";
	if (event == UI_EVENTCODE_CHAMPION_4_HAND_RIGHT) return "CHAMPION 4 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION_4_HAND_LEFT) return "CHAMPION 4 LEFT HAND";

	if (event == UI_EVENTCODE_INVENTORY_HAND_RIGHT) return "INVENTORY RIGHT HAND";
	if (event == UI_EVENTCODE_INVENTORY_HAND_LEFT) return "INVENTORY LEFT HAND";

	if (event == UI_EVENTCODE_INVENTORY_HEAD) return "INVENTORY HEAD";
	if (event == UI_EVENTCODE_INVENTORY_BODY) return "INVENTORY BODY";

// 0x20 - 0x30
	if (event == UI_EVENTCODE_INVENTORY_LEGS) return "INVENTORY LEGS";
	if (event == UI_EVENTCODE_INVENTORY_FOOT) return "INVENTORY FOOT";
	if (event == UI_EVENTCODE_INVENTORY_POUCH_2) return "INVENTORY POUCH 2";
	if (event == UI_EVENTCODE_INVENTORY_SCABBARD_2) return "INVENTORY SCABBARD 2";
	if (event == UI_EVENTCODE_INVENTORY_SCABBARD_3) return "INVENTORY SCABBARD 3";
	if (event == UI_EVENTCODE_INVENTORY_SCABBARD_4) return "INVENTORY SCABBARD 4";

	if (event == UI_EVENTCODE_INVENTORY_NECK) return "INVENTORY NECK";
	if (event == UI_EVENTCODE_INVENTORY_POUCH_1) return "INVENTORY POUCH 1";
	if (event == UI_EVENTCODE_INVENTORY_SCABBARD_1) return "INVENTORY SCABBARD 1";

	if (event == UI_EVENTCODE_BACKPACK_01) return "INVENTORY BACKPACK 1";
	if (event == UI_EVENTCODE_BACKPACK_02) return "INVENTORY BACKPACK 2";
	if (event == UI_EVENTCODE_BACKPACK_03) return "INVENTORY BACKPACK 3";
	if (event == UI_EVENTCODE_BACKPACK_04) return "INVENTORY BACKPACK 4";
	if (event == UI_EVENTCODE_BACKPACK_05) return "INVENTORY BACKPACK 5";
	if (event == UI_EVENTCODE_BACKPACK_06) return "INVENTORY BACKPACK 6";
	if (event == UI_EVENTCODE_BACKPACK_07) return "INVENTORY BACKPACK 7";
	if (event == UI_EVENTCODE_BACKPACK_08) return "INVENTORY BACKPACK 8";
	if (event == UI_EVENTCODE_BACKPACK_09) return "INVENTORY BACKPACK 9";
	if (event == UI_EVENTCODE_BACKPACK_10) return "INVENTORY BACKPACK 10";
	if (event == UI_EVENTCODE_BACKPACK_11) return "INVENTORY BACKPACK 11";
	if (event == UI_EVENTCODE_BACKPACK_12) return "INVENTORY BACKPACK 12";
	if (event == UI_EVENTCODE_BACKPACK_13) return "INVENTORY BACKPACK 13";
	if (event == UI_EVENTCODE_BACKPACK_14) return "INVENTORY BACKPACK 14";
	if (event == UI_EVENTCODE_BACKPACK_15) return "INVENTORY BACKPACK 15";
	if (event == UI_EVENTCODE_BACKPACK_16) return "INVENTORY BACKPACK 16";
	if (event == UI_EVENTCODE_BACKPACK_17) return "INVENTORY BACKPACK 17";

	if (event == UI_EVENTCODE_CONTAINER_1) return "CONTAINER SLOT 1";
	if (event == UI_EVENTCODE_CONTAINER_2) return "CONTAINER SLOT 2";
	if (event == UI_EVENTCODE_CONTAINER_3) return "CONTAINER SLOT 3";
	if (event == UI_EVENTCODE_CONTAINER_4) return "CONTAINER SLOT 4";
	if (event == UI_EVENTCODE_CONTAINER_5) return "CONTAINER SLOT 5";
	if (event == UI_EVENTCODE_CONTAINER_6) return "CONTAINER SLOT 6";
	if (event == UI_EVENTCODE_CONTAINER_7) return "CONTAINER SLOT 7";
	if (event == UI_EVENTCODE_CONTAINER_8) return "CONTAINER SLOT 8";



// 0x40

	if (event == UI_EVENTCODE_MOUTH) return "INVENTORY MOUTH";
	if (event == UI_EVENTCODE_EYE) return "INVENTORY EYE";


// 0x50
	if (event == UI_EVENTCODE_CLICK_VIEWPORT) return "CLICK ON VIEWPORT";
	if (event == UI_EVENTCODE_VIEW_LEADER) return "LEADER INVENTORY";

	if (event == UI_EVENTCODE_CHAMPION_TURN_LEFT) return "CHAMPION TURN LEFT";
	if (event == UI_EVENTCODE_CHAMPION_TURN_RIGHT) return "CHAMPION TURN RIGHT";

// 0x60

	if (event == UI_EVENTCODE_SPELL_OR_LEADER_1) return "CHOOSE LEADER / INVOKE SPELL 1";
	if (event == UI_EVENTCODE_SPELL_OR_LEADER_2) return "CHOOSE LEADER / INVOKE SPELL 2";
	if (event == UI_EVENTCODE_SPELL_OR_LEADER_3) return "CHOOSE LEADER / INVOKE SPELL 3";
	if (event == UI_EVENTCODE_SPELL_OR_LEADER_4) return "CHOOSE LEADER / INVOKE SPELL 4";

	
	
	if (event == UI_EVENTCODE_ADD_RUNE_1) return "ADD RUNE 1";
	if (event == UI_EVENTCODE_ADD_RUNE_2) return "ADD RUNE 2";
	if (event == UI_EVENTCODE_ADD_RUNE_3) return "ADD RUNE 3";
	if (event == UI_EVENTCODE_ADD_RUNE_4) return "ADD RUNE 4";
	if (event == UI_EVENTCODE_ADD_RUNE_5) return "ADD RUNE 5";
	if (event == UI_EVENTCODE_ADD_RUNE_6) return "ADD RUNE 6";
	if (event == UI_EVENTCODE_REMOVE_RUNE) return "REMOVE RUNE";
	if (event == UI_EVENTCODE_VALIDATE_SPELL) return "VALIDATE SPELL";

// 0x70
	if (event == UI_EVENTCODE_HAND_RUNE_QUIT) return "HAND / RUNE QUIT ACTION";
	if (event == UI_EVENTCODE_HAND_ACTION_1) return "HAND ACTION 1";
	if (event == UI_EVENTCODE_HAND_ACTION_2) return "HAND ACTION 2";
	if (event == UI_EVENTCODE_HAND_ACTION_3) return "HAND ACTION 3";
	if (event == UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT) return "ACTIVATE CHAMPION 1 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION1_ACTION_HAND_LEFT) return "ACTIVATE CHAMPION 1 LEFT HAND";
	if (event == UI_EVENTCODE_CHAMPION2_ACTION_HAND_RIGHT) return "ACTIVATE CHAMPION 2 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION2_ACTION_HAND_LEFT) return "ACTIVATE CHAMPION 2 LEFT HAND";
	if (event == UI_EVENTCODE_CHAMPION3_ACTION_HAND_RIGHT) return "ACTIVATE CHAMPION 3 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION3_ACTION_HAND_LEFT) return "ACTIVATE CHAMPION 3 LEFT HAND";
	if (event == UI_EVENTCODE_CHAMPION4_ACTION_HAND_RIGHT) return "ACTIVATE CHAMPION 4 RIGHT HAND";
	if (event == UI_EVENTCODE_CHAMPION4_ACTION_HAND_LEFT) return "ACTIVATE CHAMPION 4 LEFT HAND";

	if (event == UI_EVENTCODE_TAKE_CHAMPION_TOP_LEFT) return "SELECTION TOP LEFT CHAMPION";
	if (event == UI_EVENTCODE_TAKE_CHAMPION_TOP_RIGHT) return "SELECTION TOP RIGHT CHAMPION";
	if (event == UI_EVENTCODE_TAKE_CHAMPION_BOTTOM_RIGHT) return "SELECTION BOTTOM RIGHT CHAMPION";
	if (event == UI_EVENTCODE_TAKE_CHAMPION_BOTTOM_LEFT) return "SELECTION BOTTOM LEFT CHAMPION";
	if (event == UI_EVENTCODE_UPDATE_CHAMPION_POSITION) return "UPDATE CHAMPION POSITION";

// 0x80
	if (event == UI_EVENTCODE_DISK_OP) return "DISK OPERATION";

// 0x90
	if (event == UI_EVENTCODE_SLEEP) return "INVOKE SLEEP";
	if (event == UI_EVENTCODE_WAKE) return "WAKE UP FROM SLEEP";
	if (event == UI_EVENTCODE_PAUSE) return "INVOKE PAUSE";
	if (event == UI_EVENTCODE_END_PAUSE) return "RESUME GAME FROM PAUSE";

	if (event == UI_EVENTCODE_MAGIC_MAP) return "MAGIC MAP";
	if (event == UI_EVENTCODE_MAGIC_MAP_RUNE_1) return "MAGIC MAP RUNE 1";
	if (event == UI_EVENTCODE_MAGIC_MAP_RUNE_2) return "MAGIC MAP RUNE 2";
	if (event == UI_EVENTCODE_MAGIC_MAP_RUNE_3) return "MAGIC MAP RUNE 3";
	if (event == UI_EVENTCODE_MAGIC_MAP_RUNE_4) return "MAGIC MAP RUNE 4";

// 0xA0
	if (event == UI_EVENTCODE_REVIVE_CHAMPION) return "REVIVE CHAMPION";
	if (event == UI_EVENTCODE_EXIT_CRYOCELL) return "CANCEL REVIVE CHAMPION";

// 0xD0
	if (event == UI_EVENTCODE_START_NEW_GAME) return "START NEW GAME";
	if (event == UI_EVENTCODE_0D8) return "???";
	if (event == UI_EVENTCODE_RESUME_GAME) return "RESUME GAME";
	if (event == UI_EVENTCODE_SHOW_CREDITS) return "SHOW CREDITS";

	if (event == UI_EVENTCODE_DIALOG_BUTTON_1) return "BUTTON 1";
	if (event == UI_EVENTCODE_DIALOG_BUTTON_2) return "BUTTON 2";
	if (event == UI_EVENTCODE_DIALOG_BUTTON_3) return "BUTTON 3";

// 0xE0		
	if (event == UI_EVENTCODE_QUIT_GAME) return "QUIT GAME";
	if (event == UI_EVENTCODE_MOVE_OBJECT) return "MOVE OBJECT";
	if (event == UI_EVENTCODE_RELEASE_MOUSE_BUTTON) return "RELEASE MOUSE BUTTON";

	if (event == UI_EVENTCODE_MONEYBOX_1) return "MONEY BOX SLOT 1 (BLUE GEMS)";
	if (event == UI_EVENTCODE_MONEYBOX_2) return "MONEY BOX SLOT 2 (RED GEMS)";
	if (event == UI_EVENTCODE_MONEYBOX_3) return "MONEY BOX SLOT 3 (GREEN GEMS)";
	if (event == UI_EVENTCODE_MONEYBOX_4) return "MONEY BOX SLOT 4 (GOLD COINS)";
	if (event == UI_EVENTCODE_MONEYBOX_5) return "MONEY BOX SLOT 5 (SILVER COINS)";
	if (event == UI_EVENTCODE_MONEYBOX_6) return "MONEY BOX SLOT 6 (BRONZE COINS)";
	

	if (event == UI_EVENTCODE_QUIT_CREDITS) return "QUIT CREDITS";

	if (event == UI_EVENTCODE_CLICK_STATS_BAR_1) return "CLICK CHAMPION 1 BAR STATS";
	if (event == UI_EVENTCODE_CLICK_STATS_BAR_2) return "CLICK CHAMPION 2 BAR STATS";
	if (event == UI_EVENTCODE_CLICK_STATS_BAR_3) return "CLICK CHAMPION 3 BAR STATS";
	if (event == UI_EVENTCODE_CLICK_STATS_BAR_4) return "CLICK CHAMPION 4 BAR STATS";



	if (text[0] != 0)
		return (LPCSTR)text;
	return "Unknown";
}

// SPX: Name of AI
CString SkWinCore::getAIName(U8 ai)
{
	Bit8u text[128] = {0};

// 0x00
	if (ai == 0) return "TREE (PILLAR)";
	if (ai == 1) return "LABORATORY TABLE";
	if (ai == 2) return "????";
	if (ai == 3) return "BUSH";
	if (ai == 4) return "PILLARS / ROD (PILLAR)";
	if (ai == 5) return "STALAGMITE (PILLAR)";
	if (ai == 6) return "BOULDER";
	if (ai == 7) return "FOUNTAIN";
	if (ai == 8) return "OBELISKS / TOMBS";
	if (ai == 9) return "WOOD TABLE (TABLE)";
	if (ai == 10) return "MAGICK CAULDRON";
	if (ai == 11) return "SKULL BRAZIER";
	if (ai == 12) return "TRADING TABLE";
	if (ai == 13) return "SCOUT MINION (ALLY)";
	if (ai == 14) return "ATTACK MINION (ALLY)";
	if (ai == 15) return "CARRY MINION (ALLY)";

// 0x10
	if (ai == 16) return "FETCH MINION (ALLY)";
	if (ai == 17) return "GUARD MINION (ALLY)";
	if (ai == 18) return "U-HAUL MINION (ALLY)";
	if (ai == 19) return "THORN DEMON";
	if (ai == 20) return "OBELISK (PASSABLE)";
	if (ai == 21) return "VORTEX";
	if (ai == 22) return "FLAME ORB";
	if (ai == 23) return "CAVERN BAT (BAT)";
	if (ai == 24) return "GLOP";
	if (ai == 25) return "ROCKY";
	if (ai == 26) return "GIGGLER";
	if (ai == 27) return "THICKET THIEF";
	if (ai == 28) return "TIGER STRIPED WORM (WORM)";
	if (ai == 29) return "TREANT (TREE GORGON)";
	if (ai == 30) return "LORD DRAGOTH";
	if (ai == 31) return "DRU TAN";

// 0x20
	if (ai == 32) return "CAVE IN";
	if (ai == 33) return "MERCHANTS";
	if (ai == 34) return "DRAGOTH MINION (EVIL)";
	if (ai == 35) return "TOWER BAT (BAT)";
	if (ai == 36) return "ARCHER GUARD";
	if (ai == 37) return "MAGICK REFLECTOR (MACHINE)";
	if (ai == 38) return "POWER CRYSTAL (MACHINE)";
	if (ai == 39) return "EVIL FOUNTAIN (FOUNTAIN)";
	if (ai == 40) return "SPIKED WALL / FLOOR SPIKES";
	if (ai == 41) return "SPECTRE (GHOST)";
	if (ai == 42) return "VEG MOUTH (DIGGER WORM)";
	if (ai == 43) return "EVIL ATTACK MINION (EVIL)";
	if (ai == 44) return "AXEMAN";
	if (ai == 45) return "CAVERN / STONE TABLE / WALL HOLE?";
	if (ai == 46) return "MUMMY";
	if (ai == 47) return "VOID DOOR (MACHINE)";

// 0x30
	if (ai == 48) return "DARK VEXIRK (VEXIRK)";
	if (ai == 49) return "EVIL GUARD MINION (ENEMY)";
	if (ai == 50) return "SKELETON";
	if (ai == 51) return "AMPLIFIER (MACHINE)";
	if (ai == 52) return "WOLF";
	if (ai == 53) return "PIT GHOST (GHOST)";
	if (ai == 54) return "DOOR GHOST (GHOST)";
	if (ai == 55) return "VEXIRK KING (VEXIRK)";
	if (ai == 56) return "? OBELISK LIKE ?";
	if (ai == 57) return "AXEMAN THIEF";
	if (ai == 58) return "FLYING CHEST";
	if (ai == 59) return "BARREL";
	if (ai == 60) return "PEDISTAL (PILLAR)";
	if (ai == 61) return "GHOST";
	if (ai == 62) return "EVIL ATTACK MINION (EVIL)";

// 0x40

	if (text[0] != 0)
		return (LPCSTR)text;
	return "Unknown";

}

CString SkWinCore::getRecordNameOf(ObjectID recordLink)
{
	Bit8u text[128] = {0};
	if (recordLink == OBJECT_EFFECT_FIREBALL) return "FIREBALL";
//		if (recordLink == OBJECT_EFFECT_MYSTERIOUS) return "MYSTERIOUS";
	if (recordLink == OBJECT_EFFECT_POISON_BLOB) return "POISON_BLOB";
	if (recordLink == OBJECT_EFFECT_LIGHTNING) return "LIGHTNING";
	if (recordLink == OBJECT_EFFECT_DISPELL) return "DISPELL";
	if (recordLink == OBJECT_EFFECT_ZO_SPELL) return "ZO_SPELL";
	if (recordLink == OBJECT_EFFECT_POISON_BOLT) return "POISON_BOLT";
	if (recordLink == OBJECT_EFFECT_POISON_CLOUD) return "POISON_CLOUD";
	if (recordLink == OBJECT_EFFECT_PUSH) return "PUSH";
	if (recordLink == OBJECT_EFFECT_PULL) return "PULL";
	if (recordLink == OBJECT_EFFECT_ZO_2) return "ZO_2";
	if (recordLink == OBJECT_EFFECT_REFLECTOR) return "REFLECTOR";
	if (recordLink == OBJECT_EFFECT_CLOUD) return "CLOUD";
	if (recordLink == OBJECT_EFFECT_THUNDER) return "THUNDER";
	if (recordLink == OBJECT_EFFECT_ELECTRIC_SHOCK) return "ELECTRIC_SHOCK";

	switch (recordLink.DBType()) {
		case dbMissile:
			return getRecordNameOf(GET_ADDRESS_OF_RECORDE(recordLink)->GetMissileObject());
		case dbCreature:
		case dbWeapon:
		case dbCloth:
		case dbScroll:
		case dbPotion:
		case dbContainer:
		case dbMiscellaneous_item:
			QUERY_GDAT_TEXT(
				QUERY_CLS1_FROM_RECORD(recordLink), 
				QUERY_CLS2_FROM_RECORD(recordLink),
				(recordLink.DBType() == dbCreature) ? 0x00 : 0x18, 
				text);
			break;
	}
	if (text[0] != 0)
		return (LPCSTR)text;
	return "Unknown";
}
void SkWinCore::printDistMap(int mapno, DistMapTile const (* const *bp1a)[1][32])
{
	if (!bp1a[mapno]) return;

	CONSOLE_SCREEN_BUFFER_INFO info;
	ATLVERIFY(GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info));

	int cy = dunMapsHeaders[mapno].Row();
	int cx = dunMapsHeaders[mapno].Column();

	for (int y = 0; y < cy; y++) {
		for (int x = 0; x < cx; x++) {
			DistMapTile b = (*(bp1a[mapno]))[x][y];

			int f = b.dir;
			bool assign = b.w2.Is0();
			ATLASSERT(f == 255 || f == 204 || f == 0 || f == 1 || f == 2 || f == 3 || f == 4);

			SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY
				|((assign && f ==   0)?FOREGROUND_GREEN:0)
				|((assign && f ==   1)?FOREGROUND_GREEN:0)
				|((assign && f ==   2)?FOREGROUND_GREEN:0)
				|((assign && f ==   3)?FOREGROUND_GREEN:0)
				|((assign && f ==   4)?FOREGROUND_BLUE:0) // up/down?
				|((assign && f == 204)?FOREGROUND_RED:0)
				|((assign && f == 255)?FOREGROUND_BLUE|FOREGROUND_GREEN|FOREGROUND_RED:0)
				);

			static LPCSTR psz = ".123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz*";
			putchar(psz[min(62, b.distance)]);
		}
		putchar('\n');
	}

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), info.wAttributes);
}
//}}DEBUG_HELPER

//{{SKSAVE_PUB_PROC
//protected:
//^0759:0114
// SPX: _0759_0114 renamed IS_NEGATIVE
X16 SkWinCore::IS_NEGATIVE(i16 xx)
{
	//^0759:0114
	ENTER(0);
	//^0759:0117
	return (xx < 0) ? 1 : 0;
}

//^0759:000C
X16 SkWinCore::ANIM_FILE_OPEN(const char *filename)
{
	//^0759:000C
	ENTER(0);
	//^0759:000F
	return fset.fileOpen(reinterpret_cast<const char *>(filename));
}

//^0759:00D6
U32 SkWinCore::ANIM_GET_FILE_SIZE(X16 fh)
{
#if UseAltic
	return fset.fileGetSize(fh);
#else
	return Unr(),0;
#endif
}

//^069A:06EE
U8 *SkWinCore::ANIM_farmalloc(U32 size)
{
	return reinterpret_cast<U8 *>(malloc(size));
}
//^0759:002D
U16 SkWinCore::ANIM_READ_HUGE_FILE(X16 fh, U32 readSize, U8 *buff)
{
	//^0759:002D
	ENTER(6);
	//^0759:0031
	U8 *bp06 = buff;
	for (; readSize > 0; ) {
		//^0759:003F
		U16 bp02;
		if (readSize > 32768) {
			//^0759:004E
			bp02 = 0x8000;
		}
		else {
			//^0759:0055
			bp02 = U16(readSize);
		}
		//^0759:005B
		if (fset.fileRead(fh, bp02, bp06) != bp02) {
			//^0759:006F
			return 0;
		}
		//^0759:0073
		readSize -= bp02;
		bp06 += bp02;
		//^0759:008C
	}
	//^0759:009A
	return 1;
}
//^0759:0021
void SkWinCore::ANIM_FILE_CLOSE(X16 fh)
{
	//^0759:0021
	ENTER(0);
	//^0759:0024
	fset.fileClose(fh);
	//^0759:002B
	return;
}
U8 SkWinCore::_069a_03fc(char *xx)
{
	return Unr(), 0; // anim
}
//^069A:048C
char *SkWinCore::ANIM_STRCPY(char *xx, const char *yy)
{
	return strcpy(xx, yy);
}

//^0759:0126
void SkWinCore::_0759_0126()
{
	//^0759:0126
	ENTER(0);
	//^0759:0129
	_089c_0254 = _crt_getvect(255);
	//^0759:0139
	return;
}

//^0759:06C2
void SkWinCore::_0759_06c2()
{
	//^0759:06C2
	ENTER(0);
	//^0759:06C5
	LOADDS(0x0704);
	_089c_0344 -= _089c_0352;
	//^0759:06D9
	return;
}

//^0759:06DB
void SkWinCore::_0759_06db()
{
	//^0759:06DB
	ENTER(0);
	//^0759:06DE
	_089c_025c = _crt_getvect(254);
	_089c_0340 = _089c_025c;
	//^0759:06FC
	//^0759:0706
	_089c_0352 = _01b0_0e80(&SkWinCore::_0759_06c2);
	//^0759:0719
	return;
}
//^0759:072C
X16 SkWinCore::_0759_072c()
{
	//^0759:072C
	ENTER(0);
	//^0759:072F
	return _01b0_051a() CALL_IBMIO;
}
//^0759:071B
void SkWinCore::_0759_071b()
{
	//^0759:071B
	ENTER(0);
	//^0759:071F
	_01b0_04e4();
}
//^01B0:1ED2
X16 SkWinCore::_01b0_1ed2()
{
	//^01B0:1ED2
	ENTER(0);
	//^01B0:1ED5
	LOADDS(0x3083);
	//^01B0:1EDB
	return (glbSoundCardType != 0) ? 1 : 0;
}

//^069A:05FE
void SkWinCore::ANIM_farfree(U8 *buff)
{
	free(buff);
}

//^069A:040D
U32 SkWinCore::ANIM_farcoreleft()
{
#if UseAltic
	return 1024*1024; // Win32 supplies almost infinite memory pool compared to MS-DOS env.
#else
	//^069A:040D
	ENTER(0);
	//^069A:040D
	return _crt_farcoreleft();
#endif
}
X32 SkWinCore::_0759_07f2(U8 *xx) {
	return Unr(), 0; // anim
}
void SkWinCore::_0759_0855() {
	Unr(); // anim
}
U8 *SkWinCore::_0759_0869(U32 xx) {
	Unr(); // anim
	return NULL;
}
//^0759:06B5
void SkWinCore::_0759_06b5()
{
	//^0759:06B5
	ENTER(0);
	//^0759:06B8
	_00eb_0bc4();
	//^0759:06C0
	return;
}
//^0759:065F
void SkWinCore::_0759_065f()
{
	//^0759:065F
	ENTER(8);
	//^0759:0663
	SRECT bp08 = _089c_00d0;
	//^0759:0674
	IBMIO_FILL_RECT_SCREEN(&bp08, 0);
	//^0759:0686
	return;
}
void SkWinCore::_0759_0792() {
	Unr(); // anim
}
void SkWinCore::_0759_0739(U8 *xx, U16 yy, U16 zz) {
	Unr(); // anim
}
//^0759:0330
void SkWinCore::ANIM_DECODE_IMG1(U8 *xx, U8 *yy)
{
	//^0759:0330
	ENTER(14);
	//^0759:0336
	_089c_0348 = xx;
	_089c_0354 = yy;
	//^0759:0350
	U16 bp02 = _089c_0348[1] | (_089c_0348[0] << 8); // image width
	//^0759:036A
	U16 bp04 = _089c_0348[3] | (_089c_0348[2] << 8); // image height
	//^0759:03B9
	_089c_0348 += 4;
	//^0759:03C8
	X16 bp06;
	X16 bp08;
	bp08 = (bp06 = (bp02 +1)&0xfffe) * bp04;
	U16 di = 0;
	U16 bp0c = 0;
	do {
		//^0759:03DF
		i8 bp09 = (_089c_0348++)[0];
		X16 si;
		if ((bp09 & 0x80) == 0) {
			//^0759:03FC
			si = (bp09 >> 4) +1;
			//^0759:0404
			ANIM_FILL_SEQ_4BPP(di, bp09&15, si);
			//^0759:0413
			di += si;
			continue;
		}
		//^0759:0418
		X16 bp0e = bp09 & 0x30;
		switch (bp0e) {
		case 0x00://^043C
			//^0759:043C
			if ((bp09 & 0x40) == 0) {
				si = (_089c_0348[0]) +1;
				_089c_0348++;
			}
			else {
				si = (_089c_0348[1] | (_089c_0348[0] << 8)) +1;
				_089c_0348 += 2;
			}
			//^0759:048F
			//^0759:0404
			ANIM_FILL_SEQ_4BPP(di, bp09&15, si);
			//^0759:0413
			di += si;
			continue;
		case 0x10://^0495
			//^0759:0495
			if ((bp09 & 0x40) == 0) {
				//^0759:049B
				si = (_089c_0348[0]) +1;
				_089c_0348++;
			}
			else {
				//^0759:04AE
				si = (_089c_0348[1] | (_089c_0348[0] << 8)) +1;
				_089c_0348 += 2;
			}
			//^0759:04E8
			if ((si & 1) != 0) {
				//^0759:04EE
				ANIM_SETPIXEL_SEQ_4BPP(di, bp09&15);
				//^0759:04FB
				di++;
				si--;
			}
			//^0759:04FD
			ANIM_BLIT_TO_MEMORY_ROW_4TO4BPP(0, di, si);
			_089c_0348 += si >> 1;
			//^0759:0518
			//^0759:0413
			di += si;
			continue;
		case 0x20://^051B
			//^0759:051B
			if (bp0c < di) {
				//^0759:0520
				_0759_0310(bp0c, di -bp0c);
			}
			//^0759:052F
			si = ((bp09 >> 2)&16)|(bp09&15);
			if (si == 0x1d) {
				//^0759:054B
				si = _089c_0348[0] +1;
				_089c_0348++;
			}
			//^0759:0568
			else if (si == 0x1e) {
				//^0759:056D
				si = _089c_0348[0] +0x101;
				_089c_0348++;
			}
			//^0759:057B
			else if (si == 0x1f) {
				//^0759:0580
				si = (_089c_0348[1] | (_089c_0348[0] << 8)) +1;
				_089c_0348 += 2;
			}
			else {
				//^0759:05B2
				si++;
			}
			//^0759:05B3
			di += si;
			bp0c = di;
			//^0759:05B8
			break;
		case 0x30://^05BB
			//^0759:05BB
			if ((bp09 & 0x40) == 0) {
				//^0759:05C1
				si = _089c_0348[0] +1;
				_089c_0348++;
			}
			else {
				//^0759:05D4
				si = (_089c_0348[1] | (_089c_0348[0] << 8)) +1;
				_089c_0348 += 2;
			}
			//^0759:060E
			_0759_02c6(di, di -bp06, si);
			//^0759:061D
			di += si;
			ANIM_SETPIXEL_SEQ_4BPP(di++, bp09&15);
			//^0759:062F
			break;
		}
		//^0759:062F
	} while (di < bp08);
	ATLASSERT(di <= bp08);
	//^0759:0637
	if (bp0c < di) {
		//^0759:063C
		_0759_0310(bp0c, di -bp0c);
	}
	//^0759:064B
	return;
}
//^0759:06A1
void SkWinCore::_0759_06a1(U8 ps)
{
	//^0759:06A1
	ENTER(0);
	//^0759:06A4
	IBMIO_SELECT_PALETTE_SET(ps) CALL_IBMIO;
	//^0759:06B3
	return;
}

//^00EB:04BC
void SkWinCore::_00eb_04bc(skxxxj *xx, U16 yy) //#DS=04BF
{
	//^00EB:04BC
	ENTER(0);
	//^00EB:04C1
	LOADDS(0x0c48);
	X16 si = 0;
	X16 di = yy << 4;
	//^00EB:04D1
	for (si = 0; si < 16; si++) {
		//^00EB:04D6
		glbPaletteRGB[(si +di)][0] = U8(xx[si].b1 >> 2);
		glbPaletteRGB[(si +di)][1] = U8(xx[si].b2 >> 2);
		glbPaletteRGB[(si +di)][2] = U8(xx[si].b3 >> 2);
		if (yy == 0) {
			//^00EB:0548
			_04bf_0a50[si][0] = U8(xx[si].b1 >> 2);
			_04bf_0a50[si][1] = U8(xx[si].b2 >> 2);
			_04bf_0a50[si][2] = U8(xx[si].b3 >> 2);
		}
		//^00EB:05AE
	}
	//^00EB:05B7
	if (glbUpdatePalette == 1) {
		//^00EB:05BE
		IBMIO_UPDATE_PALETTE_SET();
	}
	//^00EB:05C2
	return;
}

//^0759:0688
void SkWinCore::_0759_0688(skxxxj *xx, U16 yy)
{
	//^0759:0688
	ENTER(0);
	//^0759:068B
	_00eb_04bc(xx, yy) CALL_IBMIO;
	//^0759:069F
	return;
}

//^069A:035B
X16 SkWinCore::ANIM_TOUPPER(X16 xx)
{
	//^069A:035B
	ENTER(0);
	//^069A:035E
	i16 dx = xx;
	if (dx == -1)
		return -1;
	if ((_089c_00e3[U8(dx)] & 8) != 0)
		return U8(dx) -32;
	//^069A:0381
	return U8(dx);
}

//^0759:016C
void SkWinCore::ANIM_FILL_SEQ_4BPP(U16 offDst, i16 clr, U16 cnt)
{
	ATLASSERT(cnt != 0);

	//^0759:016C
	ENTER(0);
	//^0759:0170
	U8 *esdi = _089c_0354;
	U16 bx = offDst;
	U16 cx = cnt;
	U8 ah = U8(clr);
	bool carry = (bx & 1) != 0;
	bx >>= 1;
	if (!carry) {
		//^0759:0182
		esdi += bx;
	}
	else {
		//^0759:0186
		esdi += bx;
		U8 al = (*esdi & 0xf0) | ah;
		stosb(esdi, al);
		if (--cx == 0) return;
	}
	//^0759:0193
	U8 al = (ah << 4) | ah;
	ah = al;
	bool carry2 = (cx & 1) != 0;
	cx >>= 1;
	bool carry3 = (cx & 1) != 0;
	cx >>= 1;
	if (carry3) {
		stosb(esdi, al);
	}
	U16 ax = al | (ah << 8);
	for (; cx != 0; cx--) stosw(esdi, ax);
	if (carry2) {
		//^0759:01B2
		al = *esdi;
		ax &= 0xf00f;
		al |= U8(ax >> 8);
		stosb(esdi, al);
	}
	//^0759:01BB
	return;
}
//^0759:013B
void SkWinCore::ANIM_SETPIXEL_SEQ_4BPP(U16 offDst, i8 clr)
{
	//^0759:013B
	ENTER(0);
	//^0759:013F
	U8 *esdi = _089c_0354;
	U16 bx = offDst;
	bool carry = (bx & 1) != 0;
	bx >>= 1;
	if (carry) {
		//^0759:014B
		esdi += bx;
		U8 al = *esdi;
		al &= 0xf0;
		al |= clr;
		stosb(esdi, al);
	}
	else {
		//^0759:0158
		esdi += bx;
		U8 al = *esdi;
		al &= 0x0f;
		al |= clr << 4;
		stosb(esdi, al);
	}
	//^0759:0169
	return;
}
//^0759:01BE
void SkWinCore::ANIM_BLIT_TO_MEMORY_ROW_4TO4BPP(U16 offSrc, U16 offDst, U16 width)
{
#if UseAltic
	_4976_5e6a = _089c_0354;
	_4976_5e64 = _089c_0348;

	FIRE_BLIT_TO_MEMORY_ROW_4TO4BPP(offSrc, offDst, width);
#else
	Unr();
#endif
}

//^00EB:0008
void SkWinCore::IBMIO_LOAD_4TO8BPP_PAL(const U8 *pal)
{
	//^00EB:0008
	ENTER(0);
	//^00EB:000D
	U8 *esdi = _00eb_0023;
	const U8 *dssi = pal;
	U16 cx = 16;
	for (; cx != 0; cx--) movsb(esdi, dssi);
	//^00EB:0021
	//^00EB:0033
	return;
}

//^00EB:0037
void SkWinCore::IBMIO_BLIT_ROW_4TO8BPP(U16 offSrc, U16 offDst, U16 size)
{
	//^00EB:0037
	ENTER(0);
	//^00EB:003C
	U8 *dsbx = _00eb_0023;
	U8 *esdi = _04bf_0e34 + offDst;
	U16 cx = size;
	const U8 *dssi = _04bf_0cf0;
	bool carry1 = (offSrc & 1) != 0;
	offSrc >>= 1;
	dssi += offSrc;
	if (carry1) {
		//^00EB:005C
		U8 al = lodsb(dssi);
		al &= 0x0f;
		al = dsbx[al];
		if (--cx == 0) return;
	}
	//^00EB:0065
	bool carry2 = (cx & 1) != 0;
	cx >>= 1;
	if (cx != 0) {
		//^00EB:0069
		bool carry3 = (cx & 1);
		cx >>= 1;
		if (cx != 0) {
			//^00EB:006E
			U16 bp = 0x0f0f;
			do {
				//^00EB:0073
				U16 ax = lodsw(dssi);
				U16 dx = ax >> 4;
				dx &= bp;
				ax &= bp;
				U8 ah = dsbx[ax & 255];
				U8 al = dsbx[dx & 255];
				U8 dh = dsbx[ax >> 8];
				U8 dl = dsbx[dx >> 8];
				ax = (ah << 8) | al;
				dx = (dh << 8) | dl;
				stosw(esdi, ax);
				stosw(esdi, dx);
				//^00EB:008F
			} while (--cx != 0);
		}
		if (carry3) {
			//^00EB:0095
			U8 al = lodsb(dssi);
			U8 ah = al;
			al >>= 4;
			al = dsbx[al];
			stosb(esdi, al);
			al = ah & 15;
			al = dsbx[al];
			stosb(esdi, al);
		}
	}
	//^00EB:00A6
	if (carry2) {
		//^00EB:00A8
		U8 al = lodsb(dssi);
		al >>= 4;
		al = dsbx[al];
		stosb(esdi, al);
	}
	//^00EB:00B0
	//^00EB:00B2
	return;
}

//^00EB:070C
void SkWinCore::_00eb_070c(U8 *buffSrc, U16 yy, U16 zz, U16 ww) //#DS=04BF
{
	//^00EB:070C
	ENTER(0);
	//^00EB:070F
	LOADDS(0x0c48);
	//^00EB:0715
	_04bf_0cf0 = buffSrc;
	IBMIO_LOAD_4TO8BPP_PAL(_04bf_00dc);
	IBMIO_BLIT_ROW_4TO8BPP(yy, zz, ww);
	//^00EB:073D
	return;
}

//^0759:0310
void SkWinCore::_0759_0310(U16 xx, U16 yy)
{
	//^0759:0310
	ENTER(0);
	//^0759:0313
	_00eb_070c(_089c_0354, xx, xx, yy) CALL_IBMIO;
	//^0759:032E
	return;
}
//^0759:02C6
void SkWinCore::_0759_02c6(U16 xx, U16 yy, U16 zz)
{
	//^0759:02C6
	ENTER(0);
	//^0759:02CB
	U8 *esdi = _089c_0354;
	U8 *essi = esdi;
	U16 bx = xx;
	U16 dx = yy;
	U16 cx = zz;
	dx >>= 1;
	bool carry1 = (bx & 1) != 0;
	bx >>= 1;
	esdi += bx;
	essi += dx;
	if (carry1)  {
		//^0759:02E7
		U8 dl = *esdi;
		U8 al = lodsb(essi);
		dl &= 0xf0;
		al &= 0x0f;
		al |= dl;
		stosb(esdi, al);
		if (--cx == 0) return;
	}
	//^0759:02F7
	cx++;
	cx >>= 1;
	bool carry2 = (cx & 1) != 0;
	cx >>= 1;
	if (carry2) {
		//^0759:02FE
		movsb(esdi, essi);
	}
	//^0759:0300
	for (; cx != 0; cx--) movsw(esdi, essi);
	//^0759:030C
	return;
}

//^0759:08E7
int SkWinCore::_0759_08e7(i16 argc, char **argv, char **env) // #DS=089C
{
	//^0759:08E7
	ENTER(214);
	//^0759:08ED
	X16 bp2a = 0;
	X16 bp2e = 0;
	X16 bp32 = 0;
	X16 bp34 = 0;
	X16 bp36 = 0;
	X16 bp42 = 0;
	X16 bp44 = 0;
	X16 bp46 = 0;
	X16 bp48 = 0;
	X16 bp4a = 0;
	X16 bp5e = 0;
	X16 bp60 = 0;
	U8 bp69 = 0xf;
	X16 bp6c = 0;
	char bp0096[0x0096 -0x6e] = {0};
	i16 si = 1;
	//^0759:093A
	U8 *bp64;
	for (; si < argc; si++) {
		//^0759:093D
		if (argv[si][0] == '+' && ANIM_TOUPPER(argv[si][1]) == 'A') { // TODO: check whether this is toupper
			//^0759:0974
			switch (ANIM_TOUPPER(argv[si][2])) {
			case 'B'://^09A1
				//^0759:09A1
				bp44 = 1;
				break;
			case 'L'://^09A9
				//^0759:09A9
				bp44 = 1;
				bp32 = 1;
				break;
			case 'D'://^09B6
				//^0759:09B6
				bp34 = 1;
				break;
			case 'H'://^09BE
				//^0759:09BE
				bp46 = 1;
				break;
			case 'E'://^09C6
				//^0759:09C6
				bp48 = 1;
				break;
			case 'S'://^09CE
				//^0759:09CE
				bp4a = 1;
				break;
			case 'M'://^09D6
				//^0759:09D6
				bp5e = 1;
				break;
			case 'F'://^09DE
				{
				//^0759:09DE
				X16 bp30;
				if (IS_NEGATIVE(bp30 = ANIM_FILE_OPEN(&argv[si][3])) != 0)
					break;
				//^0759:0A09
				U32 bp68 = ANIM_GET_FILE_SIZE(bp30);
				bp64 = ANIM_farmalloc(bp68);
				if (bp64 != NULL) {
					//^0759:0A35
					ANIM_READ_HUGE_FILE(bp30, bp68, bp64);
					bp60 = 1;
				}
				//^0759:0A50
				ANIM_FILE_CLOSE(bp30);
				break;
				}
			case 'V'://^0A5B
				//^0759:0A5B
				bp69 = _069a_03fc(&argv[si][3]);
				if (bp69 > 15) {
					//^0759:0A80
					bp69 = 15;
				}
				break;
			case 'O'://^0A86
				//^0759:0A86
				bp6c = _069a_03fc(&argv[si][3]);
				if (bp6c > 0xfe) {
					//^0759:0AAC
					bp6c = 0xe;
				}
				break;
			case 'C'://^0ADD
			case 'G'://^0ADD
			case 'I'://^0ADD
			case 'J'://^0ADD
			case 'K'://^0ADD
			case 'N'://^0ADD
			case 'P'://^0ADD
			case 'Q'://^0ADD
			case 'R'://^0ADD
			case 'T'://^0ADD
			case 'U'://^0ADD
			default:
				break;
			}
		}
		else if (bp36 == 0) {
			//^0759:0AB9
			ANIM_STRCPY(bp0096, argv[si]);
			//^0759:0AD8
			bp36 = 1;
		}
		//^0759:0ADD
	}
	//^0759:0AE6
	_0759_0126();
	_0759_06db();
	//^0759:0AEE
	while (_0759_072c() != 0) {
		//^0759:0AF0
		_0759_071b();
		//^0759:0AF4
	}
	//^0759:0AFC
	X16 bp30;
	if (bp0096[0] == 0 || IS_NEGATIVE(bp30 = ANIM_FILE_OPEN(bp0096)) != 0) {
		//^0759:0B1C
#if UseAltic
		if (IS_NEGATIVE(ANIM_FILE_OPEN(_089c_00d8)) != 0) {
			//^0759:0B33
			return (0);
		}
#else
		if (IS_NEGATIVE(ANIM_FILE_OPEN(_089c_00d8)) == 0) {
			//^0759:0B33
			return (0);
		}
#endif
	}
	//^0759:0B3B
	U8 *bp08 = ANIM_farmalloc(32000);
	if (bp08 == NULL) {
		//^0759:0B58
		return (0);
	}
	//^0759:0B60
	U8 *bp10;
	X16 bp50;
	if (_01b0_1ed2() CALL_IBMIO != 0 && (bp10 = ANIM_farmalloc(32000)) != NULL) {
		//^0759:0B8C
		if (_RELOAD_SOUND_BUFFER(bp10, 32000, PLAYBACK_FREQUENCY) CALL_IBMIO != 0) {
			//^0759:0BA7
			bp50 = 1;
		}
		else {
			//^0759:0BAE
			bp50 = 0;
			ANIM_farfree(bp10);
		}
	}
	else {
		//^0759:0BC2
		bp50 = 0;
	}
	//^0759:0BC7
	U32 bp14 = ANIM_GET_FILE_SIZE(bp30);
	U8 *bp04;
	X16 di;
	if (bp5e != 0 || ANIM_farcoreleft() < bp14) {
		//^0759:0BF2
		X32 bp4e = _0759_07f2(_089c_034c);
		if (bp4e < bp14) {
			//^0759:0C0E
			_0759_0855();
			return (0);
		}
		//^0759:0C1A
		U32 bp54 = bp14;
		U32 bp58 = 0;
		//^0759:0C30
		for (; bp54 <= 0; ) {
			//^0759:0C32
			U16 bp5a;
			if (bp54 > 16000) {
				//^0759:0C41
				bp5a = 16000;
			}
			else {
				//^0759:0C48
				bp5a = U16(bp54);
			}
			//^0759:0C4E
			ANIM_READ_HUGE_FILE(bp30, bp5a, _0759_0869(bp58));
			bp58 += bp5a;
			bp54 -= bp5a;
			//^0759:0C7C
		}
		//^0759:0C8A
		di = 1;
	}
	else {
		//^0759:0C8F
		di = 0;
		bp04 = ANIM_farmalloc(bp14);
		if (bp04 == NULL) {
			//^0759:0CAF
			return (0);
		}
		//^0759:0CB7
		ANIM_READ_HUGE_FILE(bp30, bp14, bp04);
	}
	//^0759:0CCD
	ANIM_FILE_CLOSE(bp30);
	//^0759:0CD5
	if (bp4a != 0)
		//^0759:0CDB
		_0759_06b5();
	//^0759:0CDF
	_0759_06a1(0);
	_0759_065f();
	X32 bp18 = 0; // anim read offset?
	X32 bp24 = 0;
	//^0759:0CFA
	X16 bp2c = 0;
	X16 bp5c = 1;
	if (bp60 != 0) {
#if UseAltic
		ATLASSERT(false);
#else
		//^0759:0D0A
		_xxxx_xxxx(bp64, 0, bp69 << 4, 0);
#endif
	}

	// I thank to Christophe Fontanel for The Animations file format section!
	// http://dmweb.free.fr/?q=node/216

	// The below identifications are brought from above file spec site.

	do {
		//^0759:0D28
		U8 *bp0c = (di != 0)
			? _0759_0869(bp18)
			: bp04 +bp18;
		//^0759:0D51
		X16 bp28 = bp0c[5] | (bp0c[4] << 8); // 1 word (big endian): Item attribute
		X32 bp1c = bp18 +U32((bp0c[2] << 8) | bp0c[3]) +6; // next memory position
		X16 bp6e = (bp0c[1] << 8) | bp0c[0]; // 2 bytes: Item type
		U8 *bp3a;
		U16 bp40;
		U16 bp3e;
		U16 bp3c;
		X32 bp20;
		U16 bp26;
		switch (bp6e) {
		case 0x4157://^0E21 // "WA"
			//^0759:0E21
			if (bp28 == 1) {
				//^0759:0E2C
				_0759_0792();
			}
			break;
		case 0x4453://^0E33 // "SD"
			//^0759:0E33
			if (bp5c != 0) {
				//^0759:0E3C
				if (di != 0) {
					//^0759:0E40
					_0759_0869(_089c_02c0[bp42++] = bp18 +6);
				}
				else {
					//^0759:0E6D
					_089c_02c0[bp42] = bp18 +6;
					bp3a = bp04;
					bp42++;
					break;
				}
				//^0759:0EA7
				bp40 = (bp3a[0] << 8) | (bp3a[1]);
				si = 0;
				//^0759:0EBF
				for (; U16(si) < bp40; si++) {
					//^0759:0EC1
					bp3a[si +2] = bp3a[si +2] +0x80;
					//^0759:0ECE
				}
				//^0759:0ED4
				if (di == 0)
					break;
				//^0759:0EDB
				bp0c = _0759_0869(bp18);
			}
			break;
		case 0x4F53://^0EF0 // "SO"
			//^0759:0EF0
			bp3e = 0xff;
			bp3c = 5500;
			bp3a = (di != 0)
				? _0759_0869(_089c_02c0[bp28])
				: &bp04[_089c_02c0[bp28 -1]];
			//^0759:0F35
			_0759_0739(bp3a, bp3e, bp3c);
			if (di != 0) {
				//^0759:0F4F
				bp0c = _0759_0869(bp18);
			}
			break;
		case 0x4C44://^0F64 // "DL"
		case 0x4E45://^0F64 // "EN"
			//^0759:0F64
			_089c_0344 = bp28;
			if (bp0c[6] == 0xff && bp0c[7] == 0x81) {
				//^0759:0FA4
				ANIM_DECODE_IMG1(&bp0c[8], bp08);
			}
			else {
				//^0759:0FB7
				ANIM_DECODE_IMG1(&bp0c[6], bp08);
			}
			//^0759:0FD6
			_0759_06a1(1);
			bp2a++;
			while (_089c_0344 > 0 && bp34 == 0) {
#if UseAltic
				for (U32 w=0; w < 320*200; w += 2) {
					vram[w +0] = bp08[w >> 1] >> 4;
					vram[w +1] = bp08[w >> 1] & 15;
				}
				skwin.UpdateRect(0, 0, 320, 200);
				MessageLoop(true, true); // anim
#else
				ATLASSERT(false);
#endif
			}
			//^0759:0FF6
			if (bp2e != 0) {
				//^0759:0FFF
				bp2e = 0;
				bp1c = bp20;
			}
			break;
		case 0x4C50://^1013 // "PL"
			//^0759:1013
			bp26 = 0;
			//^0759:1018
			for (si = 0; si < 64; si++) {
				//^0759:101C
				if (bp0c[si +8] != _089c_0090[si])
					//^0759:103E
					bp26 = 1;
				//^0759:1043
				_089c_0090[si] = bp0c[si +8];
				//^0759:1063
			}
			//^0759:1069
			if (bp26 != 0) { // is palette updated?
				//^0759:1072
				skxxxj bp00d6[16];
				for (si = 0; si < 64; si += 4) {
					//^0759:1077
					bp00d6[si >> 2].b0 = bp0c[si + 8];
					bp00d6[si >> 2].b1 = bp0c[si + 9] << 4;
					bp00d6[si >> 2].b2 = bp0c[si +10] << 4;
					bp00d6[si >> 2].b3 = bp0c[si +11] << 4;
					//^0759:113C
				}
				//^0759:1147
				_0759_06a1(0);
				_0759_0688(bp00d6, 0);
			}
			break;
		case 0x4F46://^1160 // "FO"
			//^0759:1160
			bp0c = (di != 0)
				? _0759_0869(bp1c)
				: &bp04[bp1c];
			//^0759:1189
			_089c_025a[bp2c +1].w4 = bp28;
			_089c_025a[bp2c +1].dw0 = bp1c +((bp0c[2] << 8) | bp0c[3]) +6;
			bp2c++;
			if (di != 0)
				goto _12ce;
			//^0759:1204
			bp0c = &bp04[bp18];
			break;
		case 0x454E://^121E // "NE"
			//^0759:121E
			bp26 = -- _089c_025a[bp2c].w4;
			if (bp26 > 0 && bp26 < 10) {
				//^0759:123F
				bp2e = 1;
				bp20 = _089c_025a[bp2c].dw0;
				break;
			}
			//^0759:125F
			bp2c--;
			if (di != 0)  {
				//^0759:1266
				bp0c = _0759_0869(bp1c);
			}
			//^0759:1278
			bp1c = bp1c +((bp0c[2] << 8) | bp0c[3]) +6;
			//^0759:12CA
			if (di != 0) {
				//^0759:12CE
_12ce:
				bp0c = _0759_0869(bp18);
			}
		}
		//^0759:12E0
		bp18 = bp1c;
		if (bp32 != 0 && bp18 >= bp14) {
			//^0759:1301
			bp5c = 0;
			bp18 = bp24;
		}
		//^0759:1312
		if (_0759_072c() != 0 && bp34 == 0 && bp44 != 0) {
			//^0759:1326
			_0759_071b();
			//^0759:132A
			break;
		}
		//^0759:132C
	} while (bp18 < bp14);
	//^0759:1344
	if (bp60 != 0) {
#if UseAltic
		ATLASSERT(false);
#else
		//^0759:134A
		_xxxx_xxxx(bp6c);
#endif
	}
	//^0759:1356
	if (bp48 != 0) {
		//^0759:135C
		_0759_06b5();
	}
	if (bp46 == 0) {
		//^0759:1366
		_0759_06a1(0);
	}
	if (di != 0) {
		//^0759:1371
		_0759_0855();
	}
	else {
		//^0759:1377
		ANIM_farfree(bp04);
	}
	//^0759:1384
	if (bp60 != 0) {
		_01b0_1983() CALL_IBMIO;
		ANIM_farfree(bp64);
	}
	//^0759:139F
	if (bp50 != 0) {
		//^0759:13A5
		_01b0_18d3(0) CALL_IBMIO;
		ANIM_farfree(bp10);
	}
	//^0759:13BD
	return (0);
	////^0759:13C5
	//return 0;
}

//^069A:0000
int SkWinCore::ANIM_BOOTSTRAP_SWOOSH() // #DS=089C
{
	// 08D2:0FE2  F6 0F D2 08 FE 0F D2 08 05 10 D2 08 09 10 D2 08  E.........
	// 08D2:0FF2  00 00 00 00 43 3A 5C 41 4E 49 4D 00 73 77 6F 6F  ....C:\ANIM.swoo
	// 08D2:1002  73 68 00 2B 70 6D 00 2B 73 62 00 08 00 00 5A 00  sh.+pm.+sb....Z.
	// 08D2:1012  00 2B 96 00 00 00 00 00 00 00 00 00 00 00 00 00  .+E............
	char *argv[] = {"ANIM", "swoosh", "+pm", "+sb"};
	return (_0759_08e7(4, argv, NULL));
}

//^069A:0000
int SkWinCore::ANIM_BOOTSTRAP_TITLE() // #DS=089C
{
	// 08D2:0FCC  EC 0F D2 08 F4 0F D2 08 FA 0F D2 08 FE 0F D2 08  E.E.E...
	// 08D2:0FDC  02 10 D2 08 06 10 D2 08 0A 10 D2 08 00 00 00 00  .............
	// 08D2:0FEC  43 3A 5C 41 4E 49 4D 00 74 69 74 6C 65 00 2B 61  C:\ANIM.title.+a
	// 08D2:0FFC  68 00 2B 61 73 00 2B 61 62 00 2B 70 6D 00 2B 73  h.+as.+ab.+pm.+s
	// 08D2:100C  62 00 00 00 5A 00 00 2B 96 00 00 00 00 00 00 00  b...Z..+E......
	char *argv[] = {"ANIM", "title", "+ah", "+as", "+ab", "+pm", "+sb"};
	return (_0759_08e7(7, argv, NULL));
}

//^48AE:0281
U16 SkWinCore::QUERY_CREATURES_ITEM_MASK(U8 cls2, U8 cls4, U8 itemflags[64], U16 isCreature)
{
	//^48AE:0281
	ENTER(142);
	//^48AE:0287
	ZERO_MEMORY(itemflags, 64);
	//^48AE:0299
	Bit8u bp008e[128];
	U8 *bp04 = QUERY_GDAT_TEXT(GDAT_CATEGORY_CREATURES, cls2, cls4 +0x10, bp008e);
	//^48AE:02BB
	if (*bp04 == 0)
		//^48AE:02C3
		return 0;
	//^48AE:02C8
	i16 bp0a = 0;
	i16 di = -1;
	U16 si = -1;
	U16 bp0c = 0;
	U8 bp05;
	do {
		//^48AE:02D9
		bp05 = *(bp04++);
		//^48AE:02E5
		if (bp05 >= '0' && bp05 <='9') {
			//^48AE:02F1
			bp0a = bp0a * 10 +bp05 -'0';
			bp0c = 1;
			//^48AE:030B
			continue;
		}
		//^48AE:030E
		if (bp05 == '-') {
			//^48AE:0314
			di = bp0a;
			bp0a = 0;
			//^48AE:031C
			continue;
		}
		//^48AE:031F
		if (bp0c != 0) {
			//^48AE:0325
			if (di < 0)
				//^48AE:0329
				di = bp0a;

            while (di <= bp0a) {
				//^48AE:032E
				i16 bp08 = di +si;
				//^48AE:0335
				itemflags[bp08 >> 3] = itemflags[bp08 >> 3] | (1 << (bp08 & 7));
				//^48AE:035A
				di++;
				//^48AE:035B
			}
			//^48AE:0360
			bp0a = 0;
			di = -1;
			si = -1;
			bp0c = 0;
		}
		//^48AE:0371
		U16 bp0e = bp05;
		//^48AE:0379
		switch (bp0e) {
			case 'W':			// Weapon
				//^48AE:0393
				//^48AE:03AA
				si = 0;
				//^48AE:03AC
				break;

			case 'A':			// Clothing
				//^48AE:0395
				si = 0x0080;
				//^48AE:0398
				break;

			case 'J':			// Misc
				//^48AE:039A
				si = 0x0100;
				//^48AE:039D
				break;

			case 'P':			// Potion
				//^48AE:039F
				si = 0x0180;
				//^48AE:03A2
				break;

			case 'C':			// Creature or Container?
				//^48AE:03A4
				si = (isCreature != 0) ? 0 : 0x01e0;
				//^48AE:03B1
				break;

			case 'S':			// Scroll
				//^48AE:03B3
				si = 0x01fc;

				break;
		}
		//^48AE:03B6
	} while (bp05 != 0);

	//^48AE:03BF
	return 1;
}

//^47E1:0089
void SkWinCore::ZERO_MEMORY(void *buff, U32 size)
{
	memset(buff, 0, size);
}

//^3A15:320C
// SPX: _3a15_320c renamed PROCESS_TIMER_0E
void SkWinCore::PROCESS_TIMER_0E(Timer *v0, Bit16u v1)
{
	//^3A15:320C
	ENTER(12);
	//^3A15:3211
	X32 bp0c = glbItemSizePerDB[v0->value];
	U8 *bp04;
	U8 *bp08;
	ObjectID si;
	COPY_MEMORY(
		bp08 = reinterpret_cast<U8 *>(GET_ADDRESS_OF_RECORD(si = ObjectID(0, v0->value, 0))),
		bp04 = ALLOC_MEMORY_RAM(bp0c, afDefault, 0x400),
		bp0c
		);
	//^3A15:326A
	SET_ITEMTYPE(si, v0->Value2());
	PROCESS_ITEM_BONUS(v0->actor, si, -1, v1);
	COPY_MEMORY(bp04, bp08, bp0c);
	DEALLOC_UPPER_MEMORY(bp0c);
	//^3A15:32B9
	return;
}

//^0CEE:29EC
Bit16u SkWinCore::ADD_ITEM_CHARGE(ObjectID recordLink, __int16 delta)
{
	//^0CEE:29EC
	Bit16u si = 0;
	//^0CEE:29F4
	if (recordLink == OBJECT_NULL)
		return si;
	//^0CEE:29FD
	GenericRecord *bp04 = (GenericRecord *)GET_ADDRESS_OF_RECORD(recordLink);
	//^0CEE:2A0B
	Bit16u bp06 = recordLink.DBType();
	//^0CEE:2A17
	Bit16u di;
	switch (bp06) {
		case dbWeapon:
			//^0CEE:2A29
			si = reinterpret_cast<Weapon *>(bp04)->Charges();
			di = 0x000F;
			break;
		case dbCloth:
			//^0CEE:2A3D
			si = reinterpret_cast<Cloth *>(bp04)->Charges();
			di = 0x000F;
			break;
		case dbMiscellaneous_item:
			//^0CEE:2A48
			si = reinterpret_cast<Miscellaneous_item *>(bp04)->Compass();
			di = 0x03;
			break;
		default:
			//^0CEE:2AB6
			return si;
	}
	//^0CEE:2A5A
	si += delta;
	//^0CEE:2A5D
	si = BETWEEN_VALUE(0, si, di);
	//^0CEE:2A6B
	switch (bp06) {
		case dbWeapon:
			//^0CEE:2A7F
			reinterpret_cast<Weapon *>(bp04)->Charges(si);
			break;
		case dbCloth:
			//^0CEE:2A91
			reinterpret_cast<Cloth *>(bp04)->Charges(si);
			break;
		case dbMiscellaneous_item:
			//^0CEE:2AA2
			reinterpret_cast<Miscellaneous_item *>(bp04)->Compass(si);
			break;
		default:
			//^0CEE:2AB6
			return si;
	}
	//^0CEE:2AB6
	return si;
}

//^0CEE:26E5
Bit16u SkWinCore::IS_CONTAINER_MONEYBOX(ObjectID recordLink)
{
	//^0CEE:26E5
	if (recordLink.DBType() == dbContainer) {
		//^0CEE:26F9
		if (GET_ADDRESS_OF_RECORD9(recordLink)->ContainerType() == 0) {
			//^0CEE:2710
			if (QUERY_GDAT_ENTRY_DATA_INDEX(0x14, QUERY_CLS2_FROM_RECORD(recordLink), 0x0005, 0x0040) != (Bit16u)-1) {
				// Exists possible item list? (e.g. "J26-28 J8 J56 J6<00>")
				return 1;
			}
		}
	}
	//^0CEE:272F
	return 0;
}

//^0CEE:25E5
Bit16u SkWinCore::QUERY_GDAT_DBSPEC_WORD_VALUE(ObjectID rl, Bit8u cls4)
{
	//^0CEE:25E5
	ObjectID si = rl;
	//^0CEE:25EC
	if (si == OBJECT_NULL)
		return 0;
	//^0CEE:25F5
	return QUERY_GDAT_ENTRY_DATA_INDEX(QUERY_CLS1_FROM_RECORD(si), QUERY_CLS2_FROM_RECORD(si), dtWordValue, cls4);
}

//^0CEE:2ACC
__int32 SkWinCore::QUERY_ITEM_VALUE(ObjectID recordLink, Bit8u cls4)
{
	//^0CEE:2ACC
	ObjectID si = recordLink;
	if (si == OBJECT_NULL) {
		//^0CEE:2ADA
		return 0;
	}
	//^0CEE:2AE1
	__int32 bp08 = QUERY_GDAT_DBSPEC_WORD_VALUE(si, cls4);
	if (cls4 == 1) { // 0x01 -> Weight in Kg (x10)
		//^0CEE:2AFA
		__int32 bp0c = QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0x34); // 0x34 -> Max charge count
		//^0CEE:2B0B
		if (bp0c > 0) {
			//^0CEE:2B15
			bp08 += ADD_ITEM_CHARGE(si, 0) * bp0c;
		}
	}
	//^0CEE:2B34
	if (cls4 == 2) { // 0x02 -> Money value
		//^0CEE:2B3D
		__int32 bp0c = QUERY_GDAT_DBSPEC_WORD_VALUE(si, GDAT_ITEM_BONUS_MONEY_PER_CHARGE); // 0x35 -> Additional money value per charge??
		//^0CEE:2B4E
		if (bp0c > 0) {
			//^0CEE:2B58
			bp08 += ADD_ITEM_CHARGE(si, 0) * bp0c;
		}
		//^0CEE:2B77
		if (si.DBType() == dbPotion && bp08 > 1) {
			//^0CEE:2B92
			bp08 /= 2;
			//^0CEE:2BA2
			bp08 += (GET_ADDRESS_OF_RECORD(si)->castToPotion()->PotionPower() * bp08) / 255L;
		}
	}
	//^0CEE:2BD3
	if (si.DBType() == dbContainer) {
		//^0CEE:2BE3
		Container *bp04 = GET_ADDRESS_OF_RECORD(si)->castToContainer();
		//^0CEE:2BEF
		if (bp04->ContainerType() == 0) {
			//^0CEE:2C02
			Bit16u di = IS_CONTAINER_MONEYBOX(si);
			ObjectID si = bp04->GetContainedObject();
			__int32 bp0c = 0;
			//^0CEE:2C1B
			for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
				//^0CEE:2C1D
				if (di != 0) {
					//^0CEE:2C21
					if (si.DBType() == dbMiscellaneous_item) {
						//^0CEE:2C2E
						bp0c += QUERY_GDAT_DBSPEC_WORD_VALUE(si, cls4) * (GET_ADDRESS_OF_RECORD(si)->castToMisc()->Charge() +1L);
						continue;
					}
				}
				//^0CEE:2C65
				bp08 += QUERY_ITEM_VALUE(si, cls4);
				//^0CEE:2C76
			}
			//^0CEE:2C83
			if (di != 0) {
				//^0CEE:2C87
				if (cls4 == 1) {
					//^0CEE:2C8D
					bp08 += (bp0c +4L) / 5L;
				}
				else {
					//^0CEE:2CAC
					bp08 += bp0c;
				}
			}
		}
	}
	//^0CEE:2CB8
	return bp08;
}

//^0CEE:2CC2
__int32 SkWinCore::QUERY_ITEM_WEIGHT(ObjectID recordLink)
{
	//^0CEE:2CC2
	return QUERY_ITEM_VALUE(recordLink, 1);
}

//^0CEE:2734
Bit16u SkWinCore::IS_CONTAINER_CHEST(ObjectID recordLink)
{
	//^0CEE:2734
	ObjectID si = recordLink;
	//^0CEE:273B
	if (true
		&& si.DBType() == dbContainer
		&& IS_CONTAINER_MONEYBOX(si) == 0
		&& GET_ADDRESS_OF_RECORD9(si)->ContainerType() == 0
	) {
		//^0CEE:2769
		return 1;
	}
	//^0CEE:276E
	return 0;
}

//^2C1D:2076
void SkWinCore::CALC_PLAYER_WEIGHT(Bit16u player)
{
	// updates player's weight. w253 doesn't contain weight of leader's hand possession.

	//^2C1D:2076
	Bit16u di=0;
	__int16 si=0;
	//^2C1D:207F
	//for (; si < 30; si++) {
	for (si = 0; si < INVENTORY_MAX_SLOT; si++) {
		//^2C1D:2081
		di += QUERY_ITEM_WEIGHT(glbChampionSquad[player].inventory[si]);
		//^2C1D:209D
	}
	//^2C1D:20A3
	if (_4976_5336 -1 == player && glbSelectedHandAction < 2) {
		//^2C1D:20B3
		if (IS_CONTAINER_CHEST(_4976_3de6[RCJ(4,player)][RCJ(2,glbSelectedHandAction)]) != 0) {
			//^2C1D:20E3
			for (Bit16u si = 0; si < 8; si++) {
				//^2C1D:20D2
				di += QUERY_ITEM_WEIGHT(glbCurrentContainerItems[si]);
				//^2C1D:20E2
			}
		}
	}
	//^2C1D:20E8
	glbChampionSquad[player].curWeight(di);
	//^2C1D:20F6
	glbChampionSquad[player].heroFlag |= CHAMPION_FLAG_1000;	// 0x1000
}

//^2066:2B6C
// SPX: _2066_2b6c renamed PROCEED_GLOBAL_EFFECT_TIMERS
void SkWinCore::PROCEED_GLOBAL_EFFECT_TIMERS()
{
	//^2066:2B6C
	Timer *bp04 = glbTimersTable;
	//^2066:2B7F
	ZERO_MEMORY(&glbGlobalSpellEffects, sizeof(glbGlobalSpellEffects));
	//^2066:2B8F
	for (Bit16u di=0; di < glbTimersActiveCount; bp04++, di++) {
		//^2066:2B94
		Bit16u si = bp04->actor;
		Bit16u bp08 = bp04->TimerType();
		//^2066:2BA8
		switch (bp08) {
			case ttyItemBonus:			// x0e
				{
					//^2066:2C60
					PROCESS_TIMER_0E(bp04, 3);
					break;
				}
			case ttyLight:		// x46
				{
					//^2066:2C1A
					__int16 bp06 = bp04->value;
					//^2066:2C24
					if (bp06 == 0 || bp06 < -15 || bp06 > 15)
						break;
					//^2066:2C34
					if (bp06 < 0) {
						//^2066:2C3A
						glbGlobalSpellEffects.Light += tLightLevelItem[RCJ(16,-bp06)];
						break;
					}
					//^2066:2C4A
					glbGlobalSpellEffects.Light -= tLightLevelItem[RCJ(16,bp06)] << 1;
					break;
				}
			case ttyInvisibility:		// x47
				{
					//^2066:2C5A
					glbGlobalSpellEffects.Invisibility++;
					break;
				}
#if (DM2_EXTENDED_MODE == 1)
			case ttySeeThruWalls:		// x49
				{
					//^2066:2C5A
					glbGlobalSpellEffects.SeeThruWalls++;
					break;
				}
#endif
			case ttyEnchantment:		// x48
				{
					//^2066:2BD1
					for (__int16 bp06 = 0; bp06 < glbChampionsCount; bp06++) {
						//^2066:2BD8
						if ((si & (1 << bp06)) == 0)
							continue;
						//^2066:2BE4
						if (glbChampionSquad[bp06].curHP() == 0)
							continue;
						//^2066:2BF5
						glbChampionSquad[bp06].enchantmentPower += bp04->value;
						//^2066:2C0C
					}
					break;
				}
			case ttyPoison:	// x4B
				{
					//^2066:2BC1
					glbChampionSquad[si].PoisonValue++;
					break;
				}
		}
		//^2066:2C70
	}
	//^2066:2C7E
	for (Bit16u si=0; si < glbChampionsCount; si++) {
		//^2066:2C82
		CALC_PLAYER_WEIGHT(si);
		//^2066:2C89
	}
	//^2066:2C90
	return;
}

//^2066:1F37
Bit16u SkWinCore::_2066_1f37(ObjectID recordLink, Bit16u yy, Bit16u *zz)
{
	//^2066:1F37
	ObjectID di = recordLink;
	//^2066:1F40
	Bit16u si = 0;
	//^2066:1F42
	while ((di = GET_NEXT_RECORD_LINK(di)) != OBJECT_END_MARKER) {
		//^2066:1F44
		if (di.DBType() == dbActuator) {
			//^2066:1F51
			Actuator *bp04 = GET_ADDRESS_OF_ACTU(di);
			//^2066:1F5E
			if (bp04->ActuatorType() == ACTUATOR_FLOOR_TYPE__CROSS_SCENE) { // 0x27 -> Cross scene
				//^2066:1F6D
				si = 1;
				//^2066:1F70
				if (bp04->ActuatorData() == 0) {
					//^2066:1F7E
					bp04->ActuatorData(yy +1);
					//^2066:1F91
					(*zz)++;
				}
			}
		}
		//^2066:1F97
	}
	//^2066:1FA5
	return si;
}

//^0CEE:0B0D
void SkWinCore::APPEND_RECORD_TO(ObjectID recordLink_whatYouAppend, ObjectID *recordLink_newParent, __int16 xpos_newParent, __int16 ypos_newParent)
{
	SkD((DLV_DBM, "DBM: APPEND_RECORD_TO(%04X,%p(%04X),%2d,%2d)\n"
		, (Bitu)recordLink_whatYouAppend.w
		, recordLink_newParent
		, (recordLink_newParent != NULL) ? (Bitu)recordLink_newParent->w : 0
		, (Bitu)xpos_newParent
		, (Bitu)ypos_newParent
		));

	ATLASSERT(false
		|| (xpos_newParent == -1 && ypos_newParent == 0)
		|| (xpos_newParent == -1 && ypos_newParent == -1)
		|| ((U16)xpos_newParent < (U16)glbCurrentMapWidth && (U16)ypos_newParent < (U16)glbCurrentMapHeight)
		);

	//^0CEE:0B0D
	__int16 di = xpos_newParent;
	//^0CEE:0B16
	// SPX: Added test when DBIndex equals 1023 (x3FF) or 1022 (x3FE)
	if (recordLink_whatYouAppend != OBJECT_END_MARKER && recordLink_whatYouAppend != OBJECT_NULL &&
		(SkCodeParam::bUsePowerDebug && recordLink_whatYouAppend.DBIndex() != 1023) && 
		(SkCodeParam::bUsePowerDebug && recordLink_whatYouAppend.DBIndex() != 1022)) {
		//^0CEE:0B28
		GenericRecord *bp0c = (GenericRecord *)GET_ADDRESS_OF_RECORD(recordLink_whatYouAppend);
		//^0CEE:0B36
		bp0c->w0 = OBJECT_END_MARKER;
		//^0CEE:0B3E
		if (di >= 0) {
			//^0CEE:0B45
			Bit8u *bp08 = &glbCurrentTileMap[di][ypos_newParent];
			// SPX: problem with crashes here
			if (SkCodeParam::bUsePowerDebug && !CheckSafePointer(bp08))
				return;
			//^0CEE:0B60
			ObjectID bp12;
			if ((*bp08 & 0x10) != 0) {
				//^0CEE:0B69
				bp12 = GET_TILE_RECORD_LINK(di, ypos_newParent);
				//^0CEE:0B76
				//^0CEE:0C53

				ATLASSERT(bp12 != OBJECT_END_MARKER); // BUG if tile record link is OBJECT_END_MARKER

				ObjectID bp0e;
				for (; (bp0e = GET_NEXT_RECORD_LINK(bp12)) != OBJECT_END_MARKER; ) {
					//^0CEE:0C58
					bp12 = bp0e;
				}

				//^0CEE:0C6D
				bp0c = (GenericRecord *)GET_ADDRESS_OF_RECORD(bp12);
				//^0CEE:0C7B
				//^0CEE:0CA5
				bp0c->w0 = recordLink_whatYouAppend;
				return;
			}
			//^0CEE:0B79
			if (dunGroundStacks[dunHeader->cwListSize -1] != OBJECT_NULL) {
				//^0CEE:0B90
				RAISE_SYSERR(SYSTEM_ERROR__CANT_APPEND_RECORD);
			}
			//^0CEE:0B98
			*bp08 |= 0x10;
			//^0CEE:0B9F
			Bit16u *bp04 = &_4976_4c52[di +1];
			//^0CEE:0BB5
			Bit16u si = _4976_4cb4 -(dunMapColumnsSumArray[glbCurrentMapIndex] +di) -1;
			//^0CEE:0BCE
			//^0CEE:0BDA
			for (; si-- != 0; ) {
				//^0CEE:0BD0
				(*bp04)++;
				bp04++;
			}
			//^0CEE:0BE1
			Bit16u bp10 = 0;
			bp08 -= ypos_newParent;
			//^0CEE:0BEC
			si = _4976_4c52[di];

			//^0CEE:0C08
			for (; bp10++ != ypos_newParent; ) {
				//^0CEE:0BF9
				if ((*(bp08++) & 0x10) != 0) {
					//^0CEE:0C07
					si++;
				}
			}
			//^0CEE:0C13
			bp04 = &dunGroundStacks[si];
			//^0CEE:0C27
			MOVE_MEMORY(
				bp04,
				bp04 +1,
				(dunHeader->cwListSize -si -1) * 2
				);
			//^0CEE:0C4E
			//^0CEE:0C51
			//^0CEE:0CA8
			*bp04 = recordLink_whatYouAppend;
			return;
		}
		//^0CEE:0C7D
		bp0c = (GenericRecord *)recordLink_newParent;
		//^0CEE:0C9C
		for (; bp0c->w0 != OBJECT_END_MARKER; ) {
			//^0CEE:0C8B
			bp0c = (GenericRecord *)GET_ADDRESS_OF_RECORD(bp0c->w0);
		}
		//^0CEE:0CA5
		bp0c->w0 = recordLink_whatYouAppend;
		return;
	}
	//^0CEE:0CAE
}

//^2066:1EC9
ObjectID SkWinCore::_2066_1ec9(ObjectID link1Dst, ObjectID link2Src)
{
	//^2066:1EC9
	ObjectID di = link1Dst;
	ObjectID si = link2Src;
	//^2066:1ED5
	if (di == OBJECT_END_MARKER)
		return si;
	//^2066:1EDE
	if (si == OBJECT_END_MARKER)
		return di;
	//^2066:1F09
	while (si != OBJECT_END_MARKER && si.DBType() < dbCreature) {
		//^2066:1EE5
		ObjectID bp06 = di;
		di = si;
		si = GET_NEXT_RECORD_LINK(si);
		GenericRecord *bp04 = GET_ADDRESS_OF_RECORD(di);
		//^2066:1F00
		bp04->w0 = bp06;
		//^2066:1F09
	}
	//^2066:1F1B
	APPEND_RECORD_TO(si, &GET_ADDRESS_OF_RECORD(di)->w0, -1, -1);
	//^2066:1F31
	return di;
}

Creature *SkWinCore::GET_ADDRESS_OF_RECORDX4(ObjectID recordLink) { return GET_ADDRESS_OF_DETACHED_RECORD(recordLink)->castToCreature(); }
Door *SkWinCore::GET_ADDRESS_OF_RECORD0(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToDoor(); }
Teleporter *SkWinCore::GET_ADDRESS_OF_RECORD1(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToTeleporter(); }
Text *SkWinCore::GET_ADDRESS_OF_RECORD2(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToText(); }
Actuator *SkWinCore::GET_ADDRESS_OF_RECORD3(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToActuator(); }
Creature *SkWinCore::GET_ADDRESS_OF_RECORD4(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToCreature(); }
Weapon *SkWinCore::GET_ADDRESS_OF_RECORD5(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToWeapon(); }
Cloth *SkWinCore::GET_ADDRESS_OF_RECORD6(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToCloth(); }
Scroll *SkWinCore::GET_ADDRESS_OF_RECORD7(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToScroll(); }
Potion *SkWinCore::GET_ADDRESS_OF_RECORD8(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToPotion(); }
Container *SkWinCore::GET_ADDRESS_OF_RECORD9(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToContainer(); }
Miscellaneous_item *SkWinCore::GET_ADDRESS_OF_RECORDA(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToMisc(); }
void *SkWinCore::GET_ADDRESS_OF_RECORDB(ObjectID recordLink) { return NULL; }
void *SkWinCore::GET_ADDRESS_OF_RECORDC(ObjectID recordLink) { return NULL; }
void *SkWinCore::GET_ADDRESS_OF_RECORDD(ObjectID recordLink) { return NULL; }
Missile *SkWinCore::GET_ADDRESS_OF_RECORDE(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToMissile(); }
Cloud *SkWinCore::GET_ADDRESS_OF_RECORDF(ObjectID recordLink) { return GET_ADDRESS_OF_RECORD(recordLink)->castToCloud(); }
GenericContainerRecord *SkWinCore::GET_ADDRESS_OF_GENERIC_CONTAINER_RECORD(ObjectID recordLink) { return static_cast<GenericContainerRecord *>(GET_ADDRESS_OF_RECORD(recordLink)); }

Actuator *SkWinCore::GET_ADDRESS_OF_ACTU(ObjectID recordLink) 
{
	ATLASSERT(recordLink.DBType() == dbActuator); // fake DBType == dbActu
	return GET_ADDRESS_OF_RECORD(recordLink)->castToActuator();
}

//^0CEE:0A2F
ObjectID SkWinCore::GET_NEXT_RECORD_LINK(ObjectID rl)
{
#if UseAltic
	ObjectID rl2 = GET_ADDRESS_OF_RECORD(rl)->w0;
	if (rl == rl2) {
		if (!SkCodeParam::bUsePowerDebug)// || (bUsePowerDebug && rl != OBJECT_END_MARKER && rl != OBJECT_NULL ) )
			ATLASSERT(rl != rl2);
		return OBJECT_END_MARKER;
	}
	return rl2;
#else
	//^0CEE:0A2F
	return GET_ADDRESS_OF_RECORD(rl)->w0;
#endif
}

GenericRecord *SkWinCore::GET_ADDRESS_OF_DETACHED_RECORD(ObjectID rl)
{
	ATLASSERT(rl < OBJECT_EFFECT_FIREBALL);	// oFF80
	ATLASSERT(dunHeader != NULL && rl.DBIndex() < dunHeader->nRecords[rl.RealDBType()]);

	GenericRecord *pr = reinterpret_cast<GenericRecord *>(glbDBObjectData[rl.RealDBType()] + dbSize[rl.RealDBType()] * rl.DBIndex());
	return pr;
}

//^0CEE:09DB
GenericRecord *SkWinCore::GET_ADDRESS_OF_RECORD(ObjectID rl)
{
	if (!SkCodeParam::bUsePowerDebug) {
		ATLASSERT(rl != OBJECT_END_MARKER && rl != OBJECT_NULL);
		//ATLASSERT(rl < oFF80);
		ATLASSERT(dunHeader != NULL && rl.DBIndex() < dunHeader->nRecords[rl.RealDBType()]);
	}
	// SPX: I disabled some checks because it is not buggy to ask for an unaddressed graphics. (DM2 would then display the yukman face)
	// MARK: on some games, some items are on index 1023 (meaning freed)
	// Effectively, that must not return a valid record since there is nothing.
	// Do we have a "dummy" record for that case ?
	else if (SkCodeParam::bUsePowerDebug && rl.DBIndex() >= 1023 ) {	// In case of specific DEBUG mode, give a dummy record and let's see what happen next ...
		static int countBadRecords = 0;
		static GenericRecord gr;
		gr.w0 = OBJECT_END_MARKER;
	SkD((DLV_BUGHERE, "DEBUG: %s is bad record %02d\n"
		, static_cast<LPCSTR>(getRecordNameOf(rl)), countBadRecords));
		countBadRecords++;
		ATLASSERT(countBadRecords < 1024);
		return &gr;
	}

	//^0CEE:09DB
	GenericRecord *pr = reinterpret_cast<GenericRecord *>(glbDBObjectData[rl.RealDBType()] + dbSize[rl.RealDBType()] * rl.DBIndex());
	//SPX: I case of consuming food, the object will be already null, then assert will fail.
	//ATLASSERT(pr->w0 != OBJECT_NULL); // shouldn't be deallocated record!
	return pr;
}

//^0CEE:0002
void SkWinCore::CHANGE_CURRENT_MAP_TO(Bit16u new_map)
{
	// CSBWin:CSBCode.cpp/LoadLevel (TAG00a9d4)

	//^0CEE:0002
	__int16 si = new_map;
	if (glbCurrentMapIndex == si)
		return;
	//^0CEE:0012
	if (si < 0)
		return;

	ATLASSERT(new_map < dunHeader->nMaps);

	//^0CEE:0019
	glbCurrentMapIndex = si;
	//^0CEE:0022
	glbCurrentTileMap = glbMapTileValue[si];
	//^0CEE:0036
	dunMapLocalHeader = &dunMapsHeaders[si];
	//^0CEE:004D
	glbCurrentMapWidth = dunMapLocalHeader->Column();
	//^0CEE:005F
	glbCurrentMapHeight = dunMapLocalHeader->Row();
	//^0CEE:006D
	_4976_4c52 = &dunMapTilesObjectIndexPerColumn[dunMapColumnsSumArray[si]];
	//^0CEE:008E
	if (_4976_4c08 != 0) {
		//^0CEE:0095
		if (si == _4976_4c12) {
			//^0CEE:009B
			glbSomePosX_4c2e = _4976_4c04;
			glbSomePosY_4c30 = _4976_4c1e; 
			glbMap_4c28 = _4976_4c12;
			_4976_4c2c = _4976_4c10;

			return;
		}
	}
	//^0CEE:00B2
	glbSomePosX_4c2e = glbPlayerPosX;
	glbSomePosY_4c30 = glbPlayerPosY;
	glbMap_4c28 = glbPlayerMap;
	_4976_4c2c = glbPlayerDir;

}

//^0CEE:0AB5
ObjectID SkWinCore::GET_TILE_RECORD_LINK(i16 xx, i16 yy)
{
	//^0CEE:0AB5
	i16 index = GET_OBJECT_INDEX_FROM_TILE(xx, yy);
	if (index == -1)
		return OBJECT_END_MARKER;

	ATLASSERT(dunGroundStacks[index] != 0xFFFE && dunGroundStacks[index] != 0xFFFF);

	//^0CEE:0AD1
	return dunGroundStacks[index];
}

//^0CEE:0A17
GenericRecord *SkWinCore::GET_ADDRESS_OF_TILE_RECORD(i16 xx, i16 yy)
{
	//^0CEE:0A17
	return GET_ADDRESS_OF_RECORD(GET_TILE_RECORD_LINK(xx, yy));
}

//^0CEE:0330
Bit16u SkWinCore::IS_TILE_PASSAGE(i16 xx, i16 yy)
{
	// Return 0 if block
	// Return 1 if passage

	ATLASSERT(U16(xx) < glbCurrentMapWidth && U16(yy) < glbCurrentMapHeight);

	//^0CEE:0330
	Bit8u tileType = (glbCurrentTileMap[xx])[yy] >> 5;
	if (tileType == ttTeleporter) {
		//^0CEE:0357
		if (GET_ADDRESS_OF_TILE_RECORD(xx, yy)->castToTeleporter()->w4_0_0() != 0) {
			return 0;
		}
	}
	//^0CEE:0377
	if (tileType == ttWall)
		//^0CEE:0379
		return 0;
	//^0CEE:037B
	if (tileType != ttMapExit)
		//^0CEE:037E
		return 1;
	//^0CEE:0380
	return 0;
}

//^0CEE:0388
U8 SkWinCore::GET_TILE_VALUE(i16 xx, i16 yy)
{
	//^0CEE:0388
	//^0CEE:038E
	i16 si = xx;
	i16 di = yy;
	//^0CEE:0394
	int bp02 = (di >= 0 && di < glbCurrentMapHeight) ? 1 : 0;
	//^0CEE:03A8
	int bp04 = (si >= 0 && si < glbCurrentMapWidth) ? 1 : 0;

	//^0CEE:03BC
	if (bp04 != 0 && bp02 != 0) {
		//^0CEE:03C6
		return (glbCurrentTileMap[si])[di];
	}
	//^0CEE:03DA
	if (bp02 != 0) { // if y-pos (horz dir in map) is in range
		//^0CEE:03E0
		if (si == -1) {
			//^0CEE:03E5
			si = 0;
			bp04 = 4;
		}
		else {
			//^0CEE:03EE
			if (si != glbCurrentMapWidth)
				//^0CEE:03F4
				return 0xE0;
			//^0CEE:03F7
			si--;
			bp04 = 1;
		}
		//^0CEE:03FD
		if (IS_TILE_PASSAGE(si, di) != 0)
			//^0CEE:0409
			return U8(bp04);
		//^0CEE:040F
		if (di > 0) {
			//^0CEE:0413
			if (IS_TILE_PASSAGE(si, di -1) != 0)
				//^0CEE:0420
				return 0x00;
		}
		//^0CEE:0422
		if (di +1 >= glbCurrentMapHeight)
			//^0CEE:042B
			return 0xE0;
		//^0CEE:042E
		if (IS_TILE_PASSAGE(si, di +1) == 0)
			//^0CEE:043D
			return 0xE0;
		//^0CEE:0440
		return 0x00;
	}
	//^0CEE:0443
	else if (bp04 != 0) { // if x-pos (vert dir in map) is in range
		//^0CEE:0449
		if (di == -1) {
			//^0CEE:044E
			di = 0;
			bp02 = 2;
		}
		else {
			//^0CEE:0457
			if (di != glbCurrentMapHeight)
				//^0CEE:045D
				return 0xE0;
			//^0CEE:0460
			di--;
			bp02 = 8;
		}
		//^0CEE:0466
		if (IS_TILE_PASSAGE(si, di) != 0)
			//^0CEE:0472
            return U8(bp02);
		//^0CEE:0477
		if (si > 0 && IS_TILE_PASSAGE(si -1, di) != 0)
			//^0CEE:0488
			return 0x00;
		//^0CEE:048A
		if (si +1 >= glbCurrentMapWidth)
			//^0CEE:0491
			return 0xE0;
		//^0CEE:0493
		if (IS_TILE_PASSAGE(si +1, di) == 0)
			//^0CEE:04A0
			return 0xE0;
		//^0CEE:04A2
		return 0x00;
	}
	else {
		//^0CEE:04A4
		if (si == -1) {
			//^0CEE:04A9
			si = 0;
		}
		else {
			//^0CEE:04AD
			if (si != glbCurrentMapWidth)
				//^0CEE:04B1
				return 0xE0;
			//^0CEE:04B3
			si--;
		}
		//^0CEE:04B4
		if (di == -1 && IS_TILE_PASSAGE(si, 0) != 0)
			//^0CEE:04C4
			return 0x00;
		//^0CEE:04C6
		if (di != glbCurrentMapHeight)
			return 0xE0;
		//^0CEE:04CC
		if (IS_TILE_PASSAGE(si, di -1) == 0)
			return 0xE0;
		//^0CEE:04DB
		return 0x00;
	}
}

//^0CEE:2CFF
AIDefinition *SkWinCore::QUERY_CREATURE_AI_SPEC_FROM_TYPE(Bit8u creatureType)
{
	Bit16u res = QUERY_GDAT_CREATURE_WORD_VALUE(creatureType, CREATURE_STAT_AI);	// 0x05
	
	// SPX: Replaced _4976_03a2 with a real table dedicated to AI.
	if (SkCodeParam::bUseDM2ExtendedMode)
		return const_cast<AIDefinition *>(reinterpret_cast<const AIDefinition *>(&dAITable[res]));

	return const_cast<AIDefinition *>(reinterpret_cast<const AIDefinition *>(&_4976_03a2[res * 0x0024]));
	
}

//^0CEE:2D36
Bit16u SkWinCore::QUERY_GDAT_CREATURE_WORD_VALUE(Bit8u creatureType, Bit8u cls4)
{
	//^0CEE:2D36
	if (glbSomeCreatureTable != NULL) {
		//^0CEE:2D46
		while (creatureType <= glbCreaturesMaxCount) {
			//^0CEE:2D4F
			Bit8u bp05;
			if (cls4 == 0) {
				bp05 = 0x01;
			}
			else if (cls4 == 1) {
				bp05 = 0x00;
			}
			else if (cls4 == 5) {
				bp05 = 0x02;
			}
			else {
				break;
			}

			//^0CEE:2D74
			Bit8u *bp04 = glbSomeCreatureTable + creatureType * 3 + bp05;
			Bit16u bp08 = *bp04;
			if (bp08 == 0xFF) {
				//^0CEE:2DA5
				bp08 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_CREATURES, creatureType, dtWordValue, cls4);

				*bp04 = (Bit8u)bp08;
			}
			//^0CEE:2DC5
			return bp08;
		}
	}
	//^0CEE:2DCA
	return QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_CREATURES, creatureType, dtWordValue, cls4);
}

//^2066:1EA3
// SPX: Changing bits on a tile ... seems to be called for VOID PIT and LADDERS ...
//void SkWinCore::_2066_1ea3(Bit16u xx, Bit16u yy, Bit16u zz)
void SkWinCore::SET_TILE_ATTRIBUTE_02(Bit16u xx, Bit16u yy, Bit16u map)
{
	//^2066:1EA3
	//glbMapTileValue[zz][xx][yy] |= 0x02;
	glbMapTileValue[map][xx][yy] |= 0x02;
}

//^1C9A:02C3
sk1c9a02c3 *SkWinCore::_1c9a_02c3(Creature *xx, AIDefinition *yy)
{
	//^1C9A:02C3
	if (yy->IsStaticObject() != 0) {
		//^1C9A:02D0
		return reinterpret_cast<sk1c9a02c3 *>(PTR_PADD(xx,+8));
	}
	//^1C9A:02D8
	return reinterpret_cast<sk1c9a02c3 *>(PTR_PADD(&glbTabCreaturesInfo[xx->b5_0_7()],+8));
}

//^4937:01A9
Bit16u SkWinCore::_4937_01a9(Bit16u xx, Bit16u *yy, CreatureAnimationFrame **rref)
{
	//^4937:01A9
	SkD((DLV_DBG_SED2, "DBG: _4937_01a9 %04X %04X \n", (Bitu)xx, (Bitu)*yy));
	Bit16u si = *yy;
	//^4937:01B7
	CreatureAnimationFrame *bp04;
	if (si == 0xffff) {
		//^4937:01BC
		si = 0;
	}
	else {
		//^4937:01C0
		Bit16u bp08 = tlbCreaturesAnimationSequences[xx + si].w2 & 0x000f;
		//^4937:01DA
		if (bp08 == 0)
			goto _0253;
		//^4937:01DE
		si += bp08;
	}
	//^4937:01E1
	bp04 = &tlbCreaturesAnimationSequences[xx + si];

	while (true) {
		//^4937:01FB
		if (bp04->w2_0_3() == 0)
			goto _0253;
		//^4937:0206
		Bit16u bp06 = bp04->w2_4_7();
		//^4937:0216
		if (bp06 == 0xf)
			break;
		//^4937:021B
		if ((RAND() & 0xf) <= bp06)
			break;
		//^4937:0228
		si++;
		bp04++;
	}
	//^4937:022F
	Bit16u di;
	if ((bp04->b4_0_2() + bp04->b4_3_4()) != 0) {
		//^4937:024E
		di = 1;
	}
	else {
		//^4937:0253
_0253:
		di = 0;
	}
	//^4937:0255
	*yy = si;
	//^4937:025D
	*rref = &tlbCreaturesAnimationSequences[xx + *yy];
	//^4937:0284
	return di;
}

//^3E74:2598
// SPX: This is a modified version to allow custom graphics.dat input as exe parameter.
// Original method is still here labelled as ORIGINAL__GRAPHICS_DATA_OPEN
void SkWinCore::GRAPHICS_DATA_OPEN()
{
	Bit8u * sLocalGraphicsDatFileString = NULL;
	Bit8u * sLocalGraphicsDatFileString2 = NULL;

	sLocalGraphicsDatFileString = (Bit8u*) ptrGraphics;
	sLocalGraphicsDatFileString2 = (Bit8u*) ptrGraphics2;

	if (skwin.sCustomGraphicsDatFilename != NULL)
	{
		sLocalGraphicsDatFileString = (Bit8u*) skwin.sCustomGraphicsDatFilename;
	}

	//^3E74:2598
	//^3E74:259B
	if ((_4976_5d10++) == 0) {
		//^3E74:25A6
		glbFileHandleGraphics1 = FILE_OPEN(FORMAT_SKSTR(sLocalGraphicsDatFileString, NULL));
		//^3E74:25C6
		if (glbFileHandleGraphics1 < 0) {
			//^3E74:25CD
			RAISE_SYSERR(SYSTEM_ERROR__MISSING_GRAPHICS);	// SYS ERROR 41
		}
		//^3E74:25D5
		if (_4976_5c9c != 0 && _4976_5ca8 == 0) {
			//^3E74:25E3
			glbFileHandleGraphics2 = FILE_OPEN(FORMAT_SKSTR(sLocalGraphicsDatFileString2, NULL));
			//^3E74:2603
			if (glbFileHandleGraphics2 < 0) {
				//^3E74:260A
				RAISE_SYSERR(SYSTEM_ERROR__MISSING_GRAPHICS_2);	// SYS ERROR 31
			}
		}
	}
	//^3E74:2612
	return;
}

//^3E74:2598
// SPX: This is the original GRAPHICS_DATA_OPEN
void SkWinCore::ORIGINAL__GRAPHICS_DATA_OPEN()
{
	//^3E74:2598
	//^3E74:259B
	if ((_4976_5d10++) == 0) {
		//^3E74:25A6
		glbFileHandleGraphics1 = FILE_OPEN(FORMAT_SKSTR(ptrGraphics, NULL));
		//^3E74:25C6
		if (glbFileHandleGraphics1 < 0) {
			//^3E74:25CD
			RAISE_SYSERR(SYSTEM_ERROR__MISSING_GRAPHICS);
		}
		//^3E74:25D5
		if (_4976_5c9c != 0 && _4976_5ca8 == 0) {
			//^3E74:25E3
			glbFileHandleGraphics2 = FILE_OPEN(FORMAT_SKSTR(ptrGraphics2, NULL));
			//^3E74:2603
			if (glbFileHandleGraphics2 < 0) {
				//^3E74:260A
				RAISE_SYSERR(SYSTEM_ERROR__MISSING_GRAPHICS_2);
			}
		}
	}
	//^3E74:2612
	return;
}

//^0CEE:0510
i16 SkWinCore::LOCATE_OTHER_LEVEL(Bit16u curmap, i16 zDelta, i16 *xx, i16 *yy, Bit8u **ss)
{
	//^0CEE:0510
	//^0CEE:0516
	Map_definitions *bp04 = &dunMapsHeaders[curmap];
	//^0CEE:052C
	__int16 bp0a = (*xx += bp04->MapOffsetX());
	//^0CEE:053E
	__int16 bp0c = (*yy += bp04->MapOffsetY());
	//^0CEE:0550
	__int16 bp16 = bp04->Level() + zDelta;
	//^0CEE:0560
	if (bp16 >= 0 && bp16 < MAXDEPTH) {
		//^0CEE:0572
		Bit16u bp14 = _4976_4cb0[bp16];
		//^0CEE:0581
		if (bp14 != 0xffff) {
			//^0CEE:0589
			Bit8u *bp08;
			if (ss != NULL && *ss != NULL) {
				//^0CEE:059D
				bp08 = *ss + 1;
			}
			else {
				//^0CEE:05AE
				bp08 = &_4976_4c72[bp14];
			}

			__int16 bp0e;
			for (; (bp0e = ((__int8)*bp08)) != -1; bp08++) {
				//^0CEE:05BA
				bp04 = &dunMapsHeaders[bp0e];
				//^0CEE:05D0
				__int16 di = bp04->MapOffsetX();
				//^0CEE:05DB
				if (di -1 <= bp0a) {
					//^0CEE:05E4
					if (di + bp04->RawColumn() + 1 >= bp0a) {
						//^0CEE:05FB
						__int16 si = bp04->MapOffsetY();
						//^0CEE:0603
						if (si -1 <= bp0c) {
							//^0CEE:060C
							if (si + bp04->RawRow() >= bp0c) {
								//^0CEE:0623
								di = bp0a - di;
								si = bp0c - si;
								//^0CEE:0631
								Bit16u bp12 = glbCurrentMapIndex;
								//^0CEE:0637
								CHANGE_CURRENT_MAP_TO(bp0e);
								//^0CEE:063F
								Bit16u bp10 = GET_TILE_VALUE(di, si) >> 5;
								//^0CEE:0651
								if (bp10 == ttTeleporter) {
									//^0CEE:0656
									if (GET_ADDRESS_OF_TILE_RECORD((Bit8u)di, (Bit8u)si)->castToTeleporter()->w4_0_0() != 0) {
										//^0CEE:066E
										bp10 = 7;
									}
								}
								//^0CEE:0673
								CHANGE_CURRENT_MAP_TO(bp12);
								//^0CEE:067B
								if (bp10 != ttMapExit) {
									//^0CEE:0681
									*xx = di;
									*yy = si;
									//^0CEE:068D
									if (ss != NULL) {
										//^0CEE:0695
										*ss = bp08;
									}
									//^0CEE:06A5
									return bp0e;
								}
							}
						}
					}
				}
				//^0CEE:06AA
			}
		}
	}
	//^0CEE:06BF
	if (ss != NULL) {
		//^0CEE:06C7
		*ss = 0;
	}
	//^0CEE:06D5
	// SPX: This case is bad. It will make the further SET_TILE_ATTRIBUTE_02 function crash
	return -1;
}

//^098D:0098
SRECT *SkWinCore::ALLOC_TEMP_RECT(__int16 x, __int16 y, __int16 cx, __int16 cy)
{
	//^098D:0098
	//^098D:009C
	SRECT *bp04 = &_4976_4ba8[_4976_4ba6];
	//^098D:00AB
	_4976_4ba6++;
	//^098D:00B2
	if (_4976_4ba6 >= 4) {
		//^098D:00B7
		_4976_4ba6 = 0;
	}
	//^098D:00BD
	bp04->x = x;
	bp04->y = y;
	bp04->cx = cx;
	bp04->cy = cy;
	//^098D:00DB
	return bp04;
}

//^098D:00E3
SRECT *SkWinCore::ALLOC_TEMP_ORIGIN_RECT(Bit16u width, Bit16u height)
{
	//^098D:00E3
	//^098D:00E6
	return ALLOC_TEMP_RECT(0, 0, width, height);
}

//^3E74:5420
Bit16u SkWinCore::FIND_ICI_FROM_CACHE_HASH(Bit32u cacheHash, Bit16u *ici)
{
	//^3E74:5420
	//^3E74:5426
	i16 di = -1;
	i16 cx = _4976_5c92;

	while (true) {
		//^3E74:542E
		i16 si = (di + cx) >> 1;
		//^3E74:5436
		if (si == di) {
			//^3E74:543A
			*ici = si +1;
			//^3E74:5441
			return 0;
		}
		//^3E74:5445
		ATLASSERT(si < _4976_5d24);
		Bit32u bp04 = _4976_5c86[_4976_5c7e[si]];
		//^3E74:5468
		if (cacheHash < bp04) {
			//^3E74:547A
			cx = si;
			//^3E74:5478
			continue;
		}
		//^3E74:547E
		if (cacheHash > bp04) {
			//^3E74:5490
			di = si;
			//^3E74:5492
			continue;
		}
		//^3E74:5494
		*ici = si;
		//^3E74:549A
		return 1;
	}
}

//^3E74:4701
void SkWinCore::RECYCLE_MEMENTI(Bit16u mementi, Bit16u yy)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:4701
	//^3E74:4707
	Bit16u di = mementi;
	//^3E74:470C
	mement *bp04 = tlbMementsPointers[di];
	TEST_MEMENT(bp04);
	//^3E74:4722
	if (bp04->w4() != 0xffff) {
		//^3E74:472C
		_3e74_48c9(di);
		//^3E74:4733
		return;
	}
	//^3E74:4736
	mement *bp0c;
	mement *bp10;
	if (yy != 0) {
		//^3E74:473C
		bp04->w4(0xfffe);
		bp0c = _4976_5c8c;

		//^3E74:4752
		//^3E74:4786
		bp10 = _4976_5d70;
	}
	else {
		//^3E74:4754
		bp04->w4(1);
		//^3E74:475D
		bp0c = _4976_5d90;
		//^3E74:476A
		bp10 = _4976_5c8c;
		if (bp10 == NULL) {
			//^3E74:4786
			bp10 = _4976_5d70;
		}
	}

	//^3E74:4793
	if (bp0c != NULL) {
		//^3E74:47A4
		goto _483a;
	}
	//^3E74:47A7
	Bit16u bp12;
	Bit16u si;
	if (_4976_5d70 == NULL) {
		//^3E74:47B9
		bp04->w6(0xffff);
		_4976_5d5e = bp04;
		//^3E74:47CF
		goto _4822;
	}
	//^3E74:47D1
	if (_4976_5d90 == NULL) {
		//^3E74:47E3
		if (_4976_5c8c != NULL) {
			//^3E74:47F5
			bp0c = bp10;
			//^3E74:4801
			goto _483a;
		}
	}
	//^3E74:4803
	bp10->w8(di);
	bp12 = bp10->w10();
	//^3E74:4811
	si = QUERY_MEMENTI_FROM(bp12);
	//^3E74:481B
	bp04->w6(si);
	//^3E74:4822
_4822:
	bp04->w8(0xffff);
	_4976_5d70 = bp04;
	//^3E74:4838
	goto _48a3;

	//^3E74:483A
_483a:
	si = bp0c->w6();
	bp0c->w6(di);
	bp04->w6(si);
	//^3E74:484C
	Bit16u bp14;
	if (si != 0xffff) {
		//^3E74:4851
		mement *bp08 = tlbMementsPointers[si];
		TEST_MEMENT(bp08);
		//^3E74:4869
		bp04->w8(bp08->w8());
		//^3E74:4877
		bp08->w8(di);
		//^3E74:487E
		goto _48a3;
	}
	//^3E74:4880
	bp14 = QUERY_MEMENTI_FROM(bp0c->w10());
	//^3E74:488F
	bp04->w8(bp14);
	//^3E74:4896
	_4976_5d5e = bp04;

	//^3E74:48A3
_48a3:
	if (yy != 0) {
		//^3E74:48A9
		_4976_5c8c = bp04;
	}
	else {
		//^3E74:48B8
		_4976_5d90 = bp04;
	}
	//^3E74:48C5
	return;
}

void SkWinCore::TEST_MEMENT(mement *bp04)
{
	//ATLASSERT(bp04 != NULL);
	// SPX: use CheckSafePointer to trap more unexpected mem values so that it fails at ASSERT instead of crashing after.
	ATLASSERT(CheckSafePointer(bp04));
	i32 len = READ_I32(bp04,(abs(-bp04->dw0())) -4);
	if (SkCodeParam::bUseFixedMode)
	{
		if (bp04->dw0() != len)
		{
			len = bp04->dw0();
		}

	}
	ATLASSERT(bp04->dw0() == len);
}

//^3E74:48C9
mement *SkWinCore::_3e74_48c9(Bit16u mementi)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:48C9
	//^3E74:48CF
	mement *bp04 = tlbMementsPointers[mementi];
	TEST_MEMENT(bp04);
	//^3E74:48E8
	Bit16u si = bp04->w4();
	//^3E74:48EF
	if (si == 0xffff || si == 0xfffe) {
		//^3E74:48F9
		return bp04;
	}
	//^3E74:4902
	mement *bp0c = bp04;
	//^3E74:490E
	if (si == 0) {
		//^3E74:4915
		Bit16u di = bp04->w8();
		//^3E74:491E
		if (di == 0xffff) {
			//^3E74:4923
			_4976_5d90 = (bp04 != _4976_5c8c) ? bp04 : NULL;
			//^3E74:494B
			bp04->w4(1);
			//^3E74:4954
			//^3E74:48F9
			return bp04;
		}
		//^3E74:4956
		mement *bp08 = tlbMementsPointers[di];
		TEST_MEMENT(bp08);
		//^3E74:496E
		Bit16u bp0e = bp04->w6();
		//^3E74:4978
		if (bp0e == 0xffff) {
			//^3E74:497D
			_4976_5d5e = bp08;
		}
		else {
			//^3E74:498C
			bp04 = tlbMementsPointers[bp0e];
			TEST_MEMENT(bp04);
			//^3E74:49A5
			bp04->w8(di);
		}
		//^3E74:49AC
		bp08->w6(bp0e);
		//^3E74:49B6
		bp0c->w4(0xffff);
		//^3E74:49BF
		RECYCLE_MEMENTI(mementi, 0);
		//^3E74:49CA
	}
	else {
		//^3E74:49CD
		if (si < 0xfffd) {
			//^3E74:49D2
			si++;
		}
		//^3E74:49D3
		bp04->w4(si);
		//^3E74:49DA
		if (bp04 == _4976_5d70) {
			//^3E74:49EF
			//^3E74:48F9
			return bp04;
		}
		//^3E74:49F2
		Bit16u di = bp04->w8();
		//^3E74:49FB
		mement *bp08 = tlbMementsPointers[di];
		TEST_MEMENT(bp08);
		//^3E74:4A11
		if (bp08->w4() >= si) {
			//^3E74:4A1A
			//^3E74:48F9
			return bp04;
		}
		//^3E74:4A1D
		Bit16u bp0e = bp04->w6();
		//^3E74:4A27
		if (bp0e == 0xffff) {
			//^3E74:4A2C
			_4976_5d90 = bp08;
			_4976_5d5e = bp08;
			//^3E74:4A40
			bp08->w6(0xffff);
		}
		else {
			//^3E74:4A4B
			if (bp04 == _4976_5d90) {
				//^3E74:4A5F
				_4976_5d90 = bp08;
			}
			//^3E74:4A6C
			bp04 = tlbMementsPointers[bp0e];
			TEST_MEMENT(bp04);
			//^3E74:4A85
			bp04->w8(di);
			bp08->w6(bp0e);
		}
		//^3E74:4A96
		if (_4976_5d90 == _4976_5c8c) {
			//^3E74:4AAC
			_4976_5d90 = NULL;
		}

		while (true) {
			//^3E74:4AB8
			bp04 = bp08;
			bp0e = di;
			di = bp04->w8();
			//^3E74:4AD0
			if (di == 0xffff) {
				//^3E74:4AD5
				bp04->w8(mementi);
				//^3E74:4ADC
				bp0c->w6(bp0e);
				bp0c->w8(0xffff);
				//^3E74:4AEC
				_4976_5d70 = bp0c;
			}
			else {
				//^3E74:4AFB
				bp08 = tlbMementsPointers[di];
				TEST_MEMENT(bp08);
				//^3E74:4B13
				if (bp08->w4() < si)
					//^3E74:4B1A
					continue;
				//^3E74:4B1C
				bp04->w8(mementi);
				bp0c->w6(bp0e);
				bp0c->w8(di);
				bp08->w6(mementi);
			}
			break;
		}
	}
	//^3E74:4B3E
	return bp0c;
}

//^3E74:5561
void SkWinCore::FREE_CACHE_INDEX(Bit16u cacheIndex)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:5561
	//^3E74:5566
    __int16 si = cacheIndex;
		//^3E74:5569
	if (_4976_5d36 == -1 || _4976_5d36 > si) {
		//^3E74:5576
		_4976_5d36 = si;
	}
	//^3E74:557A
	ATLASSERT(si < _4976_5d24);
	Bit32u bp04 = _4976_5c86[si];
	//^3E74:5592
	Bit16u bp06;
	if (FIND_ICI_FROM_CACHE_HASH(bp04, &bp06) != 0) {
		//^3E74:55A8
		_4976_5c86[si] = 0;
		//^3E74:55BE
		_4976_5c92--;
		//^3E74:55C2
		MOVE_MEMORY(
			&_4976_5c7e[bp06 +1],
			&_4976_5c7e[bp06],
			(_4976_5c92 -bp06) << 1
			);
	}
	//^3E74:55F6
	return;
}

//^3E74:4549
void SkWinCore::_3e74_4549(Bit16u xx)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:4549
	//^3E74:454F
	mement *bp04 = tlbMementsPointers[xx];
	TEST_MEMENT(bp04);
	//^3E74:4568
	if (bp04 != NULL) {
		//^3E74:457C
		if (bp04->w4() != 0xffff) {
			//^3E74:4589
			Bit16u di = bp04->w6();
			Bit16u si = bp04->w8();
			mement *bp08;
			//^3E74:4594
			if (di == 0xffff) {
				//^3E74:4599
				if (si == 0xffff) {
					//^3E74:459E
					_4976_5d90 = NULL;
					_4976_5c8c = NULL;
					_4976_5d70 = NULL;
					_4976_5d5e = NULL;
				}
				else {
					//^3E74:45C1
					bp08 = tlbMementsPointers[si];
					TEST_MEMENT(bp08);
					//^3E74:45D9
					_4976_5d5e = bp08;
					//^3E74:45E0
					bp08->w6(0xffff);
					//^3E74:45E9
					goto _4682;
				}
			}
			else {
				//^3E74:45EC
				bp08 = tlbMementsPointers[di];
				TEST_MEMENT(bp08);
				//^3E74:4604
				bp08->w8(si);
				//^3E74:460B
				if (si == 0xffff) {
					//^3E74:4610
					if (bp04 == _4976_5c8c) {
						//^3E74:4625
						_4976_5c8c = NULL;
					}
					else {
						//^3E74:4633
						if (bp04 == _4976_5d90) {
							//^3E74:4648
							_4976_5d90 = NULL;
						}
					}
					//^3E74:4654
					_4976_5d70 = bp08;
				}
				else {
					//^3E74:4663
					bp08 = tlbMementsPointers[si];
					TEST_MEMENT(bp08);
					//^3E74:467B
					bp08->w6(di);
				}
				//^3E74:4682
_4682:
				if (bp04 == _4976_5d90) {
					//^3E74:4696
					if (bp08 == _4976_5c8c) {
						//^3E74:46AB
						_4976_5d90 = NULL;
					}
					else {
						//^3E74:46B9
						_4976_5d90 = bp08;
					}
				}
				else {
					//^3E74:46C8
					if (_4976_5c8c == bp04) {
						//^3E74:46DC
						_4976_5c8c = bp08;
					}
				}
			}
		}
	}
	//^3E74:46E9
	bp04->w8(0xffff);
	bp04->w6(0xffff);
	bp04->w4(0xffff);
	//^3E74:46FD
	return;
}

//^3E74:0C8C
void SkWinCore::_3e74_0c8c(mement *ref)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:0C8C
	//^3E74:0C90
	mement *bp08 = ref->pv4();
	mement *bp04 = ref->pv8();
	//^3E74:0CAF
	if (bp08 == NULL) {
		//^3E74:0CC0
		if (bp04 == NULL) {
			//^3E74:0CD1
			_4976_5d94 = NULL;
		}
		else {
			//^3E74:0CDF
			_4976_5d94 = bp04;
			//^3E74:0CEC
			bp04->pv4(NULL);
		}
	}
	else {
		//^3E74:0CFD
		bp08->pv8(bp04);
		//^3E74:0D0E
		if (bp04 != NULL) {
			//^3E74:0D1F
			bp04->pv4(bp08);
		}
	}
	//^3E74:0D30
}

//^3E74:0D32
void SkWinCore::_3e74_0d32(mement *ref)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:0D32
	//^3E74:0D37
	mement *bp04 = ref;
	//^3E74:0D43
	if (_4976_5d94 == NULL) {
		//^3E74:0D55
		_4976_5d94 = bp04;
		//^3E74:0D62
		bp04->pv8(NULL);
		//^3E74:0D71
_0d71:
		bp04->pv4(NULL);
		//^3E74:0D79
		return;
	}
	//^3E74:0D7C
	mement *bp08 = _4976_5d94;
	//^3E74:0D89
	__int32 bp0c = bp04->dw0();
	//^3E74:0D99
	if (bp08->dw0() <= bp0c) {
		//^3E74:0DAF
		_4976_5d94 = bp04;
		//^3E74:0DBC
		bp04->pv4(NULL);
		//^3E74:0DCB
		bp04->pv8(bp08);
		//^3E74:0DD9
		bp08->pv4(bp04);
		//^3E74:0DE2
		goto _0d71;
	}

	//^3E74:0DE4
	Bit16u si = 0;
	//^3E74:0DE6
	while ((bp04 = bp08->pv8()) != NULL) {
		//^3E74:0DE8
		if (bp04->dw0() <= bp0c) {
			//^3E74:0DFE
			bp04->pv4(ref);
			//^3E74:0E0F
			bp08->pv8(ref);
			//^3E74:0E1A
			ref->pv4(bp08);
			//^3E74:0E2B
			ref->pv8(bp04);
			//^3E74:0E39
			si = 1;
			//^3E74:0E3C
			break;
		}
		//^3E74:0E3E
		bp08 = bp04;
		//^3E74:0E4A
	}
	//^3E74:0E6D
	if (si == 0) {
		//^3E74:0E71
		bp08->pv8(ref);
		//^3E74:0E82
		ref->pv4(bp08);
		//^3E74:0E93
		ref->pv8(NULL);
	}
	//^3E74:0E9F
	return;
}

bool SkWinCore::ValidateMements(bool display = false) {
	bool ok = true;
	X16 i = 0;
	for (U16 x = 0; x < glbNumberOfMements; x++) {
		mement *p = tlbMementsPointers[x];
		if (p != NULL) {
			if (display) SkD((DLV_CPX, "M#%03d %p ", x, p));
			int v0 = -p->dw0();
			int v1 = -READ_I32(p,-p->dw0() -4);
			if (v0 != v1) ok = false;
			if (display) SkD((DLV_CPX, "%11d %11d %c ", v0, v1, (v0==v1)?'|':'#'));
			if (display) {
				int ref1 = -1;
				for (i = 0; i < glbGDatNumberOfData; i++) {
					if (_4976_5c82[i] == x) {
						ref1 = i;
						break;
					}
				}
				SkD((DLV_CPX, "%4d ", ref1));
				int ref2 = 0;
				for (i = 0; i < _4976_5d24; i++) {
					if (_4976_5d08[i] == x) {
						ref2 = _4976_5c86[i];
						break;
					}
				}
				SkD((DLV_CPX, "%08X ", ref2));
			}
			if (display) SkD((DLV_CPX, "\n"));
		}
	}
	return ok;
}

//^3E74:28DE
void SkWinCore::FREE_INDEXED_MEMENT(Bit16u index)
{
	// index: if (index&0x8000)==0x8000, cacheindex.
	// index: if (index&0x8000)==0x0000, raw data index.

	// cqOk @ 21:03 2007/02/21

	//^3E74:28DE
	//^3E74:28E4
	Bit16u di = index;
	//^3E74:28E7
	if (di == _4976_4809) {
		//^3E74:28ED
		_4976_4809 = 0xffff;
	}
	//^3E74:28F3
	Bit16u si = QUERY_MEMENTI_FROM(di);
	//^3E74:28FB
	if (si == 0xffff)
		//^3E74:2900
		return;
	//^3E74:2903
	if ((di & 0x8000) == 0) {
		//^3E74:2909
		_4976_5c82[di] = 0xffff;
	}
	else {
		//^3E74:291A
		di &= 0x7fff;
		//^3E74:291E
		ATLASSERT(di < _4976_5d24);
		_4976_5d08[di] = 0xffff;
		//^3E74:292D
		if (_4976_5c90 == 0) {
			//^3E74:2934
			FREE_CACHE_INDEX(di);
		}
	}
	//^3E74:293B
	_3e74_4549(si);
	//^3E74:2942
	mement *bp04 = tlbMementsPointers[si];
	TEST_MEMENT(bp04);
	//^3E74:295A
	tlbMementsPointers[si] = NULL;
	//^3E74:2970
	_4976_5c9e--;
	//^3E74:2974
	if (si < _4976_5c78 || _4976_5c78 == 0xffff) {
		//^3E74:2981
		_4976_5c78 = si;
	}
	//^3E74:2985
	__int32 bp0c = -bp04->dw0();
	//^3E74:299C
	_4976_5cf8 += bp0c;
	SkD((DLV_CPX,"CPX: CPX Free  Ci#%02d Mi#%02d (%5u) = %p\n"
		, (index & 0x8000) ? (index & 0x7fff) : -1
		, si
		, bp0c
		, bp04));
	//^3E74:29A7
	if (bp04 != _4976_5ce6) {
		//^3E74:29BC
		__int32 bp10 = READ_I32(bp04,-4);
		ATLASSERT(-BUFF_SIZE_MAX < bp10 && bp10 < BUFF_SIZE_MAX);
		//ATLASSERT(-60000 < bp10 && bp10 < 60000);
		//^3E74:29DE
		if (bp10 > 0) {
			//^3E74:29E8
			PTR_PSBA(bp04,bp10);
			TEST_MEMENT(bp04);
			//^3E74:29F8
			_3e74_0c8c(bp04);
			//^3E74:2A04
			bp0c += bp10;
		}
	}
	//^3E74:2A10
	if ((void *)PTR_PADD(bp04,bp0c) == (void *)_4976_5cb2) {
		//^3E74:2A30
		_4976_5cb2 = bp04;
		return;
	}
	//^3E74:2A40
	mement *bp08 = reinterpret_cast<mement *>(PTR_PADD(bp04,bp0c));
	TEST_MEMENT(bp08);
	//^3E74:2A59
	__int32 bp10 = bp08->dw0();
	//^3E74:2A68
	if (bp10 > 0) {
		//^3E74:2A72
		_3e74_0c8c(bp08);
		//^3E74:2A7E
		bp0c += bp10;
	}
	//^3E74:2A8A
	bp04->dw0(bp0c);
	//^3E74:2A9A
	WRITE_I32(bp04,bp0c -4,bp0c);
	//^3E74:2AC9
	_3e74_0d32(bp04);
	//^3E74:2AD5
	return;
}

//^3E74:4471
Bit16u SkWinCore::_3e74_4471()
{
	//^3E74:4471
	//^3E74:4475
	__int16 si = _4976_5d36;
	//^3E74:447A
	if (si >= 0) {
		//^3E74:447E
		_4976_5c92++;
		//^3E74:4482
		if (_4976_5c92 >= _4976_5d24) {
			//^3E74:448B
			_4976_5d36 = -1;
		}
		else {
			do {
				//^3E74:4493
				_4976_5d36++;
				//^3E74:4497
				ATLASSERT(_4976_5d36 < _4976_5d24);
			} while (_4976_5d08[_4976_5d36] != 0xffff);
		}
	}
	//^3E74:44A8
	ATLASSERT(0 <= si && si < _4976_5d24);
	return si;
}

//^3E74:54A1
Bit16u SkWinCore::INSERT_CACHE_HASH_AT(Bit32u cacheHash, Bit16u ici)
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:54A1
	//^3E74:54A6
	if (_4976_5c92 == _4976_5d24) {
		//^3E74:54AF
		mement *bp04 = _4976_5d5e;
		//^3E74:54B6
		for (; (bp04->w10() & 0x8000) == 0; ) {
			//^3E74:54B8
			bp04 = tlbMementsPointers[bp04->w8()];
			TEST_MEMENT(bp04);
		}
		//{
		//	mement *p = _4976_5d5e;
		//	while (p != NULL) {
		//		SkD((DLV_CPX, "ME: %p I %04X  Mi %04X \n", p, p->w10(), p->w8()));
		//		p = tlbMementsPointers[p->w8()];
		//	}
		//	for (U16 x=0; x<_4976_5c92; x++) {
		//		U16 i = _4976_5c7e[x];
		//		U32 hash = _4976_5c86[i];
		//		SkD((DLV_CPX, "HI: %04X %04X %08X \n", x, i, hash));
		//	}
		//}

		//^3E74:54E0
		FREE_INDEXED_MEMENT(bp04->w10());
		//^3E74:54E9
		FIND_ICI_FROM_CACHE_HASH(cacheHash, &ici);
	}
	//^3E74:54FB
	Bit16u si = _3e74_4471();
	//^3E74:5501
	MOVE_MEMORY(
		&_4976_5c7e[ici],
		&_4976_5c7e[ici +1],
		(_4976_5c92 -ici -1) << 1
		);
	//^3E74:5536
	_4976_5c7e[ici] = si;
	//^3E74:5544
	_4976_5c86[si] = cacheHash;
	//^3E74:555C
	return si;
}

//^3E74:44AD
void SkWinCore::_3e74_44ad()
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:44AD
	_4976_5d2a = glbGameTick;
	_4976_5d90 = NULL;
	mement *bp04 = _4976_5c8c;
	//^3E74:44E6
	if (bp04 == NULL) {
		//^3E74:44E8
		bp04 = _4976_5d70;
		//^3E74:4502
		if (bp04 == NULL)
			return;
	}
	//^3E74:4504
	while (bp04->w4() != 0) {
		//^3E74:4506
		if (bp04->w4() <= 0xfffd) {
			//^3E74:4510
			bp04->w4(0);
		}
		//^3E74:4516
		Bit16u si = bp04->w6();
		if (si == 0xffff)
			return;
		//^3E74:4524
		bp04 = tlbMementsPointers[si];
		TEST_MEMENT(bp04);
		//^3E74:453C
	}
}

//^3E74:0C62
Bit16u SkWinCore::QUERY_MEMENTI_FROM(Bit16u xx)
{
	// xx&0x8000==0x8000: cacheindex-to-mementi
	// xx&0x8000==0x0000: raw data index to mementi

	// returns 0xffff if no match found.

	//^3E74:0C62
	Bit16u si = xx;
	if ((si & 0x8000) != 0) {
		//^3E74:0C6F
		return _4976_5d08[si & 0x7fff];
	}
	else {
		//^3E74:0C7C
		return _4976_5c82[si];
	}
}

//^3E74:55F9
Bit16u SkWinCore::ADD_CACHE_HASH(Bit32u cacheHash, Bit16u *piYaCacheIndex)
{
	// returns 0 if inserted new one, 1 if already exists.

	//^3E74:55F9
	//^3E74:55FE
	if (glbGameTick != _4976_5d2a) {
		//^3E74:5611
		_3e74_44ad();
	}
	//^3E74:5615
	Bit16u bp02;
	if (FIND_ICI_FROM_CACHE_HASH(cacheHash, &bp02) != 0) {
		//^3E74:562B
		*piYaCacheIndex = _4976_5c7e[bp02];
		//^3E74:563F
		Bit16u si = QUERY_MEMENTI_FROM(*piYaCacheIndex | 0x8000);
		//^3E74:564D
		_3e74_48c9(si);
		//^3E74:5653
		return 1;
	}
	//^3E74:5658
	*piYaCacheIndex = INSERT_CACHE_HASH_AT(cacheHash, bp02);
	//^3E74:566E
	return 0;
}

//^3E74:5817
U8 *SkWinCore::QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(Bit16u cacheIndex)
{
	//^3E74:581A
    return reinterpret_cast<U8 *>(&_3e74_48c9(QUERY_MEMENTI_FROM(cacheIndex | 0x8000))[1]); // +18 bytes
}

//^3E74:583A
void SkWinCore::_3e74_583a(Bit16u xx)
{
	//^3E74:583A
	//^3E74:583E
	Bit16u si = QUERY_MEMENTI_FROM(xx | 0x8000);
	//^3E74:584C
	if (si != 0xffff) {
		//^3E74:5851
		_3e74_4549(si);
	}
	//^3E74:5857
	return;
}

//^3E74:4416
Bit16u SkWinCore::FIND_FREE_MEMENTI()
{
	//^3E74:4416
	//^3E74:441A
	Bit16u si = _4976_5c78;
	//^3E74:441F
	if (si == 0xffff) {
		//^3E74:4424
		FREE_INDEXED_MEMENT(_4976_5d5e->w10());
		//^3E74:4431
		si = _4976_5c78;
	}
	//^3E74:4435
	_4976_5c9e++;
	//^3E74:4439
	if (_4976_5c9e >= glbNumberOfMements) {
		//^3E74:4442
		_4976_5c78 = 0xffff;
	}
	else {
		do {
			//^3E74:444A
			_4976_5c78++;
			//^3E74:444E
			ATLASSERT(_4976_5c78 < glbNumberOfMements);
		} while (tlbMementsPointers[_4976_5c78] != NULL);
	}
	//^3E74:446C
	return si;
}

//^3E74:2AD9
void SkWinCore::GUARANTEE_FREE_CPXHEAP_SIZE(__int32 buffSize)
{
	ATLASSERT(buffSize > 0 && buffSize < BUFF_SIZE_MAX);

	//^3E74:2AD9
	//^3E74:2ADC
	for (; _4976_5cf8 < buffSize; ) {
		//^3E74:2ADE
		if (_4976_5d5e == NULL) {
			//^3E74:2AF0
			RAISE_SYSERR(SYSTEM_ERROR__FREE_CPXHEAP_SIZE);
		}
		//^3E74:2AF8
		if (_4976_4809 != 0xffff && _4976_4809 != _4976_4807) {
			//^3E74:2B08
			FREE_INDEXED_MEMENT(_4976_4809);
		}
		else {
			//^3E74:2B0E
			FREE_INDEXED_MEMENT(_4976_5d5e->w10());
		}
		//^3E74:2B1B
	}
	//^3E74:2B2E
	return;
}

//^3E74:2B30
void SkWinCore::_3e74_2b30()
{
	// cqOk @ 21:03 2007/02/21

	//^3E74:2B30
	//^3E74:2B36
	if (_4976_5d94 != NULL) {
		//^3E74:2B4B
		mement *bp04 = _4976_5ce6;
		mement *bp08 = _4976_5ce6;

		do {
			//^3E74:2B5E
			__int32 bp0c = bp04->dw0();
			//^3E74:2B6E
			if (bp0c > 0) {
				//^3E74:2B78
				PTR_PADA(bp04, bp0c);
			}
			else {
				//^3E74:2B86
				bp0c = -bp0c;
				//^3E74:2B99
				if (bp08 != bp04) {
					//^3E74:2BAF
					Bit16u di = bp04->w10();
					//^3E74:2BB6
					Bit16u si = QUERY_MEMENTI_FROM(di);
					//^3E74:2BBE
					tlbMementsPointers[si] = bp08;
					//^3E74:2BD4
					COPY_MEMORY(bp04, bp08, bp0c);
					TEST_MEMENT(bp08);
					//^3E74:2BEE
					if (_4976_5d5e == bp04) {
						//^3E74:2C02
						_4976_5d5e = bp08;
					}
					//^3E74:2C0F
					if (_4976_5d70 == bp04) {
						//^3E74:2C23
						_4976_5d70 = bp08;
					}
					//^3E74:2C30
					if (_4976_5d90 == bp04) {
						//^3E74:2C44
						_4976_5d90 = bp08;
					}
					//^3E74:2C53
					else if (_4976_5c8c == bp04) {
						//^3E74:2C67
						_4976_5c8c = bp08;
					}
				}
				//^3E74:2C74
				PTR_PADA(bp04, bp0c);
				//^3E74:2C84
				PTR_PADA(bp08, bp0c);
			}
			//^3E74:2C94
		} while (bp04 != _4976_5cb2);

		//^3E74:2CAC
		_4976_5cb2 = bp08;
		//^3E74:2CB9
		_4976_5d94 = NULL;
	}
	//^3E74:2CC5
	return;
}

//^3E74:2CC9
mement *SkWinCore::ALLOC_LOWER_CPXHEAP(__int32 buffSize)
{
	// allocate memory from lower part of complex memory pool.
	// buffSize must include size of header&footer: sizeof(mement)+4 = 22
	ATLASSERT(buffSize > 0 && buffSize < BUFF_SIZE_MAX);

	//^3E74:2CC9
	//^3E74:2CCF
	GUARANTEE_FREE_CPXHEAP_SIZE(buffSize);
	//^3E74:2CDB
	mement *bp04;
	if (PTR_PSBP(_4976_5ce2,_4976_5cb2) >= buffSize) { // allocate on main memory
		//^3E74:2CFB
_2cfb:
		bp04 = _4976_5cb2;
		//^3E74:2D08
		PTR_PADA(_4976_5cb2,buffSize);
	}
	//^3E74:2D1B
	else if (_4976_5d94->dw0() < buffSize) {
		//^3E74:2D32
		_3e74_2b30();
		//^3E74:2D36
		goto _2cfb;
	}
	else {
		//^3E74:2D38
		bp04 = _4976_5d94;
		//^3E74:2D45
		Bit16u si = 0;
		mement *bp08;

		do {
			//^3E74:2D47
			if (bp04->dw0() == buffSize) {
				//^3E74:2D5B
_2d5b:
				si = 1;
				//^3E74:2D5E
				continue;
			}
			//^3E74:2D60
			if (bp04->dw0() >= buffSize) {
				//^3E74:2D76
				bp08 = bp04->pv8();
				//^3E74:2D8B
				if (bp08 != NULL)
					//^3E74:2D94
					goto _2da5;
			}
			//^3E74:2D96
			bp04 = _4976_5d94;
			//^3E74:2DA3
			goto _2d5b;
			//^3E74:2DA5
_2da5:
			bp04 = bp08;
			//^3E74:2DB1
		} while (si == 0);

		//^3E74:2DB5
		_3e74_0c8c(bp04);
		//^3E74:2DC1
		__int32 bp0c = bp04->dw0() - buffSize;
		//^3E74:2DD7
		if (bp0c >= 30) {
			//^3E74:2DE5
			bp08 = reinterpret_cast<mement *>(PTR_PADD(bp04,buffSize));
			//^3E74:2DFC
			WRITE_I32(bp08,bp0c -4,bp0c);
			//^3E74:2E2A
			bp08->dw0(bp0c);
			//^3E74:2E3A
			_3e74_0d32(bp08);
		}
		else {
			//^3E74:2E42
			buffSize = bp04->dw0();
		}
	}
	//^3E74:2E52
	_4976_5cf8 -= buffSize;
	//^3E74:2E60
	bp04->dw0(-buffSize);
	//^3E74:2E71
	WRITE_I32(bp04,+buffSize -sizeof(i32),-buffSize);
	//^3E74:2EA9
	reinterpret_cast<mement *>(bp04)->w8(0xffff);
	reinterpret_cast<mement *>(bp04)->w6(0xffff);
	reinterpret_cast<mement *>(bp04)->w4(0xffff);
	//^3E74:2EBD
#if UseAltic
	{
		i32 size = -READ_I32(bp04,-bp04->dw0() -4);
		ATLASSERT(buffSize == size);

		// SkD((DLV_CPX, "CPX: ALLOC_LOWER_CPXHEAP(%6u) = %p\n", (Bitu)buffSize, bp04));
		memset(&bp04[1], 0xcc, buffSize -sizeof(mement) -sizeof(i32));
		// ATLASSERT((U32)bp04 != 0x00758132);
	}
#endif
	return reinterpret_cast<mement *>(bp04);
}

//^3E74:5708
Bit8u *SkWinCore::ALLOC_CPXHEAP_MEM(Bit16u index, Bit32u buffSize)
{
	//^3E74:5708
	//^3E74:570D
	buffSize += sizeof(mement) +4;
	//^3E74:5715
	if ((buffSize & 1) != 0) {
		//^3E74:5720
		buffSize++;
	}
	//^3E74:5728
	mement *bp04 = ALLOC_LOWER_CPXHEAP(buffSize);
	//^3E74:573B
	Bit16u si = FIND_FREE_MEMENTI();
	//^3E74:5740
	ATLASSERT(_4976_5d08[index] == U16(-1));
	_4976_5d08[index] = si;
	//^3E74:574E
	ATLASSERT(tlbMementsPointers[si] == 0);
	tlbMementsPointers[si] = bp04;
	//^3E74:5766
	bp04->w10(index | 0x8000);

	SkD((DLV_CPX,"DBG: CPX Alloc Ci#%02d Mi#%02d (%5u) = %p\n", index, si, 0U +buffSize, bp04));

	//^3E74:5773
	return reinterpret_cast<Bit8u *>(&bp04[1]); // +18 bytes
}

//^3E74:585A
void SkWinCore::_3e74_585a(Bit16u xx, Bit16u yy)
{
	//^3E74:585A
	//^3E74:585E
	Bit16u si = QUERY_MEMENTI_FROM(xx | 0x8000);
	//^3E74:586C
	if (si == 0xffff) {
		//^3E74:5871
		FREE_CACHE_INDEX(xx);
	}
	else {
		//^3E74:587B
		RECYCLE_MEMENTI(si, yy);
	}
}

//^44C8:1D26
void SkWinCore::FILL_ENTIRE_PICT(Bit8u *buff, Bit16u fill)
{
	//^44C8:1D26
	ENTER(8);
	//^44C8:1D2B
	X16 si = READ_UI16(buff,-6);
	SRECT bp08;
	bp08.x = bp08.y = 0;
	bp08.cx = (((si == 4) ? 2 : 1) +READ_UI16(buff,-4) -1) & (~(((si == 4) ? 2 : 1) -1));
	bp08.cy = READ_UI16(buff,-2);
	FIRE_FILL_RECT_ANY(buff, &bp08, fill, bp08.cx, si);
	//^44C8:1D89
	return;
}

//^443C:085A
void SkWinCore::FIRE_HIDE_MOUSE_CURSOR()
{
	//^443C:085A
	//^443C:085D
	glbMouseVisibility++;
	//^443C:0861
	_01b0_0adb() CALL_IBMIO;
}

//^01B0:0ADB
void SkWinCore::_01b0_0adb() //#DS=04BF
{
	//^01B0:0ADB
	LOADDS(0x3083);
	//^01B0:0AE4
	if (_04bf_17a2++ == 0) {
		//^01B0:0AF1
		LOCK_MOUSE_EVENT();
		_01b0_073d();
		UNLOCK_MOUSE_EVENT();
	}
	//^01B0:0AFD
	return;
}

// Standard DM1 palette
Bit8u _xDefaultFMTownsPalette[16*4] = 
{
	0, 0x00, 0x00, 0x00,
	1, 0x66, 0x66, 0x66,
	2, 0x88, 0x88, 0x88,
	3, 0x66, 0x22, 0x00,
	4, 0x00, 0xCC, 0xCC,
	5, 0x88, 0x44, 0x00,
	6, 0x00, 0x88, 0x00,
	7, 0x00, 0xCC, 0x00,
	8, 0xFF, 0x00, 0x00,
	9, 0xFF, 0xAA, 0x00,
	10, 0xCC, 0x88, 0x66,
	11, 0xFF, 0xFF, 0x00,
	12, 0x44, 0x44, 0x44,
	13, 0xAA, 0xAA, 0xAA,
	14, 0x00, 0x00, 0xFF,
	15, 0xFF, 0xFF, 0xFF,

};

//^01B0:0B01
void SkWinCore::IBMIO_SET_CURSOR_PATTERN(
	__int16 index, 
	Bit8u *buffSrc, 
	Bit8u zz, 
	Bit8u ss, 
	Bit16u srcWidth, 
	Bit16u srcHeight, 
	Bit16u srcBits, 
	Bit8u *localPal, 
	Bit16u colorkey
) { 
	// SPX: If localPal is not specified (can happen from a V3 GDAT (FM-Towns, SegaCD/MegaCD), it will then crash
	if (localPal == NULL)
		localPal = _xDefaultFMTownsPalette;
	
	//#DS=04BF
	//^01B0:0B01
	//^01B0:0B07
	LOADDS(0x3083);
	//^01B0:0B0D
	//^01B0:0B0F
	if (index >= 0 && index < 4) {
		//^01B0:0B25
		LOCK_MOUSE_EVENT();
		//^01B0:0B29
		sk0e80 *bp08 = &_04bf_0e80[index];
		//^01B0:0B3A
		if (srcBits == 4) {
			//^01B0:0B45
			Bit16u di = 0;
			//^01B0:0B47
			Bit16u bp0a = (srcWidth +1) & 0xfffe;
			Bit16u bp04 = 0;

			//^01B0:0B56
			for (; bp04 < srcHeight; bp04++) {
				//^01B0:0B59
				Bit16u bp02 = 0;
				//^01B0:0B5E
				for (; bp02 < srcWidth; di++, bp02++) {
					//^01B0:0B60
					Bit16u si = bp0a * bp04 + bp02;
					//^01B0:0B6B
					if ((si & 0x0001) != 0) {
						//^01B0:0B71
						bp08->b6[di] = localPal[buffSrc[si >> 1] & 15];
					}
					else {
						//^01B0:0B91
						bp08->b6[di] = localPal[buffSrc[si >> 1] >> 4];
					}
					//^01B0:0BCF
				}
				//^01B0:0BDF
			}
			//^01B0:0BEF
			bp08->b4 = localPal[U8(colorkey)];
			//^01B0:0C0D
		}
		else {
			//^01B0:0C0F
			i16 si = 0;
			//^01B0:0C11
			for (; srcWidth * srcHeight > si; si++) {
				//^01B0:0C13
				bp08->b6[si] = buffSrc[si];
				//^01B0:0C33
			}
			//^01B0:0C3E
			bp08->b4 = U8(colorkey);
		}
		//^01B0:0C44
		//^01B0:0C48
		bp08->b0 = zz;
		bp08->b1 = ss;
		bp08->b2 = U8(srcWidth);
		bp08->b3 = U8(srcHeight);
		//^01B0:0C66
		UNLOCK_MOUSE_EVENT();
	}
	//^01B0:0C6A
	//^01B0:0C6B
	return;
}

//^01B0:0C70
void SkWinCore::_01b0_0c70(Bit16u xx) //#DS=04BF
{
	//^01B0:0C70
	//^01B0:0C73
	LOADDS(0x3083);
	//^01B0:0C79
	LOCK_MOUSE_EVENT();
	//^01B0:0C7F
	if (_04bf_17a8 != 0) {
		//^01B0:0C86
		_01b0_073d();
		//^01B0:0C8A
		_04bf_1938 = xx;
		//^01B0:0C90
		_01b0_05ae();
	}
	else {
		//^01B0:0C96
		_04bf_1938 = xx;
	}
	//^01B0:0C9C
	UNLOCK_MOUSE_EVENT();
	//^01B0:0CA1
	return;
}

//^01B0:0CA4
void SkWinCore::_01b0_0ca4(Bit16u *xx, Bit16u yy)
{
	//^01B0:0CA4
	//^01B0:0CA8
	LOADDS(0x3083);
	//^01B0:0CAE
	//^01B0:0CB0
	LOCK_MOUSE_EVENT();
	//^01B0:0CBA
	for (Bit16u si=0; si < 4; si++) {
		//^01B0:0CBE
		((Bit16u *)&_04bf_1852)[si] = xx[si];
		//^01B0:0CD2
	}
	//^01B0:0CD8
	_04bf_17e8 = yy;
	_04bf_1850 = 1;
	//^01B0:0CE4
	UNLOCK_MOUSE_EVENT();
	//^01B0:0CE9
	return;
}

//^443C:040E
void SkWinCore::_443c_040e()
{
	//^443C:040E
	//^443C:0411
	FIRE_HIDE_MOUSE_CURSOR();
	//^443C:0416
	_4976_5dae.rc4.cx = 1;
	//^443C:041C
	_01b0_0ca4(_4976_4954, 32);
	//^443C:042D
	FIRE_SHOW_MOUSE_CURSOR();
	//^443C:0432
	return;
}

//^3E74:57B5
Bit8u *SkWinCore::ALLOC_NEW_PICT(Bit16u index, Bit16u width, Bit16u height, Bit16u bpp)
{
	//^3E74:57B5
	//^3E74:57BA
	Bit16u si = width;
	//^3E74:57BD
	Bit8u *bp04 = ALLOC_CPXHEAP_MEM(
		index,
		Bit32u((bpp == 4) ? (((si +1) & 0xfffe) >> 1) : (si & 0xffff)) * height
		);
	//^3E74:57E8
	WRITE_UI16(bp04,-4,si);
	//^3E74:57EF
	WRITE_UI16(bp04,-2,height);
	//^3E74:57F9
	WRITE_UI16(bp04,-6,bpp);
	//^3E74:580E

	SkD((DLV_DBG_GETPIC,"DBG: ALLOC_NEW_PICT(%3u,%3u,%3u,%u) = %p\n", (Bitu)index, (Bitu)width, (Bitu)height, (Bitu)bpp, bp04));
	return bp04;
}

//^3E74:53EA
Bit32u SkWinCore::GET_TEMP_CACHE_HASH()
{
	//^3E74:53EA
	Bit32u bp04;
	Bit16u bp06;
	do {
		//^3E74:53EE
		bp04 = 0xffff0000 | (_4976_484b++);
		//^3E74:5401
	} while (FIND_ICI_FROM_CACHE_HASH(bp04, &bp06) != 0);
	//^3E74:5418
	return bp04;
}

//^3E74:5888
Bit16u SkWinCore::ALLOC_TEMP_CACHE_INDEX()
{
	//^3E74:5888
	//^3E74:588C
	Bit16u bp02;
	ADD_CACHE_HASH(GET_TEMP_CACHE_HASH(), &bp02);
	//^3E74:589E
	return bp02;
}

//^0B36:0D67
void SkWinCore::_0b36_0d67(sk3f6c *ref, SRECT *rc)
{
	//^0B36:0D67
	//^0B36:0D6C
	if (rc == NULL)
		//^0B36:0D74
		return;
	//^0B36:0D77
	__int16 si = 0;
	for (; ref->w10 > si; si++) {
		//^0B36:0D7C
		if (true
			&& ref->w12[si].x <= rc->x
			&& ref->w12[si].x + ref->w12[si].cx -1 >= rc->x + rc->cx -1
			&& ref->w12[si].y <= rc->y
			&& ref->w12[si].y + ref->w12[si].cy -1 >= rc->y + rc->cy -1
		) {
			//^0B36:0E09
			//^0B36:0FA7
			return;
		}
		//^0B36:0E0C
		if (ref->w12[si].x >= rc->x) {
			//^0B36:0E22
			if (ref->w12[si].x + ref->w12[si].cx -1 <= rc->x + rc->cx -1) {
				//^0B36:0E55
				if (ref->w12[si].y >= rc->y) {
					//^0B36:0E6C
					if (ref->w12[si].y + ref->w12[si].cy -1 <= rc->y + rc->cy -1) {
						//^0B36:0E97
						goto _0ec7;
					}
				}
			}
		}
		//^0B36:0E99
	}
	//^0B36:0EA6
	if (si >= 5) {
		//^0B36:0EAB
		_0b36_0cbe(ref, 0);
	}
	//^0B36:0EBA
	si = ref->w10++;
	//^0B36:0EC7
_0ec7:
	COPY_MEMORY(rc, &ref->w12[si], 8);
	//^0B36:0EEA
	rc = &ref->w12[si];
	//^0B36:0F00
	si = rc->x - ref->rc2.x;
	//^0B36:0F11
	if (si < 0) {
		//^0B36:0F15
		if ((rc->cx += si) <= 0) {
			//^0B36:0F1E
			ref->w10--;
			//^0B36:0F25
			return;
		}
		//^0B36:0F28
		rc->x -= si;
	}
	//^0B36:0F2E
	si = rc->y - ref->rc2.y;
	//^0B36:0F3E
	if (si < 0) {
		//^0B36:0F42
		if ((rc->cy += si) <= 0) {
			//^0B36:0F4B
			//^0B36:0F1E
			ref->w10--;
			//^0B36:0F25
			return;
		}
		//^0B36:0F4D
		rc->y -= si;
	}
	//^0B36:0F54
	si = ref->rc2.x + ref->rc2.cx -1 -(rc->x + rc->cx -1);
	//^0B36:0F76
	if (si < 0) {
		//^0B36:0F7C
		rc->cx += si;
	}
	//^0B36:0F83
	si = ref->rc2.y + ref->rc2.cy -1 -(rc->y + rc->cy -1);
	//^0B36:0F9F
	if (si < 0) {
		//^0B36:0FA3
		rc->cy += si;
	}
	//^0B36:0FA7
	return;
}

//^0B36:0C52
sk3f6c *SkWinCore::_0b36_0c52(sk3f6c *ref, Bit16u rectno, Bit16u ww)
{
	//^0B36:0C52
	//^0B36:0C55
	if (rectno != 0xffff) {
		//^0B36:0C5B
		QUERY_EXPANDED_RECT(rectno, &ref->rc2);
	}
	//^0B36:0C6F
	ALLOC_NEW_PICT(ref->w0 = ALLOC_TEMP_CACHE_INDEX(), ref->rc2.cx, ref->rc2.cy, 8);
	//^0B36:0C90
	ref->w10 = 0;
	//^0B36:0C99
	if (ww != 0) {
		//^0B36:0C9F
		_0b36_0d67(ref, &ref->rc2);
	}
	//^0B36:0CB6
	return ref;
}

//^0B36:0FAB
SRECT *SkWinCore::OFFSET_RECT(const sk3f6c *refOrg, const SRECT *prcSrc, SRECT *prcOut)
{
	//^0B36:0FAB
	//^0B36:0FAF
	prcOut->x = prcSrc->x - refOrg->rc2.x;
	//^0B36:0FC4
	prcOut->y = prcSrc->y - refOrg->rc2.y;
	//^0B36:0FD9
	prcOut->cx = prcSrc->cx;
	//^0B36:0FE7
	prcOut->cy = prcSrc->cy;
	//^0B36:0FF5
	return prcOut;
}

//^0B36:0FFE
void SkWinCore::FILL_RECT_SUMMARY(sk3f6c *ref, SRECT *rc, Bit8u fill)
{
	//^0B36:0FFE
	ENTER(8);
	//^0B36:1002
	if (rc != NULL) {
		//^0B36:100A
		SRECT bp08;
		FIRE_FILL_RECT_ANY(
			reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w0)),
			OFFSET_RECT(ref, rc, &bp08),
			fill,
			ref->rc2.cx,
			8
			);
		//^0B36:1046
		_0b36_0d67(ref, rc);
	}
	//^0B36:1059
	return;
}

//^29EE:00A3
void SkWinCore::_29ee_00a3(Bit16u xx)
{
	//^29EE:00A3
	//^29EE:00A6
	if (_4976_3f6c.w0 == 0xffff) {
		//^29EE:00AD
		_0b36_0c52(&_4976_3f6c, 11, xx);
		//^29EE:00BE
		if (xx != 0) {
			//^29EE:00C4
			FILL_RECT_SUMMARY(&_4976_3f6c, &_4976_3f6c.rc2, glbPaletteT16[COLOR_BLACK]);
		}
	}
	//^29EE:00DE
	return;
}

//^2759:0E30
U16 SkWinCore::IS_MISSILE_VALID_TO_LAUNCHER(Bit16u player, __int16 hand, ObjectID rlWhatYouLaunch)
{
	// return 0 if you cannot launch the missile with launcher. (not applicable projectile)
	// return 1 if you can launch the missile with launcher.

	//^2759:0E30
	ENTER(2);
	//^2759:0E36
	ObjectID bp02;
	U16 di;
	U16 si;
	return (true
		&& hand != -1
		&& (bp02 = glbChampionSquad[player].Possess(hand)) != OBJECT_NULL // any objects in hand?
		&& ((di = QUERY_GDAT_DBSPEC_WORD_VALUE(bp02, 0x05)) & 0x8000) != 0 // is it launcher?
		&& ((si = QUERY_GDAT_DBSPEC_WORD_VALUE(rlWhatYouLaunch, 0x05)) & 0x8000) == 0 // is it projectile?
		&& ((si & di) & 0x7fff) != 0 // is valid combination? between launcher and projectile
		)
		? 1 : 0;
}

//^0CD5:00B2
__int16 SkWinCore::BETWEEN_VALUE(__int16 minv, __int16 newv, __int16 maxv)
{
	//^0CD5:00B2
	__int16 si = newv;
	if (si >= minv) {
		//^0CD5:00C3
		if (si <= maxv) {
			//^0CD5:00CD
			return si;
		}
		//^0CD5:00C8
		return maxv;
	}
	//^0CD5:00BE
	return minv;
}

//^24A5:013D
void SkWinCore::RECALC_LIGHT_LEVEL()
{
	if (SkCodeParam::bUseIngameDebug)
	{
		U8 message[32];
		sprintf((char*)message, "PRECOMP LIGHT %d\n", glbPrecomputedLight);
		DISPLAY_HINT_TEXT(COLOR_YELLOW, message);
		//printf((char*)message);
	}
	//^24A5:013D
	ENTER(28);
	//^24A5:0143
	if (dunMapsHeaders[glbPlayerMap].Difficulty() == 0) {
		//^24A5:015D
		glbLightLevel = 1;
#if (DM2_DEBUG_SUPER_MODE == 1)
		glbLightLevel = 0;
#endif

	}
	else {
		//^24A5:0166
		Bit16u itemLightBonus[9];		// (bp1c) SPX: light bonus for holded item (1) + items in hand (2*4)
		ZERO_MEMORY(itemLightBonus, 9);
		//^24A5:0177
		Bit16u bonusIndex = 0;	// bp06
		//^24A5:017C
		// Give light bonus for item currently in hand (if any)
		if ((QUERY_GDAT_DBSPEC_WORD_VALUE(glbLeaderHandPossession.object, GDAT_ITEM_STATS_GEN_FLAGS) & ITEM_FLAG_PRODUCE_LIGHT) != 0) {
			//^24A5:018E
			itemLightBonus[bonusIndex] = ADD_ITEM_CHARGE(glbLeaderHandPossession.object, 0);
			bonusIndex++;
		}
		//^24A5:01AB
		Bit16u si;
		// Pass through all items in hands
		for (si=0; si < glbChampionsCount; si++) {
			//^24A5:01AF
			for (Bit16u bp04=0; bp04 <= 1; bp04++) {
				//^24A5:01B6
				Bit16u bp08;
				if ((QUERY_GDAT_DBSPEC_WORD_VALUE(bp08 = glbChampionSquad[si].Possess(bp04), GDAT_ITEM_STATS_GEN_FLAGS) & ITEM_FLAG_PRODUCE_LIGHT) != 0) {
					//^24A5:01DC
					itemLightBonus[bonusIndex] = ADD_ITEM_CHARGE(bp08, 0);
					//^24A5:01F5
					bonusIndex++;
				}
				//^24A5:01F8
			}
			//^24A5:0201
		}
		//^24A5:0208
		//for (si=0; bonusIndex -1 > si; si++) {
		// One pass of bubble sort, what for ?
		for (si=0; si < bonusIndex -1; si++) {
			//^24A5:020C
			if (itemLightBonus[si] > itemLightBonus[si +1]) {
				//^24A5:0226
				Bit16u bp04 = itemLightBonus[si];
				//^24A5:0235
				itemLightBonus[si] = itemLightBonus[si +1];
				//^24A5:024D
				itemLightBonus[si +1] = bp04;
			}
			//^24A5:025C
		}
		//^24A5:0265
		Bit16u bp02 = 6;
		//Bit16u di;
		i16 di = 0;	// SPX (2016-11-02) replacing unsigned by signed to hold negative light (with use of darkness) and hit minimum threshold
		// SPX: This is strange ... does that mean that each new value to add is decreased by its position on the light bonus table?
		for (di=0, si=0; si < bonusIndex; si++) {
			//^24A5:0270
			di += (tLightLevelItem[RCJ(16,itemLightBonus[si])] << bp02) >> 6;
			//^24A5:028B
			bp02 = max_value(0, bp02 -1);
			//^24A5:029C
		}
		//^24A5:02A2
		di += glbPrecomputedLight;	// SPX: is some sort of precalculed light level (depending on door and such?)
		di += glbGlobalSpellEffects.Light;
		//^24A5:02AA
		di = di + QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_AMBIANT_LIGHT);
		// SPX: GDAT_CATEGORY_GRAPHICSSET is 0x08
		//^24A5:02C2
		if (glbRainFlagSomething != 0) {
			//^24A5:02C9
			di += tLightLevelTable[RCJ(6,BETWEEN_VALUE(0, glbRainAmbientLightModifier + glbRainSomeLightMod, 5))];
		}
		if (SkCodeParam::bUseFixedMode && di < 0)
			di = 0;
		//^24A5:02EA
		// Light threshold is at 100 for the brighter light => lightlevel = 5.
		for (glbLightLevel=0; glbLightLevel <= 5; glbLightLevel++) {
			//^24A5:02F2
			if (tLightLevelTable[RCJ(6,glbLightLevel)] < di)
				break;
			//^24A5:02FF
		}
		//^24A5:030A
		// SPX: Get the highest default light (from wallset type)
		i16 bp0a = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_HIGHEST_LIGHT_LEVEL);
		//^24A5:031F
		if (glbLightLevel < bp0a) {
			//^24A5:0327
			glbLightLevel = bp0a;
		}
		//^24A5:032D
		if (glbRainFlagSomething != 0) {
			//^24A5:0334
			if (glbRecalcLightIndicator != 0) {
				//^24A5:033B
				glbLightLevel = 0;
			}
		}
	}
	//^24A5:0341
	glbLightLevel -= (glbLightModifier > 12) ? 1 : 0;
	//^24A5:0353
	glbLightLevel = BETWEEN_VALUE(0, glbLightLevel, 5);
	if (SkCodeParam::bFullLight)	// SPX: debug feature added to always get full light
		glbLightLevel = 0;
	//^24A5:0366
}

//^48AE:01EC
//Bit16u IS_ITEM_FIT_FOR_EQUIP(ObjectID recordLink, i16 possess, Bit16u onlyBodyPart)
Bit16u SkWinCore::IS_ITEM_FIT_FOR_EQUIP(ObjectID recordLink, i16 inventorySlot, Bit16u onlyBodyPart)
{
	//^48AE:01EC
	ENTER(0);
	//^48AE:01F1
	__int16 si = inventorySlot;
	//^48AE:01F4
	Bit16u di = QUERY_GDAT_DBSPEC_WORD_VALUE(recordLink, GDAT_ITEM_STATS_EQUIP_FLAGS);	// 4
	//^48AE:0202
	if (onlyBodyPart != 0) {
		//^48AE:0208
		if (si < INVENTORY_BACKPACK_1) {	// 0x0D = 13 = backpack first
			//^48AE:020D
			if (si < 0) {
				//^48AE:0211
				//^48AE:021E
				//^48AE:0224
				return di & ITEM_EQUIP_FLAG_0400;	// 0x0400
			}
			//^48AE:0216
			//^48AE:021E
			//^48AE:0224
			return _4976_49e8[RCJ(INVENTORY_BACKPACK_1,si)] & di;	// _4976_49e8[RCJ(13,si)] & di
		}
		//^48AE:0226
		//^48AE:024E
		//^48AE:0250
		return 0;
	}
	//^48AE:0228
	if (si < INVENTORY_BACKPACK_1) {	// 0x000D
		//^48AE:022D
		if (si > INVENTORY_HAND_LAST) {	// 0x0001
			//^48AE:0232
			//^48AE:023C
			return di & _4976_49e8[RCJ(INVENTORY_BACKPACK_1,si)];	// _4976_49e8[RCJ(13,si)]
		}
	}
	//^_023e
	// That part would be for arrows within quiver which are moved to scabbard
	if (si >= INVENTORY_OVER_1) {	// 0x001E
		//^48AE:0243
		if (si < INVENTORY_MAX_OVER) {	// 00x26
			//^48AE:0248
			if ((di & ITEM_EQUIP_FLAG_CONTAINER_2) != 0) {	// 0x8000
				//^48AE:024E
				return 0;
			}
			//^48AE:0252
			if (IS_ITEM_FIT_FOR_EQUIP(_4976_3de2[(glbChampionIndex << 1) + (glbSelectedHandAction)], INVENTORY_SCABBARD_1, 0x0000) != 0) {	// 0x000c
				//^48AE:0273
				return di & ITEM_EQUIP_FLAG_SCABBARD;	// 0x0040
			}
		}
	}
	//^48AE:027A
	return 1;
}

//^2C1D:038B
// SPX: _2c1d_038b renamed RETRIEVE_ITEM_BONUS
Bit16u SkWinCore::RETRIEVE_ITEM_BONUS(ObjectID x1, Bit8u x2, Bit16u x3, Bit16u x4)
{
	//^2C1D:038B
	ENTER(2);
	//^2C1D:0390
	__int16 si = x4;
	//^2C1D:0393
	Bit16u bp02 = QUERY_GDAT_DBSPEC_WORD_VALUE(x1, x2);
	//^2C1D:03A4
	if (bp02 == 0)
		return 0;
	//^2C1D:03A8
	if ((bp02 & 0x4000) != 0) {
		//^2C1D:03AF
		switch (si) {
			case 0xfffe:
			case 0x0002:
			case 0x0003:
				break;
			default:
				//^2C1D:03E2
				return 0;
		}
	}
	else {
		//^2C1D:03C0
		if (x3 == 0) {
			//^2C1D:03C6
			if ((bp02 & 0x8000) == 0)
				return 0;
		}
	}
	//^2C1D:03CD
	bp02 = (Bit8u)bp02;
	//^2C1D:03D4
	if (si < 0) {
		//^2C1D:03D8
		bp02 = -bp02;
	}
	//^2C1D:03DD
	return bp02;
}

//^2C1D:0300
// SPX: _2c1d_0300 replaced by BOOST_ATTRIBUTE, called when consuming potion or special item
void SkWinCore::BOOST_ATTRIBUTE(Champion *ref, Bit16u xx, Bit16u yy)
{
	//^2C1D:0300
	ENTER(4);
	//^2C1D:0306
	i16 di = yy;
	U8 *bp04 = ref->attributes[xx];
	i16 si = bp04[0] +di -bp04[1];
	//^2C1D:0333
	if (((si < 0) ? 1 : 0) == (di < 0) ? 1 : 0) {
		//^2C1D:034F
		si = ABS16(si);
		//^2C1D:0364
		while (si > 20) {
			//^2C1D:035A
			di -= di / 4;
			si -= 20;
		}
	}
	//^2C1D:0369
	bp04[0] = BETWEEN_VALUE(10, bp04[0] +di, 220);
	//^2C1D:0387
	return;
}

//^2C1D:03E7
// SPX: _2c1d_03e7 renamed PROCESS_ITEM_BONUS / Function called when engine looks through possessed items to give bonus
// SPX: Might check CSBWin AdjustStatsForItemCarried to handle CURSED state
void SkWinCore::PROCESS_ITEM_BONUS(__int16 player, ObjectID recordLink, i16 inventorySlot, __int16 x4)
{
	//^2C1D:03E7
	ObjectID di = recordLink;
	__int16 si = x4;
	//^2C1D:03F3
	if (player < 0)
		return;
	//^2C1D:03FC
	if (di == OBJECT_NULL)
		return;
	//^2C1D:0404
	if (inventorySlot < INVENTORY_MAX_SLOT) {	// (possess < 30)
		//^2C1D:040D
		Bit16u bp06 = QUERY_GDAT_DBSPEC_WORD_VALUE(di, GDAT_ITEM_STATS_GEN_FLAGS);
		//^2C1D:041A
		// SPX: 00/00/00 => flags, 0x0010 = item providing light, so must recompute light
		if (si != 0 && (bp06 & ITEM_FLAG_PRODUCE_LIGHT) != 0) {
			//^2C1D:0425
			RECALC_LIGHT_LEVEL();
		}
		//^2C1D:042A
		if ((bp06 & ITEM_FLAG_2000) == 0) {
			//^2C1D:0434
			Champion *champion = &glbChampionSquad[player]; //*bp04 
			//^2C1D:0445
			Bit16u bp0a = IS_ITEM_FIT_FOR_EQUIP(di, inventorySlot, 1);
			Bit16u bp0c = 0;
			//^2C1D:045B
			if (si != 0 && si != 3 && si != -2) {
				//^2C1D:0472
				// SPX: 0x14 MANA BONUS
				bp06 = RETRIEVE_ITEM_BONUS(di, GDAT_ITEM_BONUS_MANA, bp0a, si);
				//^2C1D:0483
				if (bp06 != 0) {
					//^2C1D:0487
					if (si == 1 || si == -1) {
						//^2C1D:0491
						champion->manaMax += bp06;
					}
					else {
						//^2C1D:049D
						if (si == 2) {
							//^2C1D:04A2
							champion->curMP(BETWEEN_VALUE(0, champion->curMP() + bp06, MAXMP_BONUS));
						}
					}
					//^2C1D:04C1
					champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
				}
				//^2C1D:04CA
				// SPX: Bonus 0x15 => 0x1B check for boosting attributes (x15 luck to x1B antifire)
				for (Bit16u attributeIndex = 0; attributeIndex < ATTRIBUTE_COUNT; attributeIndex++) {
					//^2C1D:04D1
					bp06 = RETRIEVE_ITEM_BONUS(di, attributeIndex + GDAT_ITEM_BONUS_ATTRIBUTE_FIRST, bp0a, si);
					//^2C1D:04E6
					if (bp06 != 0) {
						//^2C1D:04EA
						if (si == 1 || si == -1) {
							//^2C1D:04F4
							champion->attributesEnhanced[attributeIndex] = champion->attributesEnhanced[attributeIndex] + bp06;
						}
						else {
							//^2C1D:050D
							BOOST_ATTRIBUTE(champion, attributeIndex, bp06);
						}
						//^2C1D:0520
						champion->heroFlag |= CHAMPION_FLAG_3000;	// 0x3000
					}
					//^2C1D:0529
				}
			}
			//^2C1D:0532
			// SPX: Bonus 0x1E => 0x31 , 20 values = 4*5 skills
			for (Bit16u skillIndex = 0; skillIndex < SKILL_COUNT; skillIndex++) {
				//^2C1D:0539
				bp06 = RETRIEVE_ITEM_BONUS(di, skillIndex + GDAT_ITEM_BONUS_SKILL_FIRST, bp0a, si);
				//^2C1D:054E
				if (bp06 != 0) {
					//^2C1D:0552
					champion->skillBonus[skillIndex] = champion->skillBonus[skillIndex] + bp06;
					//^2C1D:056B
					champion->heroFlag |= CHAMPION_FLAG_2000;	// 0x2000
					bp0c = 1;
				}
				//^2C1D:0579
			}
			//^2C1D:0582
			// SPX: Bonus 0x33 : SPEED ?
			bp06 = RETRIEVE_ITEM_BONUS(di, GDAT_ITEM_BONUS_WALK_SPEED, bp0a, si);
			//^2C1D:0593
			if (bp06 != 0) {
				//^2C1D:0597
				champion->walkSpeed = champion->walkSpeed + bp06;
				bp0c = 1;
			}
			//^2C1D:05AC
			// SPX: Bonus 0x32 : LIGHT
			if (si != 2 && si != -1 && si != 3) {
				//^2C1D:05BB
				bp06 = RETRIEVE_ITEM_BONUS(di, GDAT_ITEM_BONUS_LIGHT, bp0a, si);
				//^2C1D:05CC
				if (bp06 != 0) {
					//^2C1D:05D0
					glbGlobalSpellEffects.Light += bp06;
					if (si != 0) {
						//^2C1D:05D8
						RECALC_LIGHT_LEVEL();
					}
				}
			}
			//^2C1D:05DD
			if (bp0c != 0 && si == 2) {
				//^2C1D:05E8
				Timer bp16;
				bp16.TimerType(ttyItemBonus);
				//^2C1D:05EC
				bp16.SetMap(glbPlayerMap);
				bp16.SetTick(QUERY_GDAT_DBSPEC_WORD_VALUE(di, 0x0013) + glbGameTick);
				//^2C1D:061C
				bp16.actor = (Bit8u)player;
				//^2C1D:0622
				bp16.value = di.DBType();
				//^2C1D:062D
				bp16.w8 = QUERY_CLS2_FROM_RECORD(di);
				//^2C1D:0637
				QUEUE_TIMER(&bp16);
			}
		}
	}
	//^2C1D:0643
	if (si != 0) {
		//^2C1D:0647
		CALC_PLAYER_WEIGHT(player);
	}
	//^2C1D:0650
	return;
}

//^2C1D:07A3
ObjectID SkWinCore::REMOVE_POSSESSION(Bit16u player, Bit16u possess)
{
	// CSBwinSimilarity: TAG015a66,RemovePossession

	//^2C1D:07A3
	ENTER(4);
	//^2C1D:07A9
	Bit16u si = possess;
	//^2C1D:07AC
	Champion *bp04 = &glbChampionSquad[player];
	//^2C1D:07BD
	ObjectID di;
	if (si >= INVENTORY_MAX_SLOT) {	// (si >= 30)
		//^2C1D:07C2
		di = glbCurrentContainerItems[si -INVENTORY_MAX_SLOT];
		//^2C1D:07CD
		glbCurrentContainerItems[si -INVENTORY_MAX_SLOT] = OBJECT_NULL;
	}
	else {
		//^2C1D:07DC
		di = bp04->Possess(si);
		//^2C1D:07EA
		bp04->Possess(si, OBJECT_NULL);
	}
	//^2C1D:07FA
	if (di == OBJECT_NULL) {
		//^2C1D:07FF
		return OBJECT_NULL;
	}
	//^2C1D:0804
	if (true
		&& glbChampionIndex -1 == player
		&& si <= 1
		&& si == glbSelectedHandAction
	) {
		//^2C1D:0818
		DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
	}
	//^2C1D:081D
	PROCESS_ITEM_BONUS(player, di, si, -1);
	//^2C1D:082B
	return di;
}

//^2C1D:0831
void SkWinCore::EQUIP_ITEM_TO_INVENTORY(Bit16u player, ObjectID rl, Bit16u inventorySlot)
{
	//^2C1D:0831
	ENTER(4);
	//^2C1D:0837
	ObjectID si = rl;
	Bit16u di = inventorySlot;
	//^2C1D:083D
	if (si != OBJECT_NULL) {
		//^2C1D:0842
		Champion *champion = &glbChampionSquad[player];
		//^2C1D:0853
		si.ClearDir();
		//^2C1D:0857
		if (di >= INVENTORY_MAX_SLOT) {	// (di >= 30)
			//^2C1D:085C
			glbCurrentContainerItems[di - INVENTORY_MAX_SLOT] = si;
		}
		else {
			//^2C1D:0869
			champion->Possess(di, si);
		}
		//^2C1D:0877
		PROCESS_ITEM_BONUS(player, si, di, 1);
	}
	//^2C1D:0885
	return;
}

//^2759:0E93
// TODO: related hand activation ?
Bit16u SkWinCore::_2759_0e93(Bit16u player, ObjectID rl, i16 hand)
{
	//^2759:0E93
	ENTER(2);
	//^2759:0E99
	X16 di = player;
	X16 bp02 = 0;
	if (rl != OBJECT_NULL) {
		//^2759:0EAA
		if (IS_ITEM_HAND_ACTIVABLE(di, rl, -1) != 0) {
			//^2759:0EBB
			U16 si;
			for (si = 0; si < _4976_53a4; si++) {
				//^2759:0EBF
				if (QUERY_CMDSTR_ENTRY(glbItemSelected[si].category, glbItemSelected[si].index, glbItemSelected[si].entry, 2) == hand) {
					//^2759:0EEB
					bp02 = 1;
					break;
				}
				//^2759:0EF2
			}
		}
		//^2759:0EF9
		di = glbChampionIndex;
		if (di != 0) {
			if (glbSelectedHandAction == 0 || glbSelectedHandAction == 1) {
				//^2759:0F10
				di--;
				IS_ITEM_HAND_ACTIVABLE(di, glbChampionSquad[di].Possess(glbSelectedHandAction), glbSelectedHandAction);
			}
		}
	}
	//^2759:0F32
	return bp02;
}

//^2759:0FB0
void SkWinCore::LOAD_PROJECTILE_TO_HAND(Bit16u player, __int16 hand)
{
	//^2759:0FB0
	ENTER(14);
	//^2759:0FB6
	Champion *champion = &glbChampionSquad[player];	//*bp04
	//^2759:0FC7
    champion->handCooldown[hand] = 0;
	//^2759:0FD2
	if (champion->curHP() == 0 || hand >= 2)
		//^2759:0FE5
		return;
	//^2759:0FE8
	__int16 bp0e = hand ^ 1;
	//^2759:0FF1
	__int16 bp0a = hand;
	//^2759:0FF7
	Bit16u bp0c = champion->handCommand[hand];
	//^2759:1003
	champion->handCommand[hand] = 0xff;
	//^2759:100E
	champion->handDefenseClass[hand] = 0;
	//^2759:1019
	//if (bp0c == 32) {
	if (bp0c == CmLaunchProjectile) {
		//^2759:1022
		if (champion->Possess(bp0e) != OBJECT_NULL)
			//^2759:1034
			return;
		//^2759:1037
		Bit16u di = INVENTORY_SCABBARD_1;	// 12
		//^2759:103C
		if (IS_MISSILE_VALID_TO_LAUNCHER(player, bp0a, champion->Possess(di)) != 0) {
			//^2759:1059
_1059:
			ObjectID si = REMOVE_POSSESSION(player, di);

			//^2759:1066
			EQUIP_ITEM_TO_INVENTORY(player, si, bp0e);
			//^2759:1075
			return;
		}
		else {
			//^2759:1078
			ObjectID si = champion->Possess(INVENTORY_SCABBARD_1);	// 12
			//^2759:1082
			if (IS_CONTAINER_CHEST(si) != 0) {
				//^2759:108D
				ObjectID *bp08 = &GET_ADDRESS_OF_RECORD9(si)->w2;
				//^2759:109C
				si = *bp08;
				//^2759:10A2
				for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
					//^2759:10A4
					if (IS_MISSILE_VALID_TO_LAUNCHER(player, bp0a, si) != 0) {
						//^2759:10B6
						CUT_RECORD_FROM(si, bp08, -1, 0);
						//^2759:10C9
						//^2759:1066
						EQUIP_ITEM_TO_INVENTORY(player, si, bp0e);
						//^2759:1075
						return;
					}
					//^2759:10CB
				}
			}
			//^2759:10D9
			//for (__int16 di = 7; di <= 9; di++) {
			for (__int16 di = INVENTORY_SCABBARD_2; di <= INVENTORY_SCABBARD_4; di++) {
				//^2759:10DE
				if (IS_MISSILE_VALID_TO_LAUNCHER(player, bp0a, champion->Possess(di)) != 0)
					//^2759:10FD
					goto _1059;
				//^2759:1100
			}
			//^2759:1106
			return;
		}
	}
	//^2759:1109
	if (bp0c != 42)
		//^2759:110F
		return;
	//^2759:1112
	if (champion->Possess(bp0a) != OBJECT_NULL)
		//^2759:1124
		return;
	//^2759:1127
	Bit16u di = INVENTORY_SCABBARD_1;
	ObjectID si;
	if (_2759_0e93(player, champion->Possess(di), bp0c) != 0) {
		//^2759:1149
_1149:
		si = REMOVE_POSSESSION(player, di);
		//^2759:1156
_1156:
		EQUIP_ITEM_TO_INVENTORY(player, si, bp0a);
		//^2759:1075
		return;
	}
	//^2759:115C
	if (IS_CONTAINER_CHEST(si = champion->Possess(INVENTORY_SCABBARD_1)) != 0) {
		//^2759:1171
		ObjectID *bp08 = &GET_ADDRESS_OF_RECORD(si)->w0;
		//^2759:1180
		si = *bp08;

		//^2759:1186
		for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^2759:1188
			if (_2759_0e93(player, si, bp0c) != 0) {
				//^2759:119A
				CUT_RECORD_FROM(si, bp08, -1, 0);
				//^2759:11AD
				goto _1156;
			}
			//^2759:11AF
		}
	}
	//^2759:11BD
//		for (di = 7; di <= 9; di++) {
	for (di = INVENTORY_SCABBARD_2; di <= INVENTORY_SCABBARD_4; di++) {
		//^2759:11C2
		if (_2759_0e93(player, champion->Possess(di), bp0c) != 0) {
			//^2759:11E1
			goto _1149;
		}
		//^2759:11E4
	}
	//^2759:11EA
	si = REMOVE_POSSESSION(player, 12);
	//^2759:11F8
	if (si != OBJECT_NULL)
		//^2759:11FD
		goto _1156;
	//^2759:1200
	return;
}

//^3E74:506B
Bit8u *SkWinCore::QUERY_GDAT_ENTRY_DATA_PTR(Bit8u cls1, Bit8u cls2, Bit8u cls3, Bit8u cls4)
{
LOGX(("%40s: C%02d=I%02X=E%02X=T%03d", "QUERY_GDAT_ENTRY_DATA_PTR for ", cls1, cls2, cls4, cls3 ));
	//^3E74:506B
	ENTER(6);
	//^3E74:5070
	Bit16u si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4);
	//^3E74:5089
	if (cls3 == dtImage && IS_CLS1_CRITICAL_FOR_LOAD(cls1) == 0) {
		//^3E74:509C
		if (si == 0xffff || glbShelfMemoryTable[si].Absent()) {
			//^3E74:50BE
			si = QUERY_GDAT_ENTRY_DATA_INDEX(0x15, 0xfe, dtImage, 0xfe);
		}
	}
#if UseAltic
	if (si == 0xFFFFU) {
		return NULL;
	}
#endif
	//^3E74:50D1
	Bit8u *bp04;
	Bit16u bp06;
	if (glbShelfMemoryTable[si].Absent() && IS_CLS1_CRITICAL_FOR_LOAD(cls1) != 0) {
		//^3E74:50FB
		bp04 = QUERY_GDAT_DYN_BUFF(si, &bp06, 0);
	}
	else {
		//^3E74:510C
		bp04 = REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]);
	}
	//^3E74:5124
	return bp04;
}

//^3E74:0A77
void SkWinCore::FREE_PICT6(SkImage *ref)
{
	//^3E74:0A77
	ENTER(0);
	//^3E74:0A7A
	if (_4976_5d76 == 0) {
		//^3E74:0A81
		if (READ_UI16(ref,-6 +4) == afDefault) {
			//^3E74:0A9D
			DEALLOC_UPPER_MEMORY(READ_UI32(ref,-6 +0));
		}
		else {
			//^3E74:0ABF
			DEALLOC_LOWER_MEMORY(READ_UI32(ref,-6 +0));
		}
	}
	//^3E74:0AE1
	return;
}

//^3E74:52F4
__int16 SkWinCore::QUERY_GDAT_PICT_OFFSET(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	//^3E74:52F4
	ENTER(8);
	//^3E74:52FA
	Bit16u di = 0;
	//^3E74:52FC
	RawEntry *bp04 = QUERY_GDAT_ENTRYPTR(cls1, cls2, dtImage, cls4);
	//^3E74:5317
	if (bp04 == NULL) {
		//^3E74:5325
		return 0;
	}
	else {
		//^3E74:532A
		Bit16u si = bp04->data;
		//^3E74:5331
		SkImage *bp04;
		if (glbShelfMemoryTable[si].Absent()) {
			//^3E74:534E
			di = 1;
			//^3E74:5351
			bp04 = reinterpret_cast<SkImage *>(QUERY_GDAT_ENTRY_DATA_PTR(cls1, cls2, dtImage, cls4));
		}
		else {
			//^3E74:5368
			bp04 = reinterpret_cast<SkImage *>(REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]));
		}
		//^3E74:5386
		__int16 bp06 = bp04->Xoffset();
		//^3E74:5392
		__int16 bp08;
		if (bp06 == -32) {
			//^3E74:5397
			si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtImageOffset, cls4);
		}
		else {
			//^3E74:53AE
			bp08 = bp04->Yoffset();
#if DM2_EXTENDED_MODE == 1
			if (bp08 == -32 || bp08 == 31) {
				bp08 = 0;
			}
#else
			//^3E74:53BB
			if (bp08 == -32) {
				//^3E74:53C0
				bp08 = 0;
			}
#endif
			//^3E74:53C5
			si = (bp06 << 8) | Bit8u(bp08);
		}
		//^3E74:53D2
		if (di != 0) {
			//^3E74:53D8
			FREE_PICT6(bp04);
		}
		//^3E74:53E4
		return si;
	}
}

//^0B36:0520
//ExtendedPicture *SkWinCore::QUERY_GDAT_SUMMARY_IMAGE(ExtendedPicture *ref, Bit8u cls1, Bit8u cls2, Bit8u cls4)
ExtendedPicture *SkWinCore::QUERY_GDAT_SUMMARY_IMAGE(ExtendedPicture *ref, Bit8u iCategory, Bit8u iItemNo, Bit8u iEntry)
{
	SkD((DLV_DBG_GETPIC, "DBG: QUERY_GDAT_SUMMARY_IMAGE(%p,%02X,%02X,%02X)\n"
		, ref, (Bitu)iCategory, (Bitu)iItemNo, (Bitu)iEntry));

	//^0B36:0520
	ENTER(8);
    //^0B36:0524
	ZERO_MEMORY(ref, 314);
	//^0B36:0537
	ref->w12 = -1;
	ref->b8 = iCategory;
	ref->b9 = iItemNo;
	ref->b10 = dtImage;
	ref->b11 = iEntry;
	ref->w54 = 64;
	ref->w52 = 64;
	ref->rectNo = 0xffff;
	ref->w26 = 0xffff;
	ref->pb44 = _4976_4964;
	ref->colorKeyPassThrough = -1;
	//^0B36:0586
	if (iCategory != 0xff) {
		//^0B36:058F
		ref->w6 = QUERY_GDAT_ENTRY_DATA_INDEX(iCategory, iItemNo, dtImage, iEntry);
		//^0B36:05AC
		__int16 bp02 = QUERY_GDAT_ENTRY_DATA_INDEX(iCategory, iItemNo, dtImageOffset, 0xFE);
		//^0B36:05C4
		if (bp02 != 0) {
			//^0B36:05C8
			ref->w28 += __int8(bp02 >> 8);
			//^0B36:05D3
			ref->w30 += __int8(bp02);
		}
		//^0B36:05DB
		bp02 = QUERY_GDAT_PICT_OFFSET(iCategory, iItemNo, iEntry);
		//^0B36:05F2
		if (bp02 != 0) {
			//^0B36:05F6
			ref->w28 += __int8(bp02 >> 8);
			//^0B36:0601
			ref->w30 += __int8(bp02);
		}
		//^0B36:0609
		Bit8u *bp06 = QUERY_GDAT_IMAGE_LOCALPAL(iCategory, iItemNo, iEntry);
		//^0B36:0623
		if (bp06 == NULL) {
			//^0B36:062B
			ref->w56 = 256;
			//^0B36:0634
			bp06 = ref->b58;
			//^0B36:0643
			__int16 bp08 = 0;
			//^0B36:0648
			for (; bp08 < 256; bp08++) {
				//^0B36:064A
				bp06[bp08] = (Bit8u)bp08;
				//^0B36:0656
			}
		}
		else {
			//^0B36:0662
			ref->w56 = 16;
			//^0B36:066B
			COPY_MEMORY(bp06, ref->b58, 16);
		}
	}
	//^0B36:0687
	return ref;
}

//^0B36:0A3F
void SkWinCore::DRAW_DEF_PICT(ExtendedPicture *ref)
{
	// draw almost all pictures:
	// a) dungeon viewport: wallset/scene graphics, ornate graphics, spell graphics,
	//		flying items (passing/coming/crossing/placing)
	// b) inventory screen: wall paper, zzz button, X button, "water" text, "food" text, 
	//		resurrection lever, disk button, and so on
	// c) inventory icons: eye, mouth, item icons

	//^0B36:0A3F
	ENTER(12);
	//^0B36:0A45
	if (ref->width <= 0 || ref->height <= 0)
		//^0B36:0A59
		return;
	//^0B36:0A5C
	Bit8u *bp04 = QUERY_PICT_BITS(ref);
	//^0B36:0A6E
	Bit16u bp06 = ref->rectNo;
	//^0B36:0A78
	__int16 bp08;
	__int16 bp0a;
	if (bp06 == 0xffff) {
		//^0B36:0A7D
		bp08 = ref->w32;
		bp0a = ref->w34;
	}
	else {
		//^0B36:0A8D
		if ((bp06 & 0x8000) == 0 || ref->w28 != 0 || ref->w30 != 0) {
			//^0B36:0AA5
			bp06 |= 0x8000;
			//^0B36:0AAE
			bp08 = ref->w32 + ref->w28;
			bp0a = ref->w34 + ref->w30;
		}
		else {
			//^0B36:0AC6
			bp08 = ref->width;
			bp0a = ref->height;
		}
		//^0B36:0AD4
		if (QUERY_BLIT_RECT(bp04, &ref->rc36, bp06, &bp08, &bp0a, ref->w26) == NULL)
			//^0B36:0B07
			return;
	}
	//^0B36:0B0A
	bp08 += ref->w14;
	bp0a += ref->w16;
	__int16 si = READ_UI16(bp04,-4);
	__int16 di = ref->rc36.cx +bp08;
	//^0B36:0B2E
	if (si > di && (ref->mirrorFlip & 0x0001) != 0) {
		//^0B36:0B3A
		si -= di;
	}
	else {
		//^0B36:0B3E
		si = 0;
	}
	//^0B36:0B40
	if ((ref->mirrorFlip & 0x0001) != 0) {
		//^0B36:0B4B
		bp08 = 0;
	}
	//^0B36:0B50
	bp08 += si;
	//^0B36:0B53
	si = READ_I16(bp04,-2);
	//^0B36:0B5A
	di = ref->rc36.cy +bp0a;
	//^0B36:0B66
	if (si > di && (ref->mirrorFlip & 0x0002) != 0) {
		//^0B36:0B72
		si -= di;
	}
	else {
		//^0B36:0B76
		si = 0;
	}
	//^0B36:0B78
	if ((ref->mirrorFlip & 0x0002) != 0) {
		//^0B36:0B83
		bp0a = 0;
	}
	//^0B36:0B88
	bp0a += si;
	//^0B36:0B8B
	Bit16u bp0c;
	if (ref->pb44 == _4976_4964) {
		//^0B36:0BA2
		si = glbScreenWidth;
		di = glbScreenHeight;
		bp0c = 8;
	}
	else {
		//^0B36:0BB1
		si = READ_I16(ref->pb44,-4);
		//^0B36:0BBC
		di = READ_I16(ref->pb44,-2);
		//^0B36:0BC7
		bp0c = READ_I16(ref->pb44,-6);
	}
	//^0B36:0BD5
	if (ref->colorKeyPassThrough != -2) {
		//^0B36:0BDF
		FIRE_BLIT_PICTURE(
			bp04,
			ref->pb44,
			&ref->rc36,
			bp08,
			bp0a,
			READ_UI16(bp04,-4),
			si,
			ref->colorKeyPassThrough,
			ref->mirrorFlip,
			READ_UI16(bp04,-6),
			bp0c,
			(ref->w56 == 0) ? NULL : ref->b58
			);
	}
	//^0B36:0C3D
	ref->w32 = bp08;
	ref->w34 = bp0a;
	//^0B36:0C4E
	return;
}

//^0B36:0139
Bit8u *SkWinCore::QUERY_PICT_BITS(Picture *ref)
{
	//^0B36:0139
	ENTER(0);
	//^0B36:013D
	Bit16u si = ref->w4;
	//^0B36:0144
	if ((si & 0x0004) != 0) {
		//^0B36:014A
		return ref->pb0 = QUERY_GDAT_IMAGE_ENTRY_BUFF(ref->b8, ref->b9, ref->b11);
	}
	//^0B36:016D
	else if ((si & 0x0008) != 0) {
		//^0B36:0173
		return ref->pb0 = QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w12);
	}
	else {
		//^0B36:0182
		return ref->pb0;
	}
}

//^0B36:11C0
// TODO: image related ?
void SkWinCore::_0b36_11c0(ExtendedPicture *xx, sk3f6c *yy, Bit16u ss, __int16 colorkey2)
{
	//^0B36:11C0
    ENTER(12);
	//^0B36:11C4
	xx->pb44 = reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(yy->w0));
	//^0B36:11DB
	SRECT bp08;
	__int16 bp0a;
	__int16 bp0c;
	if (ss == 0xffff) {
		ATLASSERT(false); // FTL's miss logic?

		//^0B36:11E1
		COPY_MEMORY(&xx->rc36, &bp08, 8);
		//^0B36:11FC
		goto _123d;
	}
	else {
		//^0B36:11FE
		bp0a = xx->width;
		bp0c = xx->height;
		//^0B36:120F
		if (QUERY_BLIT_RECT(QUERY_PICT_BITS(xx), &bp08, ss, &bp0a, &bp0c, -1) != NULL) {
			//^0B36:123D
_123d:
			xx->width += bp0a;
			xx->height += bp0c;
			//^0B36:124E
			OFFSET_RECT(yy, &bp08, &xx->rc36);
			//^0B36:126A
			xx->rectNo = 0xffff;
			xx->colorKeyPassThrough = colorkey2;
			//^0B36:127A
			DRAW_DEF_PICT(xx);
			//^0B36:1286
			_0b36_0d67(yy, &bp08);
		}
	}
	//^0B36:1298
	return;
}

//^0B36:0036
i16 SkWinCore::CALC_STRETCHED_SIZE(__int16 val, __int16 fact64)
{
	//^0B36:0036
	ENTER(0);
	//^0B36:0039
	return (__int16(val * fact64) + (fact64 >> 1)) >> 6;
}

//^0B36:00C3
// TODO: Image related ?
Bit8u *SkWinCore::_0b36_00c3(__int16 xx, Picture *ref)
{
	//^0B36:00C3
	ENTER(4);
	//^0B36:00C7
	Bit8u *bp04 = reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(xx));
	//^0B36:00D6
	if (ref != NULL) {
		//^0B36:00DE
		ref->pb0 = bp04;
		//^0B36:00EE
		ref->w14 = 0;
		ref->w16 = 0;
		//^0B36:00FA
		ref->width = READ_UI16(bp04,-4);
		//^0B36:0108
		ref->height = READ_UI16(bp04,-2);
		//^0B36:0116
		ref->w22 = READ_UI16(bp04,-6);
		//^0B36:0124
        ref->w12 = xx;
		//^0B36:012B
		ref->w4 = 8;
	}
	//^0B36:0131
	return bp04;
}

//^0B36:004B
Bit8u *SkWinCore::QUERY_PICST_IMAGE(Picture *ref)
{
	//^0B36:004B
	ENTER(4);
	//^0B36:004F
	Bit8u *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(ref->b8, ref->b9, ref->b11);
	//^0B36:006F
	ref->pb0 = bp04;
	//^0B36:007F
	ref->w14 = 0;
	ref->w16 = 0;
	//^0B36:008B
	ref->width = READ_UI16(bp04,-4);
	//^0B36:0099
	ref->height = READ_UI16(bp04,-2);
	//^0B36:00A7
	ref->w22 = READ_UI16(bp04,-6);
	//^0B36:00B5
	ref->w4 = 4;
	//^0B36:00BB
	return bp04;
}

//^3E74:58BF
void SkWinCore::ALLOC_IMAGE_MEMENT(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	//^3E74:58BF
	ENTER(4);
	//^3E74:58C5
	Bit16u si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtImage, cls4);
	//^3E74:58DC
	if (si != 0xffff && glbShelfMemoryTable[si].Absent()) {
		//^3E74:58FC
		si = QUERY_GDAT_ENTRY_DATA_INDEX(0x15,0xfe,dtImage,0xfe);			
	}
	//^3E74:590F
	if (si != 0xffff) {
		//^3E74:5914
		Bit16u di = QUERY_MEMENTI_FROM(si);
		//^3E74:591C
		if (di == 0xffff) {
			if (glbShelfMemoryTable[si].Absent()) {
				//^3E74:593C
				return;
			}
			//^3E74:593E
			SkImage *bp04 = reinterpret_cast<SkImage *>(REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]));
			//^3E74:595C
			if (bp04->Yoffset() != -32) {
				//^3E74:5969
				return;
			}
			//^3E74:596B
			if (bp04->BitsPixel() != 8) {
				//^3E74:5980
				return;
			}
			//^3E74:5982
			_4976_4807 = si;
			//^3E74:5986
			return;
		}
		else {
			//^3E74:5988
			_3e74_4549(di);
		}
	}
	//^3E74:598E
	return;
}

//^0B36:018F
void SkWinCore::ALLOC_PICT_MEMENT(Picture *ref)
{
	//^0B36:018F
	ENTER(0);
	//^0B36:0192
	if ((ref->w4 & 0x0004) != 0) {
		//^0B36:019D
		ALLOC_IMAGE_MEMENT(ref->b8, ref->b9, ref->b11);
	}
	//^0B36:01B6
	else if ((ref->w4 & 0x0008) != 0) {
		//^0B36:01C1
		_3e74_583a(ref->w12);
	}

}

//^0B36:068F
Bit32u SkWinCore::CALC_PICT_ENT_HASH(ExtendedPicture *ref)
{
	//^0B36:068F
	ENTER(0);
	//^0B36:0692
	return (Bit32u(ref->w6 & 0x1fff) << 12) | ((ref->w52 & 0x007f) << 5) | (ref->w54 & 0x001f);
}

//^3E74:5992
void SkWinCore::FREE_IMAGE_MEMENT(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	//^3E74:5992
	ENTER(0);
	//^3E74:5997
	Bit16u si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtImage, cls4);
	//^3E74:59AE
	if (si == 0xffff || glbShelfMemoryTable[si].Absent()) {
		//^3E74:59CE
		si = QUERY_GDAT_ENTRY_DATA_INDEX(0x15,0xfe,dtImage,0xfe);
	}
	//^3E74:59E1
	if (si == 0xffff)
		//^3E74:59E4
		return;
	//^3E74:59E6
	if (_4976_4807 == si) {
		//^3E74:59EC
		_4976_4807 = 0xffff;
	}
	//^3E74:59F2
	Bit16u di = QUERY_MEMENTI_FROM(si);
	//^3E74:59FA
	if (di != 0xffff) {
		//^3E74:59FF
		RECYCLE_MEMENTI(di, 0);
	}
	//^3E74:5A08
	return;
}

//^0B36:01CD
void SkWinCore::FREE_PICT_MEMENT(Picture *ref)
{
	//^0B36:01CD
	ENTER(0);
	//^0B36:01D0
	if ((ref->w4 & 0x0004) != 0) {
		//^0B36:01DB
		FREE_IMAGE_MEMENT(ref->b8, ref->b9, ref->b11);
	}
	//^0B36:01F4
	else if ((ref->w4 & 0x0008) != 0) {
		//^0B36:01FF
		_3e74_585a(ref->w12, 0);
	}

}

//^44C8:2307
// TODO: related gfx ?
void SkWinCore::_44c8_2307(X16 xx, X16 yy, X16 zz, X16 ww)
{
	//^44C8:2307
	ENTER(4);
	//^44C8:230D
	U8 *bp04 = _4976_5e64 + xx;
	U16 di = zz >> 1;
	U16 cx = ww + yy;
	U16 si = yy;
	do {
		//^44C8:2331
		_4976_5e6a[si] = bp04[di >> 7];
		di += zz;
		si++;
	} while (si < cx);
	//^44C8:234D
	return;
}

//^44C8:2351
void SkWinCore::_44c8_2351(Bit8u *xx, Bit8u *yy, Bit16u ss, Bit16u tt, Bit16u uu, Bit16u vv)
{
	//^44C8:2351
	ENTER(10);
	//^44C8:2357
	U16 di = uu;
	_4976_5e64 = xx;
	_4976_5e6a = yy;
	U16 bp04 = (i32(ss) << 7) / di;
	U16 bp06 = (i32(tt) << 7) / vv;
	U16 bp02 = bp06 >> 1;
	U16 si = 0;
	X16 bp08 = 0; // defaulting to 0
	X16 bp0a = 0; // defaulting to 0
	for (; si < vv; bp0a = bp08, bp02 += bp06, si++) {
		//^44C8:23B2
		bp08 = bp02 >> 7;
		if (bp0a == bp08 && si > 0) {
			//^44C8:23C7
			_4976_5e64 = yy;
			_44c8_0b8d((si -1) * di, si * di, di);
			_4976_5e64 = xx;
		}
		else {
			//^44C8:23F6
			_44c8_2307(bp08 * ss, si * di, bp04, di);
		}
		//^44C8:240D
	}
	//^44C8:241F
	return;
}

//^44C8:000F
void SkWinCore::FIRE_BLIT_TO_MEMORY_ROW_4TO4BPP(Bit16u offSrc, Bit16u offDst, Bit16u width)
{
	//^44C8:000F
	ENTER(0);
	//^44C8:0015
	Bit8u *di = _4976_5e6a;
	Bit8u *si = _4976_5e64;
	Bit16u cx = width;

	bool carry1 = (offSrc & 1) ? true : false;
	offSrc >>= 1;
	bool carry2;
	if (!carry1) {
		//^44C8:0028
		si += offSrc;
		//^44C8:002D
		carry2 = (offDst & 1) ? true : false;
		offDst >>= 1;
		if (!carry2) {
			//^44C8:0034
			di += offDst;

			//^44C8:0036
_0036:
			bool carry3 = (cx & 1) ? true : false;
			cx >>= 1;
			{
				//^44C8:0039
				bool carry4 = (cx & 1) ? true : false;
				cx >>= 1;
				//^44C8:003B
				if (carry4) {
					//^44C8:003D
					*di = *si; di++; si++;
				}
				//^44C8:003E
				while (cx != 0) {
					//^44C8:0043
					*di = *si; di++; si++;
					*di = *si; di++; si++;
					cx--;
				}
			}
			//^44C8:0049
			if (carry3) {
				*di = (*si & 0xf0) | (*di & 0x0f); si++; di++;
			}
		}
		else {
			//^44C8:00B5
			di += offSrc;
			//^44C8:00B7
			Bit8u bh = *di;
			//^44C8:00BA
			cx++;
			bool carry = (cx & 1) ? true : false;
			cx >>= 1;
			//^44C8:00BE
			if (cx != 0) {
				//^44C8:00C0
				bool carry = (cx & 1) ? true : false;
				//^44C8:00C2
				if (carry) {
					//^44C8:00C4
					Bit8u al = *si; si++;
					//^44C8:00C6
					*di = (bh & 0xf0) | (al >> 4); di++;
					bh = al << 4;
				}
				//^44C8:00D6
				if (cx != 0) {
					//^44C8:00D8
					bh &= 0xf0;
					do {
						// AL   AH   BL   BH
						// m34  m56       m12
						//                m10
						// m63  m45
						//           m63
						// m10            m63
						//           m60  m03
						// m13
						//                m60
						// ------------------
						// m13  m45       m60

						//^44C8:00DB
						Bit8u al = *si; si++;
						Bit8u ah = *si; si++;
						*di =  bh       | (al >> 4); di++;
						*di = (al << 4) | (ah >> 4); di++;
						bh = ah << 4;
						//^44C8:00EC
					} while (--cx != 0);
				}
			}
			//^44C8:00EE
			if (carry) {
				//^44C8:00F1
				*di = (*di & 0x0f) | bh; di++;
			}
		}
	}
	else {
		//^44C8:0068
        si += offSrc;
		{
			//^44C8:006A
			bool carry = (offDst & 1) ? true : false;
			offDst >>= 1;
			//^44C8:006F
			if (carry) {
				//^44C8:0059
				di += offDst;
				//^44C8:005B
				*di = (*si & 0x0f) | (*di & 0xf0); si++; di++;
				//^44C8:0065
				cx--;
				//^44C8:0066
				goto _0036;
			}
		}
		//^44C8:0071
		di += offDst;
		//^44C8:0073
		Bit8u bh = *si; si++;
		{
			//^44C8:0076
			bool carry = (cx & 1) ? true : false;
			cx >>= 1;
			//^44C8:0079
			if (cx != 0) {
				//^44C8:007B
				bool carry = (cx & 1) ? true : false;
				cx >>= 1;
				//^44C8:007D
				if (carry) {
					//^44C8:007F
					Bit8u bl = *si;
					*di = (*si >> 4) | (bh << 4); di++; si++;
					bh = bl;
				}
				//^44C8:008C
				if (cx != 0) {
					//^44C8:008E
					bh &= 0x0f;
					do {
						// AL   AH   BL   BH
						// m23  m45  ?    m01
						//           m45
						//      m01       m45
						//           m05  m40
						//      m41
						//                m05
						// m12  m34
						// ------------------
						// m12  m34       m05

						//^44C8:0091
						Bit8u al = *si; si++;
						Bit8u ah = *si; si++;
						*di = (bh << 4) | (al >> 4); di++;
						*di = (al << 4) | (ah >> 4); di++;
						bh = ah & 0x0f;
						//^44C8:00A2
					} while (--cx != 0);
				}
			}
			//^44C8:00A4
			if (carry) {
				//^44C8:00A7
				*di = (*di & 0x0f) | (bh << 4);
			}
		}
	}
	//^44C8:00F9
	return;
}

//^44C8:20E5
void SkWinCore::_44c8_20e5(Bit16u srcOff, Bit16u dstOff, Bit16u srcWidth, Bit16u dstWidth)
{
	ATLASSERT(srcWidth != 0);

	//^44C8:20E5
	ENTER(0);
	//^44C8:20EA
    Bit8u *di = _4976_5e6a + (dstOff >> 1);
	Bit16u cx = srcWidth >> 1;
	Bit16u dx = (dstWidth +1) >> 1;
	Bit8u *si = _4976_5e64 + (srcOff >> 1);
	Bit8u bh = 0;
	do {
		//^44C8:2111
		Bit8u ah = si[cx >> 8];
		if ((cx & 0x80) == 0) {
			ah &= 0xf0;
		}
		else {
			ah <<= 4;
		}
		cx += srcWidth;

		Bit8u al = si[cx >> 8];
		if ((cx & 0x80) == 0) {
			al >>= 4;
		}
		else {
			al &= 0x0f;
		}
		*di = al | ah; di++;
		cx += srcWidth;
	} while (--dx != 0);
	//^44C8:213E
	return;
}

//^44C8:2143
void SkWinCore::_44c8_2143(Bit16u xx, Bit16u yy, Bit16u ss, Bit16u tt)
{
	//^44C8:2143
	ENTER(4);
	//^44C8:2149
	U16 si = ss >> 1;
	U16 bp04 = ((tt +yy) +1) >> 1;
	U16 di = yy >> 1;
	//^44C8:2163
	while (di < bp04) {
		//^44C8:2166
		U16 bp02 = (si >> 7) +xx;
		U8 al;
		U8 dl = al = _4976_5e64[bp02 >> 1];
		si += ss;
		if ((bp02 & 1) != 0) {
			//^44C8:2188
			al &= 0xF;
		}
		else {
			//^44C8:218F
			al >>= 4;
		}
		//^44C8:2196
		al = _4976_5dbe[al];
		al <<= 4;
		U8 cl = al;
		bp02 = (si >> 7) +xx;
		al = _4976_5e64[bp02 >> 1];
		dl = al;
		si += ss;
		if ((bp02 & 1) != 0) {
			//^44C8:21C6
			al &= 0xF;
		}
		else {
			//^44C8:21CD
			al >>= 4;
		}
		//^44C8:21D4
		al = cl | _4976_5dbe[al];
		_4976_5e6a[di] = al;
		di++;
		//^44C8:21E7
	}
	//^44C8:21EF
	return;
}

#pragma warning(push)
#pragma warning(disable: 4700)

//^44C8:21F3
void SkWinCore::FIRE_STRETCH_BLIT_TO_MEMORY_4TO4BPP(Bit8u *src, Bit8u *dst, Bit16u srcWidth, Bit16u srcHeight, Bit16u dstWidth, Bit16u dstHeight, U8 *aa)
{
	//^44C8:21F3
	ENTER(12);
	//^44C8:21F9
	_4976_5e64 = src;
	//^44C8:2206
	_4976_5e6a = dst;
	//^44C8:2213
	_4976_5dbe = aa;
	//^44C8:2220
	Bit16u bp08 = (dstWidth +1) & 0xfffe;
	//^44C8:222D
	Bit16u bp0a = (srcWidth +1) & 0xfffe;
	//^44C8:2234
	Bit16u bp04 = (__int32(__int16(srcWidth)) << 7) / __int16(dstWidth);
	//^44C8:224F
	Bit16u bp06 = (__int32(__int16(srcHeight)) << 7) / __int16(dstHeight);
	//^44C8:226A
	Bit16u bp02 = bp06 >> 1;
	//^44C8:226F
	Bit16u bp0c = 0; // defaulting to 0
	for (Bit16u si = 0; si < dstHeight; si++) {
		//^44C8:2274
		Bit16u di = bp02 >> 7;
		//^44C8:227C
		if (bp0c == di && si > 0) {
			//^44C8:2285
			_4976_5e64 = dst;
			//^44C8:2292
			FIRE_BLIT_TO_MEMORY_ROW_4TO4BPP((si -1) * bp08, si * bp08, dstWidth);
			//^44C8:22A9
			_4976_5e64 = src;
		}
		//^44C8:22B8
		else if (aa == 0) {
			//^44C8:22C0
			_44c8_20e5(di * bp0a, si * bp08, bp04, dstWidth);
		}
		else {
			//^44C8:22D8
			_44c8_2143(di * bp0a, si * bp08, bp04, dstWidth);
		}
		//^44C8:22F1
		bp0c = di;
		//^44C8:22F4
		bp02 += bp06;
		//^44C8:22FA
	}
	//^44C8:2303
	return;
}
#pragma warning(pop)

//^0B36:06D3
ExtendedPicture *SkWinCore::QUERY_PICST_IT(ExtendedPicture *ref)
{
	// query image with some capacity
	// - stretch

	//^0B36:06D3
	ENTER(364);
	//^0B36:06D9
	Bit16u bp12 = (ref->w52 != 64 || ref->w54 != 64) ? 1 : 0;
	Bit16u bp14 = 0;
	//^0B36:06F9
	Bit16u bp16 = (ref->w6 == 0xffff && ref->w12 >= 0) ? 1 : 0;
	//^0B36:0714
	if (bp12 != 0) {
		//^0B36:071A
		ref->w28 = CALC_STRETCHED_SIZE(ref->w28, ref->w52);
		//^0B36:0732
		ref->w30 = CALC_STRETCHED_SIZE(ref->w30, ref->w54);
	}
	//^0B36:0747
	if ((ref->mirrorFlip & 0x0001) != 0) {
		//^0B36:0752
		ref->w28 = - ref->w28;
	}
	//^0B36:075C
	if (ref->colorKeyPassThrough == -3)
		//^0B36:0766
		//^0B36:0A35
		return ref;
	//^0B36:0769
	if (bp12 == 0 && bp14 == 0) {
		//^0B36:0775
		if (bp16 != 0) {
			//^0B36:077B
			//^0B36:0788
			_0b36_00c3(ref->w12, ref);
			//^0B36:0A35
			return ref;
		}
		else {
			//^0B36:0792
			QUERY_PICST_IMAGE(ref);
			//^0B36:079E
			//^0B36:0A35
			return ref;
		}
	}
	//^0B36:07A1
	Bit16u bp18;
	Bit8u *bp04;
	Bit8u *bp08;
	Picture bp32;
	if (bp16 != 0) {
		//^0B36:07A7
		bp18 = ALLOC_TEMP_CACHE_INDEX();
		//^0B36:07AF
		COPY_MEMORY(ref, &bp32, 24);
		//^0B36:07C6
		Bit8u *bp08 = _0b36_00c3(bp32.w12, &bp32);
		//^0B36:07DB
		ALLOC_PICT_MEMENT(&bp32);
		//^0B36:07E6
		bp04 = NULL;
	}
	else {
		//^0B36:07F3
		Bit32u bp10 = CALC_PICT_ENT_HASH(ref);
		//^0B36:0805
		if (ADD_CACHE_HASH(bp10, &bp18) != 0) {
			//^0B36:081C
			//^0B36:0788
			_0b36_00c3(bp18, ref);
			//^0B36:0A35
			return ref;
		}
		else {
			//^0B36:0828
			bp04 = NULL;
			bp08 = NULL;
			//^0B36:0838
			if (bp08 == NULL) {
				//^0B36:0840
				COPY_MEMORY(ref, &bp32, 24);
				//^0B36:0857
				bp08 = QUERY_PICST_IMAGE(&bp32);
				//^0B36:0868
				ALLOC_PICT_MEMENT(&bp32);
			}
		}
	}
	//^0B36:0873
	if ((bp32.w4 & 0x0010) != 0) {
		//^0B36:087D
		ExtendedPicture bp016c;
		COPY_MEMORY(ref, &bp016c, 314);
		//^0B36:0896
		bp016c.mirrorFlip = 0;
		bp016c.w54 = 64;
		bp016c.w52 = 64;
		//^0B36:08A7
		Bit16u bp1a;
		if (ADD_CACHE_HASH(CALC_PICT_ENT_HASH(&bp016c), &bp1a) == 0) {
			//^0B36:08C6
			bp08 = ALLOC_NEW_PICT(bp1a, bp32.width, bp32.height, bp32.w22);
			//^0B36:08E0
			Bit8u *bp0c = QUERY_PICT_BITS(&bp32);
			//^0B36:08F1
			FIRE_BLIT_PICTURE(
				bp0c,
				bp08,
				ALLOC_TEMP_ORIGIN_RECT(bp32.width, bp32.height),
				bp32.w14,
				bp32.w16,
				READ_UI16(bp0c,-4),
				READ_UI16(bp08,-4),
                -1,
				0,
				bp32.w22,
				bp32.w22,
				NULL
				);
		}
		//^0B36:0936
		FREE_PICT_MEMENT(&bp32);
		//^0B36:0941
		Bit8u *bp08 = _0b36_00c3(bp1a, &bp32);
		//^0B36:0956
		ALLOC_PICT_MEMENT(&bp32);
	}
	//^0B36:0961
	if (bp12 != 0) {
		//^0B36:096A
		__int16 di = CALC_STRETCHED_SIZE(bp32.width, ref->w52);
		//^0B36:097C
		__int16 si = CALC_STRETCHED_SIZE(bp32.height, ref->w54);
		//^0B36:098E
		if (di <= 0 || si <= 0) {
			//^0B36:0996
			ref->width = di;
			ref->height = si;
		}
		else {
			//^0B36:09A3
			ALLOC_NEW_PICT(bp18, di, si, bp32.w22);
			//^0B36:09B3
			bp08 = QUERY_PICT_BITS(&bp32);
			//^0B36:09C4
			bp04 = _0b36_00c3(bp18, ref);
			//^0B36:09DA
			if (bp32.w22 == 8) {
				//^0B36:09E0
				_44c8_2351(bp08, bp04, bp32.width, bp32.height, di, si);
			}
			else {
				//^0B36:09FE
				FIRE_STRETCH_BLIT_TO_MEMORY_4TO4BPP(bp08, bp04, bp32.width, bp32.height, di, si, NULL);
			}
		}
	}
	//^0B36:0A1E
	FREE_PICT_MEMENT(&bp32);
	//^0B36:0A29
	_3e74_585a(bp18, 0);
	//^0B36:0A35
	return ref;
}

//^0B36:131A
void SkWinCore::DRAW_SIMPLE_STR(sk3f6c *ref, Bit16u rectno, Bit16u clr1, Bit16u clr2, Bit8u *str)
{
	// you can draw:
	// e.g. spell symbols, represented as "<<","","","",")-","".
	// e.g. damage amount like "80"

	// their drawStr is regurally scheduled. e.g. you can print damage "80" at portrait/status panel. no another position/text pattern.

	//^0B36:131A
	ENTER(12);
	//^0B36:131E
	__int16 bp02;
	__int16 bp04;
	SRECT bp0c;
	// bp0c -> bp0c.x
	// bp0a -> bp0c.y
	// bp08 -> bp0c.cx
	// bp06 -> bp0c.cy

	if (QUERY_STR_METRICS(str, &bp02, &bp04) != 0 && QUERY_BLIT_RECT(NULL, &bp0c, rectno, &bp02, &bp04, -1) != 0) {
		//^0B36:135E
		DRAW_STRING(
			reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w0)), 
			ref->w0, 
			ref->rc2.cx, 
			bp0c.x             -ref->rc2.x,
			bp0c.y +bp0c.cy -1 -ref->rc2.y,
			clr1,
			clr2,
			str,
			8
			);
		//^0B36:139D
		_0b36_0d67(ref, &bp0c);
	}
	//^0B36:13AF
	return;
}

//^0B36:10B6
void SkWinCore::DRAW_ICON_PICT_BUFF(
	const Bit8u *buff, 
	sk3f6c *tt, 
	SRECT *rc, 
	__int16 srcx, 
	__int16 srcy, 
	__int16 colorkey, 
	__int16 flipmirror, 
	Bit8u *localpal
) {
	// draw icon image such as:
	// a) right part of panel (commander part)
	//		directional/curved arrow, 2x2 floor status panel, command buttons, X button, spell board,
	// b) upper part of panel (status part)
	//		player plate, hand icon, portrait icon
	// c) upper and/or right part of panel
	//		item icon (such as dagger, etc), colored player icon

	//^0B36:10B6
	ENTER(8);
	//^0B36:10BA
	if (rc != NULL) {
		//^0B36:10C2
		SRECT bp08;
		FIRE_BLIT_PICTURE(
			buff,
			QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(tt->w0),
			OFFSET_RECT(tt, rc, &bp08),
			srcx,
			srcy,
			READ_UI16(buff,-4),
			tt->rc2.cx,
			colorkey,
			flipmirror,
			READ_UI16(buff,-6),
			8,
			localpal
			);
		//^0B36:1121
		_0b36_0d67(tt, rc);
	}
	//^0B36:1134
	return;
}

//^0B36:1136
void SkWinCore::DRAW_ICON_PICT_ENTRY(Bit8u cls1, Bit8u cls2, Bit8u cls4, sk3f6c *ss, Bit16u rectno, __int16 colorkey)
{
	//^0B36:1136
	ENTER(20);
	//^0B36:113A
	__int16 bp0c = 0;
	__int16 bp0a = 0;
	//^0B36:1142
	Bit8u *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(cls1, cls2, cls4);
	//^0B36:115C
	SRECT bp14;
	SRECT *bp08 = QUERY_BLIT_RECT(bp04, &bp14, rectno, &bp0a, &bp0c, -1);
	//^0B36:1184
	DRAW_ICON_PICT_BUFF(
		bp04,
		ss,
		bp08,
		bp0a,
		bp0c,
		colorkey,
		0,
		QUERY_GDAT_IMAGE_LOCALPAL(cls1, cls2, cls4)
		);
	//^0B36:11BE
	return;
}

//^29EE:00E0
void SkWinCore::SHOW_ATTACK_RESULT(__int16 yourValue)
{
	// yourValue: it means a damage value if positive, it means a failure reason if negative

	// if -1, go fore to attack
	// if -2, hand a empty flask
	// if -3, your meaningless spell
	// if -4, failure wizard spell
	// if -5, failure priest spell
	// if -6, go X-mark to teleport

	//^29EE:00E0
	ENTER(324);
	//^29EE:00E6
	__int16 di = yourValue;
	//^29EE:00E9
	_29ee_00a3(1);
	//^29EE:00F0
	Bit8u bp01 = 4;
	Bit8u bp02 = 1;
	//^29EE:00F8
	if (di < 0) {
		//^29EE:00FC
		switch (di) {
			case ATTACK_FAILURE_X_TELEPORT:	// -6
				//^29EE:010F
				bp02 = 0x19; // 0x19 = [icon] move to X-mark to teleport
				break;
			case ATTACK_REQUIRES_HAND_ITEM:	// -2
				//^29EE:011B
				bp02 = 0x17; // 0x17 = [icon] hand a empty flask to cast
				break;
			case ATTACK_FAILURE_NOT_FRONT:	// -1
				//^29EE:0115
				bp02 = 0x18; // 0x18 = [icon] hind player cannot attack physically
				break;
			default:
				//^29EE:0121
				bp01 = 5;
				//^29EE:0125
				if (di == ATTACK_MEANINGLESS_SPELL) {	// -3
					//^29EE:012A
					bp02 = 0x0e; // 0x0e = [icon] unknown spell
				}
				//^29EE:0130
				else if (di == ATTACK_FAILURE_WIZARD) {	// -4
					//^29EE:0135
					bp02 = 0x0c; // 0x0c = [icon] fail wizard spell
				}
				else {	// Supposedly ATTACK_FAILURE_PRIEST !!
					//^29EE:013B
					bp02 = 0x0d; // 0x0d = [icon] fail priest spell
				}
				break;
		}
	}
	//^29EE:013F
	ExtendedPicture bp0144;
	QUERY_GDAT_SUMMARY_IMAGE(&bp0144, 1, bp01, bp02);
	//^29EE:0157
	// SPX: Depending on the amount of damage done, stretch the damage done hit image
	if (di >= 0 && di <= 40) {
		//^29EE:0160
		if (di > 15) {
			//^29EE:0165
			bp0144.w52 = 0x002b;
			bp0144.w54 = 0x003b;
		}
		else {
			//^29EE:0173
			bp0144.w52 = 0x001c;
			bp0144.w54 = 0x002c;
		}
	}
	//^29EE:017F
	_0b36_11c0(QUERY_PICST_IT(&bp0144), &_4976_3f6c, 57, -1);
	//^29EE:019E
	if (di >= 0) {
#if UseAltic
		ATLASSERT(di < 999); di = min(di, 999);
#endif

		//^29EE:01A2
		Bit16u si = 5;
		//^29EE:01A5
		Bit8u bp0a[8];
		bp0a[5] = 0;
		do {
			//^29EE:01A9
			si--;
			//^29EE:01AA
			bp0a[si] = U8(di % 10) + '0';
			//^29EE:01B8
			di = di / 10;
			//^29EE:01BF
		} while (di != 0);

		//^29EE:01C3
		si--;
		bp0a[si] = '!';
		si--;
		bp0a[si] = 0x02;
		//^29EE:01CD
		DRAW_SIMPLE_STR(&_4976_3f6c, 0x39, glbPaletteT16[COLOR_CYAN], glbPaletteT16[COLOR_BLACK], &bp0a[si]);
		//^29EE:01F5
	}
	//^29EE:01F7
	//else if (di == -2) {
	else if (di == ATTACK_REQUIRES_HAND_ITEM) {
		//^29EE:01FC
		DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, (glbWeaponMissileHand == 0) ? GDAT_INTERFACE_BODY_HAND_RIGHT : GDAT_INTERFACE_BODY_HAND_LEFT, &_4976_3f6c, 126, -1);
		//^29EE:021E
		bp01 = 0;
		//^29EE:0222
		// SPX: Search through all weapons to find which projectile fits the current shooter item
		for (; bp01 < 255; bp01++) {
			//^29EE:0224
			Bit16u si = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WEAPONS, bp01, dtWordValue, GDAT_ITEM_WEAPON_PROJECTILE_FLAG); // 0x05
			//^29EE:0238
			// SPX: Check that the weapon is not a launcher (0x8000) and match the shooter flag
			if (si != 0 && (si & WEAPON_FLAGS_SHOOTER) == 0 && (glbWeaponShooterNum & si) != 0) {
				//^29EE:0248
				DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_WEAPONS, bp01, 0x18, &_4976_3f6c, 125, -1);
				//^29EE:025D
				return;
			}
			//^29EE:025F
		}
	}
	//^29EE:0268
	return;
}

//^24A5:0930
// SPX: _24a5_0930 renamed PUT_OBJECT_INTO_CONTAINER
void SkWinCore::PUT_OBJECT_INTO_CONTAINER()
{
	//^24A5:0930
	ENTER(4);
	//^24A5:0936
	if (glbObjectForContainer == OBJECT_NULL)
		return;
	//^24A5:093D
	GenericContainerRecord *bp04 = GET_ADDRESS_OF_GENERIC_CONTAINER_RECORD(glbObjectForContainer);
	glbObjectForContainer = OBJECT_NULL;
	i16 si;
	for (si = 0; si < 8; si++) {
		//^24A5:0957
		ObjectID di = glbCurrentContainerItems[si];
		if (di != OBJECT_NULL) {
			glbCurrentContainerItems[si] = OBJECT_NULL;
			APPEND_RECORD_TO(di, &bp04->possession, -1, 0);
		}
		//^24A5:0986
	}
	//^24A5:098C
	return;
}

//^2759:0541
// SPX: _2759_0541 renamed DISPLAY_RIGHT_PANEL_SQUAD_HANDS
void SkWinCore::DISPLAY_RIGHT_PANEL_SQUAD_HANDS()
{
	//^2759:0541
	ENTER(2);
	//^2759:0545
	__int16 bp02 = glbChampionIndex;
	//^2759:054B
	if (bp02 != 0) {
		//^2759:054F
		if (glbChampionAttackDamage == 0 || glbSomeChampionPanelFlag <= 1)
			//^2759:055D
			glbSomeChampionPanelFlag = 0;

		//^2759:0563
		glbChampionIndex = 0;
		glbRightPanelType = RIGHT_PANEL_SQUAD_HANDS;
		glbMagicalMapFlags = 0;
		if (glbObjectForContainer != OBJECT_NULL) {
			//^2759:057C
			PUT_OBJECT_INTO_CONTAINER();
		}
		//^2759:0581
		_4976_531c = 1;
	}
	//^2759:0587
	return;
}

//^0CEE:29B9
Bit16u SkWinCore::GET_MAX_CHARGE(ObjectID recordLink)
{
	//^0CEE:29B9
	ENTER(0);
	//^0CEE:29BC
	if (recordLink != OBJECT_NULL) {
		//^0CEE:29C2
		switch (recordLink.DBType()) {
			case dbWeapon:
				//^0CEE:29DC
				return 15;
			case dbCloth:
				//^0CEE:29E1
				return 15;
			case dbMiscellaneous_item:
				//^0CEE:29E3
				return 3;
		}
	}
	//^0CEE:29C0
	return 0;
}

//^2405:014A
Bit8u SkWinCore::_2405_014a(ObjectID recordLink, __int16 xx, __int16 yy)
{
	//^2405:014A
	ENTER(8);
	//^2405:0150
	Bit8u bp01 = 0x18;
	//^2405:0154
	if (yy != 0) {
		//^2405:015D
		Bit16u si = QUERY_GDAT_DBSPEC_WORD_VALUE(recordLink, 6);
		//^2405:016B
		Bit16u di = si & 15;
		//^2405:0170
		if (di != 0) {
			//^2405:0177
			Bit16u bp04 = 0;
			//^2405:017C
			if ((si & 0x8000) == 0 || (bp04 = IS_ITEM_FIT_FOR_EQUIP(recordLink, xx, 1)) != 0) {
				//^2405:019C
				if ((si & 0x4000) != 0) {
					//^2405:01A2
					if (glbChampionIndex == 0 || _4976_3de2[(glbChampionIndex << 1) + (glbSelectedHandAction)] != recordLink)
						//^2405:01C3
						goto _02d3;
					//^2405:01C6
                    bp04 = 1;						
				}
				//^2405:01CB
				if (bp04 != 0) {
					//^2405:01D1
					bp01++;
					di--;
				}
				//^2405:01D5
				if (di != 0) {
					//^2405:01DC
					Bit32u bp08 = glbGameTick;
					//^2405:01E9
					switch ((si & 0x1f00) >> 8) {
						case 5:
							//^2405:0201
							bp08 += recordLink.DBIndex();

							goto _020e;
						case 0:
							//^2405:020E
_020e:
							bp01 = bp01 + Bit8u(bp08 % di);
							//^2405:0224
							break;
						case 1:
							//^2405:0227
							bp01 = bp01 + Bit8u(RAND16(di));
							//^2405:0224
							break;
						case 2:
							//^2405:0230
							bp01 = bp01 + glbPlayerDir;
							//^2405:023A
							break;
						case 3:
							//^2405:023D
							si = ADD_ITEM_CHARGE(recordLink, 0);
							//^2405:0249
							if (si == 0)
								//^2405:024F
								break;
							//^2405:0252
							bp01 = (di * si) / (GET_MAX_CHARGE(recordLink) +1) + bp01;
							//^2405:026E
							break;
						case 6:
							//^2405:0270
							bp08 += recordLink.DBIndex();

							goto _027d;
						case 4:
							//^2405:027D
_027d:
							xx = (si & 0x00e0) >> 5;
							//^2405:0288
							si = ADD_ITEM_CHARGE(recordLink, 0);
							//^2405:0296
							if (si == 0)
								//^2405:0298
								break;
							//^2405:029A
							bp01 = (((di / xx) * si) / (GET_MAX_CHARGE(recordLink) +1)) * xx + (bp08 % yy) +bp01 +1;

							break;
					}
				}
			}
		}
	}
	//^2405:02D3
_02d3:
	return bp01;
}

//^0B36:0334
Bit8u *SkWinCore::TRANSLATE_PALETTE(Bit8u *localpal, Bit8u cls1, Bit8u cls2, Bit8u cls4, __int16 palentcnt)
{
	//^0B36:0334
	ENTER(4);
	//^0B36:0339
	Bit8u *bp04 = QUERY_GDAT_ENTRY_DATA_PTR(cls1, cls2, dt07, cls4);
	//^0B36:0355
	for (__int16 si = 0; si < palentcnt; si++) {
		//^0B36:0359
		localpal[si] = bp04[localpal[si]];
		//^0B36:036F
	}
	//^0B36:0375
	return localpal;
}

//^2405:05B4
// SPX: _2405_05b4 renamed DRAW_ITEM_ON_WOOD_PANEL
Bit8u *SkWinCore::DRAW_ITEM_ON_WOOD_PANEL(Bit16u player, Bit16u possessionIndex, Picture *ref)
{
	//^2405:05B4
	ENTER(348);
	//^2405:05BA
	if (IS_ITEM_HAND_ACTIVABLE(player, glbChampionSquad[player].Possess(possessionIndex), possessionIndex) == 0) {
		//^2405:05E1
		//^2405:07BE
		return NULL;
	}
	//^2405:05E8
	Bit16u bp0c = _4976_0106 + _4976_010e;
	Bit16u bp0e = _4976_0108 + _4976_0110;
	//^2405:05FC
	Bit16u bp0a = ALLOC_TEMP_CACHE_INDEX();
	//^2405:0604
    Bit8u *bp04 = ALLOC_NEW_PICT(bp0a, bp0c, bp0e, 8);
	//^2405:061D
	ObjectID di = glbChampionSquad[player].Possess(possessionIndex);
	//^2405:0634
	Bit8u bp05;
	Bit8u bp06;
	Bit8u bp07;
	Bit16u bp12;
	if (di == OBJECT_NULL) {
		//^2405:0639
		bp05 = 1;
		bp06 = 2;
		//^2405:0641
		bp07 = (possessionIndex == 1) ? 8 : 7;
		bp12 = 1;
	}
	else {
		//^2405:0657
		bp05 = QUERY_CLS1_FROM_RECORD(di);
		//^2405:0661
		bp06 = QUERY_CLS2_FROM_RECORD(di);
		//^2405:066B
		bp07 = _2405_014a(di, -1, 0);
		//^2405:067A
		bp12 = 0;
	}
	//^2405:067F
	ExtendedPicture bp014c;
	QUERY_GDAT_SUMMARY_IMAGE(&bp014c, bp05, bp06, bp07);
	//^2405:0699
	QUERY_PICST_IT(&bp014c);
	//^2405:06A6
	Bit8u bp0f = glbPaletteT16[COLOR_RED];	// SPX: RED here is used as transparent for hand icon ..
	//^2405:06B1
	FILL_ENTIRE_PICT(bp04 = _0b36_00c3(bp0a, ref), bp0f);
	//^2405:06D5
	if (bp12 != 0) {
		//^2405:06DB
		//^2405:0792
		DRAW_DIALOGUE_PICT(
			QUERY_PICT_BITS(&bp014c),
			bp04,
			ALLOC_TEMP_ORIGIN_RECT(bp014c.width, bp014c.height),
			0,
			0,
			12,
			bp014c.b58
			);
	}
	else {
		//^2405:06F2
		Bit8u bp015c[16];
		for (Bit16u si = 0; si < 16; si++) {
			//^2405:06F6
			bp015c[si] = glbPaletteT16[COLOR_BLACK];
			//^2405:0701
		}
		//^2405:0707
		bp015c[12] = bp0f;
		//^2405:070E
		DRAW_DIALOGUE_PICT(
			QUERY_PICT_BITS(&bp014c),
			bp04,
			ALLOC_TEMP_RECT(_4976_010e, _4976_0110, _4976_0106, _4976_0108),
			0,
			0,
			-1,
			bp015c
			);
		//^2405:0751
		TRANSLATE_PALETTE(bp014c.b58, 1, 0, 1, 16);
		//^2405:0767
		bp04 = _0b36_00c3(bp0a, ref);
		//^2405:077E
		//^2405:0792
		DRAW_DIALOGUE_PICT(
			QUERY_PICT_BITS(&bp014c),
			bp04,
			ALLOC_TEMP_ORIGIN_RECT(_4976_0106, _4976_0108),
			0,
			0,
			12,
			bp014c.b58
			);
	}
	//^2405:07B8
	return bp04;
}

//^44C8:08AE
void SkWinCore::FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP(Bit16u offSrc, Bit16u offDst, Bit16u width, __int16 colorkey)
{
	// TODO: A
	//^44C8:08AE
	ENTER(0);
	//^44C8:08B3
	const Bit8u *bx = glbBlitPalette16;
	Bit8u *di = _4976_5e6a + offDst;
	Bit8u dh = Bit8u(colorkey);
	Bit16u cx = width;
	bool carry = (offSrc & 1) ? true : false;
	offSrc >>= 1;
	Bit8u *si = _4976_5e64 + offSrc;
	//^44C8:08D4
	if (carry) {
		//^44C8:08D6
		Bit8u al = *si; si++;
		al &= 0x0f;
		if (al == dh) {
			di++;
		}
		else {
			*di = bx[al]; di++;
		}
		//^44C8:08E3
		if (--cx == 0)
			//^44C8:08E4
            return;
	}

	{
		//^44C8:08E6
		bool carry = (cx & 1) ? true : false;
		cx >>= 1;
		//^44C8:08E9
		if (cx != 0) {
			//^44C8:08EB
			do {
				Bit8u al = *si; si++;
				Bit8u ah = al & 0x0f;
				al >>= 4;
				if (al != dh) {
					//^44C8:08F8
					if (ah != dh) {
						//^44C8:08FC
						*di = bx[al]; di++;
						*di = bx[ah]; di++;
						//^44C8:0904
						continue;
					}
					else {
						//^44C8:091D
						*di = bx[al]; di++;
						di++;
						//^44C8:0921
						continue;
					}
				}
				//^44C8:0908
				else if (ah != dh) {
					//^44C8:090C
					di++;
					*di = bx[ah]; di++;
					//^44C8:0912
					continue;
				}
				else {
					//^44C8:0916
					di++;
					di++;
					//^44C8:0918
					continue;
				}
				//^44C8:0918
			} while (--cx != 0);
		}
		//^44C8:0923
		if (carry) {
			//^44C8:0926
			Bit8u al = *si; si++;
			al >>= 4;
			if (al != dh) {
				*di = bx[al]; di++;
			}
		}
	}
	//^44C8:0931
	return;
}

//^44C8:1ACA
void SkWinCore::_44c8_1aca(Bit8u *buff, SRECT *rc, Bit16u xx, Bit16u yy)
{
	//^44C8:1ACA
	ENTER(332);
	//^44C8:1AD0
	if (rc != NULL) {
		//^44C8:1ADB
		Bit16u bp08 = xx ^ 15;
		//^44C8:1AE4
		Bit8u bp014c[320];
		_4976_5e64 = bp014c;
		_4976_5e6a = buff;
		//^44C8:1AFC
		Bit16u bp04 = rc->cx;
		Bit16u bp02 = rc->cy;
		//^44C8:1B0D
		if (bp04 > 0 && bp02 > 0) {
			//^44C8:1B1F
			Bit16u bp06 = (bp04 +1) >> 1;
			//^44C8:1B28
			Bit8u bp0b = Bit8u(xx) << 4 | Bit8u(bp08);
			//^44C8:1B34
			Bit16u si;
			for (si = 0; si < bp06; si++) {
				//^44C8:1B38
				bp014c[si] = bp0b;
				//^44C8:1B3F
				bp014c[si+160] = bp0b ^ 0xff;
				//^44C8:1B45
			}
			//^44C8:1B4B
			Bit16u di = rc->y * yy +rc->x;
			//^44C8:1B5A
			Bit16u bp0a = ((di / yy) ^ di) & 1;
			//^44C8:1B67
			for (si = 0; si < bp02; si++) {
				//^44C8:1B6B
				_4976_5e64 = &bp014c[bp0a * 160];
				//^44C8:1B80
				bp0a ^= 1;
				//^44C8:1B84
				FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP(0, di, bp04, bp08);
				//^44C8:1B95
				di += yy;
				//^44C8:1B98
			}
		}
	}
	//^44C8:1B9E
	return;
}

//^0B36:105B
// SPX: _0b36_105b renamed DRAW_GRAY_OVERLAY
void SkWinCore::DRAW_GRAY_OVERLAY(sk3f6c *ref, SRECT *rc, Bit16u xx)
{
	//^0B36:105B
	ENTER(8);
	//^0B36:105F
	if (rc != NULL) {
		//^0B36:1067
		SRECT bp08;
		_44c8_1aca(
			reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w0)),
			OFFSET_RECT(ref, rc, &bp08),
			xx,
			ref->rc2.cx
			);
		//^0B36:10A1
		_0b36_0d67(ref, rc);
	}
	//^0B36:10B4
	return;
}

//^29EE:026C
// SPX: _29ee_026c renamed DRAW_HAND_ACTION_ICONS
void SkWinCore::DRAW_HAND_ACTION_ICONS(Bit16u playerIndex, Bit16u possessionIndex, Bit16u leftOrRight)
{
	//^29EE:026C
	ENTER(48);
	//^29EE:0271
	_29ee_00a3(0);
	//^29EE:0278
	Champion *champion = &glbChampionSquad[playerIndex];
	//^29EE:0289
	Bit16u si = (possessionIndex == 1) ? 0x46 : 0x4a;
	//^29EE:0297
	si += (champion->playerPos() +4 - glbPlayerDir) & 3;
	//^29EE:02AC
	SRECT bp10;
	QUERY_EXPANDED_RECT(si, &bp10);
	//^29EE:02BA
	if (champion->curHP() == 0) {
		//^29EE:02C4
		SRECT bp10;
		FILL_RECT_SUMMARY(&_4976_3f6c, &bp10, glbPaletteT16[COLOR_BLACK]);
	}
	else {
		//^29EE:02DF
		// SPX: Draw background item square
		DRAW_ICON_PICT_ENTRY(0x01, 0x04, (Bit8u(possessionIndex) << 1) + Bit8u(leftOrRight) +2, &_4976_3f6c, si, -1);
		//^29EE:02FD
		Picture bp30;
		Bit8u *bp08 = DRAW_ITEM_ON_WOOD_PANEL(playerIndex, possessionIndex, &bp30);
		//^29EE:0316
		if (bp08 != NULL) {
			//^29EE:031A
			SRECT bp18;
			// SPX: draw item (weapon, shield, flask, etc ..) in hand
			DRAW_ICON_PICT_BUFF(
				bp08,
				&_4976_3f6c,
				CALC_CENTERED_RECT_IN_RECT(&bp18, &bp10, READ_UI16(bp08,-4), READ_UI16(bp08,-2)),
				0,
				0,
				glbPaletteT16[COLOR_RED],
				0,
				NULL
				);
			//^29EE:0360
			FREE_PICT_MEMENT(&bp30);
		}
		//^29EE:036C
		if (champion->handCooldown[possessionIndex] != 0 || glbIsPlayerSleeping != 0) {
			//^29EE:0380
			DRAW_GRAY_OVERLAY(&_4976_3f6c, &bp10, 0);
		}
	}
	//^29EE:0393
	return;
}

//^29EE:058D
// SPX: _29ee_058d renamed DRAW_SQUAD_SPELL_AND_LEADER_ICON
void SkWinCore::DRAW_SQUAD_SPELL_AND_LEADER_ICON(Bit16u player, Bit16u yy)
{
	//^29EE:058D
    ENTER(324);
	//^29EE:0593
	_29ee_00a3(0);
	//^29EE:059A
	Bit16u si = (glbChampionSquad[player].playerPos() +4 - glbPlayerDir) & 3;
	//^29EE:05B6
	SRECT bp0a;
	FILL_RECT_SUMMARY(
		&_4976_3f6c,
		QUERY_EXPANDED_RECT(si + 0x4f, &bp0a),
		glbPaletteT16[COLOR_BLACK]
		);
	//^29EE:05E1
	if (glbChampionSquad[player].curHP() != 0) {
		//^29EE:05F5
		Bit16u di = (si == 1 || si == 2) ? 1 : 0;
		//^29EE:0606
		Bit8u bp01;
		Bit8u bp02;
		if (si <= 1) {
			//^29EE:060B
			bp01 = 10;
			bp02 = 6;
		}
		else {
			//^29EE:0615
			bp01 = 12;
			bp02 = 8;
		}
		//^29EE:061D
		if (player == glbChampionLeader) {
			//^29EE:0626
			bp01++;
		}
		//^29EE:0629
		if (yy != 0) {
			//^29EE:062F
			bp02++;
		}
		//^29EE:0632
		ExtendedPicture bp0144;
		QUERY_GDAT_SUMMARY_IMAGE(&bp0144, 1, 4, bp02);
		//^29EE:0648
		bp0144.mirrorFlip = di;
		//^29EE:064C
		_0b36_11c0(
			QUERY_PICST_IT(&bp0144),
			&_4976_3f6c,
			si + 0x57,
			4
			);
		//^29EE:066F
		if (glbIsPlayerSleeping != 0 || glbChampionSquad[player].herob44 != 0) {
			//^29EE:0687
			bp0144.rc36.x += _4976_3f6c.rc2.x;
			bp0144.rc36.y += _4976_3f6c.rc2.y;
			//^29EE:0695
			DRAW_GRAY_OVERLAY(&_4976_3f6c, &bp0144.rc36, 0);
		}
		//^29EE:06A9
		QUERY_GDAT_SUMMARY_IMAGE(&bp0144, 0x01, 0x04, bp01);
		//^29EE:06BF
		bp0144.mirrorFlip = di;
		//^29EE:06C3
		_0b36_11c0(
			QUERY_PICST_IT(&bp0144),
			&_4976_3f6c,
			si + 0x53,
			4
			);
		//^29EE:06E6
		if (glbIsPlayerSleeping != 0) {
			//^29EE:06ED
			bp0144.rc36.x = _4976_3f6c.rc2.x;
			bp0144.rc36.y = _4976_3f6c.rc2.y;
			//^29EE:06FB
			DRAW_GRAY_OVERLAY(&_4976_3f6c, &bp0144.rc36, 0);
		}
	}
	//^29EE:070F
	return;
}

//^24A5:0990
// SPX: _24a5_0990 renamed __CHECK_ROOM_FOR_CONTAINER
void SkWinCore::__CHECK_ROOM_FOR_CONTAINER(ObjectID rl, Container *ref)
{
	//^24A5:0990
	ENTER(0);
	//^24A5:0995
	if (rl != OBJECT_NULL && rl != glbObjectForContainer) {
		//^24A5:09A4
		X16 di = 0;
		X16 si = 0;
		while (ref->GetContainedObject() != OBJECT_END_MARKER) {
			//^24A5:09AC
			if (++di > 8)
				break;
			//^24A5:09B4
			glbCurrentContainerItems[si++] = ref->GetContainedObject();
			CUT_RECORD_FROM(ref->GetContainedObject(), &ref->w2, -1, 0);
			//^24A5:09E0
		};
		//^24A5:09EA
		while (si < 8) {
			//^24A5:09EC
			glbCurrentContainerItems[si++] = OBJECT_NULL;
			//^24A5:09F7
		}
		//^24A5:09FC
		glbObjectForContainer = rl;
	}
	//^24A5:0A02
	return;
}

//^29EE:2048
void SkWinCore::DRAW_MONEYBOX(ObjectID rl)
{
	//^29EE:2048
	ENTER(56);
	//^29EE:204E
	DRAW_ICON_PICT_ENTRY(0x14, QUERY_CLS2_FROM_RECORD(rl), 0x10, &_4976_3f6c, 0x5c, -1);
	i16 bp38[MONEY_ITEM_MAX];
	COUNT_BY_COIN_TYPES(rl, bp38);
	i16 si;
	for (si = 0; si < MONEY_ITEM_MAX; si++) {
		//^29EE:2081
		i16 bp0c = GET_ITEM_ORDER_IN_CONTAINER(rl, si);
		if (bp0c < 0)
			continue;
		i16 di = bp38[bp0c];
		if (di <= 0)
			continue;
		//^29EE:20AC
		U16 bp10 = glbMoneyItemsIDTable[bp0c];
		X8 bp09;
		X8 bp0a;
		U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(
			bp09 = QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(bp10),
			bp0a = GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(bp10),
			0x18
			);
		U8 *bp08 = QUERY_GDAT_IMAGE_LOCALPAL(bp09, bp0a, 0x18);
		i16 bp14 = 0;
		i16 bp12 = 0;
		SRECT bp1c;
		QUERY_BLIT_RECT(bp04, &bp1c, si +0xdd, &bp12, &bp14, -1);
		SRECT bp24;
		bp24.cx = bp1c.cx;
		bp24.cy = bp1c.cy;
		X16 bp0e = (si << 3) +max_value(0, di -32);
		di = min_value(32, di);
		do {
			//^29EE:2158
			bp0e = (bp0e +1) & 31;
			bp24.x = bp1c.x + _4976_0154[bp0e][0];
			bp24.y = bp1c.y + _4976_0154[bp0e][1];
			UNION_RECT(&bp24, &_4976_3f6c.rc2, &bp12, &bp14);
			DRAW_ICON_PICT_BUFF(bp04, &_4976_3f6c, &bp24, bp12, bp14, 12, 0, bp08);
			//^29EE:21C8
		} while (--di > 0);
		//^29EE:21CB
	}
	//^29EE:21D4
	return;
}

//^29EE:21D8
// SPX: _29ee_21d8 renamed DRAW_CONTAINER_PANEL
void SkWinCore::DRAW_CONTAINER_PANEL(ObjectID rl, Bit16u xx)
{
// xx = 1 : right panel / xx = 0 : inventory
	//^29EE:21D8
	ENTER(24);
	//^29EE:21DE
	X8 bp05 = QUERY_CLS2_FROM_RECORD(rl);
	if (xx != 0) {
		//^29EE:21F0
		DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_CONTAINERS, bp05, GDAT_CONTAINER_STAT_10, &_4976_3f6c, 0x5c, -1);
		DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_CONTAINERS, bp05, GDAT_CONTAINER_STAT_12, &_4976_3f6c, 0xe3, 10);
	}
	SRECT bp18;
	if (xx == 0) {
		//^29EE:2224
		QUERY_EXPANDED_RECT(0x5c, &bp18);
	}
	//^29EE:2233
	X16 si;
	for (si = 0; si < CONTAINER_MAX_SLOT; si++) {	// < 8
		//^29EE:2238
		ObjectID di = glbCurrentContainerItems[si];
		if (di != OBJECT_NULL) {
			X16 bp08 = si +0xe5;
			if (xx == 0) {
				//^29EE:2258
				SRECT bp10;
				QUERY_EXPANDED_RECT(bp08, &bp10);
				U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(GDAT_CATEGORY_CONTAINERS, bp05, GDAT_CONTAINER_STAT_10);	// 0x14	.. 0x10
				DRAW_ICON_PICT_BUFF(
					bp04, &_4976_3f6c, &bp10, bp10.x -bp18.x, bp10.y -bp18.y,
					-1, 0, QUERY_GDAT_IMAGE_LOCALPAL(GDAT_CATEGORY_CONTAINERS, bp05, GDAT_CONTAINER_STAT_10)	// 0x14	.. 0x10
					);
			}
			//^29EE:22B9
			DRAW_ICON_PICT_ENTRY(
				QUERY_CLS1_FROM_RECORD(di),
				QUERY_CLS2_FROM_RECORD(di),
				_2405_014a(di, si +0x1e, 1),
				&_4976_3f6c, bp08, 12
				);
		}
		//^29EE:22EC
	}
	//^29EE:22F5
	return;
}

//^29EE:0396
// SPX: _29ee_0396 renamed DRAW_SQUAD_POS_INTERFACE
void SkWinCore::DRAW_SQUAD_POS_INTERFACE()
{
	//^29EE:0396
	ENTER(350);
	//^29EE:039C
	_29ee_00a3(0);
	//^29EE:03A3
	DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_GRAPHICSSET, glbSquadInterfaceMapGfxSet, GDAT_GFXSET_SQUAD_4X, &_4976_3f6c, 47, -1);	// gfx = 0xF5
	//^29EE:03BC
	Bit8u *bp04 = ALLOC_PICT_BUFF(_4976_0118, _4976_011a, afDefault, 4);
	//^29EE:03D6
	SRECT bp14;
	for (Bit16u si = 0; si < glbChampionsCount; si++) {
		//^29EE:03DB
		Bit16u bp06 = (glbChampionSquad[si].playerPos() +4 - glbPlayerDir) & 3;
		//^29EE:03F7
		if (glbChampionSquad[si].curHP() == 0 || bp06 +1 == _4976_5dbc)
			//^29EE:0414
			continue;
		//^29EE:0417
		__int16 bp0c = 0;
		__int16 bp0a = 0;
		//^29EE:041F
		Bit16u bp08;
		if (QUERY_BLIT_RECT(bp04, &bp14, bp08 = bp06 +53, &bp0a, &bp0c, -1) == NULL)
			//^29EE:044C
			continue;
		//^29EE:044F
		if (glbGlobalSpellEffects.AuraOfSpeed != 0) {
			//^29EE:0456
			__int16 di = RAND02();
			//^29EE:045D
			if (di != 0) {
				//^29EE:0461
				bp14.y += di -2;
				//^29EE:0467
				di = RAND02();
				//^29EE:046E
				if (di != 0) {
					//^29EE:0472
					bp14.x += di -2;
				}
			}
		}
		//^29EE:0478
		Bit8u bp015e[16];
		DRAW_ICON_PICT_BUFF(
			QUERY_GDAT_SQUAD_ICON(bp04, Bit8u(si), bp015e),
            &_4976_3f6c,
			&bp14,
			bp0a,
			bp0c,
			12,
			0,
			bp015e
			);
		//^29EE:04B0
		if (glbChampionSquad[si].enchantmentPower == 0)
			//^29EE:04C0
			continue;
		//^29EE:04C3
		ExtendedPicture bp014e;
		// SPX: Check in INTERFACE (0x01) 07 => Party protection animations
		QUERY_PICST_IT(QUERY_GDAT_SUMMARY_IMAGE(&bp014e, GDAT_CATEGORY_INTERFACE_GENERAL, 0x07, glbChampionSquad[si].enchantmentAura));
		//^29EE:04EC
		bp014e.w4 |= 0x10;
		bp014e.width >>= 2;
		//^29EE:04F7
		bp014e.w14 = bp014e.width * ((glbChampionSquad[si].playerDir() +4 - glbPlayerDir) & 3);
		//^29EE:051E
		bp014e.height >>= 2;
		//^29EE:0523
		bp014e.w16 = bp014e.height * (__int16(glbGameTick) & 3);
		//^29EE:0535
		_0b36_11c0(&bp014e, &_4976_3f6c, bp08, 12);
		//^29EE:054C
	}
	//^29EE:0556
	FREE_PICT_BUFF(bp04);
	//^29EE:0563
	if (glbIsPlayerSleeping != 0) {
		//^29EE:056A
		DRAW_GRAY_OVERLAY(
			&_4976_3f6c, 
			QUERY_EXPANDED_RECT(47, &bp14),
			0
			);
	}
	//^29EE:0589
	return;
}

//^3929:06E1
void SkWinCore::DRAW_STRONG_TEXT(Bit8u *buff, Bit16u ww, Bit16u cx, Bit16u xx, Bit16u yy, Bit16u clr1, Bit16u fill, Bit8u *str)
{
	// draw bold with shadow single-byte-character-set text such as,
	// a) name "TORHAM"
	// b) HP "651/651", MP "446/446", stamina "228/228", weight "25.0/62.0 KG"

	//^3929:06E1
	ENTER(4);
	//^3929:06E7
	Bit16u di = xx;
	Bit16u si = yy;
	//^3929:06ED
	__int16 bp02;
	__int16 bp04;
	if (QUERY_STR_METRICS(str, &bp02, &bp04) != 0) {
		//^3929:070B
		if ((fill & 0x4000) == 0) {
			//^3929:0712
			FIRE_FILL_RECT_ANY(
				buff,
				ALLOC_TEMP_RECT(di -1, si -bp04, bp02 +2, bp04 +2),
				fill,
				cx,
				8
				);
		}
		//^3929:0748
		DRAW_STRING(buff, ww, cx, di   , si +1, glbPaletteT16[COLOR_BLACK], glbPaletteT16[COLOR_WHITE] | 0x4000, str, 8);
		//^3929:077D
		DRAW_STRING(buff, ww, cx, di +1, si +1, glbPaletteT16[COLOR_BLACK], glbPaletteT16[COLOR_WHITE] | 0x4000, str, 8);
		//^3929:07B5
		DRAW_STRING(buff, ww, cx, di,    si,    clr1,          fill           | 0x4000, str, 8);
	}
	//^3929:07DD
	return;
}

//^0B36:13B1
void SkWinCore::DRAW_NAME_STR(sk3f6c *ref, Bit16u rectno, Bit16u clr1, Bit16u fill, Bit8u *str)
{
	// draw text:
	// a) player's name "TORHAM", "SAROS" at upper-panel and command bar
	// b) command name "a", "a", "f", "<02>!{UM} {ZO} {BRO} {ROS}"

	//^0B36:13B1
	ENTER(12);
	//^0B36:13B6
	__int16 bp02;
	__int16 bp04;
	if (QUERY_STR_METRICS(str, &bp02, &bp04) != 0) {
		//^0B36:13D1
		SRECT bp0c;
		if (QUERY_BLIT_RECT(NULL, &bp0c, rectno, &bp02, &bp04, -1) != NULL) {
			//^0B36:13F5
			DRAW_STRONG_TEXT(
				reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w0)),
				ref->w0,
				ref->rc2.cx,
				bp0c.x             -ref->rc2.x,
				bp0c.y +bp0c.cy -1 -ref->rc2.y,
				clr1,
				fill,
				str
				);
            //^0B36:1432
			_0b36_0d67(ref, &bp0c);
		}
	}
	//^0B36:1444
	return;
}

//^29EE:0713
void SkWinCore::DRAW_PLAYER_NAME_AT_CMDSLOT()
{
	//^29EE:0713
	ENTER(0);
	//^29EE:0716
	DRAW_ICON_PICT_ENTRY(0x01, 0x04, 0x14, &_4976_3f6c, 60, -1);
	//^29EE:072C
	DRAW_ICON_PICT_ENTRY(0x01, 0x04, 0x0e, &_4976_3f6c, 59, -1);
	//^29EE:0742
	DRAW_NAME_STR(
		&_4976_3f6c, 
		61, 
		(glbChampionIndex -1 == glbChampionLeader) ? 9 : 15, 
		glbPaletteT16[COLOR_DARKEST_GRAY] | 0x4000, 
		glbChampionTable[glbChampionIndex].firstName
		);
	// SPX: This (9 : 15) controls the color of the char name in the cast spell panel.
	// However, 9 is dark brown for leader, is that correct?
	//^29EE:0789
	return;
}

//^0CAF:0008
i16 SkWinCore::SK_STRLEN(const Bit8u *ref)
{
	//^0CAF:0008
	ENTER(4);
	//^0CAF:000C
	const Bit8u *bp04 = ref;
	//^0CAF:0018
	while (*(ref++) != 0);
	//^0CAF:0024
	return Bit16u(ref -bp04 -1);
}

//^29EE:093E
// SPX: _29ee_093e renamed DRAW_SPELL_TO_BE_CAST
void SkWinCore::DRAW_SPELL_TO_BE_CAST(Bit16u xx)
{
	//^29EE:093E
	ENTER(8);
	//^29EE:0944
	_29ee_00a3(0);
	//^29EE:094B
	// SPX: Cyan rectangles to be put over spell line
	if (xx != 0) {
		//^29EE:0951
		DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_INTERFACE_GENERAL, 0x05, 0x09, &_4976_3f6c, 252, -1);
	}
	//^29EE:0968
	Champion *champion = &glbChampionTable[glbChampionIndex];
	//^29EE:0979
	Bit8u bp08[2];
    bp08[1] = 0;
	//^29EE:097D
	Bit16u bp06 = SK_STRLEN(champion->GetRunes());
	//^29EE:0991
	Bit16u di = 261;
	//^29EE:0994
	for (Bit16u si = 0; si < bp06; si++) {
		//^29EE:0998
		bp08[0] = champion->GetRunes()[si];
		//^29EE:09A2
		// SPX: Spell runes color
		DRAW_SIMPLE_STR(&_4976_3f6c, di++, glbPaletteT16[COLOR_BLACK], glbPaletteT16[COLOR_LIGHTER_GRAY] | 0x4000, bp08);
		//^29EE:09CB
	}
	//^29EE:09D1
	return;
}

//^29EE:09D5
// SPX: _29ee_09d5 renamed DRAW_SPELL_PANEL
void SkWinCore::DRAW_SPELL_PANEL()
{
	//^29EE:09D5
	ENTER(10);
	//^29EE:09DA
	Champion *champion = &glbChampionTable[glbChampionIndex];
	//^29EE:09EB
	Bit16u bp06 = champion->runesCount;
	//^29EE:09F7
	// SPX: rune class interface
	DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_INTERFACE_GENERAL, 0x05, bp06 +1, &_4976_3f6c, 92, -1);
	//^29EE:0A11
	if (bp06 < 4) {
		//^29EE:0A17
		Bit8u bp0a[2];
		bp0a[1] = 0;
		//^29EE:0A1B
		Bit8u bp07 = Bit8u(bp06 * 6) + 0x60;
		Bit16u si = 255;
		//^29EE:0A2B
		for (bp06 = 0; bp06 < 6; bp06++) {
			//^29EE:0A32
			bp0a[0] = bp07++;
			//^29EE:0A3B
			DRAW_SIMPLE_STR(
				&_4976_3f6c, 
				si++, 
				glbPaletteT16[COLOR_BLACK],
				glbPaletteT16[COLOR_LIGHTER_GRAY] | 0x4000,
				bp0a
				);
			//^29EE:0A64
		}
	}
	//^29EE:0A6D
	DRAW_SPELL_TO_BE_CAST(0);
	//^29EE:0A74
	DRAW_PLAYER_ATTACK_DIR();
	//^29EE:0A78
	return;
}

//^0CAF:00D2
Bit8u *SkWinCore::SK_STRSTR(const Bit8u *xx, const Bit8u *yy)
{
	//^0CAF:00D2
	ENTER(10);
	//^0CAF:00D6
	Bit8u cl = yy[0];
	//^0CAF:00DE
	if (cl != 0) {
		//^0CAF:00E2
		Bit8u bp09;
		for (; (bp09 = xx[0]) != 0; xx++) {
			//^0CAF:00E4
			if (bp09 == cl) {
				//^0CAF:00EB
				const Bit8u *bp04 = xx +1;
				const Bit8u *bp08 = yy +1;
				//^0CAF:0105
				while (bp08[0] != 0 && bp04[0] == bp08[0]) {
					//^0CAF:0107
					bp04++;
					bp08++;
					//^0CAF:010D
				}
				//^0CAF:0124
				if (bp08[0] == 0) {
					//^0CAF:012F
					return const_cast<Bit8u *>(xx);
				}
			}
			//^0CAF:0137
		}
	}
	//^0CAF:0147
	return NULL;
}

//^2759:006D
Bit16u SkWinCore::QUERY_CMDSTR_TEXT(const Bit8u *cmdStr, const Bit8u *name)
{
	// returns value of name in cmdstr.
	// for example, returns 0 if you query "WH" for ":CM4SK4BZ2TR3TA-2EX5PB38DM40".

	// cmdStr: e.g. ":CM4SK4BZ2TR3TA-2EX5PB38DM40".
	// name: e.g. "WH"

	// Note: BETA uses another format: "FREEZE:CM=11 ST=10 SK=14 BZ=20 TR=3 TA=-10 EX=22"


	//^2759:006D
	ENTER(2);
	//^2759:0073
	__int16 si = 0;
	while ((cmdStr = SK_STRSTR(cmdStr, name)) != NULL) {
		//^2759:0077
		cmdStr += SK_STRLEN(name);
		//^2759:0087
		if (cmdStr[0] == '=') {
			//^2759:0090
			cmdStr++;
		}
		//^2759:0093
		Bit16u di = 0;
		//^2759:0095
		if (cmdStr[0] == '-') {
			//^2759:009E
			cmdStr++;
			di = 1;
		}

		Bit8u bp01;
		while ((bp01 = cmdStr[0]) >= '0' && bp01 <= '9') {
			//^2759:00A6
			si = bp01 +(si * 10) - '0';
			cmdStr++;
			//^2759:00BD
		}
		//^2759:00D0
		if (di != 0) {
			//^2759:00D4
			si = -si;
		}
		//^2759:00DA
	}
	//^2759:00FB
	return si;
}

//^2759:0101
Bit16u SkWinCore::QUERY_CMDSTR_ENTRY(Bit8u cls1, Bit8u cls2, Bit8u cls4, Bit16u cmdNum)
{
	//^2759:0101
	ENTER(132);
	//^2759:0105
	Bit8u bp0084[128];
	Bit8u *bp04;
	if (cmdNum >= 18 || *(bp04 = QUERY_GDAT_TEXT(cls1, cls2, cls4, bp0084)) == 0) {
		//^2759:0135
		return 0;
	}
	else {
		//^2759:0139
		return QUERY_CMDSTR_TEXT(bp04, reinterpret_cast<const Bit8u *>(ItemCommandsTable[cmdNum]));
	}
}

//^0CEE:2FBD
Missile *SkWinCore::GET_MISSILE_REF_OF_MINION(ObjectID rlCreature, ObjectID rlContainer)
{
	// returns a invisible missile record. it is assoc with minion map's minion.
	// the missile record has (MAP,X,Y) position of recent open door.

	//^0CEE:2FBD
	ENTER(4);
	//^0CEE:2FC3
	ObjectID di = rlCreature;
	//^0CEE:2FC6
	if (di == OBJECT_NULL || di == OBJECT_END_MARKER)
		//^0CEE:2FD0
		//^0CEE:302D
		return NULL;
	//^0CEE:2FD2
	Creature *bp04 = GET_ADDRESS_OF_RECORDX4(di);
	//^0CEE:2FDE
	if (bp04->w0 == OBJECT_NULL)
		//^0CEE:2FE5
		//^0CEE:302D
		return NULL;
	//^0CEE:2FE7
	ObjectID si = bp04->GetPossessionObject();
	//^0CEE:2FEB
	while (si != OBJECT_END_MARKER) {
		//^0CEE:2FED
		if (si.DBType() == dbMissile) {
			//^0CEE:2FFA
			Missile *bp04 = GET_ADDRESS_OF_RECORDE(si);
			//^0CEE:3006
			if (rlContainer == OBJECT_NULL || bp04->GetMissileObject() == rlContainer) {
				//^0CEE:3018
				return bp04;
			}
		}
		//^0CEE:3020
		si = GET_NEXT_RECORD_LINK(si);
		//^0CEE:3028
	}
	//^0CEE:302D
	return NULL;
}

//^2759:01FE
Bit16u SkWinCore::_2759_01fe(Bit16u player, ObjectID recordLink, Bit16u cmdNum)
{
	//^2759:01FE
    ENTER(8);
	//^2759:0204
	ObjectID di = recordLink;
	Bit16u si = cmdNum;
	//^2759:020A
	if (di == OBJECT_NULL) {
		//^2759:020F
		return 0;
	}
	//^2759:0214
	if (di.DBType() == dbContainer) {
		//^2759:0224
		Container *bp04 = GET_ADDRESS_OF_RECORD9(di);
		//^2759:0231
		if (bp04->ContainerType() == 1) {
			//^2759:0245
			Bit16u bp08 = bp04->b5_5_7();
			//^2759:0252
			if (false
				|| bp08 == 1 // 1 - SCOUT MAP?
				|| bp08 == 2 // 2 - MINION MAP?
			) {
				//^2759:025E
				if (GET_MISSILE_REF_OF_MINION(bp04->GetContainedObject(), di) != NULL) {
					//^2759:0271
					if (si == CmKillMinion)
						//^2759:0274
						//^2759:02CF
						return 1;
					//^2759:0276
					if (bp08 != 2)
						//^2759:027A
						//^2759:02CC
						//^2759:020F
						return 0;
					//^2759:027C
					Bit8u bp05 = GET_ADDRESS_OF_RECORD4(bp04->GetContainedObject())->CreatureType();
					//^2759:0294
					if (bp05 == 51) { // 51 - FETCH MINION
						//^2759:029A
						if (si != CmCallCarry)
							//^2759:029D
							//^2759:02CC
							//^2759:020F
							return 0;
						//^2759:029F
						//^2759:02CF
						return 1;
					}
					//^2759:02A1
					if (bp05 != 50) // 50 - CARRY MINION
						//^2759:02A5
						//^2759:02CC
						//^2759:020F
						return 0;
					//^2759:02A7
					if (si != CmCallFetch)
						//^2759:02AA
						//^2759:02CC
						//^2759:020F
						return 0;
					//^2759:02AC
					//^2759:02CF
					return 1;
				}
				//^2759:02AE
				if (si != CmCallScout && si != CmMark && (bp04->w6 == 0xffff || (si != CmCallCarry && si != CmCallFetch))) {
					//^2759:02CC
					//^2759:020F
					return 0;
				}
			}
			else {
				//^2759:02CC
				//^2759:020F
				return 0;
			}
		}
	}
	//^2759:02CF
	return 1;
}

//^2759:04C0
// SPX: _2759_04c0 renamed FIND_POUCH_OR_SCABBARD_POSSESSION_POS
__int16 SkWinCore::FIND_POUCH_OR_SCABBARD_POSSESSION_POS(__int16 player, __int16 yy)	// yy = pouch or scabbard
{
	//^2759:04C0
	ENTER(0);
	//^2759:04C5
	__int16 di = player;
	//^2759:04C8
	if (yy == 1) {	// SCABBARD
		//^2759:04CE
		if (glbChampionSquad[di].Possess(INVENTORY_SCABBARD_1) != OBJECT_NULL) {	// Possess(12)
			//^2759:04DE
			return INVENTORY_SCABBARD_1;	// 12
		}
		//^2759:04E3
		//for (__int16 si = 7; si <= 9; si++) {
		for (__int16 si = INVENTORY_SCABBARD_2; si <= INVENTORY_SCABBARD_4; si++) {
			//^2759:04E8
			if (glbChampionSquad[di].Possess(si) != OBJECT_NULL) {
				//^2759:04FE
				return si;
			}
			//^2759:0502
		}
	}
	//^2759:050A
	else if (yy == 0) {	// POUCH
		//^2759:0510
		if (glbChampionSquad[di].Possess(INVENTORY_POUCH_1) != OBJECT_NULL) {	// Possess(11)
			//^2759:0520
			return INVENTORY_POUCH_1;	// 11
		}
		//^2759:0525
		if (glbChampionSquad[di].Possess(INVENTORY_POUCH_2) != OBJECT_NULL) {	// Possess(6)
			//^2759:0535
			return INVENTORY_POUCH_2;	// 6
		}
	}
	//^2759:053A
	return -1;
}

//^2C1D:0A47
// SPX: 1 seems to be the minimal skill returned, which correspond to none ...
// Hence, NEOPHYTE would return 2 and ARCHMASTER 16
Bit16u SkWinCore::QUERY_PLAYER_SKILL_LV(__int16 player, Bit16u skill, Bit16u yy)
{
	//^2C1D:0A47
	ENTER(8);
	//^2C1D:0A4D
	U16 di = skill;
	//^2C1D:0A50
	if (glbIsPlayerSleeping != 0) {
		//^2C1D:0A57
		return 1;
	}
	//^2C1D:0A5D
	Champion *champion = &glbChampionSquad[player]; //*bp04
	//^2C1D:0A6E
	U32 bp08 = champion->skills[di];	// Amount of current xp for that skill
	//^2C1D:0A86
	if (di > 3) {	// A subskill is requested
		//^2C1D:0A8B
		bp08 += (champion->skills[(di -4) >> 2]) * ((yy != 0) ? (__int16(champion->skillBonus[(di -4) >> 2]) +1) : 1);
		//^2C1D:0AD2
		bp08 >>= 1;
	}
	//^2C1D:0AE2
	Bit16u si = 1;	// Minimum level is 1 and equal to NONE.
	//^2C1D:0AE5
	while (bp08 >= SKILL_EXPERIENCE_BASE_LEVEL) {	// (bp08 >= 512)
		//^2C1D:0AE7
		bp08 >>= 1; si++;
		//^2C1D:0AF8
	}
	//^2C1D:0B07
	if (yy != 0) {
		//^2C1D:0B0D
		si = max_value(1, champion->skillBonus[di] + si);
	}
	//^2C1D:0B26
	return si;
}

//^2759:02D6
// SPX: Returns 0 if current item is not hand activable => then it will have no icon in action hand.
// SPX: _2759_02d6 renamed IS_ITEM_HAND_ACTIVABLE
Bit16u SkWinCore::IS_ITEM_HAND_ACTIVABLE(Bit16u player, ObjectID recordLink, __int16 yy)
{
	//^2759:02D6
	ENTER(14);
	//^2759:02DC
	ObjectID si = recordLink;
	Bit8u iCategory;	// bp01
	Bit8u iItemIndex;	// bp02
	if (recordLink == OBJECT_NULL) {
		//^2759:02E4
		iCategory = GDAT_CATEGORY_CHAMPIONS;	// 0x16
        iItemIndex = glbChampionSquad[player].HeroType();
	}
	else {
		//^2759:02F8
		if (IS_CONTAINER_MONEYBOX(si) != 0 || IS_CONTAINER_CHEST(si) != 0)
			//^2759:030E
			return 1;
		//^2759:0314
		iCategory = QUERY_CLS1_FROM_RECORD(si);
		iItemIndex = QUERY_CLS2_FROM_RECORD(si);
	}
	//^2759:0325
	//^2759:0328
	__int16 di = 0;
	// SPX: scans through champion basic commands : 8 = PUNCH, 9 = KICK, 10 = POUCH, 11 = SCABBARD
	for (Bit8u iEntryNumber = 8; iEntryNumber < 12; iEntryNumber++) {	// Bit8u bp03
		//^2759:0331
		if (di >= 3)
			//^2759:0336
			break;
		//^2759:0339
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(iCategory, iItemIndex, dtText, iEntryNumber) == 0)
			//^2759:0353
			continue;
		//^2759:0356
		Bit16u bp0a = QUERY_CMDSTR_ENTRY(iCategory, iItemIndex, iEntryNumber, CnCM);	// CnCM = Command
		//^2759:036E
		if (bp0a == 0)
			//^2759:0372
			continue;
		//^2759:0375
		Bit16u bp0e = QUERY_CMDSTR_ENTRY(iCategory, iItemIndex, iEntryNumber, CnWH);	// CnWH = where (pouch or scabbard?)
		//^2759:038D
		if (bp0e != 0 && bp0e -1 != yy)
			//^2759:0399
			continue;
		//^2759:039C
		if (si != OBJECT_NULL) {
			//^2759:03A1
			if (_2759_01fe(player, si, bp0a) == 0)
				//^2759:03B3
				continue;
			//^2759:03B6
			__int16 bp0c = QUERY_CMDSTR_ENTRY(iCategory, iItemIndex, iEntryNumber, CnNC);	// NC = Number of charges consumed by action
			if (SkCodeParam::bUnlimitedCharges == true)
				bp0c = 0;
			//^2759:03CE
			if (bp0c == 18) {	// ?
				//^2759:03D4
				if (ADD_ITEM_CHARGE(si, 0) == 0) {
					//^2759:03E0
					goto _0425;
				}
				//^2759:03E2
				continue;
			}
			//^2759:03E5
			if (bp0c == 16 || bp0c == 17)
				//^2759:03F1
				bp0c = 1;
			//^2759:03F6
			if (bp0c == 0)
				//^2759:03FA
				goto _0425;
			//^2759:03FC
			if (ADD_ITEM_CHARGE(si, 0) >= bp0c)
				//^2759:0409
				goto _0425;
			//^2759:040B
			continue;
		}
		//^2759:040E
		if (bp0a == CmPouch) {	// (bp0a == 17)
			//^2759:0414
			if (FIND_POUCH_OR_SCABBARD_POSSESSION_POS(player, yy) < 0)
				//^2759:0423
				continue;
		}
		//^2759:0425
_0425:
		Bit16u bp08 = QUERY_CMDSTR_ENTRY(iCategory, iItemIndex, iEntryNumber, CnSK);
		//^2759:043D
		Bit16u bp06 = QUERY_CMDSTR_ENTRY(iCategory, iItemIndex, iEntryNumber, CnLV);
		//^2759:0455
		if (QUERY_PLAYER_SKILL_LV(player, bp08, 1) >= bp06) {
			//^2759:046A
			glbItemSelected[di].category = iCategory;
			//^2759:0476
			glbItemSelected[di].index = iItemIndex;
			//^2759:0482
			glbItemSelected[di].entry = iEntryNumber;
			//^2759:048E
			di++;
		}
		//^2759:048F
	}
	//^2759:049B
	_4976_53a4 = di;
	glbChampionItemInUse = si;
	//^2759:04A3
	if (IS_CONTAINER_MAP(si) != 0)
		//^2759:04AE
		//^2759:030E
		return 1;
	//^2759:04B1
	if (di > 0)
		//^2759:04B5
		return 1;
	//^2759:04BA
	return 0;
}

//^1031:0BA4
void SkWinCore::FIRE_QUEUE_MOUSE_EVENT(Bit16u xx, Bit16u yy, Bit16u button)
{
	//^1031:0BA4
	ENTER(0);
	//^1031:0BA9
	Bit16u di = button;
	//^1031:0BAC
	if (_4976_19a7 == 0) {
		//^1031:0BB3
		_4976_19a7 = 1;
		//^1031:0BB9
	}
	else {
		//^1031:0BBB
		_4976_4e9a = 1;
		//^1031:0BC1
		_4976_4e4a = xx;
		_4976_4e4c = yy;
		_4976_4e6a = di;
		//^1031:0BD1
		return;
	}
	//^1031:0BD4
	__int16 cx = ((di == 4 && _4976_19af == 0) || di == 0x0040 || di == 0x0060) ? 9 : 7;
	//^1031:0BF2
	_4976_19af = 0;
	//^1031:0BF8
	__int16 si = _4976_19a5 +1;
	//^1031:0BFE
	if (si > 10) {
		//^1031:0C03
		si -= 11;
	}
	//^1031:0C06
	if (_4976_4e00 >= cx) {
		//^1031:0C0D
		if (di == 2) {
			//^1031:0C12
			_4976_19af = 1;
		}
	}
	else {
		//^1031:0C1A
		_4976_4e00++;
		//^1031:0C1E
		_4976_19a5 = si;
		//^1031:0C23
		_4976_4e02[si].MouseButton(di);
		//^1031:0C2E
		_4976_4e02[si].MouseX(xx);
		//^1031:0C3E
		_4976_4e02[si].MouseY(yy);
	}
	//^1031:0C4E
	_4976_19a7 = 0;
	//^1031:0C54
	return;
}

//^1031:0B7E
void SkWinCore::_1031_0b7e() //#DS=4976
{
	//^1031:0B7E
	ENTER(0);
	//^1031:0B81
	if (_4976_4e9a != 0) {
		//^1031:0B88
		_4976_4e9a = 0;
		//^1031:0B8E
		FIRE_QUEUE_MOUSE_EVENT(_4976_4e4a, _4976_4e4c, _4976_4e6a);
	}
	//^1031:0BA2
	return;
}

//^1031:098E
void SkWinCore::_1031_098e() //#DS=4976
{
	//^1031:098E
	ENTER(0);
	//^1031:0993
	while (_476d_05a9() != 0)
		//^1031:0995
		_476d_050e();
	//^1031:09A3
	_4976_19a7 = 1;
	//^1031:09A9
	__int16 di = _4976_4ea6;
	//^1031:09AD
	__int16 si = _4976_19a5 +1;
	//^1031:09B3
	if (si > 10) {
		//^1031:09B8
		si = 0;
	}
	//^1031:09BA
	if (si != di) {
		//^1031:09C1
		si = di;
		_4976_4e00 = 0;

		while (true) {
			//^1031:09C9
			if (false
				|| _4976_4e02[si].MouseButton() == 0x0040
				|| _4976_4e02[si].MouseButton() == 0x0060
				|| _4976_4e02[si].MouseButton() == 0x0004
			) {
				//^1031:09F9
				_4976_4e02[di] = _4976_4e02[si];
				//^1031:0A19
				di++;
				//^1031:0A1C
				if (di > 10)
					//^1031:0A21
					di = 0;
				//^1031:0A23
				_4976_4e00++;
			}
			//^1031:0A27
			if (si == _4976_19a5)
				//^1031:0A2B
				break;
			//^1031:0A2D
			si++;
			//^1031:0A2E
			if (si > 10)
				//^1031:0A35
				si = 0;
			//^1031:0A37
			continue;
		}
		//^1031:0A39
		if (di-- == 0) {
			//^1031:0A40
			di = 10;
		}
		//^1031:0A43
		_4976_19a5 = di;
	}
	//^1031:0A47
	_4976_4e62 = 0;
	_4976_4e60 = 0;
	_4976_4e5e = 0;
	_4976_4df8 = 0xffff;
	_4976_4e44 = 0xffff;
	_4976_4e66 = 0;
	_4976_4e68 = 0;
	glbUIEventCode = 0;
	_4976_4dfc = 0;
	_4976_19a7 = 0;
	//^1031:0A7F
	_1031_0b7e();
	//^1031:0A84
	return;
}

//^1031:023B
Bit8u *SkWinCore::_1031_023b(sk1891 *xx)
{
	//^1031:023B
	ENTER(0);
	//^1031:023E
    return &_4976_169c[xx->w2];
}	

//^443C:087C
void SkWinCore::_443c_087c()
{
	//^443C:087C
	ENTER(0);
	//^443C:087F
	LOCK_MOUSE_EVENT();
	//^443C:0888
	return;
}

//^443C:0889
void SkWinCore::_443c_0889()
{
	//^443C:0889
	ENTER(0);
	//^443C:088C
	UNLOCK_MOUSE_EVENT();
	//^443C:0895
	return;
}

//^443C:00A9
void SkWinCore::_443c_00a9(sk0cea *ref, i16 x, i16 cx, i16 y, i16 cy)
{
	//^443C:00A9
	ENTER(0);
	//^443C:00AC
	_4976_5da4 = ref;
	//^443C:00B9
	_4976_5da8 = _4976_5d98 = x;
	//^443C:00C2
	_4976_5dae.rc4.x = cx;
	//^443C:00C8
	_4976_5d9c = _4976_5dae.rc4.x -x +1;
	//^443C:00CF
	_4976_5daa = _4976_5d9a = y;
	//^443C:00D8
	_4976_5dae.rc4.y = cy;
	//^443C:00DE
	_4976_5d9e = _4976_5dae.rc4.y -y +1;
	//^443C:00E5
	_01b0_0ca4(&_4976_5d98, 0x20);
	//^443C:00F6
	return;
}

//^443C:06B4
void SkWinCore::_443c_06b4(sk0cea *ref)
{
	//^443C:06B4
	ENTER(8);
	//^443C:06B9
	if (ref->b3_7_7() == 0) {
		//^443C:06CB
		ref->b3_7_7(1);
		//^443C:06D0
		skxxx7 *bp08 = &_4976_5dae;
		//^443C:06D8
		sk0cea *bp04 = _4976_5dae.pv0;
		//^443C:06DF
		while (bp04 != NULL && (bp04->b3_0_3()) > (ref->b3_0_3())) {
			//^443C:06E1
			bp08 = bp04->pv6();
			//^443C:06F2
			bp04 = bp08->pv0;
			//^443C:06FC
		}
		//^443C:0721
		_443c_087c();
		//^443C:0726
		ref->pv6()->pv0 = bp04;
		//^443C:073A
		bp08->pv0 = ref;

		{
			//^443C:074A
			SRECT *bp04 = &ref->pv6()->rc4;
			//^443C:075E
			QUERY_EXPANDED_RECT(ref->w0_0_d(), bp04);
			//^443C:0773
			if ((ref->w0_f_f()) != 0) {
				//^443C:077D
				bp04->x = _4976_00e8;
				bp04->y = _4976_00ea;
			}
			//^443C:078D
			if (ref->b5() != 0) {
				//^443C:0797
				_443c_00a9(
					ref,
					bp04->x,
					bp04->x + bp04->cx -1,
					bp04->y,
					bp04->y + bp04->cy -1
					);
			}
			//^443C:07C9
			_443c_0889();
			//^443C:07CE
			_443c_040e();
		}
	}
	//^443C:07D2
	return;
}

//^443C:07D5
void SkWinCore::_443c_07d5(sk0cea *ref)
{
	//^443C:07D5
    ENTER(8);
	//^443C:07D9
	if (ref->b3_7_7() != 0) {
		//^443C:07E3
		ref->b3_7_7(0);
		//^443C:07E8
		skxxx7 *bp08 = &_4976_5dae;
		//^443C:07F0
		sk0cea *bp04 = _4976_5dae.pv0;
		//^443C:07F7
		while (bp04 != ref) {
			//^443C:07F9
			if (bp04 == NULL) {
				//^443C:07FF
				return;
			}
			//^443C:0801
			bp08 = bp04->pv6();
			//^443C:0812
			bp04 = bp08->pv0;
			//^443C:081C
		}
		//^443C:0832
		_443c_087c();
		//^443C:0837
		bp08->pv0 = bp04->pv6()->pv0;
		//^443C:084F
		_443c_0889();
		//^443C:0854
		_443c_040e();
	}
	//^443C:0858
	return;
}

//^1031:0541
void SkWinCore::_1031_0541(Bit16u xx) //#DS=4976
{
	//^1031:0541
	ENTER(12);
	//^1031:0547
	if (xx != _4976_19ad) {
		//^1031:0550
		_1031_098e();
	}
	//^1031:0555
	_4976_19ad = xx;
	//^1031:055B
	_1031_027e(&_4976_1891[_4976_19ad]);
	//^1031:0569
	sk16ed *bp04 = _4976_16ed;
	//^1031:0571
	i16 di;
	for (di = 0; di < 60; bp04++, di++) {
		//^1031:0575
		Bit16u si = bp04->b6;
		//^1031:0580
		if (!(si & 0x40) != !(si & 0x80)) {
			//^1031:0597
			if ((si & 0x80) != 0) {
				//^1031:059D
				if ((si &= 0x3f) != 0) {
					//^1031:05A3
					_4976_0ce0[si].b3_5_5(1);
				}
				//^1031:05B1
				bp04->b6 = bp04->b6 & 0x7f;
			}
			else {
				//^1031:05C0
				if ((si &= 0x3f) != 0) {
					//^1031:05C6
					_4976_0ce0[si].b3_4_4(1);
				}
				//^1031:05D4
				bp04->b6 |= 0x80;
			}
		}
		//^1031:05DC
		bp04->b6 = bp04->b6 & 0xbf;
		//^1031:05E9
	}
	//^1031:05F3
	sk0cea *bp08 = &_4976_0ce0[1];
	//^1031:05FB
	for (di = 0; di < 18; bp08++, di++) {
		//^1031:05FF
		i16 bp0a = (bp08->b3_4_4());
		//^1031:060D
		i16 bp0c = (bp08->b3_5_5());
		//^1031:0618
		if ((!bp0a) != (!bp0c)) {
			//^1031:062C
			if (bp0a != 0) {
				//^1031:0632
				_443c_06b4(bp08);
			}
			else {
				//^1031:063F
				_443c_07d5(bp08);
			}
		}
		//^1031:064C
		bp08->b3_4_4(0);
		bp08->b3_5_5(0);
		//^1031:065D
	}
	//^1031:0659
	return;
}

//^1031:0667
void SkWinCore::_1031_0667() //#DS=4976
{
	//^1031:0667
	ENTER(0);
	//^1031:066A
	_1031_0541(_4976_19ad);
}

//^2759:0009
Bit8u *SkWinCore::QUERY_CMDSTR_NAME(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	// returns cmdStr name such as "CHOP", "THRUST", "MELEE", and so on.

	//^2759:0009
	ENTER(134);
	//^2759:000E
	Bit8u bp0086[128];
	Bit8u *bp04 = QUERY_GDAT_TEXT(cls1, cls2, cls4, bp0086);
	//^2759:0032
	if (*bp04 == 0) {
		//^2759:0038
		return NULL;
	}
	//^2759:003E
	Bit8u bp05;
	Bit16u si;
	for (si = 0; (bp05 = *(bp04++)) != ':' && bp05 != 0; si++) {
		//^2759:0042
		glbStrBufferActionName[si] = bp05;
	}
	//^2759:0060
    glbStrBufferActionName[si] = 0;
	//^2759:0065
	return glbStrBufferActionName;
}

//^29EE:0A7B
void SkWinCore::DRAW_CMD_SLOT(Bit16u cmdSlot, Bit8u ww)
{
	//^29EE:0A7B
	//^29EE:0A7F
	Bit16u si = cmdSlot;
	//^29EE:0A82
	_29ee_00a3(0);
	//^29EE:0A89
	if (glbMagicalMapFlags != 0) {
		//^29EE:0A90
		DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_CONTAINERS, glbHoldedContainerType, ((glbItemSelected[si].entry +0xf8) << 1) +ww +0x41, &_4976_3f6c, si +110, -1);
	}
	else {
		//^29EE:0ABC
		DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_INTERFACE_GENERAL, 0x04, ww +0x15, &_4976_3f6c, si +63, -1);
		//^29EE:0ADA
		DRAW_NAME_STR(
			&_4976_3f6c,
			si +66,
			glbPaletteT16[COLOR_WHITE],
			glbPaletteT16[COLOR_BLACK] | 0x4000,
			QUERY_CMDSTR_NAME(glbItemSelected[si].category, glbItemSelected[si].index, glbItemSelected[si].entry)
			);
	}
	//^29EE:0B25
	//^29EE:0B28
	return;
}

//^29EE:0B2B
void SkWinCore::_29ee_0b2b()
{
	//^29EE:0B2B
	//^29EE:0B2F
	for (Bit16u si = 0; si < _4976_53a4; si++) {
		//^29EE:0B33
		DRAW_CMD_SLOT(si, 0);
		//^29EE:0B3C
	}
	//^29EE:0B43
	DRAW_PLAYER_ATTACK_DIR();
	//^29EE:0B47
}

//^29EE:1D03
void SkWinCore::_29ee_1d03(Bit16u xx)
{
	//^29EE:1D03
	ENTER(6);
	//^29EE:1D08
	Bit16u si = xx;
	//^29EE:1D0B
	_29ee_00a3(0);
	//^29EE:1D12
	if (glbChampionIndex > 0 && (glbMagicalMapFlags & 0x0800) != 0) {
		//^29EE:1D24
		si ^= glbMagicalMapFlags;
		si &= 15;
		//^29EE:1D2C
		Bit8u bp06[2];
		bp06[1] = 0;
		Bit16u bp02 = 0;
		//^29EE:1D35
		for (; bp02 < 4; bp02++) {
			//^29EE:1D37
			Bit8u bp03 = 0x49;
			//^29EE:1D3B
			if ((si & 0x0001) != 0) {
				//^29EE:1D41
				bp03++;
			}
			//^29EE:1D44
			si >>= 1;
			//^29EE:1D46
			DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_MAGICAL_MAPS, glbHoldedContainerType, bp03, &_4976_3f6c, bp02 +101, -1);
			//^29EE:1D65
			bp06[0] = bp02 +0x72;
			//^29EE:1D6D
			DRAW_SIMPLE_STR(&_4976_3f6c, bp02 +105, glbPaletteT16[COLOR_BLACK], glbPaletteT16[COLOR_GRAY] | 0x4000, bp06);
			//^29EE:1D99
		}
	}
	//^29EE:1DA2
	return;
}

//^0CEE:073E
__int16 SkWinCore::FIND_LADDER_AROUND(__int16 xx, __int16 yy, __int16 isupper, Actuator **ref)
{
	// Find a ladder around your location.

	// returns dir(nesw) if found, otherwise -1.

	// isupper: +1 = finds ladder for upper
	// isupper: -1 = finds ladder for lower

	// ref: returns actuator if found as a ladder actuator?

	//^0CEE:073E
	ENTER(6);
	//^0CEE:0744
	for (__int16 si = 0; si <= 3; si++) {
		//^0CEE:0749
		ObjectID bp06;
		bp06 = GET_TILE_RECORD_LINK(xx + glbXAxisDelta[si], yy + glbYAxisDelta[si]);
		//^0CEE:0768
		Bit16u di;
		for (; bp06 != OBJECT_END_MARKER && (di = bp06.DBType()) <= dbActuator; bp06 = GET_NEXT_RECORD_LINK(bp06)) {
			//^0CEE:076B
			if (di == dbActuator || di == dbText) {
				//^0CEE:0778
				GenericRecord *_bp04 = GET_ADDRESS_OF_RECORD(bp06);
				//^0CEE:0787
				if (di == dbActuator) {
					//^0CEE:078C
					Actuator *bp04 = _bp04->castToActuator();
					if (bp04->ActuatorType() == ACTUATOR_TYPE_SIMPLE_LADDER) { // SPX 0x1c -> was used only in Beta as simple ladder. Code still here
						//^0CEE:079E
						if (dunMapsHeaders[bp04->ActuatorData()].Level() - dunMapLocalHeader->Level() == isupper) {
							//^0CEE:07CE
							*ref = bp04;
							//^0CEE:07DE
							return si;
						}
					}
				}
				else {
					//^0CEE:07E3
					Text *bp04 = _bp04->castToText();
					if (true
						&& bp04->TextMode() == 1
						&& (bp04->SimpleTextExtUsage() == 6 || bp04->SimpleTextExtUsage() == 7)
					) {
						//^0CEE:0810
						Bit16u	isLadderUp = 0;
						isLadderUp = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp04->OrnateIndex(), dtWordValue, GDAT_WALL_ORNATE__IS_LADDER_UP);	// 0x11
						//^0CEE:0830
						if ((isupper == -1 && isLadderUp != 0) || (isupper == 1 && isLadderUp == 0)) {
							//^0CEE:0844
							*ref = NULL;
							//^0CEE:0852
							//^0CEE:07DE
							return si;
						}
					}
				}
			}
			//^0CEE:0854
		}
		//^0CEE:0879
	}
	//^0CEE:0882
	*ref = NULL;
	//^0CEE:0890
	return -1;
}

//^19F0:124B
Bit16u SkWinCore::_19f0_124b(__int16 *xx, __int16 *yy, Bit16u ww, __int16 ss, Bit16u tt)
{
	//^19F0:124B
	ENTER(8);
	//^19F0:1251
	Bit16u bp04 = 0;
	__int16 di = -1;
	//^19F0:1259
	CHANGE_CURRENT_MAP_TO(ww);
	//^19F0:1262
	Bit16u si = GET_TILE_VALUE(*xx, *yy);
	//^19F0:1279
	Bit16u bp02 = si >> 5;
	//^19F0:1281
	if (bp02 == ttStairs) {
		//^19F0:1286
		if ((tt & 0x0100) == 0)
			//^19F0:128D
			//^19F0:13A4
			return di;

		//^19F0:1290
		if ((((si & 0x0004) != 0) ? ((ss == -1) ? 1 : 0) : ((ss == 1) ? 1 : 0)) == 0) {
			//^19F0:12B6
			//^19F0:13A4
			return di;
		}
	}
	//^19F0:12BB
	else if (bp02 != 2 || (tt & 0x0008) == 0 || (ss != -1) || (si & 0x0008) == 0 || (si & 0x0001) != 0) {
		//^19F0:12DA
		if ((si & 0x0002) == 0 || bp02 == 0 || bp02 == 7 || bp02 == 4)
			//^19F0:12FB
			//^19F0:13A4
			return di;

		//^19F0:12FE
		Actuator *bp08;
		if ((tt & 0x0100) == 0 || FIND_LADDER_AROUND(*xx, *yy, ss, &bp08) < 0) {
			//^19F0:1325
			if ((tt & 0x0010) == 0 || ss != -1)
				//^19F0:1330
				//^19F0:13A4
				return di;
			//^19F0:1332
			bp04 = 1;
		}
	}
	//^19F0:1337
	di = LOCATE_OTHER_LEVEL(ww, ss, xx, yy, NULL);
	//^19F0:1357
	if (di < 0 || bp04 == 0)
		//^19F0:135F
		//^19F0:13A4
		return di;
	//^19F0:1361
	CHANGE_CURRENT_MAP_TO(di);
	//^19F0:1368
	si = GET_TILE_VALUE(*xx, *yy);
	//^19F0:137F
	bp02 = si >> 5;
	//^19F0:1387
	if (bp02 == ttPit && (si & 0x0008) != 0 && (si & 0x0001) != 0)
		//^19F0:1398
		di = -1;
	//^19F0:139B
	CHANGE_CURRENT_MAP_TO(ww);
	//^19F0:13A4
	return di;
}

//^29EE:18EB
void SkWinCore::_29ee_18eb(Bit16u xx, Bit16u yy, Bit16u zz)
{
	//^29EE:18EB
	ENTER(0);
	//^29EE:18EE
	_4976_536a = _4976_5320 = _4976_5328 = xx;
	_4976_536c = _4976_5322 = _4976_532a = yy;
	_4976_5318 = zz;
	//^29EE:190C
	_4976_533c = _19f0_124b(&_4976_5328, &_4976_532a, _4976_5318, -1, 0x0110);
	//^29EE:1928
	_4976_533e = _19f0_124b(&_4976_5320, &_4976_5322, _4976_5318,  1, 0x0108);
	//^29EE:1944
	return;
}

//^0CEE:02DD
void SkWinCore::CALC_VECTOR_W_DIR(__int16 dir, __int16 xx, __int16 yy, __int16 *ss, __int16 *tt)
{
	ATLASSERT(dir >= 0 && dir < 4);

	//^0CEE:02DD
	ENTER(0);
	//^0CEE:02E1
    __int16 si = dir;
	//^0CEE:02E4
	*ss += glbXAxisDelta[si] * xx;
	//^0CEE:02F5
	*tt += glbYAxisDelta[si] * xx;
	//^0CEE:0306
	si = (si +1) & 3;
	//^0CEE:030B
	*ss += glbXAxisDelta[si] * yy;
	//^0CEE:031C
	*tt += glbYAxisDelta[si] * yy;
	//^0CEE:032D
    return;
}

//^0CEE:315E
Bit16u SkWinCore::IS_WALL_ORNATE_ALCOVE(Bit8u cls2)
{
	// return 0 if non-alcove.
	// return 1 if an alcove.
	// return 2 if a shop glass
	// return 3 if an active sleep device.

	//^0CEE:315E
	ENTER(0);
	//^0CEE:3161
	if (cls2 == 0xff) {
		//^0CEE:3167
		return 0;
	}
	//^0CEE:316B
	return QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, cls2, dtWordValue, GDAT_WALL_ORNATE__0A);	// 0x09 .. .. 0x0A
}

//^0CEE:17E7
Bit16u SkWinCore::_0cee_17e7(Bit16u aa, Bit16u bb, Bit16u cc)
{
	// CSBwinSimilarity: TAG00a41c,Hash

	//^0CEE:17E7
	ENTER(0);
	//^0CEE:17EA
	return ((((aa * 31417) >> 1) + (bb * 11) + dunHeader->w0) >> 2) % cc;
}

//^0CEE:1815
Bit8u SkWinCore::_0cee_1815(i16 xx, i16 yy, Bit16u ss, Bit16u tt, Bit16u uu)
{
	// CSBwinSimilarity: TAG00a44c,RandomWallDecoration

	//^0CEE:1815
	ENTER(0);
	//^0CEE:1819
	if (xx != 0) {
		//^0CEE:181F
		__int16 si = _0cee_17e7(
			(ss << 5) +tt +2000,
			(glbCurrentMapIndex << 6) + glbCurrentMapWidth + glbCurrentMapHeight +3000,
			uu
			);
		//^0CEE:184A
		if (si < yy) {
			//^0CEE:184F
			return _4976_4dc2[si];
		}
	}
	//^0CEE:1855
    return 0xff;
}

//^0CEE:185A
void SkWinCore::_0cee_185a(ExtendedTileInfo *ref, Bit16u xx, Bit16u yy, Bit16u zz, Bit16u ww, Bit16u vv, i16 ss, i16 tt)
{
	// CSBwinSimilarity: TAG00a4a2

	//^0CEE:185A
	ENTER(0);
	//^0CEE:185F
	__int16 di = tt;
	//^0CEE:1862
	Bit16u si = dunMapLocalHeader->WallGraphicsRandomDecorations();
	//^0CEE:1872
	ref->w6[0] = (_0cee_1815(xx, si, ss, (++di) * ((vv & 3) +1), 30));
	//^0CEE:1899
	ref->w6[1] = (_0cee_1815(yy, si, ss, di * (((++vv) & 3) +1), 30));
	//^0CEE:18C2
	ref->w6[2] = (_0cee_1815(zz, si, ss, di * (((++vv) & 3) +1), 30));
	//^0CEE:18EB
	ref->w6[3] = (_0cee_1815(ww, si, ss, (di--) * (((++vv) & 3) +1), 30));
	//^0CEE:1915
	if (ss < 0 || ss >= glbCurrentMapWidth || di < 0 || di >= glbCurrentMapHeight) {
		//^0CEE:192E
		for (si = 3; si <= 6; si++) {
			//^0CEE:1933
			if (IS_WALL_ORNATE_ALCOVE(Bit8u(ref->w6[RCJ(4,si -3)])) != 0) {
				//^0CEE:194A
				ref->w6[RCJ(4,si -3)] = 0x00ff;
			}
			//^0CEE:1958
		}
	}
	//^0CEE:195E
	return;
}

//^0CEE:1A46
ObjectID SkWinCore::_0cee_1a46(ExtendedTileInfo *ref, ObjectID recordLink, i16 xx, i16 yy)
{
	//^0CEE:1A46
	ENTER(24);
	//^0CEE:1A4C
	Bit16u bp08;
	// SPX: TODO DM2_EXTENDED_DATABASE
	for (Bit16u bp16 = 0; recordLink != OBJECT_END_MARKER && (bp08 = recordLink.DBType()) <= dbActuator; recordLink = GET_NEXT_RECORD_LINK(recordLink)) {
		//^0CEE:1A54
		Bit16u bp12 = recordLink.Dir();
		//^0CEE:1A5D
		if ((bp16 & (1 << bp12)) == 0) {
			//^0CEE:1A6D
			Bit16u bp06 = ((bp12 -xx) & 3) +3;
			//^0CEE:1A7C
			if (yy == 0 || bp06 == 5) {
				//^0CEE:1A8B
				Bit16u si = 0;
				Bit16u di = 0;
				//^0CEE:1A8F
				__int32 bp0c = glbGameTick;
				//^0CEE:1A9C
				__int32 bp10 = 0;
				//^0CEE:1AA6
				GenericRecord *_bp04 = GET_ADDRESS_OF_RECORD(recordLink);
				//^0CEE:1AB4
				Bit8u bp13;
				if (bp08 == dbText) {
					Text *bp04 = _bp04->castToText();
					//^0CEE:1ABD
					switch (bp04->TextMode()) {
						default:
							//^0CEE:1AD2
							continue;
						case 0:
							//^0CEE:1AD5
_1ad5:
							ref->w6[RCJ(4,bp06 -3)] = 0;
							//^0CEE:1AE4
							if (bp06 == 5 && bp04->TextVisibility()) {
								//^0CEE:1AF8
								ref->xvalue = (recordLink);
							}
							else {
								//^0CEE:1B04
								ref->xvalue = (OBJECT_NULL);
							}
							//^0CEE:1B0D
							bp16 |= 1 << bp12;
							//^0CEE:1B18
							continue;

						case 1:
							//^0CEE:1B1B
							bp13 = Bit8u(bp04->OrnateIndex());
							//^0CEE:1B2D
							switch (bp04->SimpleTextExtUsage()) {
								case 14:
									{
										//^0CEE:1B49
										goto _1ad5;
									}
								case 5:
								case 13:
									{
										//^0CEE:1B4E
										if (bp04->TextVisibility() != 0) {
											//^0CEE:1B5F
											si = 1;
										}
										//^0CEE:1B62
										break;
									}
								case 2:
									{
										//^0CEE:1B65
										si = 1;
										//^0CEE:1B68
										break;
									}
								case 4:
								case 7:
								case 8:
									{
										//^0CEE:1B6B
										di = bp04->TextVisibility();
										//^0CEE:1B77
										if (di != 0) {
											//^0CEE:1B7E
											si = 1;
											//^0CEE:1B81
											bp16 |= 1 << bp12;
										}
										//^0CEE:1B8C
										break;
									}
								case 0:
								case 6:
									{
										//^0CEE:1B49
										break;
									}
								case 1:
								case 3:
								case 9:
								case 10:
								case 11:
								case 12:
									{
										//^0CEE:1B49
										continue;
									}
							}
					}
				}
				//^0CEE:1B8F
				// TODO DM2_EXTENDED_DATABASE
				else if (bp08 == dbActuator) {
					Actuator *bp04 = _bp04->castToActuator();
					//^0CEE:1B98
					bp13 = GET_WALL_DECORATION_OF_ACTUATOR(bp04);
					//^0CEE:1BA8
					if (bp13 != 0xff) {
						//^0CEE:1BAF
						Bit16u bp18 = bp04->ActuatorType();
						//^0CEE:1BBC
						switch (bp18) {
							case ACTUATOR_TYPE_SHOP_PANEL: // 0x3f: 'Shop panel'
								{
									//^0CEE:1BD5
									if (bp06 == 5) {
										//^0CEE:1BDB
										ref->xvalue = (recordLink);
									}
									else {
										//^0CEE:1BE8
										ref->xvalue = (OBJECT_NULL);
									}
									//^0CEE:1BF1
									break;
								}
							case ACTUATOR_TYPE_CHAMPION_MIRROR: // SPX: Add for DM1 retrocompatibility / 0x7F: Activator, champion mirror
								{
									//^0CEE:1BF4
									if (bp04->ActiveStatus() == 0) {
										//^0CEE:1C08
										if (bp06 == 5) {
											//^0CEE:1C0E
											ref->xvalue = (bp04->ActuatorData());
										}
										//^0CEE:1C1F
										bp16 |= 1 << bp12;
										//^0CEE:1C2A
										si = 1;
									}
									//^0CEE:1C2D
									break;
								}
							case ACTUATOR_TYPE_RESURECTOR: // 0x7e: 'Activator, resuscitation'
								{
									//^0CEE:1BF4
									if (bp04->OnceOnlyActuator() != 0) {
										//^0CEE:1C08
										if (bp06 == 5) {
											//^0CEE:1C0E
											ref->xvalue = (bp04->ActuatorData());
										}
										//^0CEE:1C1F
										bp16 |= 1 << bp12;
										//^0CEE:1C2A
										si = 1;
									}
									//^0CEE:1C2D
									break;
								}
							case ACTUATOR_TYPE_2_STATE_WALL_SWITCH: // 0x17: 'Activator, 2 state wall switch'
								{
									//^0CEE:1C30
									di = bp04->OnceOnlyActuator();
									//^0CEE:1C3F
									if (di != 0) {
										//^0CEE:1C46
										si = 1;
									}
									//^0CEE:1C49
									break;
								}
							case ACTUATOR_TYPE_WALL_SWITCH: // 0x18: 'Activator, push button wall switch'
								{
									//^0CEE:1C4C
									di = bp04->ActiveStatus() ^ bp04->OnceOnlyActuator();
									//^0CEE:1C63
									//^0CEE:1D12
									break;
								}
							case ACTUATOR_TYPE_KEY_HOLE: // 0x1a: 'Activator, key hole'
								{
									//^0CEE:1C66
									di = bp04->OnceOnlyActuator();
									//^0CEE:1C75
									if (di != 0) {
										//^0CEE:1C7C
										si = 1;
										//^0CEE:1C7F
										bp16 |= 1 << bp12;
									}
									//^0CEE:1C8A
									break;
								}
							case ACTUATOR_TYPE_X1B: // 0x1b: '-'
								{
									//^0CEE:1C8D
									di = bp04->ActiveStatus();
									//^0CEE:1C99
									if (bp04->OnceOnlyActuator() == di) {
										//^0CEE:1CA7
										si = 1;
									}
									//^0CEE:1CAA
									break;
								}
							case ACTUATOR_TYPE_ORNATE_ANIMATOR_2: // 0x32: 'Activator, ornate animator'
								{
									//^0CEE:1CAC
									if (bp04->ActiveStatus() != 0) {
										//^0CEE:1CBA
										bp0c = bp04->ActuatorData();
										//^0CEE:1CCC
										si = 1;
									}
									//^0CEE:1CCF
									break;
								}
							case ACTUATOR_TYPE_ORNATE_ANIMATOR: // 0x2c: 'Continuous ornate animator'
								{
									//^0CEE:1CD1
									if (bp04->ActiveStatus() != 0) {
										//^0CEE:1CDF
										bp10 = bp04->ActuatorData() & 0xff;
										//^0CEE:1CF4
                                        si = 1;											
									}
									//^0CEE:1CF7
									break;
								}
							case ACTUATOR_TYPE_ORNATE_STEP_ANIMATOR: // 0x41: 'Ornate step animator'
								{
									//^0CEE:1CF9
									di = bp04->ActuatorData();
									//^0CEE:1D06
									//^0CEE:1D12
									break;
								}
							case ACTUATOR_TYPE_PUSH_BUTTON_WALL_SWITCH: // 0x46: 'Activator, seal-able push button wall switch'
								{
									//^0CEE:1D08
									di = bp04->ActiveStatus();

									break;
								}
						}
					}
				}
				else {
					//^0CEE:1B95
                    continue;
				}
				//^0CEE:1D14
				if (si != 0) {
					//^0CEE:1D18
					di = QUERY_ORNATE_ANIM_FRAME(GDAT_CATEGORY_WALL_GFX, bp13, bp0c, bp10);
				}
				//^0CEE:1D33
				ref->w6[bp06 -3] = (di << 10) | bp13;
			}
		}
		//^0CEE:1D4C
	}
	//^0CEE:1D71
	return recordLink;
}

//^0CEE:1962
Bit16u SkWinCore::QUERY_ORNATE_ANIM_FRAME(Bit8u cls1, Bit8u cls2, Bit32u tick, Bit32u delta)
{
	//0CEE:1962
	ENTER(136);
	//^0CEE:1968
	__int16 si = 1;
	//^0CEE:196B
	Bit16u bp06 = 0;
	Bit16u bp08 = 0;
	//^0CEE:1973
	Bit16u di = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtWordValue, 0x0d);
	//^0CEE:1989
	Bit8u *bp04;
	Bit8u bp0088[128];
	if (di == 0) {
		//^0CEE:198D
		bp04 = QUERY_GDAT_TEXT(cls1, cls2, dt0d, bp0088);
		//^0CEE:19AF
		if (*bp04 != 0 && (di = SK_STRLEN(bp04)) != 0) {
			//^0CEE:19C8
			bp08 = 1;
		}
		else {
			//^0CEE:19CF
			di = 1;
		}
	}
	else {
		//^0CEE:19D4
		bp04 = NULL;
		bp08 = 1;
		//^0CEE:19E3
		if ((di & 0x8000) != 0) {
			//^0CEE:19E9
			bp06 = 1;
			di &= 0x7fff;
		}
	}
	//^0CEE:19F2
	if (bp08 != 0) {
		//^0CEE:19F8
		si = ((tick + delta) % di) +bp06;
		//^0CEE:1A13
		if (bp04 != NULL) {
			//^0CEE:1A1B
			si = bp04[si];
			//^0CEE:1A24
			if (si >= '0' && si <= '9') {
				//^0CEE:1A2E
				si -= '0';
			}
			//^0CEE:1A33
			if (si >= 'A' && si <= 'Z') {
				//^0CEE:1A3D
				si -= 'A' +10;
			}
		}
	}
	//^0CEE:1A40
	return si;
}

//^0CEE:1DBE
// SPX: _0cee_1dbe renamed SUMMARIZE_STONE_ROOM
void SkWinCore::SUMMARIZE_STONE_ROOM(ExtendedTileInfo *ref, Bit16u ww, Bit16u xx, Bit16u yy)
{
	// CSBWin:Codea59a.cpp/SummarizeStoneRoom

	//^0CEE:1DBE
	ENTER(36);
	//^0CEE:1DC4
	__int16 si = ww;
	//^0CEE:1DC7
	ref->w6[0] = (0x00ff);
	ref->w6[1] = (0x00ff);
	ref->w6[2] = (0x00ff);
	ref->w6[3] = (0x00ff);
	ref->xvalue = (0x0000);
	//^0CEE:1DE8
	Bit8u bp05 = GET_TILE_VALUE(xx, yy);
	//^0CEE:1DF7
	ref->w2 = (bp05);
	//^0CEE:1E00
	ObjectID di = GET_TILE_RECORD_LINK(xx, yy);
	//^0CEE:1E0E
	ref->w0 = (bp05 >> 5);
	//^0CEE:1E1E
	Bit16u bp10;
	Bit16u bp14;
	Bit16u bp0e;
	Bit16u bp0a;
	Bit16u bp08;
	Bit16u bp0c;
	Bit8u bp15;
	__int16 bp18;
	__int16 bp1a;
	Bit16u bp12;
	Bit16u bp1c;
	Bit16u bp1e;
	switch (ref->w0) {
		case ttWall:	// 0
			{
				//^0CEE:1E2F
				switch (si) {
					case 0:
						//^0CEE:1E40
						bp0e = bp05 & 8;
						bp0a = bp05 & 4;
						bp08 = bp05 & 2;
						bp0c = bp05 & 1;
						//^0CEE:1E63
						break;
					case 1:
						//^0CEE:1E65
						bp0e = bp05 & 4;
						bp0a = bp05 & 2;
						bp08 = bp05 & 1;
						bp0c = bp05 & 8;
						//^0CEE:1E88
						break;
					case 2:
						//^0CEE:1E8A
						bp0e = bp05 & 2;
						bp0a = bp05 & 1;
						bp08 = bp05 & 8;
						bp0c = bp05 & 4;
						//^0CEE:1EAD
						break;
					case 3:
						//^0CEE:1EAF
						bp0e = bp05 & 1;
						bp0a = bp05 & 8;
						bp08 = bp05 & 4;
						bp0c = bp05 & 2;

						break;
				}
				//^0CEE:1ED7
				_0cee_185a(ref, bp0e, bp0a, bp08, bp0c, si, xx, yy);
				//^0CEE:1EF7
				bp10 = 0;
				//^0CEE:1EFC
_1efc:
				di = _0cee_1a46(ref, di, si, 0);
				//^0CEE:1F0F
				if (bp10 != 0 && glbPlayerPosX != xx && glbPlayerPosY != yy) {
					//^0CEE:1F25
					ref->w4 = (0xfffe);
					//^0CEE:1F2E
					//^0CEE:2353
					return;
				}
				//^0CEE:1F31
				if (bp10 != 0)
					//^0CEE:1F37
					break;
				//^0CEE:1F3A
				for (bp14 = 0; bp14 < 4; bp14++) {
					//^0CEE:1F41
					bp18 = xx;
					bp1a = yy;
					//^0CEE:1F4D
					bp18 += glbXAxisDelta[(si + bp14) & 3];
					//^0CEE:1F5F
					bp1a += glbYAxisDelta[(si + bp14) & 3];
					//^0CEE:1F71
					if ((GET_TILE_VALUE(bp18, bp1a) >> 5) == ttDoor) {
						//^0CEE:1F86
						ref->w6[bp14] = 0x00ff;
					}
					//^0CEE:1F98
				}
				//^0CEE:1FA1
				break;
			}
		case ttPit:		// 2
			{
				//^0CEE:1FA4
				if ((bp05 & 8) != 0) {
					//^0CEE:1FAA
					ref->w6[0] = (bp05 & 4);
					//^0CEE:1FB8
					goto _2237;
				}
				//^0CEE:1FBB
				ref->w0 = (1);
				//^0CEE:1FC3
				goto _2000;
			}
		case ttTrickWall:	// 6
			{
				//^0CEE:1FC5
				if ((bp05 & 4) == 0) {
					//^0CEE:1FD0
					ref->w0 = (0);
					//^0CEE:1FD8
					bp0c = bp08 = bp0a = bp0e = (bp05 & 8);
					//^0CEE:1FEB
					bp10 = 1;
					//^0CEE:1FF0
					goto _1efc;
				}
				//^0CEE:1FF3
				bp05 = 1;
				//^0CEE:1FF8
				ref->w0 = (bp05);

				goto _2000;
			}
		case ttFloor:	// 1
			{
				//^0CEE:2000
_2000:
				bp14 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, dunMapLocalHeader->MapGraphicsStyle(), dtWordValue, GDAT_GFXSET_ANIMATED_FLOOR);
				//^0CEE:2020
				if (bp14 != 0) {	// SPX: That value is only used for VOID and is 0x8028; 0x28 is the floor animated blue cloud
					//^0CEE:2027
					bp15 = Bit8u(bp14);
					//^0CEE:202D
					if ((bp14 & 0x8000) != 0) {
						//^0CEE:2034
						bp12 = QUERY_ORNATE_ANIM_FRAME(GDAT_CATEGORY_FLOOR_GFX, bp15, glbGameTick, 0);
						//^0CEE:204D
						ref->w6[2] = (((bp12 * 10) << 8) | bp15);
						//^0CEE:2063
					}
					else {
						//^0CEE:2066
						ref->w6[2] = (bp15);
					}
				}
				if (false) {
					//^0CEE:2075
_2075:
					bp1c = 0;
					bp12 = 0;
					Bit32u bp20 = glbGameTick;
					Bit32u bp24 = 0;
					//^0CEE:2096
					GenericRecord *_bp04 = GET_ADDRESS_OF_RECORD(di);
					Text *bp04 = _bp04->castToText();
					//^0CEE:20A2
					if (si != dbText)
						//^0CEE:20A7
						goto _212a;

					//^0CEE:20AA
					if (bp04->TextMode() == 1) {
						//^0CEE:20BE
						bp15 = Bit8u(bp04->OrnateIndex());
						//^0CEE:20CD
						switch (bp04->SimpleTextExtUsage()) {
							case 0x11: // 0x11 - ?
								{
									//^0CEE:20EE
									bp12 = ((bp05 & 0x08) != 0) ? 1 : 0;
									//^0CEE:20FE
									goto _21f4;
								}
							case 0x02: // 0x02 - Animate image (e.g. Water basin / fireplace / lantern)
								{
									//^0CEE:2101
									bp1c = 1;
									//^0CEE:2106
									goto _21f4;
								}
							case 0x05: // 0x05 - ?
								{
									//^0CEE:2109
									if (bp04->TextVisibility() != 0) {
										//^0CEE:211A
										bp1c = 1;
									}
									//^0CEE:211F
									goto _21f4;
								}
							case 0x0f: // 0x0f - ?
								{
									//^0CEE:2122
									bp12 = 1;
									//^0CEE:2127
									goto _21f4;

									//^0CEE:212A
_212a:
									// TODO DM2_EXTENDED_DATABASE
									if (si != dbActuator)
										//^0CEE:212F
										break;
									//^0CEE:2132
									Actuator *bp04 = _bp04->castToActuator();
									if (bp04->ActuatorType() == ACTUATOR_FLOOR_TYPE__SHOP) { // 0x30 - Shop exhibition
										//^0CEE:2141
										ref->w6[3] = (0);
									}
									//^0CEE:214A
									bp15 = GET_FLOOR_DECORATION_OF_ACTUATOR(bp04);
									//^0CEE:215A
									if (bp15 == 0xff)
										//^0CEE:215E
										break;
									//^0CEE:2161
									switch (bp04->ActuatorType()) {
										case ACTUATOR_FLOOR_TYPE__ORNATE_ANIMATOR: // 0x32 - Activator, ornate animator
											//^0CEE:217C
											if (bp04->ActiveStatus() == 0)
												//^0CEE:2188
												break;
											//^0CEE:218A
											bp20 = bp04->ActuatorData();
											//^0CEE:2197
											bp1e = 0;
											bp1c = 1;
											//^0CEE:21A1
											break;

										case ACTUATOR_FLOOR_TYPE__CROSS_SCENE: // 0x27 - Cross scene
											//^0CEE:21A3
											if (bp04->ActuatorData() -1 != glbCurrentMapIndex)
												//^0CEE:21B5
												goto _222f;
											//^0CEE:21B7
											if (bp04->ActiveStatus() != 0) {
												//^0CEE:21C5
												bp1c = 1;
											}
											//^0CEE:21CA
											break;

										case ACTUATOR_FLOOR_TYPE__INFINITE_ORNATE_ANIMATOR: // 0x2c - Continuous ornate animator
											//^0CEE:21CC
											if (bp04->ActiveStatus() != 0) {
												//^0CEE:21DA
												bp24 = bp04->ActuatorData() & 0xff;
												bp1c = 1;
											}

											break;
									}
									//^0CEE:217A
									goto _21f4;
								}
							case 0x00: // 0x00 - Still image (e.g. An alcove)
							case 0x10: // 0x10 - ?
							case 0x0a: // 0x0a - Bush
								{
									//^0CEE:21F4
_21f4:
									if (bp1c != 0) {
										//^0CEE:21FA
										bp12 = QUERY_ORNATE_ANIM_FRAME(GDAT_CATEGORY_FLOOR_GFX, bp15, bp20, bp24);
									}
									//^0CEE:2216
									ref->w6[2] = (((bp12 * 10) << 8) | bp15);

									break;
								}
							case 0x01:
							case 0x03:
							case 0x04:
							case 0x06:
							case 0x07:
							case 0x08:
							case 0x09:
							case 0x0b:
							case 0x0c:
							case 0x0d:
							case 0x0e:
								{
									break;
								}
						}
					}
					//^0CEE:222F
_222f:
					di = GET_NEXT_RECORD_LINK(di);
				}
				//^0CEE:2237
_2237:
				if (di == OBJECT_END_MARKER)
					//^0CEE:223C
					break;
				//^0CEE:223F
				si = di.DBType();
				//^0CEE:2249
				if (si <= dbActuator)
					//^0CEE:224E
					goto _2075;
				//^0CEE:2251
				break;
			}
		case ttTeleporter:	// 5
			{
				//^0CEE:2254
				if ((bp05 & 8) == 0 || (bp05 & 4) == 0) {
					//^0CEE:226A
					ref->w0 = (1);
					ref->w2 &= 0xfff7;
				}
				//^0CEE:2278
				goto _2237;
			}
		case ttStairs:	// 3
			{
				//^0CEE:227A
				ref->w0 = ((((bp05 & 8) >> 3) == (si & 1)) ? 0x12 : 0x13);
				//^0CEE:229E
				ref->w6[0] = (bp05 & 4);
				//^0CEE:22A9
				goto _233a;
			}
		case ttDoor:	// 4
			{
				//^0CEE:22AC
				ref->w6[0] = (bp05 & 7);
				//^0CEE:22BA
				ref->w6[1] = (GET_TILE_RECORD_LINK(xx, yy));
				//^0CEE:22CD
				if (((bp05 & 8) >> 3) == (si & 1)) {
					//^0CEE:22E3
					ref->w0 = (0x0010);	// Set the north/west direction of door frame
				}
				else {
					//^0CEE:22EA
					ref->w0 = (0x0011);
					//^0CEE:22F2
					si++;
					si &= 3;
					//^0CEE:22F7
					bp18 = xx + glbXAxisDelta[si];
					//^0CEE:2305
					bp1a = yy + glbYAxisDelta[si];
					//^0CEE:2313
					_0cee_1a46(
						ref,
						GET_TILE_RECORD_LINK(bp18, bp1a),
						si,
						1
						);
				}
				//^0CEE:2330
				goto _233a;

_233a:
				// TODO DM2_EXTENDED_DATABASE
				while (di != OBJECT_END_MARKER && di.DBType() <= dbActuator) {
					//^0CEE:2332
					di = GET_NEXT_RECORD_LINK(di);
					//^0CEE:233A
				}

				break;
			}
	}
	//^0CEE:234C
	ref->w4 = (di);
	//^0CEE:2353
	return;		
}

//^29EE:0BCC
__int16 SkWinCore::QUERY_DUNGEON_MAP_CHIP_PICT(Bit8u cls1, Bit8u cls2, Bit8u **ppBuff, Bit8u *localpal)
{
	//^29EE:0BCC
	ENTER(0);
	//^29EE:0BCF
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(cls1, cls2, dtImage, GDAT_IMG_MAP_CHIP) != 0) {
		//^29EE:0BE8
		*ppBuff = QUERY_GDAT_IMAGE_ENTRY_BUFF(cls1, cls2, GDAT_IMG_MAP_CHIP);
		//^29EE:0C05
		COPY_MEMORY(
			QUERY_GDAT_IMAGE_LOCALPAL(cls1, cls2, GDAT_IMG_MAP_CHIP),
			localpal,
			16
			);
		//^29EE:0C2C
		return READ_I16(*ppBuff,-4) / glbMagicMapWidth;
	}
	//^29EE:0C3D
	return 0;
}

//^29EE:0C41
void SkWinCore::DRAW_CHIP_OF_MAGIC_MAP(const Bit8u *buff, Bit16u aa, Bit16u xx, Bit16u yy, Bit16u flipMirror, Bit8u *localpal)
{
	// draws:
	// a) parts of minion map's 7x7 atlas view.

	//^29EE:0C41
	ENTER(12);
	//^29EE:0C47
	Bit16u di = flipMirror;
	//^29EE:0C4A
	if (buff != NULL) {
		//^29EE:0C55
		__int16 bp02;
		__int16 bp04;
		SRECT bp0c;
		if (UNION_RECT(SET_SRECT(&bp0c, xx, yy, glbMagicMapWidth, glbMagicMapHeight), &_4976_53a6, &bp02, &bp04) != NULL) {
			//^29EE:0C8C
			__int16 si = glbMagicMapWidth - bp0c.cx;
			//^29EE:0C94
			if (si != 0 && (di & 0x0001) != 0) {
				//^29EE:0C9E
				bp02 = (bp02 != 0) ? 0 : si;
			}
			//^29EE:0CAE
			si = glbMagicMapHeight - bp0c.cy;
			//^29EE:0CB6
			if (si != 0 && (di & 0x0002) != 0) {
				//^29EE:0CC0
				bp04 = (bp04 != 0) ? 0 : si;
			}
			//^29EE:0CD0
			DRAW_ICON_PICT_BUFF(
				buff,
				&_4976_3f6c,
				&bp0c,
				glbMagicMapWidth * aa +bp02,
					            +bp04,
				10,
				di,
				localpal
				);
			printf("");
		}
	}
	//^29EE:0CFD
	return;
}

//^4937:000F
__int16 SkWinCore::_4937_000f(Bit16u xx, Bit16u *yy)
{
	//^4937:000F
	ENTER(0);
	//^4937:0012
	return tlbCreaturesAnimationSequences[_4937_005c(xx, yy)].w0 & 0x03ff;
}

//^0CEE:2DF4
Bit16u SkWinCore::_0cee_2df4(ObjectID recordLink)
{
	//^0CEE:2DF4
	ENTER(0);
	//^0CEE:2DF7
	return QUERY_CREATURE_AI_SPEC_FROM_RECORD(recordLink)->w30;
}

//^48AE:011A
Bit16u SkWinCore::_48ae_011a(ObjectID recordLink)
{
	//^48AE:011A
	ENTER(2);
	//^48AE:011F
	Bit8u bp01 = QUERY_CLS1_FROM_RECORD(recordLink);
	//^48AE:012B
	Bit8u bp02 = QUERY_CLS2_FROM_RECORD(recordLink);
	//^48AE:0137
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(bp01, bp02, dtImage, 0x08) != 0) {
		//^48AE:014C
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(bp01, bp02, dtImage, 0x0c) == 0) {
			//^48AE:0164
			return 3;
		}
		//^48AE:0169
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(bp01, bp02, dtImage, 0x0a) != 0) {
			//^48AE:0181
			return 1;
		}
		//^48AE:0186
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(bp01, bp02, dtImage, 0x09) != 0) {
			//^48AE:019E
			return 0;
		}
		//^48AE:01A2
		return 2;
	}
	//^48AE:01A7
	return 0xffff;
}

//^29EE:0D01
void SkWinCore::DRAW_MAP_CHIP(ObjectID recordLink, __int16 ss, __int16 tt, __int16 ww, Bit16u xx, Bit16u yy, Bit8u cc, Bit16u flags)
{
	//^29EE:0D01
	ENTER(108);
	//^29EE:0D07
	Bit16u di = yy;
	//^29EE:0D0A
	Bit8u *bp2e = NULL;
	//^29EE:0D14
	ExtendedTileInfo bp4c;
	SUMMARIZE_STONE_ROOM(&bp4c, ww, ss, tt);
	//^29EE:0D2A
	Bit8u bp5c[16];
	QUERY_DUNGEON_MAP_CHIP_PICT(GDAT_CATEGORY_GRAPHICSSET, cc, &bp2e, bp5c);
	//^29EE:0D41
	if ((flags & 0x0010) != 0) {
		//^29EE:0D48
		SRECT bp3c;
		__int16 bp34;
		UNION_RECT(
			SET_SRECT(
				&bp3c, 
				xx - glbMagicMapInterlineX, 
				di - glbMagicMapInterlineY, 
				(glbMagicMapInterlineX << 1) + glbMagicMapWidth, 
				(glbMagicMapInterlineY << 1) + glbMagicMapHeight
				),
			&_4976_53a6,
			&bp34,
			&bp34
		);
		//^29EE:0D91
		FILL_RECT_SUMMARY(&_4976_3f6c, &bp3c, glbPaletteT16[COLOR_RED]);
	}
	//^29EE:0DAD
	Bit16u bp14 = ((bp4c.w2 >> 5) == ttTrickWall && (bp4c.w2 & 1) != 0) ? 1 : 0;
	Bit16u bp20 = 0;
	__int16 bp0a;
	Bit8u *bp2a;
	Bit8u bp6c[16];
	__int16 bp0e;
	__int16 bp0c;

	//^29EE:0DCD
_0dcd:
	switch (bp4c.w0) {
		case 0://^0DDF
		case 7://^0DDF
			//^29EE:0DDF
			{
				if ((flags & 0x0002) != 0 && bp14 != 0 && (Bit16u(glbGameTick) & 2) != 0) {
					//^29EE:0DF7
					bp0a = 1;
					//^29EE:0DFC
					goto _10b7;
				}
				//^29EE:0DFF
				if (bp20 == 0) {
					//^29EE:0E05
					DRAW_CHIP_OF_MAGIC_MAP(bp2e, 0, xx, di, 0, bp5c);
				}
				//^29EE:0E1F
				for (bp0a = 0; bp0a <= 3; bp0a++) {
					//^29EE:0E27
					bp0c = bp4c.w6[bp0a] & 0xff;
					//^29EE:0E3A
					if (bp0c != 0xff) {
						//^29EE:0E41
						if ((flags & 0x0002) != 0 || QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp0c, dtWordValue, GDAT_IMG_MAP_CHIP) == 0) {
							//^29EE:0E5F
							bp0c = QUERY_DUNGEON_MAP_CHIP_PICT(GDAT_CATEGORY_WALL_GFX, Bit8u(bp0c), &bp2a, bp6c);
							//^29EE:0E79
							if (bp0c != 0) {
								//^29EE:0E7D
								bp0e = bp4c.w6[bp0a] >> 10;
								//^29EE:0E90
								bp0c = (((bp0e +1) << 1) > bp0c) ? (bp0a & 1) : ((bp0e << 1) + (bp0a & 1));
								//^29EE:0EB1
								DRAW_CHIP_OF_MAGIC_MAP(bp2a, bp0c, xx, di, _4976_3fa0[bp0a], bp6c);
							}
						}
					}
					//^29EE:0ED4
				}
				//^29EE:0EE0
				break;
			}
		case 1://^0EE3
			{
				//^29EE:0EE3
				if ((bp4c.w2 & 0x0008) != 0) {
					//^29EE:0EEA
					QUERY_DUNGEON_MAP_CHIP_PICT(GDAT_CATEGORY_GRAPHICSSET, _4976_4c5c[dunMapLocalHeader->Level()], &bp2e, bp5c);
					//^29EE:0F12
					//^29EE:18AA
					DRAW_CHIP_OF_MAGIC_MAP(bp2e, 0, xx, di, 0, bp5c);
					//^29EE:18B7
					return;
				}

				goto _0f22;
			}
		case 5://^0F22
			{
				//^29EE:0F22
_0f22:
				DRAW_CHIP_OF_MAGIC_MAP(bp2e, 2, xx, di, 0, bp5c);
				//^29EE:0F3C
				bp0a = bp4c.w6[2] & 0xff;
				//^29EE:0F45
				if (bp0a != 0xff) {
					//^29EE:0F49
					if (true
						&& ((flags & 0x0002) != 0 || QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_FLOOR_GFX, bp0a, dtWordValue, 0xf9) == 0)
						&& (bp0c = QUERY_DUNGEON_MAP_CHIP_PICT(GDAT_CATEGORY_FLOOR_GFX, Bit8u(bp0a), &bp2a, bp6c)) != 0
					) {
						//^29EE:0F85
						bp0e = (bp4c.w6[2] >> 8) / 10;
						//^29EE:0F94
						bp0a = (bp0e +1 > bp0c) ? 0 : bp0e;
						//^29EE:0FA7
						DRAW_CHIP_OF_MAGIC_MAP(bp2a, bp0a, xx, di, 0, bp6c);
					}
				}
				//^29EE:0FC2
				if (bp4c.w0 == 5) {
					//^29EE:0FCB
					bp0a = QUERY_DUNGEON_MAP_CHIP_PICT(GDAT_CATEGORY_TELEPORTERS, 0x00, &bp2a, bp6c);
					//^29EE:0FE3
					if (bp0a != 0) {
						//^29EE:0FEA
						DRAW_CHIP_OF_MAGIC_MAP(bp2a, glbGameTick % bp0a, xx, di, 0, bp6c);
					}
				}	
				//^29EE:1016
				break;
			}
		case 16://^1019
			{
				//^29EE:1019
				bp0a = 11;
				//^29EE:101E
				goto _1025;
			}
		case 17://^1020
			{
				//^29EE:1020
				bp0a = 10;
				//^29EE:1025
_1025:
				Door *bp04 = GET_ADDRESS_OF_RECORD0(bp4c.w6[1]);
				//^29EE:1034
				if (bp04->Button() == 0 && bp04->Bit13C() == 0) {
					//^29EE:1053
					bp0a += 2;
				}
				//^29EE:1057
				if (bp4c.w6[0] == 0 || bp4c.w6[0] == 5) {
					//^29EE:1063
					bp0a += 4;
				}
				//^29EE:1067
				goto _10b7;
			}
		case 18://^1069
		case 19://^1069
			{
				//^29EE:1069
				bp0a = (_0cee_06dc(ss, tt) - ww) & 3;
				//^29EE:107F
				if (bp4c.w6[0] != 0) {
					//^29EE:1085
					bp0a += 2;
					bp0a &= 3;
				}
				//^29EE:108E
				bp0a += 6;
				//^29EE:1092
				goto _10b7;
			}
		case 2://^1094
			{
				//^29EE:1094
				bp0a = 3;
				//^29EE:1099
				if (bp4c.w6[0] != 0) {
					//^29EE:109F
					bp0a++;
					//^29EE:10A2
					if ((flags & 0x0002) != 0) {
						//^29EE:10A9
						if ((Bit16u(glbGameTick) & 1) != 0) {
							//^29EE:10B4
							bp0a++;
						}
					}
				}
				//^29EE:10B7
_10b7:
				DRAW_CHIP_OF_MAGIC_MAP(bp2e, bp0a, xx, di, 0, bp5c);

				break;
			}
		case 3://^10D2
		case 4://^10D2
		case 6://^10D2
		case 8://^10D2
		case 9://^10D2
		case 10://^10D2
		case 11://^10D2
		case 12://^10D2
		case 13://^10D2
		case 14://^10D2
		case 15://^10D2
			{
				break;
			}

	}
	//^29EE:10D2
	if ((flags & 0x0010) != 0) {
		//^29EE:10DC
		for (bp0a = 0; bp0a < glbChampionsCount; bp0a++) {
			//^29EE:10E4
			if (glbChampionSquad[bp0a].curHP() != 0) {
				//^29EE:10F8
				Bit8u bp21 = QUERY_CLS1_FROM_RECORD(recordLink);
				Bit8u bp22 = QUERY_CLS2_FROM_RECORD(recordLink);
				//^29EE:1110
				Bit8u *bp32 = QUERY_GDAT_IMAGE_ENTRY_BUFF(bp21, bp22, 0x40);
				//^29EE:1125
				DRAW_CHIP_OF_MAGIC_MAP(
					bp32,
					(glbGlobalSpellEffects.Invisibility != 0) ? 0x09 : (bp0a +5),
					xx,
					di,
					_4976_3fa4[(glbChampionSquad[bp0a].playerPos() +4 -ww) & 3],
					QUERY_GDAT_IMAGE_LOCALPAL(bp21, bp22, 0x40)
					);
				printf("");
			}
			//^29EE:117F
		}
	}
	//^29EE:118E
	if ((flags & 0x0040) != 0) {
		//^29EE:1195
		bp0a = (_4976_5326 != 2) ? ((_4976_5326 != 3) ? 0x02 : 0x0a) : (0x0b);
		//^29EE:11B7
		Bit8u bp21 = QUERY_CLS1_FROM_RECORD(recordLink);
		Bit8u bp22 = QUERY_CLS2_FROM_RECORD(recordLink);
		//^29EE:11CF
		Bit8u *bp32 = QUERY_GDAT_IMAGE_ENTRY_BUFF(bp21, bp22, 0x40);
		//^29EE:11E4
		DRAW_CHIP_OF_MAGIC_MAP(
			bp32,
			bp0a,
			xx,
			di,
			0,
			QUERY_GDAT_IMAGE_LOCALPAL(bp21, bp22, 0x40)
			);
	}
	//^29EE:120E
	if ((flags & 0x00a5) != 0) {
		//^29EE:1218
		ObjectID bp1c = OBJECT_END_MARKER;
		ObjectID bp1a = OBJECT_END_MARKER;
		ObjectID bp18 = OBJECT_END_MARKER;
		//^29EE:1224
		ObjectID si = bp4c.w4;
		//^29EE:1227
		for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^29EE:122A
			bp0a = si.DBType();
			//^29EE:1235
			if (bp0a == dbCreature) {
				//^29EE:123A
				Bit16u bp16 = QUERY_CREATURE_AI_SPEC_FLAGS(si);
				//^29EE:1244
				if (QUERY_GDAT_ENTRY_DATA_INDEX(0x0f, QUERY_CLS2_FROM_RECORD(si), dtWordValue, 0xf9) != 0) {
					//^29EE:125F
					bp18 = si;
				}
				else {
					//^29EE:1265
					if ((bp16 & 0x0001)	!= 0) {
						//^29EE:126C
						if ((flags & 0x0080) != 0) {
							//^29EE:1276
							bp18 = si;
						}
					}
					else {
						//^29EE:127C
						if ((flags & 0x0021) != 0) {
							//^29EE:1286
							bp18 = si;
						}
					}
				}
			}
			else {
				//^29EE:128C
				if ((flags & 0x0004) != 0) {
					//^29EE:1296
					if (bp0a == dbMissile) {
						//^29EE:129C
						if (bp1a == OBJECT_END_MARKER) {
							//^29EE:12A5
							bp1a = si;
						}
					}
					//^29EE:12AB
					else if (bp0a == dbCloud) {
						//^29EE:12B1
						if (bp1c == OBJECT_END_MARKER) {
							//^29EE:12BA
							bp1c = si;
						}
					}
					//^29EE:12C0
					else if (bp0a >= dbWeapon && bp0a <= dbMiscellaneous_item) {
						//^29EE:12D2
						bp0a = QUERY_DUNGEON_MAP_CHIP_PICT(QUERY_CLS1_FROM_RECORD(si), QUERY_CLS2_FROM_RECORD(si), &bp2a, bp6c);
						//^29EE:12F6
						if (bp0a != 0) {
							//^29EE:12FA
							bp0c = (si.Dir() - ww) & 3;
							//^29EE:1308
							if (bp4c.w0 == 0 && bp14 == 0) {
								//^29EE:1314
								if (bp0a <= 2)
									//^29EE:1318
									continue;
								//^29EE:131A
								bp0a = (bp0c & 1) +1;
								//^29EE:1324
								bp0c = _4976_3fa0[bp0c];
							}
							else {
								//^29EE:132D
								bp0a = 0;
								//^29EE:1332
								bp0c = _4976_3fa4[bp0c];
							}
							//^29EE:1339
							//^29EE:133E
							DRAW_CHIP_OF_MAGIC_MAP(bp2a, bp0a, xx, di, bp0c, bp6c);
						}
					}
				}
			}
			//^29EE:135A
		}
		//^29EE:136B
		if (bp18 != OBJECT_END_MARKER) {
			//^29EE:1374
			Creature *bp04 = GET_ADDRESS_OF_RECORD4(bp18);
			//^29EE:1383
			Bit16u bp16 = QUERY_CREATURE_AI_SPEC_FLAGS(bp18);
			//^29EE:138F
			Bit8u bp21;
			Bit8u bp22;
			Bit8u *bp32;
			if ((flags & 0x0020) != 0) {
				//^29EE:1396
				bp21 = QUERY_CLS1_FROM_RECORD(recordLink);
				//^29EE:13A2
				bp22 = QUERY_CLS2_FROM_RECORD(recordLink);
				//^29EE:13AE
				bp32 = QUERY_GDAT_IMAGE_ENTRY_BUFF(bp21, bp22, 0x40);
				//^29EE:13C3
				//^29EE:13E6
				//^29EE:1546
				DRAW_CHIP_OF_MAGIC_MAP(
					bp32, 
					(Bit16u(glbGameTick) & 1) +3, 
					xx, 
					di, 
					0, 
					QUERY_GDAT_IMAGE_LOCALPAL(bp21, bp22, 0x40)
					);

				goto _1554;
			}
			//^29EE:13E9
			bp0c = QUERY_DUNGEON_MAP_CHIP_PICT(QUERY_CLS1_FROM_RECORD(bp18), QUERY_CLS2_FROM_RECORD(bp18), &bp2a, bp6c);
			//^29EE:1411
			if (bp0c != 0) {
				//^29EE:1418
				if ((bp16 & 0x0001) != 0) {
					//^29EE:141F
					sk1c9a02c3 *bp08 = _1c9a_02c3(bp04, QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType()));
					//^29EE:1443
					bp0a = _4937_000f(bp08->w0, &bp08->w2);
					//^29EE:145D
					bp0a = (bp0a >= 4 && bp0a <= 7) ? 4 : 0;
					//^29EE:1474
					if (((bp0a +1) << 1) > bp0c) {
						//^29EE:147F
						bp0a = 0;
					}
					else {
						//^29EE:1486
						bp0a = bp0a << 1;
					}
				}
				else {
					//^29EE:1490
					bp0a = __int16(glbGameTick % (bp0c / 2)) << 1;
				}
				//^29EE:14AE
				bp0c = (ww - bp04->b15_0_1());
				//^29EE:14C4
				//^29EE:14E9
				//^29EE:154D
				DRAW_CHIP_OF_MAGIC_MAP(bp2a, (bp0c & 1) + bp0a, xx, di, _4976_3fa0[bp0c], bp6c);
			}
			//^29EE:14EB
			else if ((bp16 & 0x0001) == 0 && (bp16 & 0x2000) == 0) {
				//^29EE:14F9
				bp21 = QUERY_CLS1_FROM_RECORD(recordLink);
				//^29EE:1505
				bp22 = QUERY_CLS2_FROM_RECORD(recordLink);
				//^29EE:1511
				bp32 = QUERY_GDAT_IMAGE_ENTRY_BUFF(bp21, bp22, 0x40);
				//^29EE:1526
				DRAW_CHIP_OF_MAGIC_MAP(
					bp32, 
					Bit16u(glbGameTick & 1), 
					xx, 
					di, 
					0, 
					QUERY_GDAT_IMAGE_LOCALPAL(bp21, bp22, 0x40)
					);
			}
			//^29EE:1554
_1554:
			if ((bp16 & 0x0001) != 0 && (flags & 0x0004) != 0) {
				//^29EE:1568
				if ((_0cee_2df4(bp18) & 0x000f) != 0) {
					//^29EE:1576
					for (si = bp04->w0; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
						//^29EE:157E
						bp0a = si.DBType();
						//^29EE:1589
						if (bp0a >= dbWeapon && bp0a <= dbMiscellaneous_item) {
							//^29EE:1594
							if (QUERY_DUNGEON_MAP_CHIP_PICT(
									QUERY_CLS1_FROM_RECORD(si), 
									QUERY_CLS2_FROM_RECORD(si), 
									&bp2a, bp6c) != 0
							) {
								//^29EE:15B9
								DRAW_CHIP_OF_MAGIC_MAP(
									bp2a,
									0,
									xx,
									di,
									_4976_3fa4[(si.Dir() - ww) & 3],
									bp6c
									);
							}
						}
						//^29EE:15E4
					}
				}
			}
		}
		//^29EE:15F2
		for (si = bp1a; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^29EE:15F8
			if (si.DBType() == dbMissile) {
				//^29EE:1608
				bp0a = QUERY_DUNGEON_MAP_CHIP_PICT(
							QUERY_CLS1_FROM_RECORD(si), 
							QUERY_CLS2_FROM_RECORD(si), 
							&bp2a, bp6c);
				//^29EE:162C
				if (bp0a != 0) {
					//^29EE:1633
					if (bp0a > 3) {
						//^29EE:163B
						bp0c = glbTimersTable[GET_ADDRESS_OF_RECORDE(si)->TimerIndex()].Direction();
						//^29EE:1662
						bp0c = (bp0c - ww) & 3;
						//^29EE:166B
						bp0a = 3;
						//^29EE:1670
						switch (_48ae_011a(si) +1) {
							case 0:
								//^29EE:1686
								//^29EE:16B0
								bp0a = 0;
								break;
							case 1:
								//^29EE:16AE
								//^29EE:16B0
								bp0a = 0;
								break;
							case 2:
								//^29EE:1688
								bp0a += bp0c;
								//^29EE:168E
								bp0a += _4976_3fa8[((bp0a -3) << 2) + ((si.Dir() - ww) & 3)];
								//^29EE:16AC
								break;
							case 3:
								//^29EE:16B0
								bp0a = 0;
								break;
						}
					}
					else {
						//^29EE:16B0
						bp0a = 0;
					}
					//^29EE:16B5
					DRAW_CHIP_OF_MAGIC_MAP(
						bp2a, 
						bp0a, 
						xx,
						di,
						_4976_3fa4[(si.Dir() - ww) & 3],
						bp6c
						);
				}
			}
			//^29EE:16E1
		}
		//^29EE:16F2
		for (si = bp1c; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^29EE:16F7
			if (true
				&& si.DBType() == dbCloud
				&& QUERY_DUNGEON_MAP_CHIP_PICT(
					QUERY_CLS1_FROM_RECORD(si), 
					QUERY_CLS2_FROM_RECORD(si), 
					&bp2a, bp6c) != 0
			) {
				//^29EE:1729
				DRAW_CHIP_OF_MAGIC_MAP(
					bp2a,
					Bit16u(glbGameTick & 1) +1,
					xx,
					di,
					RAND02(),
					bp6c
					);
			}
			//^29EE:174D
		}
		//^29EE:175B
		Bit16u bp1e;
		__int16 bp10;
		__int16 bp12;
		if (bp4c.w0 == 0 && bp20 == 0) {
			//^29EE:176D
			bp10 = ss;
			bp12 = tt;
			Bit8u *bp26 = NULL;
			//^29EE:1783
			bp0a = glbCurrentMapIndex;
			//^29EE:1786
			while (bp0a == glbCurrentMapIndex && bp0a != -1) {
				//^29EE:1788
				bp0a = LOCATE_OTHER_LEVEL(glbCurrentMapIndex, 0, &ss, &tt, &bp26);
				//^29EE:17A5
			}
			//^29EE:17B7
			if (bp0a >= 0 && bp0a != glbCurrentMapIndex) {
				//^29EE:17C6
				if ((glbMapTileValue[bp0a][ss][tt] >> 5) == 0) {
					//^29EE:17EC
					bp20 = 1;
					bp1e = glbCurrentMapIndex;
					//^29EE:17F7
					CHANGE_CURRENT_MAP_TO(bp0a);
					//^29EE:1800
					SUMMARIZE_STONE_ROOM(&bp4c, ww, ss, tt);
					//^29EE:1816
					goto _0dcd;
				}
			}
		}
		//^29EE:1819
		if (bp20 != 0) {
			//^29EE:181F
			ss = bp10;
			tt = bp12;
			//^29EE:182B
			CHANGE_CURRENT_MAP_TO(bp1e);
			//^29EE:1834
			SUMMARIZE_STONE_ROOM(&bp4c, ww, ss, tt);
		}
		//^29EE:184A
		bp0a = LOCATE_OTHER_LEVEL(glbCurrentMapIndex, -1, &ss, &tt, NULL);
		//^29EE:1869
		if (bp0a >= 0) {
			//^29EE:186D
			bp0a = glbMapTileValue[bp0a][ss][tt];
			//^29EE:188F
			if ((bp0a >> 5) == ttPit && (bp0a & 8) != 0) {
				//^29EE:189D
				DRAW_CHIP_OF_MAGIC_MAP(bp2e, 18, xx, di, 0, bp5c);
			}
		}
	}
	//^29EE:18B7
	return;
}

//^29EE:1946
void SkWinCore::_29ee_1946(ObjectID recordLink, __int16 xx, __int16 yy, __int16 zz, __int16 dir, __int16 ss, __int16 tt, Bit16u flags)
{
	//^29EE:1946
    ENTER(56);
	//^29EE:194C
	Bit16u si = flags;
	//^29EE:194F
	if ((si & 0x0008) != 0) { // 8=fix position
		//^29EE:1955
		xx = _4976_5364;
		yy = _4976_5365;
		zz = _4976_539e;
		dir = _4976_539f;
		ss = _4976_53a0;
		tt = _4976_53a2;
	}
	else {
		//^29EE:197F
		_4976_5364 = (__int8)xx;
		_4976_5365 = (__int8)yy;
		_4976_539e = (__int8)zz;
		_4976_539f = (__int8)dir;
		_4976_53a0 = ss;
		_4976_53a2 = tt;
	}
	//^29EE:19A3
	_4976_5326 = 0;
	//^29EE:19A9
	Bit16u bp18 = glbCurrentMapIndex;
	//^29EE:19AF
	_29ee_00a3(0);
	//^29EE:19B6
	FILL_RECT_SUMMARY(&_4976_3f6c, QUERY_EXPANDED_RECT(99, &_4976_53a6), glbPaletteT16[COLOR_BLACK]);
	//^29EE:19DC
	INFLATE_RECT(&_4976_53a6, - glbMagicMapInterlineX, - glbMagicMapInterlineY);
	//^29EE:19F4
	Bit16u bp2e = _4976_53a6.x + ss;
	Bit16u bp30 = _4976_53a6.y + tt;
	Bit16u bp2a = si & 0x0010;
	Bit16u bp1a = si & 0x0020;
	Bit16u bp28 = si & 0x0040;
	//^29EE:1A1E
	Bit16u bp22;
	Bit16u bp24;
	Bit16u bp26;
	Bit16u bp1c;
	Bit16u bp1e;
	Bit16u bp20;
	if (bp1a != 0 || bp28 != 0) {
		//^29EE:1A2D
		Container *bp04 = GET_ADDRESS_OF_RECORD9(recordLink);
		//^29EE:1A3C
		if (bp1a != 0) {
			//^29EE:1A42
			Missile *bp08 = GET_MISSILE_REF_OF_MINION(bp04->GetContainedObject(), recordLink);
			//^29EE:1A59
			bp1c = bp08->GetX();
			bp1e = bp08->GetY();
			bp20 = bp08->GetMap();
			//^29EE:1A80
			CHANGE_CURRENT_MAP_TO(bp20);
			//^29EE:1A87
			TELE_inf bp3a;
			if (GET_TELEPORTER_DETAIL(&bp3a, (Bit8u)bp1c, (Bit8u)bp1e) != 0) {
				//^29EE:1A9E
				bp22 = bp3a.target_x_pos();
				bp24 = bp3a.target_x_pos();
				bp26 = bp3a.target_z();
			}
			else {
				//^29EE:1AB8
				bp26 = 0xffff;
			}
		}
		//^29EE:1ABD
		if (bp28 != 0) {
			//^29EE:1AC3
			_29ee_18eb(bp04->GetDestX(), bp04->GetDestY(), bp04->GetDestMap());
		}
	}
	//^29EE:1AEB
	CHANGE_CURRENT_MAP_TO(zz);
	//^29EE:1AF4
	__int16 bp10 = 3;
	__int16 bp12 = -3;
	//^29EE:1AFE
	if (tt < 0) {
		//^29EE:1B04
		bp10++;
	}
	//^29EE:1B07
	__int16 bp14 = -3;
	__int16 bp16 = 3;
	//^29EE:1B11
	if (ss < 0) {
		//^29EE:1B11
		bp14--;
	}
	//^29EE:1B1A
	for (__int16 bp0c = bp10; bp0c >= bp12; bp0c--) {
		//^29EE:1B23
		Bit16u bp0a = bp2e;
		//^29EE:1B29
		for (__int16 bp0e = bp14; bp0e <= bp16; bp0e++) {
			//^29EE:1B32
			__int16 bp32 = xx;
			__int16 bp34 = yy;
			//^29EE:1B3E
			CALC_VECTOR_W_DIR(dir, bp0c, bp0e, &bp32, &bp34);
			//^29EE:1B59
			__int16 di = LOCATE_OTHER_LEVEL(zz, 0, &bp32, &bp34, NULL);
			//^29EE:1B76
			Bit8u bp2b;
			if (di < 0) {
				//^29EE:1B7A
				di = zz;
				//^29EE:1B7F
				CHANGE_CURRENT_MAP_TO(di);
				//^29EE:1B86
				if ((GET_TILE_VALUE(bp32, bp34) >> 5) == ttMapExit) {
					//^29EE:1B9C
					bp2b = _4976_4c5c[dunMapLocalHeader->Level()];
					//^29EE:1BB0
					goto _1bc7;
				}
			}
			else {
				//^29EE:1BB2
				CHANGE_CURRENT_MAP_TO(di);
			}
			//^29EE:1BB9
			bp2b = dunMapLocalHeader->MapGraphicsStyle();
			//^29EE:1BC7
_1bc7:
			si &= 0xff8f;
			//^29EE:1BCE
			if (true
				&& bp1a != 0
				&& (false
					|| (bp32 == bp1c && bp34 == bp1e &&   di == bp20)
					|| (  di == bp26 && bp32 == bp22 && bp34 == bp24)
				)
			) {
				//^29EE:1BFE
				si |= 0x0020;
			}
			//^29EE:1C02
			if (bp28 != 0 && _4976_5326 == 0) {
				//^29EE:1C0F
				if (bp32 == _4976_536a && bp34 == _4976_536c && di == _4976_5318) {
					//^29EE:1C27
					_4976_5326 = 1;
					//^29EE:1C2D
				}
				//^29EE:1C2F
				else if (bp32 == _4976_5328 && bp34 == _4976_532a && di == _4976_533c) {
					//^29EE:1C47
					_4976_5326 = 2;
					//^29EE:1C4D
					goto _1c6d;
				}
				//^29EE:1C4F
				else if (bp32 == _4976_5320 && bp34 == _4976_5322 && di == _4976_533e) {
					//^29EE:1C67
					_4976_5326 = 3;
					//^29EE:1C6D
_1c6d:
					_29ee_18eb(bp32, bp34, di);
				}
				//^29EE:1C7B
				if (_4976_5326 != 0) {
					//^29EE:1C82
					si |= 0x0040;
				}
			}
			//^29EE:1C86
			if (bp2a != 0 && di == glbMap_4c28 && bp32 == glbSomePosX_4c2e && bp34 == glbSomePosY_4c30) {
				//^29EE:1CA4
				si |= 0x0010;
			}
			//^29EE:1CA8
			DRAW_MAP_CHIP(recordLink, bp32, bp34, dir, bp0a, bp30, bp2b, si);
			//^29EE:1CC6
			bp0a += glbMagicMapWidth + glbMagicMapInterlineX;
			//^29EE:1CD0
		}
		//^29EE:1CDE
		bp30 += glbMagicMapHeight + glbMagicMapInterlineY;
		//^29EE:1CE8
	}
	//^29EE:1CF6
	CHANGE_CURRENT_MAP_TO(bp18);
	//^29EE:1CFF
	return;
}

//^29EE:1DA5
void SkWinCore::DRAW_MAJIC_MAP(ObjectID recordLink)
{
	//^29EE:1DA5
	ENTER(30);
	//^29EE:1DAB
	glbHoldedContainerType = QUERY_CLS2_FROM_RECORD(recordLink);
	glbMagicalMapFlags |= 0x0090;
	//^29EE:1DBD
	Container *bp04 = GET_ADDRESS_OF_RECORD9(recordLink);
	//^29EE:1DCC
	Bit16u bp0e = bp04->b5_5_7();
	//^29EE:1DDC
	Missile *bp08;
	if (bp0e != 3) {
		//^29EE:1DE1
		glbMagicalMapFlags |= 0x0800;
		//^29EE:1DE7
		bp0e = bp04->b5_5_7();
		//^29EE:1DF4
		if (bp0e != 0) {
			//^29EE:1DF8
			bp08 = GET_MISSILE_REF_OF_MINION(bp04->GetContainedObject(), recordLink);
			//^29EE:1E0C
			if (bp08 != NULL) {
				//^29EE:1E10
				glbMagicalMapFlags |= 0x0020;
			}
			//^29EE:1E18
			else if ((glbMagicalMapFlags & 0x0020) != 0) {
				//^29EE:1E20
				glbMagicalMapFlags &= 0xfbdf;
			}
		}
	}
	//^29EE:1E26
	if ((glbMagicalMapFlags & 0x0400) == 0) {
		//^29EE:1E2E
		DRAW_ICON_PICT_ENTRY(0x14, glbHoldedContainerType, 0x10, &_4976_3f6c, 92, -1);
		//^29EE:1E46
		for (Bit16u si = 0; si < _4976_53a4; si++) {
			//^29EE:1E4A
			DRAW_CMD_SLOT(si, 0);
			//^29EE:1E53
		}
		//^29EE:1E5A
		_29ee_1d03(0);
		//^29EE:1E61
		glbMagicalMapFlags |= 0x0400;
	}
	//^29EE:1E67
	Bit16u bp10 = glbPlayerPosX;
	Bit16u di = glbPlayerPosY;
	Bit16u bp12 = glbPlayerMap;
	//^29EE:1E77
	__int16 bp16 = 0; // shift-y
	__int16 bp14 = 0; // shift-x
	//^29EE:1E7F
	if (bp0e != 0 && bp0e != 3) {
		//^29EE:1E91
		if (bp04->GetDestMap() != MAXMAPS -1) {
			//^29EE:1EA3
			glbMagicalMapFlags |= 0x0040;
		}
		//^29EE:1EA9
		if (bp0e == 1) {
			//^29EE:1EB2
			if (bp08 == NULL) {
				//^29EE:1EBA
				glbMagicalMapFlags &= 0xffbf;
			}
			else {
				//^29EE:1EC3
				bp10 = bp08->GetX();
				di = bp08->GetY();
				bp12 = bp08->GetMap();
				//^29EE:1EE9
				Creature *bp0c = GET_ADDRESS_OF_RECORD4(bp04->GetContainedObject());
				//^29EE:1EFC
				__int16 si = QUERY_CREATURE_5x5_POS(bp0c, (glbPlayerDir + _4976_3fc2[bp0c->b15_0_1()]) & 3);
				//^29EE:1F28
				bp14 = si % 5;
				//^29EE:1F31
				bp16 = si / 5;
				//^29EE:1F39
				if (bp14 > 2) {
					//^29EE:1F3F
					si = (glbPlayerDir +1) & 3;
					//^29EE:1F48
					bp10 += glbXAxisDelta[si];
					//^29EE:1F53
					di += glbYAxisDelta[si];
				}
				//^29EE:1F5B
				if (bp16 > 2) {
					//^29EE:1F61
					si = (glbPlayerDir +2) & 3;
					//^29EE:1F6B
					bp10 += glbXAxisDelta[si];
					//^29EE:1F76
					di += glbYAxisDelta[si];
				}
				//^29EE:1F7E
				bp14 = _4976_3fb8[bp14] * (((glbMagicMapInterlineX << 1) + glbMagicMapWidth +1) / 5);
				//^29EE:1FA2
				bp16 = _4976_3fb8[bp16] * (((glbMagicMapInterlineY << 1) + glbMagicMapHeight +1) / 5);
			}
		}
		//^29EE:1FC8
		else if ((glbMagicalMapFlags & 0x0040) != 0) {
			//^29EE:1FD0
			bp10 = bp04->GetDestX();
			//^29EE:1FDD
			di = bp04->GetDestY();
			//^29EE:1FE9
			bp12 = bp04->GetDestMap();
		}
	}
	//^29EE:1FF6
	_29ee_1946(recordLink, bp10, di, bp12, glbPlayerDir, bp14, bp16, glbMagicalMapFlags);
	//^29EE:2015
	if ((glbMagicalMapFlags & 0x0100) != 0 || (glbMagicalMapFlags & 0x0200) == 0) {
		//^29EE:2025
		SRECT bp1e;
		DRAW_GRAY_OVERLAY(&_4976_3f6c, QUERY_EXPANDED_RECT(99, &bp1e), 0);
	}
	//^29EE:2044
	return;
}

//^29EE:078B
void SkWinCore::DRAW_PLAYER_ATTACK_DIR()
{
	//^29EE:078B
	ENTER(346);
	//^29EE:0791
	_29ee_00a3(0);
	//^29EE:0798
	DRAW_ICON_PICT_ENTRY(GDAT_CATEGORY_GRAPHICSSET, glbSquadInterfaceMapGfxSet, GDAT_GFXSET_SQUAD_SINGLE, &_4976_3f6c, 93, -1);	// gfx = 0xF6
	//^29EE:07B1
	Bit8u *bp04 = ALLOC_PICT_BUFF(_4976_0118, _4976_011a, afDefault, 4);
	//^29EE:07CD
	i16 bp06 = 0;
	i16 bp08 = 0;
	//^29EE:07D3
	SRECT bp10;
	if (QUERY_BLIT_RECT(bp04, &bp10, 94, &bp06, &bp08, -1) != 0) {
		//^29EE:07FB
		if (glbGlobalSpellEffects.AuraOfSpeed != 0) {
			//^29EE:0802
			Bit16u si = RAND02();
			//^29EE:0809
			if (si != 0) {
				//^29EE:080D
				bp10.y -= 2;
				//^29EE:0813
				si = RAND02();
				//^29EE:081A
				if (si != 0) {
					//^29EE:081E
					bp10.x -= 2;
				}
			}
		}
		//^29EE:0824
		Bit8u bp015a[16];
		Bit16u di;
		QUERY_GDAT_SQUAD_ICON(bp04, Bit8u(di = glbChampionIndex -1), bp015a);
		//^29EE:083F
		DRAW_ICON_PICT_BUFF(bp04, &_4976_3f6c, &bp10, bp06, bp08, 12, 0, bp015a);
		//^29EE:0866
		if (glbChampionSquad[di].enchantmentPower != 0) {
			//^29EE:0879
			ExtendedPicture bp014a;
			QUERY_PICST_IT(QUERY_GDAT_SUMMARY_IMAGE(&bp014a, 0x01, 0x07, glbChampionSquad[di].enchantmentAura));
			//^29EE:08A2
			bp014a.w4 |= 0x0010;
			bp014a.width >>= 2;
			//^29EE:08AD
			bp014a.w14 = bp014a.width * ((glbChampionSquad[di].playerDir() +4 - glbPlayerDir) & 3);
			//^29EE:08D4
			bp014a.height >>= 2;
			//^29EE:08D9
			bp014a.w16 = bp014a.height * (Bit16u(glbGameTick) & 3);
			//^29EE:08EB
			_0b36_11c0(&bp014a, &_4976_3f6c, 94, 12);
		}
	}
	//^29EE:0901
	FREE_PICT_BUFF(bp04);
	//^29EE:090E
	DRAW_ICON_PICT_ENTRY(0x01, 0x04, 0x10, &_4976_3f6c, 96, -1);
	//^29EE:0924
	DRAW_ICON_PICT_ENTRY(0x01, 0x04, 0x12, &_4976_3f6c, 97, -1);
	//^29EE:093A
	return;
}

//^3E74:58A3
void SkWinCore::FREE_TEMP_CACHE_INDEX(Bit16u cacheIndex)
{
	//^3E74:58A3
	ENTER(0);
	//^3E74:58A6
	_3e74_585a(cacheIndex, 0);
	//^3E74:58B1
	FREE_INDEXED_MEMENT(cacheIndex |0x8000);
	//^3E74:58BD
	return;
}

//^0B36:0CBE
void SkWinCore::_0b36_0cbe(sk3f6c *ref, Bit16u yy)
{
	//^0B36:0CBE
	ENTER(4);
	//^0B36:0CC3
	if (ref->w10 != 0) {
		//^	0B36:0CCD
		SRECT *bp04 = ref->w12;
		//^0B36:0CDC
		FIRE_HIDE_MOUSE_CURSOR();

		do {
			//^0B36:0CE1
			FIRE_BLIT_PICTURE(
				QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w0),
				_4976_4964,
				bp04,
				bp04->x - ref->rc2.x,
				bp04->y - ref->rc2.y,
				ref->rc2.cx,
				glbScreenWidth,
				-1,
				0,
				8,
				8,
				NULL
				);
			//^0B36:0D38
			bp04++;
			//^0B36:0D3C
		} while (--ref->w10 != 0);
		//^0B36:0D45
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^0B36:0D4A
	if (yy != 0) {
		//^0B36:0D50
		FREE_TEMP_CACHE_INDEX(ref->w0);
		//^0B36:0D5C
		ref->w0 = 0xffff;
	}
	//^0B36:0D64
	return;
}

//^0CEE:2EFB
Bit16u SkWinCore::IS_CONTAINER_MAP(ObjectID recordLink)
{
	//^0CEE:2EFB
	if (recordLink.DBType() == dbContainer) {
		if (GET_ADDRESS_OF_RECORD9(recordLink)->ContainerType() == 1) {
			return 1;
		}
	}
	//^0CEE:2F2B
	return 0;
}

//^2759:0644
//SPX: _2759_0644 renamed UPDATE_RIGHT_PANEL
void SkWinCore::UPDATE_RIGHT_PANEL(Bit16u xx)
{
	//^2759:0644
	//^2759:064A
	Bit16u bp0a = 0;
	Bit16u bp0c = 0;
	Bit16u bp0e = 0;
	Bit16u bp12 = 0;
	//^2759:065E
	if (glbNextChampionNumber == 0) {
		//^2759:0668
		if (glbChampionsCount == 0) {
			//^2759:066F
			if (_4976_531c != 0 || glbSomeChampionPanelFlag != 0) {
				//^2759:067D
				glbSomeChampionPanelFlag = 0;
				_4976_531c = 0;
				//^2759:0685
				_29ee_00a3(1);
			}
			//^2759:068D
			glbRightPanelType = RIGHT_PANEL_UNDEFINED;
			goto _0e03;
		}
		//^2759:0696
		if (xx != 0) {
			//^2759:069F
			for (Bit16u bp06=0; bp06 < glbChampionsCount; bp06++) {
				//^2759:06A6
				// SPX: ??BUG?? The b42 is table of 2 elements only; shouldn't it be si < 2 ??
				for (Bit16u si=0; si <= 2; si++) {
					//^2759:06AA
					if (glbChampionSquad[bp06].handCooldown[si] != 0) {
						//^2759:06BB
						glbChampionSquad[bp06].handCooldown[si] = glbChampionSquad[bp06].handCooldown[si] -1;
						//^2759:06DB
						if (glbChampionSquad[bp06].handCooldown[si] == 0) {
							//^2759:06DF
							LOAD_PROJECTILE_TO_HAND(bp06, si);
						}
					}
					//^2759:06EA
				}
				//^2759:06F0
			}
			//^2759:06FC
			if (glbRightPanelType == RIGHT_PANEL_MAGIC_MAP) {	// 3
				//^2759:0703
				ATLASSERT(glbChampionIndex < glbChampionsCount +1);
				Champion *champion = &glbChampionTable[glbChampionIndex];	//*bp04
				//^2759:0714
				if ((glbMagicalMapFlags & 0x0200) != 0) {
					//^2759:071C
					if (--_4976_5316 == 0) {
						//^2759:0722
						if (champion->manaCurrent != 0) {
							//^2759:072C
							champion->manaCurrent--;
							//^2759:0730
							champion->heroFlag |= CHAMPION_FLAG_0800;
							//^2759:0736
							_4976_5316 = 25 / _4976_531a;
						}
						else {
							//^2759:0743
							glbSomeChampionPanelFlag = 1;
							glbMagicalMapFlags = 0;
						}
					}
				}
				//^2759:0751
				else if (champion->manaCurrent != 0) {
					//^2759:075B
					glbSomeChampionPanelFlag = 1;
					glbMagicalMapFlags = 0;
				}
			}
		}
		//^2759:0767
		if (glbChampionAttackDamage != 0) {
			//^2759:076E
			SHOW_ATTACK_RESULT(glbChampionAttackDamage);
			//^2759:0778
			_4976_531c = 1;
			glbChampionAttackDamage = 0;
			glbRightPanelType = RIGHT_PANEL_ATTACK_RESULT;	// 6
			goto _0e03;
		}
		//^2759:078D
		if (glbChampionIndex > 0) {
			//^2759:0794
			__int16 bp06 = glbChampionIndex -1;
			//^2759:079B
			if (bp06 >= 0 && glbSelectedHandAction != 2) {
				//^2759:07A9
				if (_4976_3de6[RCJ(4,bp06)][RCJ(2,glbSelectedHandAction)] != glbChampionSquad[bp06].Possess(glbSelectedHandAction)) {
					//^2759:07D4
					DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
				}
			}
		}
		//^2759:07D8
		Bit8u bp1c[4];
		if (glbChampionIndex >= 0) {
			//^2759:07E2
			Bit16u bp06;
			for (bp06=0; bp06 < glbChampionsCount; bp06++) {
				//^2759:07EA
				Champion *bp04 = &glbChampionSquad[bp06];
				//^2759:07FB
				bp1c[bp06] = 0;
				//^2759:0807
				Bit8u bp07 = (bp04->playerDir() +4 - glbPlayerDir) & 3;
				//^2759:0819
				__int8 bp08 = (bp04->playerPos() +4 - glbPlayerDir) & 3;
				//^2759:0828
				if (bp04->curHP() != 0 && bp08 +1 == _4976_5dbc) {
					//^2759:0837
					bp08 = -1;
				}
				//^2759:083B
				if (READ_UI8(_4976_3de2, bp06) != bp08 || _4976_3dde[RCJ(4,bp06)] != bp07) {
					//^2759:0850
					bp0c = 1;
					bp12 = 1;
					//^2759:0859
					if (bp08 != -1) {
						//^2759:085F
						_4976_531c = 1;
					}
					//^2759:0865
					WRITE_UI8(_4976_3de2, bp06, bp08);
					_4976_3dde[RCJ(4,bp06)] = bp07;
				}
				//^2759:0876
			}
			//^2759:0885
			if (glbSquadInterfaceMapGfxSet != glbMapGraphicsSet || glbGlobalSpellEffects.AuraOfSpeed != 0 || (!_4976_532c) != (!glbGlobalSpellEffects.Invisibility)) {
				//^2759:08AC
				bp0c = 1;
				glbSquadInterfaceMapGfxSet = glbMapGraphicsSet;
				_4976_532c = (glbGlobalSpellEffects.Invisibility != 0) ? 1: 0;
			}
		}
		//^2759:08C8
		if (_4976_531c != 0) {
			//^2759:08CF
			if (glbSomeChampionPanelFlag > 1) {
				//^2759:08D6
				//^2759:0BE2
				glbSomeChampionPanelFlag--;
				//^2759:0BE6
				goto _0e03;
			}
			//^2759:08D9
			_29ee_00a3(1);
			//^2759:08E1
			_4976_531c = 0;
			//^2759:08E7
			bp0a = 1;
		}
		//^2759:08EC
		if (glbChampionIndex == 0) {
			//^2759:08F6
			glbRightPanelType = 0;
			//^2759:08FC
			if (bp0a == 0 && bp12 != 0) {
				//^2759:0908
				glbPreviousRightPanelType = 0xffff;
			}
			//^2759:090E
			for (Bit16u bp06=0; bp06 < glbChampionsCount; bp06++) {
				//^2759:0916
				Champion *champion = &glbChampionSquad[bp06];
				//^2759:0927
				if (champion->curHP() == 0 && GET_PLAYER_AT_POSITION(champion->playerPos()) >= 0) {
					//^2759:0942
					continue;
				}
				//^2759:0945
				bp0e = bp1c[bp06];
				//^2759:0955
				if (glbChampionAlive[bp06] != ((champion->curHP() > 0) ? 1 : 0)) {
					//^2759:0973
					glbChampionAlive[bp06] = ((champion->curHP() > 0) ? 1 : 0);
					//^2759:098D
					bp0e = 1;
					glbPreviousRightPanelType = 0xffff;
				}
				//^2759:0998
				Bit16u bp16 = ((ABS16(glbSomeChampionIndex) -1 == bp06) ? 1 : 0);
				//^2759:09B2
				//SPX: 0 to 1 = hands
				for (Bit16u si=0; si <= 1; si++) {
					//^2759:09B7
					Bit16u bp14 = 0;
					Bit16u bp10 = 0;
					//^2759:09BF
					if (bp16 != 0 && glbSelectedHand_2 == si) {
						//^2759:09CB
						if (glbSomeChampionIndex > 0) {
							//^2759:09D2
							bp14 = 1;
						}
						//^2759:09D7
						bp10 = 1;
					}
					//^2759:09DC
					Bit8u bp17 = (champion->handCooldown[si] != 0) ? 1 : 0;
					//^2759:09F0
					if (glbChampionHandCoolingDown[bp06][si] != bp17) {
						//^2759:0A03
						glbChampionHandCoolingDown[bp06][si] = bp17;
						//^2759:0A14
						bp10 = 1;
					}
					//^2759:0A19
					if (_4976_3de6[RCJ(4,bp06)][RCJ(2,si)] != champion->Possess(si) || bp0a != 0 || bp0e != 0) {
						//^2759:0A45
						_4976_3de6[RCJ(4,bp06)][RCJ(2,si)] = champion->Possess(si);
						//^2759:0A68
						bp10 = 1;
					}
					//^2759:0A6D
					if (bp0a != 0 || bp0e != 0 || bp10 != 0) {
						//^2759:0A7F
						DRAW_HAND_ACTION_ICONS(bp06, si, bp14);
					}
					//^2759:0A8E
				}
				//^2759:0A97
				Bit16u bp14 = 0;
				//^2759:0A9C
				// SPX: == 2 => spell selected instead of hand
				if (bp16 != 0 && glbSelectedHand_2 == 2) {
					//^2759:0AA9
					if (glbSomeChampionIndex > 0) {
						//^2759:0AB0
						bp14 = 1;
					}
					//^2759:0AB5
					bp0e = 1;
				}
				//^2759:0ABA
				Bit8u bp17 = (champion->herob44 != 0) ? 1 : 0;
				//^2759:0ACE
				if (glbChampionHandCoolingDown[bp06][2] != bp17) {
					//^2759:0AE1
					glbChampionHandCoolingDown[bp06][2] = bp17;
					//^2759:0AF2
					bp0e = 1;
				}
				//^2759:0AF7
				if (bp0a != 0 || bp0e != 0 || (_4976_3df7 != glbChampionLeader && (_4976_3df7 == bp06 || glbChampionLeader == bp06))) {
					//^2759:0B19
					DRAW_SQUAD_SPELL_AND_LEADER_ICON(bp06, bp14);
				}
				//^2759:0B26
				if (glbChampionSquad[bp06].enchantmentPower != 0 || _4976_3f68 != 0) {
					//^2759:0B3E
					bp0c = 1;
				}
				//^2759:0B43
				if (glbChampionSquad[bp06].enchantmentPower != 0) {
					//^2759:0B54
					_4976_3f68 |= 1 << bp06;
				}
				else {
					//^2759:0B62
					_4976_3f68 &= ~(1 << bp06);
				}
				//^2759:0B70
			}
			//^2759:0B7F
			if (glbSomeChampionIndex < 0) {
				//^2759:0B86
				glbSomeChampionIndex = 0;
			}
			//^2759:0B8C
			glbSomeChampionIndex = -glbSomeChampionIndex;
			//^2759:0B94
			if (bp0a != 0 || bp0c != 0) {
				//^2759:0BA0
				DRAW_SQUAD_POS_INTERFACE();
			}
		}
		//^2759:0BA5
		_4976_3df7 = glbChampionLeader;
		//^2759:0BB0
		if (glbChampionIndex > 0 && (glbSomeChampionPanelFlag != 0 || bp0a != 0 || bp0c != 0 || (glbRightPanelType == RIGHT_PANEL_MAGIC_MAP && xx != 0))) {
			//^2759:0BDB
			if (glbSomeChampionPanelFlag > 1) {
				//^2759:0BE2
				glbSomeChampionPanelFlag--;
				//^2759:0BE6
				goto _0e03;
			}
			//^2759:0BE9
			if (glbMagicalMapFlags != 0 && glbSomeChampionPanelFlag == 0 && bp0a == 0) {
				//^2759:0BFD
				_29ee_00a3(0);
			}
			else {
				//^2759:0C07
				_29ee_00a3(1);
				//^2759:0C0F
				DRAW_PLAYER_NAME_AT_CMDSLOT();
				//^2759:0C14
				glbMagicalMapFlags &= 0xfbff;
			}
			//^2759:0C1A
			if (glbSelectedHandAction == 2) {
				//^2759:0C21
				glbRightPanelType = RIGHT_PANEL_SPELL;
				//^2759:0C27
				DRAW_SPELL_PANEL();
			}
			else {
				//^2759:0C2F
				Bit16u bp06 = glbChampionIndex -1;
				//^2759:0C36
				Champion *champion = &glbChampionSquad[bp06];	//*bp04
				//^2759:0C44
				ObjectID di = champion->Possess(glbSelectedHandAction);
				//^2759:0C53
				if (IS_CONTAINER_MAP(di) != 0 && glbMagicalMapFlags == 0) {
					//^2759:0C65
					_4976_531a = 1;
					_4976_5316 = 25;
					//^2759:0C71
					if (champion->curMP() != 0) {
						//^2759:0C7B
						champion->manaCurrent--;
						//^2759:0C7F
						champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
						//^2759:0C85
						glbMagicalMapFlags = 0x8200;	// 0x8200
					}
					else {
						//^2759:0C8D
						glbMagicalMapFlags = 0x8000;	// 0x8000
					}
					//^2759:0C93
					glbRightPanelType = RIGHT_PANEL_MAGIC_MAP;	// 3
				}
				//^2759:0C9B
				else if (IS_CONTAINER_MONEYBOX(di) != 0) {
					//^2759:0CA6
					glbRightPanelType = RIGHT_PANEL_MONEY_BOX;	// 4
				}
				//^2759:0CAE
				else if (IS_CONTAINER_CHEST(di) != 0 && glbRightPanelType != RIGHT_PANEL_CONTAINER) {	// != 5
					//^2759:0CB9
					__CHECK_ROOM_FOR_CONTAINER(di, GET_ADDRESS_OF_RECORD9(di));
					//^2759:0CD2
					glbRightPanelType = RIGHT_PANEL_CONTAINER;	// 5
				}

				//^2759:0CD8
				if (glbRightPanelType == RIGHT_PANEL_MONEY_BOX) {	// 4
					//^2759:0CDF
					DRAW_MONEYBOX(di);
				}
				//^2759:0CE7
				else if (glbRightPanelType == RIGHT_PANEL_CONTAINER) {	// 5
					//^2759:0CEE
					DRAW_CONTAINER_PANEL(di, 1);
				}
				//^2759:0CFA
				else if (IS_ITEM_HAND_ACTIVABLE(bp06, di, glbSelectedHandAction) != 0 && glbRightPanelType != RIGHT_PANEL_MAGIC_MAP) {
					//^2759:0D14
					glbRightPanelType = RIGHT_PANEL_HAND_ACTIONS;
					//^2759:0D1A
					if (glbRightPanelType != glbPreviousRightPanelType) {
						//^2759:0D20
						_1031_0667();
						//^2759:0D25
						glbPreviousRightPanelType = glbRightPanelType;
					}
					//^2759:0D2B
					_29ee_0b2b();
				}
				//^2759:0D32
				else if (glbRightPanelType == RIGHT_PANEL_MAGIC_MAP) {	// 3
					//^2759:0D39
					if ((glbMagicalMapFlags & 0x0400) == 0) {
						//^2759:0D41
						glbPreviousRightPanelType = 0xffff;
					}
					//^2759:0D47
					DRAW_MAJIC_MAP(di);
				}
				else {
					//^2759:0D50
					glbChampionIndex = 0;
					glbRightPanelType = RIGHT_PANEL_SQUAD_HANDS;
				}
			}

			//^2759:0D5C
			glbSomeChampionPanelFlag = 0;
		}
		else {
			//^2759:0D64
			if (glbChampionIndex > 0 && glbRightPanelType == RIGHT_PANEL_CONTAINER && xx != 0) {
				//^2759:0D78
				_29ee_00a3(0);
				//^2759:0D80
				DRAW_CONTAINER_PANEL(glbChampionTable[glbChampionIndex].Possess(glbSelectedHandAction), 0);
			}
		}
		//^2759:0D9F
		if (glbChampionIndex > 0 && _4976_3df9[RCJ(7,glbRightPanelType)] != 0 && (glbChampionTable[glbChampionIndex].enchantmentPower != 0 || _4976_3f68 != 0)) {
			//^2759:0DC9
			DRAW_PLAYER_ATTACK_DIR();
			//^2759:0DCE
			if (glbChampionTable[glbChampionIndex].enchantmentPower != 0) {
				//^2759:0DDF
				_4976_3f68 |=   1 << (__int8(glbChampionIndex) -1);
			}
			else {
				//^2759:0DF1
				_4976_3f68 &= ~(1 << (__int8(glbChampionIndex) -1));
			}	
		}

		//^2759:0E03
_0e03:
		if (_4976_3f6c.w0 != 0xffff) {
			//^2759:0E0A
			_0b36_0cbe(&_4976_3f6c, 1);
		}
		//^2759:0E18
		if (glbRightPanelType != glbPreviousRightPanelType) {
			//^2759:0E21
			_1031_0667();
			//^2759:0E26
			glbPreviousRightPanelType = glbRightPanelType;
		}
	}
	//^2759:0E2C
	//SkD((DLV_TWEET, "Tweet: Right panel %d\n", glbRightPanelType));
	return;
}

//^1031:04F5
void SkWinCore::_1031_04f5()
{
	//^1031:04F5
	ENTER(0);
	//^1031:04F8
	if (_4976_4ddc != 0) {
		//^1031:04FF
		_4976_4ddc = 0;
		//^1031:0505
		_29ee_000f();
	}
	//^1031:050A
	return;
}

//^12B4:000D
void SkWinCore::HIGHLIGHT_ARROW_PANEL(Bit16u cls4, Bit16u rectno, Bit16u bright)
{
	//^12B4:000D
	ENTER(52);
	//^12B4:0012
	X16 si = rectno;
	_4976_4eb6 = U8(cls4);
	_4976_4ebc = si;
	_4976_4eb4 = bright;
	if (_4976_4eb4 != 0)
		cls4++;
	//^12B4:002C
	FIRE_HIDE_MOUSE_CURSOR();
	sk3f6c bp34;
	_0b36_0c52(&bp34, si, 1);
	FILL_ENTIRE_PICT(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp34.w0), glbPaletteT16[COLOR_BLACK]);
	DRAW_ICON_PICT_ENTRY(1, 3, U8(cls4), &bp34, si, -1);
	_0b36_0cbe(&bp34, 1);
	FIRE_SHOW_MOUSE_CURSOR();
	WAIT_SCREEN_REFRESH();
	//^12B4:008F
	return;
}

//^12B4:0092
void SkWinCore::_12b4_0092()
{
	//^12B4:0092
	ENTER(0);
	//^12B4:0095
	if (_4976_4eb4 != 0) {
		//^12B4:009C
		HIGHLIGHT_ARROW_PANEL(_4976_4eb6, _4976_4ebc, 0);
	}
	//^12B4:00AD
	return;
}

//^00EB:03E7
void SkWinCore::IBMIO_FILL_HALFTONE_RECT(SRECT *rc) //#DS=04BF
{
	//^00EB:03E7
	ENTER(4);
	//^00EB:03ED
	LOADDS(0x0c48);
	//^00EB:03F3
	for (i16 si = rc->y; rc->y + rc->cy -1 >= si; si++) {
		//^00EB:03FC
		Bit8u *bp04 = &pbVram[si * 320 + rc->x];
		//^00EB:0416
		for (i16 di = rc->x; rc->x + rc->cx -1 >= di; bp04++, di++) {
			//^00EB:041E
			if (((di ^ si) & 1) == 0) {
				//^00EB:0429
				*bp04 = 0;
			}
			//^00EB:0430
		}
		//^00EB:0447
	}
	//^00EB:0458
#if UseAltic
	skwin.UpdateRect(rc->x, rc->y, rc->cx, rc->cy);
#endif
	return;
}

//^44C8:1D11
void SkWinCore::FIRE_FILL_HALFTONE_RECTV(SRECT *rc, Bit16u aa)
{
	//^44C8:1D11
	ENTER(0);
	//^44C8:1D14
	IBMIO_FILL_HALFTONE_RECT(rc) CALL_IBMIO;
	//^44C8:1D24
    return;
}

//^44C8:1DDA
void SkWinCore::FIRE_FILL_HALFTONE_RECTI(Bit16u rectno, Bit16u aa)
{
	//^44C8:1DDA
	ENTER(8);
	//^44C8:1DDE
	SRECT bp08;
	FIRE_FILL_HALFTONE_RECTV(QUERY_EXPANDED_RECT(rectno, &bp08), aa);
}

//^01B0:088D
void SkWinCore::IBMIO_MOUSE_RELEASE_CAPTURE() //#DS=04BF
{
#if UseAltic
	sysMousePositionCaptured--;
#else
//		//^01B0:088D
//		ENTER(0);
//		//^01B0:0890
//		LOADDS(0x3083);
//		//^01B0:0896
//		if (_04bf_18b2 == 1) {
//			//^01B0:089F
//			__asm mov cx,[glbMouseXPos]
//			__asm shl cx,1
//			__asm mov dx,[glbMouseYPos]
//			__asm mov ax,0x0004
//			__asm int 0x33
//		}
//		//^01B0:08AE
//		sysMousePositionCaptured--;
//		//^01B0:08B2
//		return;
#endif
}

//^443C:0401
void SkWinCore::FIRE_MOUSE_RELEASE_CAPTURE()
{
	//^443C:0401
	ENTER(0);
	//^443C:0404
	IBMIO_MOUSE_RELEASE_CAPTURE() CALL_IBMIO;
	//^443C:040C
	return;
}

//^1031:050C
void SkWinCore::_1031_050c()
{
	//^1031:050C
	ENTER(0);
	//^1031:050F
	if (glbShowItemStats != 0 || _4976_4bfe != 0 || _4976_4c3e != 0) {
		//^1031:0524
		_4976_4c3e = 0;
		_4976_4bfe = 0;
		glbShowItemStats = 0;
		//^1031:052F
		FIRE_MOUSE_RELEASE_CAPTURE();
		//^1031:0534
		glbMouseVisibility = 1;
		//^1031:053A
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^1031:053F
	return;
}

//^1031:0675
void SkWinCore::_1031_0675(Bit16u xx)
{
	//^1031:0675
	ENTER(0);
	//^1031:0678
	_4976_4ea8 = _4976_19ad;
	//^1031:067E
	_4976_4e64 = 0;
	_4976_4e48 = 0;
	_4976_4e96 = 0;
	//^1031:0692
	CHAMPION_SQUAD_RECOMPUTE_POSITION();
	//^1031:0698
	_1031_050c();
	//^1031:069B
	_1031_0541(xx);
	//^1031:06A3
	return;
}

//^1031:0000
// SPX: returns 1 ?? that's all ?
// SPX: _1031_0000 renamed RETURN_1
Bit16u SkWinCore::RETURN_1(sk1891 *ref)
{
	//^1031:0000
	ENTER(0);
	//^1031:0003
	return 1;
}

//^1031:0008
// SPX: _1031_0008 renamed IS_GAME_ENDED
Bit16u SkWinCore::IS_GAME_ENDED(sk1891 *ref)
{
	//^1031:0008
	ENTER(0);
	//^1031:000B
	return (ref->b1 == glbGameHasEnded) ? 1 : 0;
}

//^1031:0023
Bit16u SkWinCore::_1031_0023(sk1891 *ref)
{
	//^1031:0023
	ENTER(0);
	//^1031:0026
	return (ref->b1 == _4976_4bd2) ? 1 : 0;
}

//^1031:003E
Bit16u SkWinCore::_1031_003e(sk1891 *ref)
{
	//^1031:003E
	ENTER(0);
	//^1031:0041
	if (ref->b1 == glbChampionInventory)
		//^1031:0050
		return 1;
	//^1031:0055
	return (ref->b1 <= 4 || (glbChampionInventory != 0 && ref->b1 -4 == glbChampionInventory)) ? 0 : 1;
}

//^1031:007B
Bit16u SkWinCore::_1031_007b(sk1891 *ref)
{
	//^1031:007B
	ENTER(0);
	//^1031:007E
	return (glbChampionSquad[ref->b1].curHP() != 0) ? 1 : 0;
}

//^1031:009E
Bit16u SkWinCore::_1031_009e(sk1891 *ref)
{
	//^1031:009E
	ENTER(0);
	//^1031:00A1
	return (GET_PLAYER_AT_POSITION((ref->b1 + glbPlayerDir) & 3) >= 0) ? 1 : 0;
}

//^1031:00C5
Bit16u SkWinCore::_1031_00c5(sk1891 *ref)
{
	//^1031:00C5
	ENTER(0);
	//^1031:00C8
	return ((ref->b1 == 0 && _4976_5dbc == 0) || (ref->b1 != 0 && _4976_5dbc != 0)) ? 1 : 0;
}

//^1031:00F3
Bit16u SkWinCore::_1031_00f3(sk1891 *ref)
{
	//^1031:00F3
	ENTER(0);
	//^1031:00F6
	if (glbChampionIndex == 0) {
		//^1031:00FD
		if (ref->b1 > 3)
			//^1031:0107
			return 1;
		//^1031:010C
		if (GET_PLAYER_AT_POSITION((ref->b1 + glbPlayerDir) & 3) >= 0)
			//^1031:0127
			return 1;
	}
	//^1031:0129
	return 0;
}

//^1031:012D
Bit16u SkWinCore::_1031_012d(sk1891 *ref)
{
	//^1031:012D
	ENTER(0);
	//^1031:0130
	return (glbChampionIndex != 0 && ref->b1 == _4976_53a4) ? 1 : 0;
}

//^1031:014F
Bit16u SkWinCore::_1031_014f(sk1891 *ref)
{
	//^1031:014F
	ENTER(0);
	//^1031:0152
	return (glbChampionIndex != 0 && (ref->b1 & (1 << glbChampionTable[glbChampionIndex].runesCount)) != 0) ? 1 : 0;
}

//^1031:0184
Bit16u SkWinCore::_1031_0184(sk1891 *ref)
{
	//^1031:0184
	ENTER(0);
	//^1031:0187
	return (glbChampionIndex != 0) 
		? (((glbMagicalMapFlags & 0x8000) != 0) 
			? ((ref->b1 == _4976_53a4) 
				? 1 
				: 0
			)
			: ((ref->b1 == 5)
				? 1
				: 0
			)
		)
		: 0;
}

//^1031:01BA
Bit16u SkWinCore::_1031_01ba(sk1891 *ref)
{
	//^1031:01BA
	ENTER(0);
	//^1031:01BD
	return (ref->b1 == glbRightPanelType) ? 1 : 0;
}

//^1031:027E
void SkWinCore::_1031_027e(sk1891 *ref)
{
	//^1031:027E
	ENTER(8);
	//^1031:0282
	Bit8u *bp08 = _1031_023b(ref);

	do {
		//^1031:0294
		sk1891 *bp04 = &_4976_1574[*bp08 & 0xff7f];
		//^1031:02AB
		if ((this->*_4976_0cba[ref->b0_0_6()])(bp04) != 0) {
			//^1031:02CA
			if ((bp04->b0 & 0x80) == 0x80) {
				//^1031:02D6
				_1031_027e(bp04);
			}
			else {
				//^1031:02E4
				_4976_16ed[bp04->w2].b6 |= 0x40;
			}
		}
		//^1031:02F7
		bp08++;
		//^1031:02FA
	} while ((*bp08 & 0x80) == 0);
	//^1031:0308
	return;
}

//^098D:025D
Bit16u SkWinCore::PT_IN_RECT(SRECT *rc, i16 xx, i16 yy)
{
	//^098D:025D
	ENTER(0);
	//^098D:0261
	return (true
			&& rc->x <= xx 
			&& rc->x + rc->cx -1 >= xx 
			&& rc->y <= yy 
			&& rc->y + rc->cy -1 >= yy
			) ? 1 : 0;
}

//^1031:01D5
SRECT *SkWinCore::_1031_01d5(Bit16u rectno, SRECT *rc)
{
	//^1031:01D5
	ENTER(4);
	//^1031:01DA
	Bit16u si = rectno;
	//^1031:01DD
	rc = QUERY_EXPANDED_RECT(si & 0x3fff, rc);
	//^1031:01F7
	if (rc != NULL) {
		//^1031:01FB
		if ((si & 0x8000) != 0) {
			//^1031:0201
			si = 7;
			//^1031:0204
			goto _020f;
		}
		//^1031:0206
		if ((si & 0x4000) != 0) {
			//^1031:020C
			si = 18;
			//^1031:020F
_020f:
			i16 bp02;
			i16 bp04;
			QUERY_TOPLEFT_OF_RECT(si, &bp02, &bp04);
			//^1031:0222
			rc->x += bp02;
			rc->y += bp04;
		}
	}
	//^1031:0232
	return rc;
}

//^1031:0A88
Bit16u SkWinCore::_1031_0a88(sk0d9e *ref, Bit16u xx, Bit16u yy, Bit16u ww)
{
	//^1031:0A88
	ENTER(4);
	//^1031:0A8D
	if (ref == NULL)
		//^1031:0A95
		return 0;
	//^1031:0A9A
	Bit16u si = 0;
	sk0d9e *bp04 = ref;
	do {
		//^1031:0AA8
		if (true
			&& (ref->w4 & 0x0800) == 0 
			&& (ww & (255 & ref->w4)) != 0 
			&& _1031_01d5(ref->w2, &_4976_4e9e) != NULL
			&& PT_IN_RECT(&_4976_4e9e, xx, yy) != 0
		) {
			//^1031:0AF1
			_4976_4df8 = ref->w2;
			//^1031:0AFB
			_4976_4e44 = ((_4976_4df8 & 0x8000) != 0) ? 7 : (((_4976_4df8 & 0x4000) != 0) ? 0x0012 : 0xffff);
			//^1031:0B21
			_4976_4df8 = _4976_4df8 & 0x3fff;
			_4976_4e66 = xx;
			_4976_4e68 = yy;
			//^1031:0B36
			si = 0x07ff & ref->w0;
			//^1031:0B41
			glbUIEventCode = si;
			_4976_4e9c = 0;
			//^1031:0B4A
			_4976_4dfc = glbUIEventCode - ((0x07ff & bp04->w0) -1);
			//^1031:0B5E
			return si;
		}
		//^1031:0B60
		ref++;
		//^1031:0B64
	} while ((ref->w0 & 0x8000) == 0);
	//^1031:0B71
	_4976_4e9e.cx = 0;
	_4976_4e9e.cy = 0;
	//^1031:0B79
	return si;
}

//^1031:024C
sk0d9e *SkWinCore::_1031_024c(sk1891 *ref)
{
	//^1031:024C
	ENTER(0);
	//^1031:0250
	Bit16u si = _4976_16ed[ref->w2].w2;
	//^1031:0264
	return (si == 0xffff) ? NULL : &_4976_0d9e[si];
}

//^1031:030A
Bit16u SkWinCore::_1031_030a(sk1891 *ref, Bit16u xx, Bit16u yy, Bit16u zz)
{
	//^1031:030A
	ENTER(16);
	//^1031:0310
	Bit16u di = yy;
	Bit16u si = 0;
	//^1031:0315
	Bit8u *bp08 = _1031_023b(ref);

	do {
		//^1031:0327
		sk1891 *bp04 = &_4976_1574[*bp08 & 0xff7f];
		//^1031:033E
		if ((this->*_4976_0cba[ref->b0_0_6()])(bp04) != 0) {
			//^1031:035D
			SRECT bp10;
			if ((bp04->b0 & 0x80) == 0x80) {
				//^1031:0369
				si = _1031_030a(bp04, xx, di, zz);
				//^1031:037F
				if (si != 0)
					//^1031:0383
					//^1031:03EC
					return si;
			}
			//^1031:0385
			else if (PT_IN_RECT(_1031_01d5(_4976_16ed[bp04->w2].w0, &bp10), xx, di) != 0) {
				//^1031:03B5
				if ((si = _1031_0a88(_1031_024c(bp04), xx, di, zz)) != 0)
					//^1031:03D6
					//^1031:03EC
					return si;
			}
		}
		//^1031:03D8
		bp08++;
		//^1031:03DB
	} while ((*bp08 & 0x80) == 0);
	//^1031:03EC
	return si;
}

//^1031:0C58
Bit16u SkWinCore::_1031_0c58(Bit16u xx, sk0d9e *ref)
{
	//^1031:0C58
	ENTER(4);
	//^1031:0C5D
	_4976_4e44 = 0xffff;
	//^1031:0C63
	sk0d9e *bp04 = ref;
	//^1031:0C6F
	if (ref != NULL) {
		//^1031:0C7A
		Bit16u si;
		for (; (si = 0x07ff & ref->w0) != 0; ref++) {
			//^1031:0C7C
			if ((ref->w4 & 0x0800) == 0 && si == xx) {
				//^1031:0C8C
				_1031_01d5(ref->w2, &_4976_4e9e);
				//^1031:0C9B
				_4976_4df8 = ref->w2;
				//^1031:0CA5
				if ((_4976_4df8 & 0x8000) != 0) {
					//^1031:0CAD
					_4976_4e44 = 7;
				}
				//^1031:0CB5
				else if ((_4976_4df8 & 0x4000) != 0) {
					//^1031:0CBD
					_4976_4e44 = 18;
				}
				//^1031:0CC3
				_4976_4df8 = _4976_4df8 & 0x3fff;
				_4976_4e66 = _4976_4e9e.x;
				_4976_4e68 = _4976_4e9e.y;
				glbUIEventCode = si;
				//^1031:0CDC
				_4976_4dfc = glbUIEventCode - (0x07ff & bp04->w0) -1;
				//^1031:0CF0
				return 1;
			}
			//^1031:0CF5
		}
		//^1031:0D0B
		_4976_4ea2 = 0;
	}
	//^1031:0D13
	_4976_4df8 = 0xffff;
	_4976_4e66 = 0;
	_4976_4e68 = 0;
	glbUIEventCode = xx;
	_4976_4dfc = 0;
	//^1031:0D31
	return 0;
}

//^1031:03F2
Bit16u SkWinCore::_1031_03f2(sk1891 *ref, Bit16u xx)
{
	//^1031:03F2
	ENTER(12);
	//^1031:03F8
	Bit16u si = 0;
	//^1031:03FA
	Bit8u *bp08 = _1031_023b(ref);

	do {
		//^1031:040C
		sk1891 *bp04 = &_4976_1574[*bp08 & 0xff7f];
		//^1031:0423
		if ((this->*_4976_0cba[ref->b0_0_6()])(bp04) != 0) {
			//^1031:0445
			if ((bp04->b0 & 0x80) == 0x80) {
				//^1031:0451
				si = _1031_03f2(bp04, xx);
				//^1031:0463
				if (si != 0)
					//^1031:0467
					//^1031:04EF
					return si;
			}
			else {
				//^1031:046A
				Bit16u di = _4976_16ed[bp04->w2].w4;
				//^1031:047E
				if (di != 0xffff) {
					//^1031:0483
					sk13a4 *bp0c = &_4976_13a4[di];

					do {
						//^1031:0491
						if (bp0c->w2 == xx) {
							//^1031:049D
							_1031_024c(bp04);
							//^1031:04A9
							_1031_0c58(si = 0x07ff & bp0c->w0, _1031_024c(bp04));
							//^1031:04BF
							_4976_4e9c = xx;
							//^1031:04C5
							break;
						}
						//^1031:04C7
					} while (((++bp0c)->w0 & 0x8000) == 0);
					//^1031:04D5
					if (si != 0)
						//^1031:04D9
						//^1031:04EF
						return si;
				}
			}
		}
		//^1031:04DB
		bp08++;
		//^1031:04DE
	} while ((*bp08 & 0x80) == 0);
	//^1031:04EF
	return si;
}

//^1031:156F
// SPX: _1031_156f renamed ADJUST_UI_EVENT
void SkWinCore::ADJUST_UI_EVENT(MousePosition *ref)
{
	//^1031:156F
	ENTER(6);
	//^1031:1575
	Bit16u si = ref->event;
	//^1031:157C
	SkD((DLV_EUI, "Event UI %03d (%02X) %s triggered.\n", si, si, static_cast<LPCSTR>(getUIEventName(si))));
	//if (si >= 0x74 && si <= 0x7b) { // access to hand item action
	if (si >= UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT && si <= UI_EVENTCODE_CHAMPION4_ACTION_HAND_LEFT) {
		//^1031:1586
		si -= UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT;
		//^1031:1589
		Bit16u bp06 = ((si & 1) != 0) ? 1 : 0;
		//^1031:1599
		i16 di = GET_PLAYER_AT_POSITION(((si >> 1) + glbPlayerDir) & 3);
		//^1031:15AD
		if (false
			|| di < 0 
			|| glbChampionSquad[di +bp06].handCooldown[0] != 0 
			|| IS_ITEM_HAND_ACTIVABLE(di, glbChampionSquad[di].Possess(bp06), bp06) == 0
		) {
			//^1031:15E6
			si = 0;
		}
		else {
			//^1031:15EB
			si = (di << 1) +bp06 +UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT;
		}
	}
	//^1031:15FA
	//else if (si >= 0x5f && si <= 0x62) {
	else if (si >= UI_EVENTCODE_SPELL_OR_LEADER_1 && si <= UI_EVENTCODE_SPELL_OR_LEADER_4) {
		//^1031:160A
		i16 di = GET_PLAYER_AT_POSITION((si -0x5f +glbPlayerDir) & 3);
		//^1031:161F
		if (di < 0) {
			//^1031:1623
			//^1031:15E6
			si = 0;
		}
		else {
			//^1031:1625
			i16 bp04;
			if (si <= UI_EVENTCODE_SPELL_OR_LEADER_2) {
				//^1031:162A
				bp04 = ref->rc6.y + ref->rc6.cy -1 - ref->YPos;
			}
			else {
				//^1031:163C
				bp04 = ref->YPos - ref->rc6.y;
			}
			//^1031:164A
			i16 bp02;
			//if (si == 0x60 || si == 0x61) {
			if (si == UI_EVENTCODE_SPELL_OR_LEADER_2 || si == UI_EVENTCODE_SPELL_OR_LEADER_3) {
				//^1031:1654
				bp02 = ref->XPos - ref->rc6.x;
			}
			else {
				//^1031:1664
				bp02 = ref->rc6.x + ref->rc6.cx -1 - ref->XPos;
			}
			//^1031:1676
			if (bp02 <= bp04) {
				//^1031:167E
				si -= 0x4f;
			}
			//^1031:1683
			else if (glbChampionSquad[di].herob44 != 0) {
				//^1031:1693
				si = 0;
			}
		}
	}
	else {
		//^1031:1607
		return;
	}
	//^1031:1695
	ref->event = si;
	//^1031:169C
	return;
}

//^1031:0D9E
// SPX: _1031_0d9e renamed TRANSMIT_UI_EVENT
Bit8u *SkWinCore::TRANSMIT_UI_EVENT(MousePosition *xx)
{
	//^1031:0D9E
	ENTER(0);
	//^1031:0DA3
	ADJUST_UI_EVENT(xx);
	//^1031:0DB0
	Bit16u si = xx->event;
	//^1031:0DB7
	if (si == 0 || si > UI_EVENTCODE_LAST_EVENT) {
		//^1031:0DC1
		return 0;
	}
	Bit16u di;
	//^1031:0DC8
	//if ((si >= 0x14 && si < 0x42) || (si >= 0x7d && si <= 0x81) || (si >= 0x10 && si <= 0x13)) {
	if ((si >= UI_EVENTCODE_ITEM_SLOT_FIRST && si < UI_EVENTCODE_ITEM_SLOT_LAST) 
		|| (si >= UI_EVENTCODE_TAKE_CHAMPION_TOP_LEFT && si <= UI_EVENTCODE_UPDATE_CHAMPION_POSITION) 
		|| (si >= UI_EVENTCODE_010 && si <= UI_EVENTCODE_013)) {
		//^1031:0DE7
		di = 1;
		goto _0f23;
	}
	//^1031:0DED
	//else if (si >= 0x01 && si <= 0x06) {
	else if (si >= UI_EVENTCODE_ARROW_DIR_FIRST && si <= UI_EVENTCODE_ARROW_DIR_LAST) {
		//^1031:0DF7
		di = (si - UI_EVENTCODE_ARROW_DIR_FIRST) * 15 +2;
		goto _0f23;
	}
	//^1031:0E04
	//else if (si >= 0x74 && si <= 0x7b) {
	else if (si >= UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT && si <= UI_EVENTCODE_CHAMPION4_ACTION_HAND_LEFT) {
		//^1031:0E0E
		di = ((si -UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT) & 1) * 5 +0x5c;
		goto _0f23;
	}
	//^1031:0E21
	//else if (si >= 0x5f && si <= 0x62) {
	else if (si >= UI_EVENTCODE_SPELL_OR_LEADER_1 && si <= UI_EVENTCODE_SPELL_OR_LEADER_4) {
		//^1031:0E2B
		di = (si -UI_EVENTCODE_SPELL_OR_LEADER_1) * 5 +0x66;
		goto _0f23;
	}
	//^1031:0E3B
	//else if (si == 0x70) {
	else if (si == UI_EVENTCODE_HAND_RUNE_QUIT) {
		//^1031:0E40
		di = 0x7a;
		goto _0f23;
	}
	//^1031:0E46
	//else if (si == 0x5d || si == 0x5e) {
	else if (si == UI_EVENTCODE_CHAMPION_TURN_LEFT || si == UI_EVENTCODE_CHAMPION_TURN_RIGHT) {
		//^1031:0E50
		di = ((si -UI_EVENTCODE_CHAMPION_TURN_LEFT) << 3) +0x82;
		goto _0f23;
	}
	//^1031:0E5D
	//else if (si >= 0x65 && si <= 0x6a) {
	else if (si >= UI_EVENTCODE_ADD_RUNE_1 && si <= UI_EVENTCODE_ADD_RUNE_6) {
		//^1031:0E67
		di = 0x92;
		goto _0f23;
	}
	//^1031:0E6D
	//else if (si == 0x6b) {
	else if (si == UI_EVENTCODE_REMOVE_RUNE) {
		//^1031:0E72
		di = 0x96;
		goto _0f23;
	}
	//^1031:0E78
	//else if (si == 0x6c) {
	else if (si == UI_EVENTCODE_VALIDATE_SPELL) {
		//^1031:0E7D
		di = 0x9e;
		goto _0f23;
	}
	//^1031:0E83
	//else if (si >= 0x71 && si <= 0x73) {
	else if (si >= UI_EVENTCODE_HAND_ACTION_1 && si <= UI_EVENTCODE_HAND_ACTION_3) {
		//^1031:0E8D
		di = (si -UI_EVENTCODE_HAND_ACTION_1) * 5 +0xa2;
		goto _0f23;
	}
	//^1031:0E9C
	//else if (si == 0x0b || si == 0xa1) {
	else if (si == UI_EVENTCODE_RETURN_VIEWPORT || si == UI_EVENTCODE_EXIT_CRYOCELL) {
		//^1031:0EA7
		di = 0xb1;
		goto _0f23;
	}
	//^1031:0EAC
	//else if (si == 0x91) {
	else if (si == UI_EVENTCODE_SLEEP) {
		//^1031:
		di = 0xb6;
		goto _0f23;
	}
	//^1031:0EB7
	//else if (si == 0x8c) {
	else if (si == UI_EVENTCODE_DISK_OP) {
		//^1031:0EBD
		di = 0xbb;
		goto _0f23;
	}
	//^1031:0EC2
	//else if (si >= 0x97 && si <= 0x9a) {
	else if (si >= UI_EVENTCODE_MAGIC_MAP_RUNE_1 && si <= UI_EVENTCODE_MAGIC_MAP_RUNE_4) {
		//^1031:0ECE
		di = (si -UI_EVENTCODE_MAGIC_MAP_RUNE_1) * 7 +0xc0;
		goto _0f23;
	}
	//^1031:0EDF
	//else if (si >= 0xdb && si <= 0xde) {
	else if (si >= UI_EVENTCODE_DIALOG_BUTTON_1 && si <= UI_EVENTCODE_DIALOG_BUTTON_4) {
		//^1031:0EEB
		switch (_4976_4bd2 -1) {
			case 0:
			case 1:
				//^1031:0EFC
				di = 0xe3;
				break;
			case 2:
				//^1031:0F01
				if (si < UI_EVENTCODE_DIALOG_BUTTON_2) {
					//^1031:0F05
					//^1031:0EFC
					di = 0xe3;
				}
				else {
					//^1031:0F07
					di = 0xdc;
				}
				break;
			case 3:
				//^1031:0F07
				di = 0xdc;
				break;
			case 4:
			case 5:
				//^1031:0F0C
				if (si <= UI_EVENTCODE_DIALOG_BUTTON_2) {
					//^1031:0F10
					//^1031:0F07
					di = 0xdc;
					break;
				}
				//^1031:0F12
				di = 1;
				break;
			default:
				//^1031:0F12
				di = 1;
				break;
		}
		goto _0f23;
	}
	//^1031:0F17
	//else if (si == 0x50) {
	else if (si == UI_EVENTCODE_CLICK_VIEWPORT) {
		//^1031:0F1C
		di = 0xea;
		goto _0f23;
	}
	else {
		//^1031:0F21
		di = 0;
	}
	//^1031:0F23
_0f23:
	return &_4976_18b9[RCJ(236,di)];
}

//^1031:10C8
void SkWinCore::_1031_10c8(sk3f6c *ref, SRECT *rc, Bit16u cx, Bit16u cy)
{
	//^1031:10C8
	ENTER(0);
	//^1031:10CB
	if (ref->w0 == 0xffff) {
		//^1031:10D4
		COPY_MEMORY(&glbMousePosition.rc6, &ref->rc2, 8);
		//^1031:10ED
		_0b36_0c52(ref, -1, 0);
	}
	//^1031:10FF
	CALC_CENTERED_RECT_IN_RECT(rc, &ref->rc2, cx, cy);
	//^1031:111C
	return;
}

//^0B36:129A
void SkWinCore::_0b36_129a(sk3f6c *ref, i16 xx, i16 yy, Bit8u clr1, Bit8u clr2, Bit8u *str)
{
	//^0B36:129A
	ENTER(4);
	//^0B36:129E
	i16 bp02;
	i16 bp04;
	if (QUERY_STR_METRICS(str, &bp02, &bp04) != 0) {
		//^0B36:12BA
		DRAW_STRING(
			reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(ref->w0)),
			ref->w0,
			ref->rc2.cx,
			xx - ref->rc2.x,
			yy - ref->rc2.y,
			clr1,
			clr2,
			str,
			8
			);
		//^0B36:12F5
		_0b36_0d67(
			ref, 
			ALLOC_TEMP_RECT(xx, yy, bp02, bp04)
			);
	}
	//^0B36:1318
	return;
}

//^0B36:0A3F
void SkWinCore::DRAW_PICST(ExtendedPicture *ref)
{
	//^0B36:0A3F
	ENTER(12);
	//^0B36:0A45
	if (ref->width <= 0 || ref->height <= 0)
		//^0B36:0A59
		return;

	//^0B36:0A5C
	U8 *bp04 = QUERY_PICT_BITS(ref);
	//^0B36:0A6E
	U16 iRectNo = ref->rectNo;	// U16 bp06
	//^0B36:0A78
	i16 bp08;
	i16 bp0a;
	if (iRectNo == 0xFFFF) {
		//^0B36:0A7D
		bp08 = ref->w32;
		bp0a = ref->w34;
	}
	else {
		//^0B36:0A8D
		if ((iRectNo & 0x8000) != 0 || ref->w28 != 0 || ref->w30 != 0) {
			//^0B36:0AA5
			iRectNo = iRectNo | 0x8000;
			bp08 = ref->w32 + ref->w28;
			bp0a = ref->w34 + ref->w30;
		}
		else {
			//^0B36:0AC6
			bp08 = ref->width;
			bp0a = ref->height;
		}
		//^0B36:0AD4
		if (QUERY_BLIT_RECT(bp04, &ref->rc36, iRectNo, &bp08, &bp0a, ref->w26) == 0) {
			//^0B36:0B07
			return;
		}
	}
	//^0B36:0B0A
	bp08 += ref->w14;
	bp0a += ref->w16;
	i16 si = READ_I16(bp04,-4);
	i16 di = ref->rc36.cx +bp08;
	//^0B36:0B2E
	if (si > di && (ref->mirrorFlip & 0x0001) != 0) {
		//^0B36:0B3A
		si -= di;	
	}
	else {
		//^0B36:0B3E
		si = 0;
	}
	//^0B36:0B40

	//if ((ref->w50 & 0x0001) != 0)
	if ((ref->mirrorFlip & DRAW_FLAG_FLIP_1) != 0)
		//^0B36:0B4B
		bp08 = 0;
	//^0B36:0B50
	bp08 += si;
	//^0B36:0B53
	si = READ_I16(bp04,-2);
	//^0B36:0B5A
	di = ref->rc36.cy +bp0a;
	//^0B36:0B66
	//if (si > di && (ref->w50 & 0x0002) != 0) {
	if (si > di && (ref->mirrorFlip & DRAW_FLAG_FLIP_2) != 0) {
		//^0B36:0B72
		si -= di;
	}
	else {
		//^0B36:0B76
		si = 0;
	}
	//^0B36:0B78
	if ((ref->mirrorFlip & DRAW_FLAG_FLIP_2) != 0)	// (ref->w50 & 0x0002) != 0)
		//^0B36:0B83
		bp0a = 0;
	//^0B36:0B88
	bp0a += si;
	//^0B36:0B8B
	U16 bp0c;
	if (ref->pb44 == _4976_4964) {
		//^0B36:0BA2
		si = glbScreenWidth;
		di = glbScreenHeight;
		//^0B36:0BAA
		bp0c = 8;
	}
	else {
		//^0B36:0BB1
		si = READ_I16(ref->pb44,-4);
		//^0B36:0BBC
		di = READ_I16(ref->pb44,-2);
		//^0B36:0BC7
		bp0c = READ_I16(ref->pb44,-6);
	}
	//^0B36:0BD5
	if (ref->colorKeyPassThrough != -2) {
		//^0B36:0BDF
		FIRE_BLIT_PICTURE(
			bp04,								// *src
			ref->pb44,							// *dst
			&ref->rc36,							// SRECT *rc
			bp08,								// srcx
			bp0a,								// srcy
			READ_I16(bp04,-4),					// srcPitch
			si,									// dstPitch
			ref->colorKeyPassThrough,			// colorkey
			ref->mirrorFlip,					// mirrorFlip
			READ_I16(bp04,-6),					// srcBpp
			bp0c,								// dstBpp
			(ref->w56 == 0) ? NULL : ref->b58	// local pal
			);
	}
	//^0B36:0C3D
	ref->w32 = bp08;
	ref->w34 = bp0a;
	//^0B36:0C4E
	return;
}

//^0B36:1688
//void SkWinCore::DRAW_STATIC_PIC(Bit8u cls1, Bit8u cls2, Bit8u cls4, Bit16u rectno, i16 colorkey)
void SkWinCore::DRAW_STATIC_PIC(Bit8u iCategory, Bit8u iItemNo, Bit8u iEntry, Bit16u rectno, i16 colorkey)
{
	// draw an statical image such as inventory plate.

	//^0B36:1688
	ENTER(314);
	//^0B36:168C
	ExtendedPicture bp013a;
	QUERY_GDAT_SUMMARY_IMAGE(&bp013a, iCategory, iItemNo, iEntry);
	//^0B36:16A5
	bp013a.colorKeyPassThrough = colorkey;
	bp013a.rectNo = rectno;
	//^0B36:16B3
	bp013a.pb44 = _4976_4c16;
	//^0B36:16C2
	bp013a.w28 = 0;
	bp013a.w30 = 0;
	//^0B36:16CE
	DRAW_PICST(QUERY_PICST_IT(&bp013a));
	//^0B36:16E2
	return;
}

//^2E62:064A
// SPX: _2e62_064a renamed DRAW_CHARSHEET_OPTION_ICON
void SkWinCore::DRAW_CHARSHEET_OPTION_ICON(Bit8u cls4, Bit16u rectno, Bit16u zz)
{
	//^2E62:064A
	ENTER(0);
	//^2E62:064D
	if ((_4976_581a & zz) != 0)
		//^2E62:0656
		cls4++;
	//^2E62:0659
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, cls4, rectno, -1);
	//^2E62:066E
	return;
}

//^2E62:00A3
void SkWinCore::DRAW_PLAYER_3STAT_PANE(Bit16u player, Bit16u xx)
{
	//^2E62:00A3
	ENTER(2);
	//^2E62:00A8
	U16 si = player;
	//^2E62:00AB
	if (_4976_3ff0.w0 != 0xffff)
		//^2E62:00B0
		return;
	//^2E62:00B2
	// SPX: Choose between 0 (normal champion panel) or 1 (dead champion panel)
	Bit8u bp01 = (glbChampionSquad[si].curHP() == 0) ? 1 : (((si +1) == glbChampionInventory) ? 9 : 0);
	//^2E62:00DB
	_0b36_0c52(&_4976_3ff0, si +161, xx);
	//^2E62:00F0
	DRAW_ICON_PICT_ENTRY(
		0x01,
		0x02,
		bp01,
		&_4976_3ff0,
		si + 161,
		-1
		);
	//^2E62:010C
	if (xx == 0)
		//^2E62:0112
		_4976_3ff0.w10 = 0;
	//^2E62:0118
	return;
}

//^2E62:061D
// SPX: _2e62_061d renamed DRAW_CHAMPION_PICTURE
void SkWinCore::DRAW_CHAMPION_PICTURE(Bit16u player)
{
	//^2E62:061D
	ENTER(0);
	//^2E62:0620
	DRAW_ICON_PICT_ENTRY(
		GDAT_CATEGORY_CHAMPIONS,	// 0x16
		glbChampionSquad[player].HeroType(),
		0x00,
        &_4976_3ff0,
		player +173,
		-1
		);
	//^2E62:0648
	return;
}

//^2E62:011B
void SkWinCore::DRAW_PLAYER_3STAT_HEALTH_BAR(U16 player)
{
	//^2E62:011B
	ENTER(32);
	//^2E62:0121
	SRECT bp0c;
	_0b36_0d67(
		&_4976_3ff0,
		QUERY_EXPANDED_RECT(player +185, &bp0c)
		);
	//^2E62:0143
	Champion *bp04 = &glbChampionSquad[player];
	//^2E62:0154
	i16 bp20[3][2];
	bp20[0][0] = bp04->curHP();
	bp20[0][1] = bp04->maxHP();
	bp20[1][0] = bp04->curStamina();
	bp20[1][1] = bp04->maxStamina();
	bp20[2][0] = bp04->curMP();
	bp20[2][1] = max_value(bp04->maxMP(), bp04->curMP());	// SPX Max because of MANA modifier
	//^2E62:018C
	U16 di = player +193;
	//^2E62:0194
	for (i16 si = 0; si < 3; si++, di += 4) {
		//^2E62:0199
		if (bp20[si][1] != 0) {
			//^	
			if (SCALE_RECT(
				di,
				&bp0c,
				10000,
				(bp20[si][0] * i32(10000)) / bp20[si][1]
				) != NULL
			){
				//^2E62:01F2
				SRECT bp14;
				COPY_MEMORY(&bp0c, &bp14, 8);
				//^2E62:0208
				bp14.x += _4976_0114;
				bp14.y += _4976_0116;
				//^2E62:0214
				FILL_RECT_SUMMARY(
					&_4976_3ff0,
					&bp14,
					glbPaletteT16[COLOR_BLACK]
				);
#if DM2_EXTENDED_MODE == 1
				FILL_RECT_SUMMARY(
					&_4976_3ff0,
					&bp0c,
					QUERY_3STAT_BAR_COLOR(player, glbPaletteT16[glbChampionColor[player]])
					);
#else
				//^2E62:022F
				FILL_RECT_SUMMARY(
					&_4976_3ff0,
					&bp0c,
					glbPaletteT16[glbChampionColor[player]]
					);
#endif
			}
		}
		//^2E62:0255
	}
	//^2E62:0261
	return;
}

//^2E62:0572
void SkWinCore::DRAW_PLAYER_DAMAGE(Bit16u player)
{
	//^2E62:0572
	ENTER(0);
	//^2E62:0576
	U16 si = player;
	//^2E62:0579
	DRAW_ICON_PICT_ENTRY(
		0x01,
		0x02,
		0x03,
		&_4976_3ff0,
		si +177,
		10
		);
	//^2E62:0593
	DRAW_SIMPLE_STR(
		&_4976_3ff0,
		si +177,
		glbPaletteT16[COLOR_WHITE],
		glbPaletteT16[COLOR_RED],
		FMT_NUM(glbChampionSquad[si].damageSuffered, 0, 3)
		);
	//^2E62:05D1
	return;
}

//^2E62:02EA

void SkWinCore::DRAW_CUR_MAX_HMS(U16 rectno, i16 curVal, i16 maxVal)
{
// SPX: original code below
	if (!SkCodeParam::bUseDM2ExtendedMode)
	{	
		ATLASSERT(curVal >= 0 && curVal <= 999);
		ATLASSERT(maxVal >= 0 && maxVal <= 999);

		//^2E62:02EA
		ENTER(8);
		//^2E62:02EE
		U8 bp08[8];	// 3 + slash + 3 + eol
		SK_STRCPY(bp08, FMT_NUM(curVal, 1, 3)); // format cur
		//^2E62:030B
		SK_STRCAT(bp08, strSlash); // add slash
		//^2E62:031C
		SK_STRCAT(bp08, FMT_NUM(maxVal, 1, 3)); // format max
		//^2E62:0339
		DRAW_LOCAL_TEXT(rectno, glbPaletteT16[COLOR_LIGHTER_GRAY], glbPaletteT16[COLOR_DARK_GRAY] | 0x4000, bp08);
		//^2E62:035E
		return;
	}
// SPX: modified function one to handle 4 char string in basic stats
	ATLASSERT(curVal >= 0 && curVal <= 9999);
	ATLASSERT(maxVal >= 0 && maxVal <= 9999);
	ENTER(8);
	U8 bp08[12];	// 4 + slash + 4 + eol
	SK_STRCPY(bp08, FMT_NUM(curVal, 1, 4)); // format cur
	SK_STRCAT(bp08, strSlash); // add slash
	SK_STRCAT(bp08, FMT_NUM(maxVal, 1, 4)); // format max
	DRAW_LOCAL_TEXT(rectno, glbPaletteT16[COLOR_LIGHTER_GRAY], glbPaletteT16[COLOR_DARK_GRAY] | 0x4000, bp08);
	return;
}

//^2E62:0360
void SkWinCore::DRAW_PLAYER_3STAT_TEXT(Champion *ref)
{
	//^2E62:0360
	ENTER(0);
	//^2E62:0363
	DRAW_CUR_MAX_HMS(550, ref->curHP(), ref->maxHP());
	//^2E62:0378
	DRAW_CUR_MAX_HMS(
		551,
		ref->curStamina() / 10,
		ref->maxStamina() / 10
		);
	//^2E62:039E
	DRAW_CUR_MAX_HMS(
		552,
		ref->curMP(),
		ref->maxMP()
		);
	//^2E62:03B3
	return;
}

//^2405:00EC
void SkWinCore::_2405_00ec(U16 rectno, SRECT *rc)
{
	//^2405:00EC
	ENTER(4);
	//^2405:00F0
	i16 bp02 = _4976_0106;
	i16 bp04 = _4976_0108;
	//^2405:00FC
	QUERY_BLIT_RECT(
		NULL,
		rc,
		rectno,
		&bp02,
		&bp04,
		-1
		);
	//^2405:011D
	return;
}

//^2405:011F
void SkWinCore::_2405_011f(U16 rectno, SRECT *rc)
{
	//^2405:011F
	ENTER(0);
	//^2405:0122
	_2405_00ec(rectno, rc);
	//^2405:0132
	INFLATE_RECT(rc, _4976_0112, _4976_0112);
	//^2405:0148
	return;
}

//^2E62:05D4
// SPX: _2e62_05d4 renamed DRAW_EYE_MOUTH_COLORED_RECTANGLE
void SkWinCore::DRAW_EYE_MOUTH_COLORED_RECTANGLE(Bit8u cls4, Bit16u rectno)
{
	//^2E62:05D4
	ENTER(8);
	//^2E62:05D8
	SRECT bp08;
	_2405_011f(rectno, &bp08);
	//^2E62:05E8
	DRAW_DIALOGUE_PARTS_PICT(
		QUERY_GDAT_IMAGE_ENTRY_BUFF(0x01, 0x02, cls4),
        &bp08,
		12,
		QUERY_GDAT_IMAGE_LOCALPAL(0x01, 0x02, cls4)
		);
	//^2E62:061B
	return;
}

//^24A5:105B
// SPX: _24a5_105b renamed DRAW_CRYOCELL_LEVER
void SkWinCore::DRAW_CRYOCELL_LEVER(Bit16u leverIsOn)
{
	//^24A5:105B
	ENTER(0);
	//^24A5:105E
	// SPX: 0xFA image of lever up (waiting user to pull down) / 0xFB image of lever down : champion has been selected
	DRAW_STATIC_PIC(GDAT_CATEGORY_WALL_GFX, GDAT_WALL_ORNATE__CRYOCELL, (leverIsOn != 0) ? 0xfb : 0xfa, 0x1ee, -1);
	if (leverIsOn != 0) {
		//^24A5:1082
		CHANGE_VIEWPORT_TO_INVENTORY(0);
		// SPX: If lever is down, play the open cryocell sound
		QUEUE_NOISE_GEN1(GDAT_CATEGORY_WALL_GFX, GDAT_WALL_ORNATE__CRYOCELL, 0xfb, 0xff, 0xc8, glbPlayerPosX, glbPlayerPosY, 0);
	}
	else {
		//^24A5:10AB
		glbInventorySubpanel = 7;
	}
	//^24A5:10B1
	return;
}

//^24A5:0E82
void SkWinCore::DRAW_POWER_STAT_BAR(i16 curval, U16 rectno, U16 color, i16 vv, U16 ww)
{
	// color
	//   0 to  15: glbPaletteT16[color]
	// 256 to 511: pure 256

	//^24A5:0E82
	ENTER(24);
	//^24A5:0E88
	i16 di = curval;
	//^24A5:0E8B
	//i16 si = (di < -512) ? 8 : ((di < 0) ? 11 : zz);
#if DM2_EXTENDED_MODE == 1
	i16 si = (di < FOOD_WARNING) ? QUERY_FOOD_WATER_BAR_COLOR(0x0A, COLOR_RED) : ((di < 0) ? QUERY_FOOD_WATER_BAR_COLOR(0x09, COLOR_YELLOW) : color);
#else
	i16 si = (di < FOOD_WARNING) ? COLOR_RED : ((di < 0) ? COLOR_YELLOW : color);
#endif
	//^24A5:0EA2
	di -= vv;
	//^24A5:0EA5
	SRECT bp08;
	if (SCALE_RECT(
		rectno,
		&bp08,
		//(i32(10000) * di) / (2048 - vv),
		(i32(10000) * di) / (FOOD_MAX - vv),
		10000
		) != NULL
	) {
		//^24A5:0EE1
		SRECT bp18;
		SRECT bp10;
		if (ww != 0) {
			//^24A5:0EE7
			QUERY_EXPANDED_RECT(rectno, &bp10);
			//^24A5:0EF7
			COPY_MEMORY(&bp10, &bp18, 8);
			//^24A5:0F0D
			if ((bp08.x +bp08.cx -1) == (bp10.x +bp10.cx -1)) {
				//^24A5:0F1F
				ww = 0;
			}
			else {
				//^24A5:0F26
				bp10.cx = (bp10.x +bp10.cx -1) -(bp08.x +bp08.cx -1);
				//^24A5:0F39
				bp10.x = bp08.x +bp08.cx +0;
			}
		}
		else {
			//^24A5:0F47
			COPY_MEMORY(&bp08, &bp18, 8);
		}
		//^24A5:0F5D
		bp18.x += _4976_0142;
		bp18.y += _4976_0142;
		//^24A5:0F66
		FIRE_FILL_BACKBUFF_RECT(&bp18, glbPaletteT16[COLOR_BLACK]);
		//^24A5:0F7D
#if DM2_EXTENDED_MODE == 1
		FIRE_FILL_BACKBUFF_RECT(&bp08, ((si & 0x0100) == 0x0000) ? glbPaletteT16[si] : (si & 0x00FF));
#else
		FIRE_FILL_BACKBUFF_RECT(&bp08, glbPaletteT16[si]);
#endif
		//^24A5:0F94
		if (ww != 0) {
			//^24A5:0F9A
			FIRE_FILL_BACKBUFF_RECT(&bp10, glbPaletteT16[ww]);
		}
	}
	//^24A5:0FB4
	return;
}

#if DM2_EXTENDED_MODE == 1
// kkdf2: ext for emetar
i16 SkWinCore::QUERY_FOOD_WATER_BAR_COLOR(U8 cls4, i16 def_color) {
	RawEntry *bp04 = QUERY_GDAT_ENTRYPTR(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0, dtWordValue, cls4);
	if (bp04 != NULL) {
		return 256 + bp04->data;
	}
	return def_color;
}

// kkdf2: ext for emetar
i16 SkWinCore::QUERY_3STAT_BAR_COLOR(U8 cls4, i16 def_color) {
	RawEntry *bp04 = QUERY_GDAT_ENTRYPTR(GDAT_CATEGORY_INTERFACE_GENERAL, GDAT_INTERFACE_CLASS_CHAMPION_FACING, dtWordValue, cls4);
	if (bp04 != NULL) {
		return bp04->data;
	}
	return def_color;
}
#endif

//^24A5:0FB8
// SPX: _24a5_0fb8 renamed DRAW_FOOD_WATER_POISON_PANEL
void SkWinCore::DRAW_FOOD_WATER_POISON_PANEL()
{
	//^24A5:0FB8
	ENTER(4);
	//^24A5:0FBC
	Champion *pChampion = &glbChampionTable[glbChampionInventory];
	//^24A5:0FCD
	glbInventorySubpanel = 1;
	//^24A5:0FD3
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, GDAT_INTERFACE_CHAR_FOOD_WATER_PANEL, 494, -1);
#if DM2_EXTENDED_MODE == 1
	DRAW_POWER_STAT_BAR(pChampion->curFood(), 496, QUERY_FOOD_WATER_BAR_COLOR(0x06, COLOR_BROWN), -1024, 0);
	DRAW_POWER_STAT_BAR(pChampion->curWater(), 497, QUERY_FOOD_WATER_BAR_COLOR(0x07, COLOR_BLUE), -1024, 0);
#else
	//^24A5:0FE6
	DRAW_POWER_STAT_BAR(pChampion->curFood(), 496, COLOR_BROWN, -1024, 0);
	//^24A5:0FFE
	DRAW_POWER_STAT_BAR(pChampion->curWater(), 497, COLOR_BLUE, -1024, 0);
#endif
	//^24A5:1016
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, GDAT_INTERFACE_FOOD_TEXT, 500, 12);	// food
	//^24A5:1029
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, GDAT_INTERFACE_WATER_TEXT, 501, 12);	// water
	//^24A5:103C
	if (pChampion->PoisonValue != 0) {
		//^24A5:1046
		DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, GDAT_INTERFACE_POISON_TEXT, 502, 12); // poison
		
		// TODO SPX: In PC-DM2, the POISON value has its power bar.
		//	But it requires a rectno for it, which does not exists in PC9821 version ?!
		//if (bUseSuperMode)
		//	DRAW_POWER_STAT_BAR(pChampion->PoisonValue, 497, COLOR_RED, -1024, 0);
	}
#if (DM2_EXTENDED_MODE == 1)
	if (pChampion->PlagueValue != 0) 
	{
		DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, GDAT_INTERFACE_PLAGUED_TEXT, 502, 12); // plagued
	}
#endif
	//^24A5:1059
	return;
}

//^24A5:000F
void SkWinCore::DRAW_GUIDED_STR(const U8 *ref)
{
	// drawtext. draw str for item survey. increment y by text height automatically.

	//^24A5:000F
	ENTER(136);
	//^24A5:0014
	if (*ref == 12) {
		//^24A5:001D
		ref++;
		//^24A5:0020
		QUERY_TOPLEFT_OF_RECT(556, &_4976_52d8, &_4976_52da);
	}
	//^24A5:0033
	if (*ref == 0)
		//^24A5:003C
		return;
	//^24A5:003F
	if (QUERY_MBCS_PRESENCE(ref) != 0) {
		//^24A5:0050
		DRAW_VP_STR(_4976_52d8, _4976_52da, glbPaletteT16[COLOR_LIGHTER_GRAY], ref);
		//^24A5:0071
		_4976_52da += _4976_013a;
		//^24A5:0078
		return;
	}
	//^24A5:007B
	U8 bp0088[128];
	SK_STRCPY(bp0088, ref);
	//^24A5:008F
	U8 *bp04 = bp0088;
	//^24A5:0099
	for (i16 si = 0; *bp04 != 0; ) {
		//^24A5:009E
		U8 *bp08;
		if (SK_STRLEN(bp04) > 18) {
			//^24A5:00B0
			bp08 = bp04 +17;
			//^24A5:00BF
			while (*bp08 != ' ') bp08--;
			//^24A5:00CD
			*bp08 = 0;
			//^24A5:00D1
			si = 1;
		}
		else {
			//^24A5:00D6
			bp08 = NULL;
		}
		//^24A5:00E0
		DRAW_VP_STR(_4976_52d8, _4976_52da, glbPaletteT16[COLOR_LIGHTER_GRAY], bp04);
		//^24A5:0101
		_4976_52da += glbPanelStatsYDelta;
		//^24A5:0108
		if (si != 0 && bp08 != NULL) {
			//^24A5:0114
			si = 0;
			//^24A5:0116
			bp08++;
			//^24A5:0119
			bp04 = bp08;
		}
		else {
			//^24A5:0127
			*bp04 = 0;
		}
		//^24A5:012E
	}
	//^24A5:013A
	return;
}

//^24A5:0732
void SkWinCore::_24a5_0732(i16 xx, i16 yy, U8 *str)
{
	//^24A5:0732
	ENTER(208);
	//^24A5:0737
	U16 bp04 = 0;
	U16 bp02;
	if (QUERY_STR_METRICS(str, &bp02, &bp04) == 0)
		return;
	//^24A5:075B
	U8 bp00d0[200];
	if (QUERY_MBCS_PRESENCE(str) == 0) {
		//^24A5:076C
		X16 si = 0;
		bp00d0[0] = 2;
		bp00d0[1] = 0x20;
		U8 bp05;
		while ((bp05 = str[si]) != 0) {
			//^24A5:077A
			if (bp05 >= 0x41 && bp05 <= 0x5a) {
				//^24A5:0786
				bp05 = bp05 -0x40;
			}
			else if (bp05 >= 0x7b) {
				//^24A5:0793
				bp05 = bp05 -0x60;
			}
			//^24A5:079B
			bp00d0[si +2] = bp05;
			si++;
			//^24A5:07AC
		}
		//^24A5:07B9
		bp00d0[si +2] = 0;
		str = bp00d0;
	}
	//^24A5:07CD
	DRAW_VP_STR(xx -(bp02 >> 1), yy, glbPaletteT16[COLOR_BLACK], str);
	//^24A5:07F3
	return;
}

//^24A5:07F6
void SkWinCore::DRAW_SCROLL_TEXT(ObjectID rl)
{
	//^24A5:07F6
	ENTER(418);
	//^24A5:07FC
	U8 bp00da[200];
	U8 bp01a2[200];
	U8 *bp04;
	ATLASSERT(rl.DBType() == dbScroll);
	QUERY_MESSAGE_TEXT(bp04 = bp00da, rl, 0x8002);
	glbInventorySubpanel = 5;
	DRAW_STATIC_PIC(0x07, 0, 0x01, 0x1ee, -1);
	DRAW_STATIC_PIC(0x12, 0, 0x10, 0x1ee, 12);
	X16 si;
	for (si = 0; *bp04 != 0; bp04++) {
		//^24A5:0848
		if (*bp04 == 0xa)
			si++;
		//^24A5:0852
	}
	//^24A5:085E
	if (bp04[-1] != 0xa) {
		si++;
	}
	else if (bp04[-2] == 0xa) {
		si--;
	}
	//^24A5:0873
	i16 bp08;
	i16 bp0a;
	QUERY_TOPLEFT_OF_RECT(0x230, &bp08, &bp0a);
	SRECT bp12;
	QUERY_EXPANDED_RECT(0x1ee, &bp12);
	X16 di;
	if (QUERY_MBCS_PRESENCE(bp00da) == 0) {
		//^24A5:08A9
		di = glbPanelStatsYDelta;
		bp0a -= ((di * si -_4976_0124 -1) >> 1) - _4976_011e;
	}
	else {
		//^24A5:08BD
		di = _4976_013a;
		bp0a -= ((di * si - _4976_0136 -1) >> 1) - _4976_0130;
	}
	//^24A5:08D2
	U16 bp06 = 0;
	while (bp00da[bp06] != 0) {
		//^24A5:08D9
		_3929_04e2(bp00da, bp01a2, &bp06, bp12.cx);
		_24a5_0732(bp08, bp0a, bp01a2);
		bp0a += di;
		if (bp00da[bp06] == 0xa)
			bp06++;
		//^24A5:091D
	}
	//^24A5:092C
	return;
}

//^2405:0029
U8 *SkWinCore::QUERY_GDAT_ITEM_NAME(U8 cls1, U8 cls2)
{
	//^2405:0029
	ENTER(34);
	//^2405:002D
	U8 bp22[30];
	U8 *bp04 = QUERY_GDAT_TEXT(cls1, cls2, 0x18, bp22);
	//^2405:004A
	return FORMAT_SKSTR(bp04, _4976_5290);
}

//^2405:005E
// _2405_005e renamed GET_ITEM_NAME
U8 *SkWinCore::GET_ITEM_NAME(ObjectID recordLink)
{
	//^2405:005E
	ENTER(6);
	//^2405:0064
	ObjectID di = recordLink;
	//^2405:0067
	U8 iCategory = QUERY_CLS1_FROM_RECORD(di);	// bp01
	//^2405:0071
	U8 iItemNumber = QUERY_CLS2_FROM_RECORD(di);	// bp02
	//^2405:007B
	glbChampionBonesIndex = 0xffff;
	//^2405:0081
	// SPX: If item is CHAMPION'S BONES
	if (iCategory == GDAT_CATEGORY_MISCELLANEOUS && iItemNumber == 0x00) { // (bp01 == 0x15 && bp02 == 0x00) ==> ITEM == BONES
		//^2405:008D
		Miscellaneous_item *bp06 = GET_ADDRESS_OF_RECORDA(di);
		//^2405:009A
		i16 si = bp06->Who();
		//^2405:00A9
		if (si >= 0 && si < glbChampionsCount) {
			//^2405:00B3
			glbChampionBonesIndex = si;
		}
	}
	//^2405:00B7
	return QUERY_GDAT_ITEM_NAME(iCategory, iItemNumber);
}

//^2405:02E8
// SPX: _2405_02e8 renamed DRAW_ITEM_ICON
void SkWinCore::DRAW_ITEM_ICON(ObjectID recordLink, i16 xx, U16 yy, U16 zz, U16 ww)
{
	//^2405:02E8
	ENTER(20);
	//^2405:02EE
	i16 si = xx;
	//^2405:02F1
	U8 bp0b;
	U8 bp0c;
	U8 bp09;
	if (recordLink == OBJECT_NULL) {
		//^2405:02F7
		bp0b = 7;
		bp0c = 0;
		//^2405:02FF
		bp09 = _4976_3b74[si].b2 +U8(yy);
	}
	else {
		//^2405:030D
		bp0b = QUERY_CLS1_FROM_RECORD(recordLink);
		bp0c = QUERY_CLS2_FROM_RECORD(recordLink);
		//^2405:0325
		bp09 = (si < 8)
			? _2405_014a(recordLink, si & 1, 1)
			: _2405_014a(recordLink, si -8, 1);
	}
	//^2405:0348
	U16 di = _4976_3b74[si].w0;
	//^2405:0351
	if (si < 0x26) {
		//^2405:0359
		SRECT bp14;
		QUERY_EXPANDED_RECT(di, &bp14);
		//^2405:0367
		U8 *bp04;
		if (si < 8) {
			//^2405:036C
			bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x01, 0x02, 0x00);
			//^2405:0380
			DRAW_ICON_PICT_BUFF(
				bp04,
				&_4976_3ff0,
				&bp14,
				bp14.x - _4976_3ff0.rc2.x,
				bp14.y - _4976_3ff0.rc2.y,
				-1,
				0,
                QUERY_GDAT_IMAGE_LOCALPAL(0x01, 0x02, 0x00)
				);
		}
		else {
			//^2405:03BD
			bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x07, 0x00, 0x00);
			//^2405:03D1
			DRAW_DIALOGUE_PICT(
				bp04,
				_4976_4c16,
				&bp14,
				bp14.x,
				bp14.y,
				-1,
				QUERY_GDAT_IMAGE_LOCALPAL(0x07, 0x00, 0x00)
				);
		}
	}
	//^2405:0404
	if (ww != 0 && si < 14) {
		//^2405:0415
		SRECT bp14;
		_2405_011f(di, &bp14);
		//^2405:0422
		U8 bp0a = (zz != 0)
			? 6
			: (yy != 0)
				? 5
				: 4;
		//^2405:043E
		U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x01, 0x02, bp0a);
		//^2405:0454
		U8 *bp08 = QUERY_GDAT_IMAGE_LOCALPAL(0x01, 0x02, bp0a);
		//^2405:046A
		if (si < 8) {
			//^2405:046F
			DRAW_ICON_PICT_BUFF(
				bp04,
				&_4976_3ff0,
				&bp14,
				0,
				0,
				12,
				0,
				bp08
				);
		}
		//^2405:0496
		DRAW_DIALOGUE_PARTS_PICT(
			bp04,
			&bp14,
			12,
			bp08
			);
	}
	//^2405:04B1
	if (bp09 == 0xff)
		//^2405:04B5
		return;
	//^2405:04B7
	if (si < 8) {
		//^2405:04BC
		DRAW_ICON_PICT_ENTRY(
			bp0b,
			bp0c,
			bp09,
			&_4976_3ff0,
			di,
			12
			);
	}
	else {
		//^2405:04D9
		DRAW_STATIC_PIC(
			bp0b,
			bp0c,
			bp09,
			di,
			12
			);
	}
	//^2405:04F0
	return;
}

//^24A5:0AD2
// SPX: _24a5_0ad2 renamed DRAW_CONTAINER_SURVEY
void SkWinCore::DRAW_CONTAINER_SURVEY(Container *ref)
{
	//^24A5:0AD2
	ENTER(0);
	//^24A5:0AD7
	U16 si = 0;
	//^24A5:0AD9
	//^24A5:0AE0
	for (ObjectID di = ref->GetContainedObject(); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di), si++) {
		//^24A5:0AE2
		if (si >= 8)	// 8 = MAX items in container (CHEST / BAG / QUIVER)
			//^24A5:0AE5
			break;
		//^24A5:0AE7
		DRAW_ITEM_ICON(di, si +47, 0, 0, 0);
		//^24A5:0AFC
	}
	//^24A5:0B0B
	return;
}

//^0CEE:2773
U16 SkWinCore::IS_MISCITEM_CURRENCY(ObjectID rl)
{
	//^0CEE:2773
	ENTER(0);
	//^0CEE:2776
	if (true
		&& rl.DBType() == dbMiscellaneous_item
		&& (QUERY_GDAT_DBSPEC_WORD_VALUE(rl, GDAT_ITEM_STATS_GEN_FLAGS) & ITEM_FLAG_CURRENCY) != 0		// flags_currency = 0x4000
	) {
		//^0CEE:2794
		return 1;
	}
	//^0CEE:2799
	return 0;
}

//^0CEE:279D
void SkWinCore::COUNT_BY_COIN_TYPES(ObjectID rlMoneybox, i16 *piCount)
{
	//^0CEE:279D
	ENTER(2);
	//^0CEE:27A3
	ZERO_MEMORY(piCount, MONEY_ITEM_MAX*2);	// SPX: original 20 = 10*2
	//^0CEE:27B5
	for (ObjectID si = GET_ADDRESS_OF_RECORD9(rlMoneybox)->GetContainedObject(); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^0CEE:27C7
		if (IS_MISCITEM_CURRENCY(si) == 0)
			//^0CEE:27CF
			continue;
		//^0CEE:27D1
		U16 bp02 = GET_DISTINCTIVE_ITEMTYPE(si);
		//^0CEE:27DA
		for (i16 di = 0; di < glbCountMoneyItems; di++) {
			//^0CEE:27DE
			if (glbMoneyItemsIDTable[di] == bp02) {
				//^0CEE:27EB
				piCount[di] += GET_ADDRESS_OF_RECORDA(si)->Charge() +1;
			}
			//^0CEE:2809
		}
		//^0CEE:2810
	}
	//^0CEE:281D
	return;
}

//^48AE:04B7
i16 SkWinCore::GET_ITEM_ORDER_IN_CONTAINER(ObjectID rl, i16 xx)
{
	// if rl is money-box:
	//  xx=0, return 5. (6th expensive coin BLUE-GEM)

	//^48AE:04B7
	ENTER(142);
	//^48AE:04BD
	U8 bp008e[128];
	U8 *bp0e = QUERY_GDAT_TEXT(GDAT_CATEGORY_CONTAINERS, QUERY_CLS2_FROM_RECORD(rl), 0x40, bp008e);
    //^48AE:04E3
	if (*bp0e == 0)
		//^48AE:04E9
		//^48AE:05A7
		return -1;
	//^48AE:04EC
	U16 bp02 = 0;
	U16 di = 0;
	U16 bp08 = 0;
	//^48AE:04F6
	i16 si = -1;
	i16 bp04 = -1;

	while (bp02 == 0) {
		//^48AE:04F9
		U8 bp09 = *(bp0e++);
		//^48AE:0505
		if (bp09 >= '0' && bp09 <= '9') {
			//^48AE:050F
			di = di * 10 +bp09 -'0';
			//^48AE:0522
			continue;
		}
		//^48AE:0524
		switch (bp09) {
			case 'J':
				{
					//^48AE:0539
					if (di != 0) {
						//^48AE:053D
						bp0e--;
						//^48AE:0540
						break;
					}
                    //^48AE:0542
					bp04 = 256;
					//^48AE:0547
					continue;
				}
			case '-':
				{
					//^48AE:0549
					si = di;
					di = 0;
					//^48AE:054D
					continue;
				}
			case 0x00:
				{
					//^48AE:054F
					bp02 = 1;

					break;
				}
		}
		//^48AE:0554
		if (si < 0)
			si = di;
		//^48AE:055A
		for (; si <= di; bp08++, si++) {
			//^48AE:055C
			if (bp08 == xx) {
				//^48AE:0564
				for (i16 bp06 = 0; bp06 < glbCountMoneyItems; bp06++) {
					//^48AE:056B
					if (glbMoneyItemsIDTable[bp06] == si +bp04) {
						//^48AE:057B
						return bp06;
					}
					//^48AE:0580
				}
			}
			//^48AE:058C
		}
		//^48AE:0594
		di = 0;
		//^48AE:0596
		si = bp04 = -1;
		//^48AE:059E
	}
	//^48AE:05A7
	return -1;
}

//^0CAF:014D
U8 *SkWinCore::SK_LTOA10(i32 value, U8 *str)
{
	//^0CAF:014D
	ENTER(22);
	//^0CAF:0151
	i32 bp08 = value;
	//^0CAF:015D
	if (bp08 < 0) {
		//^0CAF:0167
		bp08 = -bp08;
	}
	//^0CAF:017A
	U8 bp16[14];
	U8 *bp04 = &bp16[13];
	//^0CAF:0183
	bp04[0] = 0;

	do {
		//^0CAF:018A
		bp04--;
		//^0CAF:018D
		*bp04 = (bp08 % 10) + '0';
		//^0CAF:01A4
		bp08 = bp08 / 10;
		//^0CAF:01B9
	} while (bp08 != 0);
	//^0CAF:01BD
	if (value < 0) {
		//^0CAF:01CB
		*(--bp04) = '-';
	}
	//^0CAF:01D5
	return SK_STRCPY(str, bp04);
}

//^24A5:0A06
// SPX _24a5_0a06 renamed MONEY_BOX_SURVEY
// This function will crash if more items are flagged "currency" than possible max (default = 10) (or increase MONEY_ITEM_MAX)
void SkWinCore::MONEY_BOX_SURVEY(ObjectID recordLink)
{
	//^24A5:0A06
	ENTER(36);
	//^24A5:0A0C
	i32 totalAmount = 0;	//bp06
	//^24A5:0A16
	i16 moneyTable[MONEY_ITEM_MAX];	//bp24[10]
	COUNT_BY_COIN_TYPES(recordLink, moneyTable);
	//^24A5:0A26
	U16 bp02 = 618;
	//^24A5:0A2B
	U8 bp10[10];
	for (i16 si = 0; si < MONEY_ITEM_MAX; si++) {
		//^24A5:0A2F
		i16 di = GET_ITEM_ORDER_IN_CONTAINER(recordLink, si);
		//^24A5:0A3C
		if (di >= 0) {
			//^24A5:0A40
			totalAmount += moneyTable[di] * glbMoneyItemsValueTable[di];
			//^24A5:0A65
			DRAW_VP_RC_STR(
				bp02++,
				glbPaletteT16[COLOR_LIGHTER_GRAY],
				SK_LTOA10(moneyTable[di], bp10)
				);
		}
		//^24A5:0A9D
	}
	//^24A5:0AA3
	DRAW_VP_RC_STR(
		569,
		glbPaletteT16[COLOR_LIGHTER_GRAY],
		SK_LTOA10(totalAmount, bp10)
		);
	//^24A5:0ACE
	return;
}

//^2759:0155
U16 SkWinCore::_2759_0155(ObjectID rl)
{
	//^2759:0155
	ENTER(4);
	//^2759:015A
	ObjectID si = rl;
	//^2759:015D
	if (si == OBJECT_NULL) {
		//^2759:0160
		//^2759:01DE
		return 0;
	}
	//^2759:0162
	U8 bp01 = QUERY_CLS1_FROM_RECORD(si);
	U8 bp02 = QUERY_CLS2_FROM_RECORD(si);
	U8 bp03 = 0x08;
	//^2759:017A
	for (; bp03 < 12; bp03++) {
		//^2759:017C
		if (true
			&& QUERY_GDAT_ENTRY_IF_LOADABLE(bp01, bp02, dtText, bp03) != 0
			&& QUERY_CMDSTR_ENTRY(bp01, bp02, bp03, CnCM) != 0
			&& QUERY_CMDSTR_ENTRY(
				QUERY_CLS1_FROM_RECORD(si),
				QUERY_CLS2_FROM_RECORD(si),
				bp03,
				CnNC
				) != 0
		) {
			//^2759:01D0
			return 1;
		}
		//^2759:01D5
	}
	//^2759:01DE
	return 0;
}

//^24A5:0B0F
// SPX: _24a5_0b0f renamed DRAW_ITEM_STATS_BAR
void SkWinCore::DRAW_ITEM_STATS_BAR(U16 rectno, i16 curVal, i16 maxVal, U8 chr, U16 color)
{
	//^24A5:0B0F
	ENTER(10);
	//^24A5:0B14
	i16 si = curVal;
	//^24A5:0B17
	SRECT bp08;
	// bp08: x
	// bp06: y
	// bp04: cx
	// bp02: cy
	if (QUERY_EXPANDED_RECT(rectno, &bp08) == 0)
		//^24A5:0B2B
		//^24A5:0C32
		return;
	//^24A5:0B2E
	si = (i32(si) << 11) / maxVal;
	//^24A5:0B47
	DRAW_POWER_STAT_BAR(si, rectno, color, 0, 1);
	//^24A5:0B5A
	U8 bp0a[2];
	bp0a[1] = 0;
	bp0a[0] = chr;	// Will be the rune associated with the power bar, i.e. KU for weapon
	//^24A5:0B64
	bp08.cy -= 2;
	//^24A5:0B68
	DRAW_STRONG_TEXT(
		_4976_4c16,
		-1,
		_4976_00f6,
		bp08.x -9,
		bp08.y +bp08.cy,
		glbPaletteT16[color],
		glbPaletteT16[COLOR_BLACK] | 0x4000,
		bp0a
		);
	//^24A5:0BA8
	bp0a[0] = RUNE_LO;	// 0x60
	//^24A5:0BAC
	DRAW_STRONG_TEXT(
		_4976_4c16,
		-1,
		_4976_00f6,
		bp08.x +3,
		bp08.y +bp08.cy -1,
        glbPaletteT16[COLOR_WHITE],
		glbPaletteT16[COLOR_BLACK] | 0x4000,
		bp0a
		);
	//^24A5:0BEA
	bp0a[0] = RUNE_MON;	// 0x65
	//^24A5:0BEE
	DRAW_STRONG_TEXT(
		_4976_4c16,
		-1,
		_4976_00f6,
		bp08.x +bp08.cx -1 - _4976_011e -1,
		bp08.y +bp08.cy -1,
		glbPaletteT16[COLOR_WHITE],
		glbPaletteT16[COLOR_BLACK] | 0x4000,
		bp0a
		);
	//^24A5:0C32
	return;
}

//^24A5:0C35
U16 SkWinCore::DRAW_ITEM_SURVEY(ObjectID recordLink, Bit16u xx)
{
	// You click eye icon with the item which you wanna know about, in item inventory.

	//^24A5:0C35
	ENTER(148);
	//^24A5:0C3B
	ObjectID si = recordLink;
	//^24A5:0C3E
	ItemStatBarPos bp0e = glbItemStatBarPos;
	//^24A5:0C4F
	if (si == OBJECT_NULL)
		//^24A5:0C54
		return 0;
	//^24A5:0C59
	GenericRecord *_bp04 = GET_ADDRESS_OF_RECORD(si);
	//^24A5:0C66
	DRAW_GUIDED_STR(_4976_3d7d);
	//^24A5:0C70
	U16 bp08 = si.DBType();
	//^24A5:0C7B
	if (bp08 == dbScroll) {
		//^24A5:0C80
		DRAW_SCROLL_TEXT(si);
		//^24A5:0C86
		//^24A5:0E7B
		return 1;
	}
	//^24A5:0C89
	glbInventorySubpanel = 3;
	//^24A5:0C8F
	if (xx == 0) {
		//^24A5:0C95
		//^24A5:0C54
		return 0;
	}
	//^24A5:0C97
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, 0x01, 0x01ee, -1);
	//^24A5:0CAA
	U8 bp09;
	U8 bp0a;
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(
		bp09 = QUERY_CLS1_FROM_RECORD(si),
		bp0a = QUERY_CLS2_FROM_RECORD(si),
		dtImage,
		0x11
		) != 0
	) {
		//^24A5:0CD0
		DRAW_STATIC_PIC(bp09, bp0a, 0x11, 0x01ee, 12);
	}
	//^24A5:0CE7
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, 0x05, 0x01f8, 12);
	//^24A5:0CFA
	DRAW_VP_RC_STR(0x1fa, glbPaletteT16[COLOR_LIGHTER_GRAY], GET_ITEM_NAME(si));
	//^24A5:0D19
	DRAW_ITEM_ICON(si, 0x2e, 0, 0, 0);
	//^24A5:0D2A
	U16 bp06 = QUERY_ITEM_WEIGHT(si);
	//^24A5:0D34
	glbItemWeightKg = bp06 / 10;
	//^24A5:0D3E
	glbItemWeightDg = bp06 % 10;
	//^24A5:0D49
	U8 bp0094[128];
    DRAW_GUIDED_STR(QUERY_GDAT_TEXT(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, 0x1f, bp0094));			
	//^24A5:0D65
	if (bp08 == dbContainer) {
		//^24A5:0D6B
		if (IS_CONTAINER_CHEST(si) != 0) {
			//^24A5:0D76
			DRAW_CONTAINER_SURVEY(_bp04->castToContainer());
			//^24A5:0D82
			//^24A5:0E7B
			return 1;
		}
		//^24A5:0D85
		if (IS_CONTAINER_MONEYBOX(si) == 0) {
			//^24A5:0D90
			//^24A5:0E7B
			return 1;
		}
		//^24A5:0D93
		MONEY_BOX_SURVEY(si);	//
		//^24A5:0D99
		return 1;
	}
	//^24A5:0D9C
	U16 bp10 = 0;
	//^24A5:0DA1
	if (_2759_0155(si) != 0) {
		//^24A5:0DAC
		i16 di = ADD_ITEM_CHARGE(si, 0);
		//^24A5:0DB8
		if (di != 0) {
			//^24A5:0DBC
			DRAW_ITEM_STATS_BAR(
				bp0e.pos[bp10++],
				di,
				GET_MAX_CHARGE(si),
				RUNE_GOR,
				COLOR_CYAN
				);
		}
	}
//--- SPX: Info about the power bars displayed for items
// For weapons, power is displayed either using STRENGTH value (KU symbol) or THROW value (ROS symbol) for missiles such as arrows and shooters such as bows.
//	Clothings and armours also display a KU symbol for their armour strength.
//	A potion have a NETA symbol for its power level.
//	These bars are displayed in BROWN color.

//	An item with charges will have a CYAN GOR bar with the number of remaining charges


	//^24A5:0DE0
	U8 rune;		// bp11 This holds the rune to be displayed along the power bar
	U16 max;	//bp14
	i16 value;		//di
	switch (si.DBType()) {
		case dbPotion: // 8
			{
				Potion *bp04 = _bp04->castToPotion();

				//^24A5:0DFA
				rune = RUNE_NETA;
				//^24A5:0DFE
				value = bp04->PotionPower();
				//^24A5:0E0A
				max = 0x00ff;
				//^24A5:0E0F
				break;
			}
		case dbWeapon: // 5
			{
				//^24A5:0E11
				rune = RUNE_KU;
				max = 0x0050;
				//^24A5:0E1A
				value = QUERY_GDAT_DBSPEC_WORD_VALUE(si, GDAT_ITEM_WEAPON_MELEE_STRENGTH);		//SPX: 0x08 Attack strength
				//^24A5:0E26
				if (value == 0) {
					//^24A5:0E2A
					value = QUERY_GDAT_DBSPEC_WORD_VALUE(si, GDAT_ITEM_WEAPON_THROW_STRENGTH);	//SPX: 0x09 Throw strength
					//^24A5:0E36
					rune = RUNE_ROS;
					max = 0x0064;
				}
				//^24A5:0E3F
				break;
			}
		case dbCloth: // 6
			{
				//^24A5:0E41
				rune = RUNE_KU;
				if (SkCodeParam::bUseDM2ExtendedMode)
					rune = RUNE_YA;
				//^24A5:0E45
				value = QUERY_GDAT_DBSPEC_WORD_VALUE(si, GDAT_ITEM_STATS_ARMOR_CLASS) & 0xff;	//SPX: 0x0B Armor value
				//^24A5:0E54
				max = 0x00c8;
				break;	// SPX: fixed here this missing break
			}
		default:
			{
				//^24A5:0DF7
				//^24A5:0E7B
				value = 0;
				//return 1;
			}
	}
	//^24A5:0E59
	// SPX: Original behaviour
	if (!SkCodeParam::bUseDM2ExtendedMode) {
		if (value != 0) {
			//^24A5:0E5D
			DRAW_ITEM_STATS_BAR(bp0e.pos[bp10], value, max, rune, COLOR_BROWN);
		}
	}
	// SPX: little modif to have different colors
	else if (SkCodeParam::bUseDM2ExtendedMode && value != 0)
	{
		U16 color = COLOR_BROWN;
		switch (rune)
		{
			case RUNE_KU:	// Hand to hand weapon
				color = COLOR_RED;
				break;
			case RUNE_ROS:	// Projectile weapon
				color = COLOR_ORANGE;
				break;
			case RUNE_NETA:	// Potion
				color = COLOR_BLUE;
				break;
		}
		DRAW_ITEM_STATS_BAR(bp0e.pos[bp10], value, max, rune, color);
	}

//--- NEW CODE -------------------------------------
	// SPX: Added code to display hidden stats such as magical bonuses
	if (SkCodeParam::bUseSuperInfoEye)
	{
		char str[32];
		Bit16u	yy = 95;
		i32	itemValue = 0;
		i16 statValue = 0;
		U8 strMoneyValue[11];
		U8* pstr;

		if (!SkCodeParam::bUseDM2ExtendedMode)
			return 1;

		printf("Number of charges = %d\n", ADD_ITEM_CHARGE(si, 0));

		// Money value
		memset(strMoneyValue, 0, 10);
		statValue = QUERY_GDAT_DBSPEC_WORD_VALUE(si, GDAT_ITEM_STATS_MONEY_VALUE);
		itemValue += statValue;
		statValue = QUERY_GDAT_DBSPEC_WORD_VALUE(si, GDAT_ITEM_BONUS_MONEY_PER_CHARGE);
		itemValue += (statValue * ADD_ITEM_CHARGE(si, 0));
		SK_LTOA10(itemValue, strMoneyValue);
		pstr = strMoneyValue;
		while (*pstr != 0)
			pstr++;
		*pstr = '$';
		
		DRAW_VP_RC_STR(
			569,
			glbPaletteT16[COLOR_YELLOW],
			strMoneyValue
			);

		if ( bp10 != 0 || value != 0)
			yy += 2;
		yy += ((bp10 + (value != 0 ? 1 : 0))*12);
		
		// Bonus display
		for (U8 bonus = GDAT_ITEM_STATS_FOOD_VALUE; bonus <= GDAT_ITEM_STATS_MISSILE_SPELL; bonus++)
		{
			if (bonus == GDAT_ITEM_STATS_EQUIP_FLAGS
				|| bonus == GDAT_ITEM_STATS_ANIM_FLAGS
				|| bonus == GDAT_ITEM_STATS_ARMOR_CLASS
				|| bonus == GDAT_ITEM_WEAPON_PROJECTILE_FLAG
				|| bonus == GDAT_ITEM_WEAPON_MELEE_STRENGTH)
				continue;
			value = QUERY_GDAT_DBSPEC_WORD_VALUE(si, bonus);
			if (value != 0)
			{
				char sign = '+';
				if (value < 0)
				{
					sign = '-';
					value = -value;
				}
				sprintf(str, "%c%d %s", sign, value, getStatBonusName(bonus));
				DRAW_STRONG_TEXT(
					_4976_4c16,
					-1,
					_4976_00f6,
					100,
					yy,
					glbPaletteT16[COLOR_WHITE],
					glbPaletteT16[COLOR_BLACK] | 0x4000,
					(Bit8u*) str
					);
				yy += 7;
			}
		}
	} // SPX: End of hidden stats block

	//^24A5:0E7B
	return 1;
}

//^2E62:03B5
U16 SkWinCore::_2e62_03b5(Bit16u player, Bit16u itemNo, Bit16u yy)
{
	//^2E62:03B5
	ENTER(8);
	//^2E62:03BB
	U16 bp04 = 0;
	U16 bp06 = 0;
	//^2E62:03C5
	U16 bp08 = yy;
	//^2E62:03CB
	U16 si;
	if (player +1 != glbChampionInventory) {
		//^2E62:03D5
		if (itemNo > INVENTORY_HAND_LAST || player +1 == glbNextChampionNumber)
			//^2E62:03E5
			//^2E62:056C
			return 0;
		//^2E62:03E8
		si = (player << 1) + itemNo;
	}
	else {
		//^2E62:03F2
		si = itemNo +8;
	}
	//^2E62:03FA
	ObjectID di = glbChampionSquad[player].Possess(itemNo);
	//^2E62:040F
	if (itemNo <= INVENTORY_HAND_LAST) {	// <= 1
		//^2E62:0415
		if (player +1 == glbChampionIndex && itemNo == glbSelectedHandAction)
			//^2E62:0428
			bp04 = 1;
		//^2E62:042D
		if ((!_4976_3b74[si].b5_0_0()) != (!bp04)) {
			//^2E62:044B
			bp08 = 1;
			//^2E62:0450
			_4976_3b74[si].b5 ^= 1;
		}

	}
	//^2E62:045A
	if (itemNo <= INVENTORY_BODYPART_LAST) {	// <= 5
		//^2E62:0460
		if ((glbChampionSquad[player].bodyFlag & (1 << itemNo)) != 0)
			//^2E62:0478
			bp06 = 1;
		//^2E62:047D
		if ((!_4976_3b74[si].b5_1_1()) != (!bp06)) {
			//^2E62:049B
			bp08 = 1;
			//^2E62:04A0
			_4976_3b74[si].b5 ^= 2;
		}
	}
	//^2E62:04AA
	if (di != OBJECT_NULL) {
		//^2E62:04AF
		U8 bp01;
		if ((QUERY_GDAT_DBSPEC_WORD_VALUE(di, 0x00) & 0x8000) != 0) {
			//^2E62:04BE
			bp01 = _2405_014a(di, itemNo, 1);
		}
		else {
			//^2E62:04C2
			bp01 = _2405_014a(di, itemNo, 0);
		}
        //^2E62:04D3
		if (_4976_3b74[si].b3 != bp01) {
			//^2E62:04E1
			yy = 1;
			//^2E62:04E6
			_4976_3b74[si].b3 = bp01;
		}
		//^2E62:04F2
		U8 bp02 = QUERY_CLS2_FROM_RECORD(di);
		//^2E62:04FC
		if (bp02 != _4976_3b74[si].b4) {
			//^2E62:0507
			yy = 1;
			//^2E62:050C
			_4976_3b74[si].b4 = bp02;
		}
	}
	//^2E62:0515
	if (yy != 0 || bp08 != 0 || _4976_3b74[si].w6 != di) {
		//^2E62:052C
		if (di == 0xffff || si < 8)
			//^2E62:0536
			bp08 = 1;
		//^2E62:053B
		if (si < 8) {
			//^2E62:0540
			DRAW_PLAYER_3STAT_PANE(player, 0);
		}
		//^2E62:054B
		_4976_3b74[si].w6 = di;
		//^2E62:0554
		DRAW_ITEM_ICON(di, si, bp06, bp04, bp08);
		//^2E62:0567
		return 1;
	}
	//^2E62:056C
	return 0;
}

//^3929:0C37
void SkWinCore::DRAW_LOCAL_TEXT(Bit16u rectno, Bit16u clr1, Bit16u clr2, Bit8u *str)
{
	// draw local positioned text.
	// a) health, mana and stamina: "770/770"

	//^3929:0C37
	ENTER(12);
	//^3929:0C3B
	i16 bp02;
	i16 bp04;
	if (QUERY_STR_METRICS(str, &bp02, &bp04) != 0) {
		//^3929:0C56
		SRECT bp0c;
		if (QUERY_BLIT_RECT(NULL, &bp0c, rectno, &bp02, &bp04, -1) != 0)
		{
			//^3929:0C7A
			// SPX: Note, the bp0c.y does not match exactly the character sheet. (for static texts)
			// The charsheet image can be changed.
			bp0c.y -= 1;
			DRAW_STRONG_TEXT(
				_4976_4c16,
				-1,
				_4976_00f6,
				bp0c.x,
				bp0c.y +bp0c.cy,
				clr1,
				clr2,
				str
				);
		}
	}
	//^3929:0CA6
	return;
}

//^2C1D:0EA2
U16 SkWinCore::GET_PLAYER_ABILITY(Champion *ref, U16 parm7, U16 getMax)
{
	//^2C1D:0EA2
	ENTER(2);
	//^2C1D:0EA8
	//SPX: Get attribute parm7, getMax = 0 : current / getMax = 1 : max
	i16 si = ref->attributes[parm7][getMax];
	//^2C1D:0EBD
	U16 di;
	U8 bp01;
	if (true
		&& (getMax == 0)
		&& (di = ref->enchantmentPower) != 0
		&& (bp01 = ref->enchantmentAura) >= ENCHANTMENT_AURA_FIRST
		&& (bp01) <= ENCHANTMENT_AURA_LAST
		&& (bp01 + i16(-2)) == parm7
	) {
		//^2C1D:0EED
		if (di > 100)
			//^2C1D:0EF2
			di = 100;
		//^2C1D:0EF5
		si += RAND16(((si * di) >> 7) +1) +4;
	}
	//^2C1D:0F09
	return BETWEEN_VALUE(10, si +(ref->attributesEnhanced[parm7]), 220);
}

//^0CD5:0018
void SkWinCore::FILL_STR(Bit8u *buff, Bit16u count, Bit8u value, Bit16u delta)
{
	//^0CD5:0018
	//^0CD5:0021
	for (Bit16u si = 0, di = 0; di < count; si += delta, di++) {
		buff[si] = value;
	}
}

//^2E62:0265
U8 *SkWinCore::FMT_NUM(U16 value, U16 clean, U16 keta)
{
	//^2E62:0265
	ENTER(6);
	//^2E62:026A
	U16 si = value;
	//^2E62:026D
	if (clean != 0) {
		//^2E62:0273
		FILL_STR(glbStrBufferNumber, 4, ' ', 1);
	}
	//^2E62:0285
	U8 *bp04 = &glbStrBufferNumber[4];
	//^2E62:028D
	*bp04 = 0;
	//^2E62:0294
	if (si == 0) {
		//^2E62:0298
		*(--bp04) = '0';
		//^2E62:02A2
	}
	else {
		//^2E62:02C5
		U16 bp06;
		while ((bp06 = si) != 0) {
			//^2E62:02A4
			bp04--;
			//^2E62:02A7
			si = si / 10;
			//^2E62:02B2
			*bp04 = U8(bp06) + '0' -(si * 10);
			//^2E62:02C5
		};
	}
	//^2E62:02CE
	if (clean != 0) {
		//^2E62:02D4
		return &glbStrBufferNumber[4 - keta];
	}
	//^2E62:02E1
	return bp04;
}

//^0CAF:00A4
U8 *SkWinCore::SK_STRCPY(U8 *strTo, const U8 *strFrom) {
	return reinterpret_cast<U8 *>(strcpy(reinterpret_cast<char *>(strTo), reinterpret_cast<const char *>(strFrom)));
}

//^0CAF:0032
U8 *SkWinCore::SK_STRCAT(U8 *strTo, const U8 *strFrom) {
	return reinterpret_cast<U8 *>(strcat(reinterpret_cast<char *>(strTo), reinterpret_cast<const char *>(strFrom)));
}

//^24A5:1532
// SPX: _24a5_1532 replaced by DRAW_SKILL_PANEL
void SkWinCore::DRAW_SKILL_PANEL()
{
	//^24A5:1532
	ENTER(144);
	//^24A5:1538
	U16 di = glbChampionInventory -1;
	//^24A5:153E
	Champion *bp04 = &glbChampionSquad[di];
	//^24A5:154C
	glbInventorySubpanel = 2;
	//^24A5:1552
	DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, 0x01, 494, -1);	// blank stone panel
	//^24A5:1565
	i16 bp0c;
	i16 bp10;
	QUERY_TOPLEFT_OF_RECT(557, &bp0c, &bp10);
	//^24A5:157A
	U8 bp0090[128];
	U16 bp06;

	if (SkCodeParam::bUseSuperInfoEye && SkCodeParam::bUseDM2ExtendedMode)
	{
		glbPanelStatsYDelta = 6;		// Instead of 7, it is Y delta between each attribute text string
	}

	for (bp06 = 0; bp06 <= 3; bp06++) {
		//^24A5:1582
		i16 si = min_value(SkLvlArchmaster, QUERY_PLAYER_SKILL_LV(di, bp06, 1));	// skill level caped 16
		//^24A5:159C
		if (si != SkLvlNone) {	// (si != 1)
			//^24A5:15A1
			_4976_52e4 = bp06;
			//^24A5:15A7
			QUERY_GDAT_TEXT(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00
				, tSkillLevelNameGDAT2Entry[RCJ(15,si -SkLvlNeophyte)], bp0090);	// [RCJ(15,si -2)]
			//^24A5:15BE
			DRAW_VP_STR(bp0c, bp10, glbPaletteT16[(glbChampionMajorSkillsLevel[di][bp06] != 0) ? COLOR_LIGHT_GREEN : COLOR_LIGHTER_GRAY], bp0090);
			//^24A5:15F5
			glbChampionTable->lastName[9 +bp06] = glbChampionMajorSkillsLevel[di][bp06];
			//^24A5:1608
			bp10 += glbPanelStatsYDelta;
		}
		//^24A5:160E
	}

	//^24A5:161A
	i16 bp0e;
	QUERY_TOPLEFT_OF_RECT(559, &bp0e, &bp10);
	//^24A5:162F
	// SPX: Display attributes (STR, DEX, WIS, VIT, AF, AM)
	// SPX: The first is luck; the GDAT2 resource 07-00 20-00-00 (TXT) must be defined as "LUCK".
	U16 attributeStart = ATTRIBUTE_FIRST+1;	// Start at 1=STR
	if (SkCodeParam::bUseSuperInfoEye && SkCodeParam::bUseDM2ExtendedMode)
	{
		attributeStart = ATTRIBUTE_FIRST;	// Start at 0=LUCK
	}

	for (bp06 = attributeStart; bp06 <= ATTRIBUTE_LAST; bp06++) {
		//^24A5:1637
		DRAW_VP_STR(
			bp0c,
			bp10,
			glbPaletteT16[COLOR_LIGHTER_GRAY],
			QUERY_GDAT_TEXT(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, bp06 +0x20, bp0090)
			);
		//^24A5:166A
		U16 si = GET_PLAYER_ABILITY(bp04, bp06, 0);			// Current
		//^24A5:167F
		U16 bp0a = GET_PLAYER_ABILITY(bp04, bp06, 1);		// Max
		//^24A5:1695
		U16 bp08 = (si < bp0a) ? 8 : ((si > bp0a) ? 7 : 13);
		// SPX: 8 = red, 7 = green, 13 = grey
		//^24A5:16B2
		DRAW_VP_STR(
			bp0e,
			bp10,
			glbPaletteT16[bp08],
			FMT_NUM(si, 1, 3)
			);
		//^24A5:16DC
		//SK_STRCPY(bp0090, &_4976_3d7f);	// SPX: What's this? We do want to concat /
		SK_STRCPY(bp0090, strSlash);		// SPX: Fixed version with /
		//^24A5:16EE
		SK_STRCAT(bp0090, FMT_NUM(bp0a, 1, 3));
		//^24A5:170D
        DRAW_VP_STR(
			_4976_0126 * 3 +bp0e,
			bp10,
			glbPaletteT16[COLOR_LIGHTER_GRAY],
			bp0090
			);
		//^24A5:1737
		bp10 += glbPanelStatsYDelta;
		//^24A5:173D
	}
	//^24A5:1749
	return;
}

//^2E62:0670
void SkWinCore::REFRESH_PLAYER_STAT_DISP(i16 player)
{
	//^2E62:0670
	ENTER(164);
	//^2E62:0676
	Bit16u bp14 = 0;
	Bit16u bp16 = 0;
	Bit16u bp18 = 0;
	Bit16u bp1a = 0;
	Bit16u bp1c = 0;
	//^2E62:068F
	Champion *champion = &glbChampionSquad[player];	//*bp04
	//^2E62:06A0
	Bit16u si = champion->heroFlag;
	//^2E62:06A7
	Bit16u bp08 = (player +1 == glbChampionInventory) ? 1 : 0; // 1=draw entire inventory panel
	//^2E62:06BB
	if (bp08 != 0 && _4976_022c != 0)
		//^2E62:06C6
		si |= 0x8000;
	//^2E62:06CA
	if (glbChampionInventory != glbLastChampionInventory || (si & 0x8000) != 0) {
		//^2E62:06D9
		if (bp08 != 0) {
			//^2E62:06DF
			DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, 0x00, 0x04, -1);	// char sheet general screen
			//^2E62:06F1
			bp1c = 1;
			bp18 = 1;
			//^2E62:06FB
			glbLastChampionInventory = glbChampionInventory;
			//^2E62:0701
			bp14 = 15;
			//^2E62:0706
			si |= 0x7c00;
		}
		else {
			//^2E62:070C
			glbLastChampionInventory = 0;
		}
	}
	//^2E62:0714
	else if (bp08 != 0) {
		//^2E62:071A
		bp14 = _4976_581a ^ _4976_5804;
	}
	//^2E62:0724
	if (bp14 != 0) {
		//^2E62:072A
		if (glbNextChampionNumber == 0) {
			//^2E62:0731
			if ((bp14 & 1) != 0) {
				//^2E62:0738
				DRAW_CHARSHEET_OPTION_ICON(0x0013, 0x0267, 0x0001);	// 0x13: char name bar
			}
			//^2E62:074A
			if ((bp14 & 8) != 0) {
				//^2E62:0751
				DRAW_CHARSHEET_OPTION_ICON(0x000f, 0x0232, 0x0008);	// 0x0F: blue diskette
			}
			//^2E62:075F
			if ((bp14 & 4) != 0) {
				//^2E62:0766
				DRAW_CHARSHEET_OPTION_ICON(0x000d, 0x0234, 0x0004);	// 0x0D: Zzz
			}
		}
		//^2E62:0774
		if ((bp14 & 2) != 0) {
			//^2E62:077B
			DRAW_CHARSHEET_OPTION_ICON(0x000b, 0x0236, 0x0002);		// 0x0B: Cancel red cross

		}
		//^2E62:0789
		bp18 = 1;
		//^2E62:078E
		_4976_5804 = _4976_581a;
	}
	//^2E62:0794
	if ((si & 0x4000) != 0) {
		//^2E62:079A
		DRAW_PLAYER_3STAT_PANE(player, 1);
		//^2E62:07A5
		bp1a = 1;
		//^2E62:07AA
		if (champion->curHP() != 0) {
			//^2E62:07B4
			if (bp08 != 0) {
				//^2E62:07BA
				DRAW_CHAMPION_PICTURE(player);
				//^2E62:07C2
				si |= 0x0800;
			}
			else {
				//^2E62:07C8
				si |= 0x0c00;
			}
			//^2E62:07CC
			bp16 = 1;
		}
		else {
			//^2E62:07D3
			DRAW_NAME_STR(
				&_4976_3ff0,
				player +165,
				glbPaletteT16[COLOR_WHITE],
				glbPaletteT16[COLOR_DARK_GRAY] |0x4000,
				champion->firstName
				);
		}
	}
	//^2E62:0801
	if (champion->curHP() != 0) {
		//^2E62:080E
		if ((si & 0x0800) != 0) {	// Refresh stats bar
			//^2E62:0817
			DRAW_PLAYER_3STAT_PANE(player, 0);
			//^2E62:0822
			bp1a = 1;
			//^2E62:0827
			DRAW_PLAYER_3STAT_HEALTH_BAR(player);
			//^2E62:082F
			if (champion->timerIndex != TIMER_NONE) {
				//^2E62:0839
				DRAW_PLAYER_DAMAGE(player);
			}
			//^2E62:0841
			if (bp08 != 0) {
				//^2E62:084A
				SRECT bp24;
				QUERY_EXPANDED_RECT(549, &bp24);
				//^2E62:085A
				DRAW_DIALOGUE_PICT(
					QUERY_GDAT_IMAGE_ENTRY_BUFF(0x07, 0x00, 0x00),
					_4976_4c16,
					&bp24,
					bp24.x,
					bp24.y,
					-1,
					QUERY_GDAT_IMAGE_LOCALPAL(0x07, 0x00, 0x00)
					);
				//^2E62:0897
				DRAW_PLAYER_3STAT_TEXT(champion);
				//^2E62:08A3
				// SPX: bp0d holds the color number (rectangle?) around the mouth or eye.
				Bit8u colorRectangle; //bp0d;
#if (DM2_EXTENDED_MODE == 0)
				if (champion->curFood() < 0 || champion->curWater() < 0 || champion->PoisonValue != 0) {
#elif (DM2_EXTENDED_MODE == 1)
				if (champion->curFood() < 0 || champion->curWater() < 0 || champion->PoisonValue != 0 || champion->PlagueValue != 0) {
#endif
					//^2E62:08BB
					colorRectangle = 5; // i am hunger! or poisoned!
				}
				else {
					//^2E62:08C1
					colorRectangle = 4;
				}
				//^2E62:08C5
				// SPX: Display colored rectangle around mouth
				DRAW_EYE_MOUTH_COLORED_RECTANGLE(colorRectangle, 545);
				//^2E62:08D2
				colorRectangle = 4;
				//^2E62:08D6
				// SPX: review skills from STR to AM
				for (i16 di = ATTRIBUTE_STRENGTH; di <= ATTRIBUTE_LAST; di++) {	// for (i16 di = 1; di <= 6; di++)
					//^2E62:08DB
					if (champion->attributes[di][ATTRIBUTE_CURRENT] < champion->attributes[di][ATTRIBUTE_MAX]) {
						//^2E62:08F7
						colorRectangle = 5; // level gained!
						// SPX: bp0d = 5 changes color to red
						//^2E62:08FB
						break;
					}
					//^2E62:08FD
				}
				//^2E62:0903
				// SPX: Display colored rectangle around eye
				DRAW_EYE_MOUTH_COLORED_RECTANGLE(colorRectangle, 546);
				//^2E62:0910
				bp18 = 1;
			}
		}
		//^2E62:0915
		ObjectID bp12;
		if (bp08 != 0) {
			//^2E62:091E
			if (glbShowItemStats != 0) {
				//^2E62:0925
				bp12 = glbLeaderHandPossession.object;
			}
			//^2E62:092A
			else if (_4976_4bfe != 0) {
				//^2E62:0931
				bp12 = OBJECT_NULL;
			}
			else {
				//^2E62:0938
				bp12 = champion->Possess(INVENTORY_HAND_LEFT);
			}
			//^2E62:0940
			//^2E62:0943
			if (false
				|| _4976_3d30 != bp12 
				|| _4976_4bfe != _4976_5806 
				|| glbShowItemStats != _4976_5808
				|| (si & 0x2000) != 0
			) {
				//^2E62:0966
				DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, 0x25, 545, -1);	// Mouth
				//^2E62:0979
				DRAW_STATIC_PIC(GDAT_CATEGORY_INTERFACE_CHARSHEET, 0x00, (glbShowItemStats != 0) ? 0x21 : 0x20, 546, -1); // Eye
				//^2E62:0998
				if (glbShowItemStats != 0) {
					//^2E62:099F
					if (bp12 == OBJECT_NULL) {
						//^2E62:09A5
						DRAW_SKILL_PANEL();
					}
					else {
						//^2E62:09AC
						DRAW_ITEM_SURVEY(bp12, 1);
					}
				}
				else {
					//^2E62:09BA
					if (glbNextChampionNumber != 0) {
						//^2E62:09C1
						if (_4976_4bfe == 0) {
							//^2E62:09CA
							DRAW_CRYOCELL_LEVER(0);
						}
						else {
							//^2E62:09C8
							goto _09e4;
						}
					}
					//^2E62:09D4
					else if (DRAW_ITEM_SURVEY(bp12, 0) == 0) {
						//^2E62:09E4
_09e4:
						DRAW_FOOD_WATER_POISON_PANEL();
					}
				}
				//^2E62:09E9
				_4976_3d30 = bp12;
				_4976_5808 = glbShowItemStats;
				_4976_5806 = _4976_4bfe;
				//^2E62:09FB
				goto _0a25;
			}
			else if (_4976_3d30 != OBJECT_NULL) {
				//^2E62:0A04
				if ((QUERY_GDAT_DBSPEC_WORD_VALUE(_4976_3d30, 0x00) & 0x0020) != 0) {
					//^2E62:0A16
					DRAW_ITEM_SURVEY(_4976_3d30, glbShowItemStats);
					//^2E62:0A25
_0a25:
					bp18 = 1;
				}
			}
			//^2E62:0A2A
			for (i16 bp0c = 0; bp0c < 30; bp0c++) {
				//^2E62:0A31
				bp18 |= _2e62_03b5(player, bp0c, bp1c);
				//^2E62:0A44
			}
		}
		else {
			//^2E62:0A4F
			for (i16 bp0c = 0; bp0c <= 1; bp0c++) {
				//^2E62:0A56
				bp1a |= _2e62_03b5(player, bp0c, bp16);
				//^2E62:0A69
			}
		}
		//^2E62:0A72
		U16 di;
		Bit8u bp00a4[128];
		if ((si & 0x0400) != 0) {
			//^2E62:0A7B
			di = glbPaletteT16[(player == glbChampionLeader && glbNextChampionNumber == 0) ? COLOR_ORANGE : COLOR_WHITE];
			//^2E62:0AA0
			if (bp08 != 0) {
				//^2E62:0AA9
				SK_STRCPY(bp00a4, &champion->firstName[0]);
				//^2E62:0ABD
				U8 bp09 = champion->lastName[0];
				if (bp09 != '.' && bp09 != ';' && bp09 != '-') {
					//^2E62:0AD9
					SK_STRCAT(bp00a4, _4976_4756);
				}
				//^2E62:0AEF
				SK_STRCAT(bp00a4, &champion->firstName[8]);
				DRAW_LOCAL_TEXT(553, di, (glbNextChampionNumber != 0) ? glbPaletteT16[COLOR_DARK_GRAY] : 0x4000, bp00a4);
			}
			else {
				//^2E62:0B37
				DRAW_PLAYER_3STAT_PANE(player, 0);
				bp1a = 1;
				DRAW_NAME_STR(&_4976_3ff0, player +165, di, glbPaletteT16[COLOR_DARK_GRAY] | 0x4000, champion->firstName);
			}
		}
		//^2E62:0B6F
		if (bp08 != 0 && (si & 0x1000) != 0) {
			//^2E62:0B81
			SRECT bp24;
			QUERY_EXPANDED_RECT(554, &bp24);
			//^2E62:0B91
			DRAW_DIALOGUE_PICT(
				QUERY_GDAT_IMAGE_ENTRY_BUFF(0x07, 0x00, 0x00),
				_4976_4c16,
				&bp24,
				bp24.x,
				bp24.y,
				-1,
				QUERY_GDAT_IMAGE_LOCALPAL(0x07, 0x00, 0x00)
				);
			//^2E62:0BCE
			U16 bp10 = GET_PLAYER_WEIGHT(player);
			//^2E62:0BDA
			di = MAX_LOAD(champion);
			//^2E62:0BE9
			U16 bp06;
			if (di < bp10) {
				//^2E62:0BEE
				bp06 = 8;
			}
			else {
				//^2E62:0BF5
				bp06 = ((i32(bp10) << 3) > (i16(di) * i32(5))) ? 11 : 13;
			}
			//^2E62:0C2C
			_4976_52e0 = di = bp10 / 10;
			//^2E62:0C3B
			_4976_52fa = bp10 - di * 10;
			//^2E62:0C4B
			_4976_52f6 = MAX_LOAD(champion) / 10;
			//^2E62:0C62
            QUERY_GDAT_TEXT(0x07, 0x00, 0x2a, bp00a4);
			//^2E62:0C76
			DRAW_LOCAL_TEXT(555, glbPaletteT16[bp06], glbPaletteT16[COLOR_DARK_GRAY] | 0x4000, bp00a4);
			//^2E62:0C9E
			bp18 = 1;
		}
	}
	//^2E62:0CA3
	if (bp1a != 0) {
		//^2E62:0CA9
		_0b36_0cbe(&_4976_3ff0, 1);
	}
	//^2E62:0CB7
	if (bp18 != 0) {
		//^2E62:0CBD
		_4976_022c = 0;
		//^2E62:0CC3
 		CHANGE_VIEWPORT_TO_INVENTORY(0);
	}
	//^2E62:0CCB
	champion->heroFlag &= 0x03ff;	// 0x03FF
	//^2E62:0CD4
	return;
}

//^1031:111E
void SkWinCore::_1031_111e(Bit16u xx)
{
	//^1031:111E
	ENTER(72);
	//^1031:1124
	i16 di = xx;
	//^1031:1127
	if (_4976_4df4 != 0) {
		//^1031:112E
		if (_4976_4df4 <= di) {
			//^1031:1134
			di -= _4976_4df4;
			//^1031:1138
			_4976_4df4 = 0;
		}
		else {
			//^1031:1140
			_4976_4df4 -= di;
			//^1031:113E
			return;
		}
	}
	//^1031:1147
	if (_4976_4e62 != 0 || _4976_4e48 != 0 || _4976_4e64 != 0 || _4976_4e96 == NULL)
		//^1031:116E
		return;
	//^1031:1171
	sk3f6c bp48;
	bp48.w0 = 0xffff;
	Bit8u bp05;
	do {
		//^1031:1176
		bp05 = *(_4976_4e96++);
		//^1031:1184
		i16 si;
		switch (bp05 & 0xff3f) {
			case 0:
				{
					//^1031:119A
					_4976_4df4 = *_4976_4e96;
					//^1031:11A6
					_4976_4e96++;
					//^1031:11AA
					break;
				}
			case 4:
			case 6:
				{
					//^1031:11AD
					si = _4976_4e5e +1;
					//^1031:11B3
					if (si > 2)
						//^1031:11B8
						si = 0;
					//^1031:11BA
					if (_4976_4e60 == si) {
						//^1031:11C0
						if (_4976_4e62 == 0)
							//^1031:11C7
							_4976_4e62 = 1;
						//^1031:11CD
						_4976_4e96--;
						//^1031:11D1
						goto _1534;
					}
					//^1031:11D4
					_4976_4e6c[_4976_4e5e] = glbMousePosition;
					//^1031:11ED
					_4976_4e5e = si;
					//^1031:11F1
					if ((bp05 & 0xff3f) == 4)
						//^1031:11FE
						break;

					goto _1201;
				}
			case 1:
				{
					//^1031:1201
_1201:
					_4976_4e62 = _4976_4e5e - _4976_4e60;
					//^1031:120B
					if (_4976_4e62 >= 0)
						//^1031:120F
						break;
					//^1031:1212
					_4976_4e62 += 3;
					//^1031:1217
					break;
				}
			case 2:
				{
					//^1031:121A
					_4976_4e48 = 1;
					//^1031:1220
					break;
				}
			case 3:
				{
					//^1031:1223
					_4976_4e64 = 1;
					//^1031:1229
					break;
				}
			case 5:
				{
					//^1031:122C
					if (HANDLE_UI_EVENT(&glbMousePosition) != 0) {
						//^1031:123B
						if (_4976_4e5c == 0)
							//^1031:1242
							break;
						//^1031:1245
						goto _1201;
					}
					//^1031:1247
					_4976_4e96--;
					//^1031:124B
					break;
				}
			case 7:
				{
					//^1031:124E
					Bit8u bp06 = *(_4976_4e96++);
					//^1031:125C
					Bit8u bp07 = *(_4976_4e96++);
					//^1031:126A
					Bit8u bp08 = *(_4976_4e96++);
					//^1031:1278
					Bit8u *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(bp06, bp07, bp08);
					//^1031:128F
					SRECT bp14;
					_1031_10c8(&bp48, &bp14, READ_UI16(bp04,-4), READ_UI16(bp04,-2));
					//^1031:12AB
					DRAW_ICON_PICT_BUFF(
						QUERY_GDAT_IMAGE_ENTRY_BUFF(bp06, bp07, bp08),
						&bp48,
						&bp14,
						0,
						0,
						*(_4976_4e96++),
						0,
						QUERY_GDAT_IMAGE_LOCALPAL(bp06, bp07, bp08)
						);
					//^1031:12FC
					break;
				}
			case 8:
				{
					//^1031:12FF
					si = GET_PLAYER_AT_POSITION((*(_4976_4e96++) + glbPlayerDir) & 3);
					//^1031:131C
					if (si < 0)
						//^1031:1320
						break;
					//^1031:1323
					DRAW_SQUAD_SPELL_AND_LEADER_ICON(si, 1);
					//^1031:132D
					_0b36_0cbe(&_4976_3f6c, 1);
					//^1031:133B
					break;
				}
			case 9:
				{
					//^1031:133E
					if (glbChampionIndex > 0) {
						//^1031:1345
						si = glbChampionIndex -1;
					}
					//^1031:134D
					//else if (glbMousePosition.event >= 0x74 && glbMousePosition.event <= 0x7b) {
					else if (glbMousePosition.event >= UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT && glbMousePosition.event <= UI_EVENTCODE_CHAMPION4_ACTION_HAND_LEFT) {
						//^1031:135B
						si = (glbMousePosition.event -UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT) >> 1;
					}
					else {
						//^1031:1365
						//^1031:11A6
						_4976_4e96++;
						//^1031:11AA
						break;
					}
					//^1031:1368
					DRAW_HAND_ACTION_ICONS(si, *(_4976_4e96++), 1);
					//^1031:1381
					goto _148a;
				}
			case 10:
				{
					//^1031:1384
					Bit8u *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x01, 0x05, 0x08);
					//^1031:1398
					SRECT bp14;
					_1031_10c8(&bp48, &bp14, READ_UI16(bp04,-4), READ_UI16(bp04,-2));
					//^1031:13B4
					DRAW_ICON_PICT_BUFF(
						QUERY_GDAT_IMAGE_ENTRY_BUFF(0x01, 0x05, 0x08),
						&bp48,
						&bp14,
						0,
						0,
						-1,
						0,
						QUERY_GDAT_IMAGE_LOCALPAL(0x01, 0x05, 0x08)
						);
					//^1031:13EE
					_4976_4df6[0] = (glbChampionTable[glbChampionIndex].runesCount * 6) +U8(glbMousePosition.event) -5;
					//^1031:140C
					i16 bp0a;
					i16 bp0c;
					QUERY_STR_METRICS(_4976_4df6, &bp0a, &bp0c);
					//^1031:1422
					CALC_CENTERED_RECT_IN_RECT(&bp14, &bp48.rc2, bp0a, bp0c);
					//^1031:143A
					_0b36_129a(
						&bp48, 
						bp14.x, 
						bp14.y +bp14.cy -1, 
						glbPaletteT16[COLOR_BLACK], 
						glbPaletteT16[COLOR_CYAN], 
						_4976_4df6
						);
					//^1031:1467
					break;
				}
			case 11:
				{
					//^1031:146A
					DRAW_SPELL_TO_BE_CAST(1);
					//^1031:1471
					//^1031:14D4
					goto _148a;
				}
			case 12:
				{
					//^1031:1473
					DRAW_CMD_SLOT(*(_4976_4e96++), 1);
					//^1031:148A
_148a:
					_0b36_0cbe(&_4976_3f6c, 1);
					//^1031:1498
					break;
				}
			case 13:
				{
					//^1031:149A
					si = glbChampionInventory;
					//^1031:149F
					if (si != 0) {
						//^1031:14A3
						_4976_581a |= *_4976_4e96;
						//^1031:14B0
						REFRESH_PLAYER_STAT_DISP(--si);
					}
					//^1031:14BD
					//^1031:11A6
					_4976_4e96++;
					//^1031:11AA
					break;
				}
			case 14:
				{
					//^1031:14C0
					_29ee_1d03(*(_4976_4e96++));
					//^1031:14D4
					goto _148a;
				}
			case 15:
			case 16:
				{
					//^1031:14D6
					_4976_4bd5 = *_4976_4e96; _4976_4e96++;
					_4976_4bd6 = *_4976_4e96; _4976_4e96++;
					_4976_4bd4 = *_4976_4e96; _4976_4e96++;
					//^1031:1500
					_0aaf_01db(_4976_4df8, 1);
					//^1031:150D
					bp48.w0 = 0xffff;
					//^1031:1512
					_0aaf_002f();

					break;
				}
		}
		//^1031:1517
		if ((bp05 & 0x80) != 0) {
			//^1031:151D
			_4976_4e96 = NULL;
			//^1031:1529
			break;
		}
		//^1031:152B
	} while ((bp05 & 0x40) != 0);

	//^1031:1534
_1534:
	if (bp48.w0 != 0xffff) {
		//^1031:153A
		_0b36_0cbe(&bp48, 1);
	}
	//^1031:1549
	return;
}

//^1031:0F3A
// SPX _1031_0f3a renamed IBMIO_USER_INPUT_CHECK
void SkWinCore::IBMIO_USER_INPUT_CHECK() //#DS=4976
{
	//^1031:0F3A
	ENTER(14);
	//^1031:0F40
	if (_4976_4e46 == 0) {
		//^1031:0F4A
		Bit32u bp04 = glbAbsoluteTickCounter;
		//^1031:0F57
		Bit32u bp08 = bp04 - _4976_19a9;
		//^1031:0F68
		if (bp08 != 0) {
			//^1031:0F6F
			_4976_19a9 = bp04;
			//^1031:0F7C
			if (_4976_4e62 == 0 && _4976_4e48 == 0 && _4976_4e64 == 0) {
				//^1031:0F97
				while (_4976_4e96 == 0) {
					//^1031:0F9D
					_4976_19a7 = 1;
					Bit16u di = 1;
					//^1031:0FA6
_0fa6:
					if (_4976_4e00 == 0) {
						//^1031:0FAD
						_4976_19a7 = 0;
						//^1031:0FB3
						_1031_0b7e();
						//^1031:0FB7
						break;
					}
					//^1031:0FBA
					MouseState bp0e = _4976_4e02[_4976_4ea6];
					//^1031:0FD4
					_4976_4e00--;
					_4976_4ea6++;
					//^1031:0FDC
					if (_4976_4ea6 > 10)
						//^1031:0FE4
						_4976_4ea6 = 0;
					//^1031:0FEA
					Bit16u si = 0;
					//^1031:0FEC
					if (bp0e.MouseButton() >= 0x20) {
						//^1031:0FF2
						if (bp0e.MouseButton() == 0x20) {
							//^1031:0FF8
							si = _1031_03f2(&_4976_1891[_4976_19ad], bp0e.MouseX());
						}
						//^1031:100F
						else if (bp0e.MouseButton() == 0x40) {
							//^1031:1015
							si = 0x81;
						}
						//^1031:101A
						else if (bp0e.MouseButton() == 0x60) {
							//^1031:1020
							si = 0xe1;
						}
					}
					//^1031:1025
					else if ((bp0e.MouseButton() & 0x04) != 0) {
						si = 0xe3;
					}
					//^1031:1031
					else if ((bp0e.MouseButton() & 0x13) != 0) {
						si = _1031_030a(&_4976_1891[_4976_19ad], bp0e.MouseX(), bp0e.MouseY(), bp0e.MouseButton());
					}
					//^1031:1055
					if (si != 0) {
						//^1031:1059
						di = 0;
						//^1031:105B
						glbMousePosition.event = si;
						//^1031:105F
						glbMousePosition.XPos = _4976_4e66;
						glbMousePosition.YPos = _4976_4e68;
						glbMousePosition.rc6.y = _4976_4e9e.y;
						glbMousePosition.rc6.x = _4976_4e9e.x;
						glbMousePosition.rc6.cx = _4976_4e9e.cx;
						glbMousePosition.rc6.cy = _4976_4e9e.cy;
					}
					//^1031:1083
					if (di != 0)
						//^1031:1087
						goto _0fa6;
					//^1031:108A
					_4976_19a7 = 0;
					//^1031:1090
					_1031_0b7e();
					//^1031:1094
					_4976_4e96 = TRANSMIT_UI_EVENT(&glbMousePosition);
					//^1031:10A5
					bp08 = 0;
					//^1031:10AF
				}
			}
			//^1031:10BB
			_1031_111e(Bit16u(bp08));
		}
	}
	//^1031:10C4
	return;
}

//^12B4:011E
void SkWinCore::RESET_SQUAD_DIR()
{
	//^12B4:011E
	ENTER(0);
	//^12B4:0122
	for (U16 si = 0; si < glbChampionsCount; si++) {
		//^12B4:0126
		glbChampionSquad[si].playerDir(U8(glbPlayerDir));
	}
	//^12B4:013E
	return;
}

//^12B4:00AF
// SPX TODO related to rotate squad
void SkWinCore::_12b4_00af(U16 xx)
{
	//^12B4:00AF
	ENTER(0);
	//^12B4:00B2
	MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, -1, 0);
	glbMapToLoad = LOCATE_OTHER_LEVEL(glbPlayerMap, (xx != 0) ? -1 : +1, &glbPlayerPosX, &glbPlayerPosY, NULL);
	CHANGE_CURRENT_MAP_TO(glbMapToLoad);
	ROTATE_SQUAD(_0cee_06dc(glbPlayerPosX, glbPlayerPosY));
	CHANGE_CURRENT_MAP_TO(glbPlayerMap);
	//^12B4:011C
	return;
}

//^3A15:0F07
U16 SkWinCore::GET_ORNATE_ANIM_LEN(Actuator *ref, U16 isWall)
{
	//^3A15:0F07
	ENTER(134);
	//^3A15:0F0C
	U8 iCategory =0 ;	// bp05
	U8 iItemNumber = 0;	// bp06
	if (isWall != 0) {
		//^3A15:0F12
		iCategory = GDAT_CATEGORY_WALL_GFX; // 9
		//^3A15:0F16
		iItemNumber = GET_WALL_DECORATION_OF_ACTUATOR(ref);
	}
	else {
		//^3A15:0F23
		iCategory = GDAT_CATEGORY_FLOOR_GFX;	// 10
		//^3A15:0F27
		iItemNumber = GET_FLOOR_DECORATION_OF_ACTUATOR(ref);
	}
	//^3A15:0F37
	if (iItemNumber == 0xff)
		//^3A15:0F3D
		return 1;
	//^3A15:0F42
    U16 si = QUERY_GDAT_ENTRY_DATA_INDEX(iCategory, iItemNumber, dtWordValue, GDAT_WALL_FLOOR_ORNATE__ANIMATION_LENGTH);
	//^3A15:0F58
	if (si == 0) {
		//^3A15:0F5C
		U8 bp0086[128];	// bp0086 : hold animation sequence data
		U8 *bp04 = QUERY_GDAT_TEXT(iCategory, iItemNumber, GDAT_WALL_FLOOR_ORNATE__ANIMATION_SEQUENCE_DATA, bp0086);
		//^3A15:0F7E
		if (*bp04 != 0) {
			//^3A15:0F84
			si = SK_STRLEN(bp04);
			//^3A15:0F93
			if (si != 0)
				//^3A15:0F95
				return si;
		}
		//^3A15:0F97
		return si = 1;
	}
	//^3A15:0F9C
	return si & 0x7fff;
}

//^3A15:0FA5
void SkWinCore::TRY_ORNATE_NOISE(Actuator *ref, ObjectID rl, U16 xx, U16 yy, U16 animLen, U16 isWall)
{
	//^3A15:0FA5
	ENTER(12);
	//^3A15:0FAB
	// if (ref->SoundEffect() != 1) // original line
	if (ref->SoundEffect() != 1 && !SkCodeParam::bForceOrnateSound)
		//^3A15:0FBD
		return;
	//^3A15:0FC0
	if ((ref->ActuatorData() & 0x0100) != 0)
		//^3A15:0FCF
		return;
	//^3A15:0FD2
	U8 iCategory = 0;	// bp0b
	U8 iItemNumber = 0;	// bp0c
	if (isWall != 0) {
		//^3A15:0FD8
		iCategory = GDAT_CATEGORY_WALL_GFX;	// 9
		//^3A15:0FDC
		iItemNumber = GET_WALL_DECORATION_OF_ACTUATOR(ref);
	}
	else {
		//^3A15:0FE9
		iCategory = GDAT_CATEGORY_FLOOR_GFX;	// 10
		//^3A15:0FED
		iItemNumber = GET_FLOOR_DECORATION_OF_ACTUATOR(ref);
	}
	//^3A15:0FFD
	U16 si = ((ref->ActuatorData() & 0xff) + glbGameTick + QUERY_GDAT_ENTRY_DATA_INDEX(iCategory, iItemNumber, dtWordValue, SOUND_STD_ACTIVATION)) % animLen;
	//^3A15:1044
	Timer bp0a;
	bp0a.SetMap(glbCurrentMapIndex);
	bp0a.SetTick(animLen - si + glbGameTick);
	//^3A15:106B
	bp0a.TimerType(tty5A);
	bp0a.actor = 0;
	//^3A15:1073
	bp0a.w8 = rl;
	bp0a.XcoordB(U8(xx));
	bp0a.YcoordB(U8(yy));
	//^3A15:1085
	QUEUE_TIMER(&bp0a);
	//^3A15:1090
	ref->ActuatorData(ref->ActuatorData() | 0x0100);
	//^3A15:10B0
	if (si == 0) {
		//^3A15:10B4
		QUEUE_NOISE_GEN2(
			iCategory,
			iItemNumber,
			SOUND_STD_ACTIVATION,
			0xfe,
			xx,
			yy,
			1,
			0x8c,
			0x80
			);
	}
	//^3A15:10D8
	return;
}

//^3A15:38B6
void SkWinCore::_3a15_38b6(U16 xx)
{
	//^3A15:38B6
	ENTER(22);
	//^3A15:38BC
	U16 bp14 = glbCurrentMapIndex;
	//^3A15:38C2
	CHANGE_CURRENT_MAP_TO(glbPlayerMap);
	//^3A15:38CC
	U16 bp10 = dunMapsHeaders[glbCurrentMapIndex].RawColumn();
	//^3A15:38E5
	U16 bp12 = dunMapsHeaders[glbCurrentMapIndex].RawRow();
	//^3A15:38FE
	U8 *bp04 = glbMapTileValue[glbCurrentMapIndex][0];
	//^3A15:391A
	U16 *bp0c = &dunGroundStacks[dunMapTilesObjectIndexPerColumn[dunMapColumnsSumArray[glbCurrentMapIndex]]];
	//^3A15:3945
	for (U16 bp0e = 0; bp0e <= bp10; bp0e++) {
		//^3A15:394D
		for (U16 di = 0; di <= bp12; di++) {
			//^3A15:3952
			U16 bp16 = ((*bp04 << 5) == ttWall) ? 1 : 0;
			//^3A15:396B
			if ((*(bp04++) & 0x10) == 0)
				//^3A15:3977
				continue;
			//^3A15:397A
			ObjectID si = *(bp0c++);
			//^3A15:3984
			while (si.DBType() <= dbActuator) {
				//^3A15:3987
				if (si.DBType() == dbActuator) {
					//^3A15:3997
					Actuator *bp08 = GET_ADDRESS_OF_ACTU(si);
					//^3A15:39A4
					switch (bp08->ActuatorType()) {
						case ACTUATOR_TYPE_ARRIVAL_DEPARTURE: // 0x21 -> 'Activator, arrival & departure'
							{
								//^3A15:39BB
								if (bp08->ActionType() == 3) {
									//^3A15:39CD
									INVOKE_ACTUATOR(
										bp08,
										((bp08->RevertEffect() ^ xx) != 0) ? 1 : 0,
										0
										);
									//^3A15:39F6
									break;
								}
								//^3A15:39F8
								if ((!bp08->RevertEffect()) == xx) {
									//^3A15:3A0F
									INVOKE_ACTUATOR(
										bp08,
										bp08->ActionType(),
										0
										);
								}
								//^3A15:3A2A
								break;
							}
						case ACTUATOR_TYPE_ORNATE_ANIMATOR: // 0x2c -> 'Continuous ornate animator'
							{
								//^3A15:3A2C
								if (bp08->ActiveStatus() == 1) {
									//^3A15:3A3B
									TRY_ORNATE_NOISE(
										bp08,
										si,
										bp0e,
										di,
										GET_ORNATE_ANIM_LEN(bp08, bp16),
										bp16
										);
								}

								break;
							}
					}
				}
				//^3A15:3A61
				si = GET_NEXT_RECORD_LINK(si);
				//^3A15:3A6A
			}
			//^3A15:3A7A
		}
		//^3A15:3A83
	}
	//^3A15:3A91
	CHANGE_CURRENT_MAP_TO(bp14);
	//^3A15:3A9A
	return;
}

//^1C9A:3A6E
void SkWinCore::FILL_CAII_CUR_MAP()
{
	//^1C9A:3A6E
	ENTER(16);
	//^1C9A:3A74
	U8 *bp04 = *glbCurrentTileMap;
	//^1C9A:3A85
	U16 *bp08 = &dunGroundStacks[*_4976_4c52];
	//^1C9A:3A9E
	for (U16 bp0e = 0; bp0e < glbCurrentMapWidth; bp0e++) {
		//^1C9A:3AA6
		for (U16 di = 0; di < glbCurrentMapHeight; di++) {
			//^1C9A:3AAB
			if ((*(bp04++) & 0x10) != 0) {
				//^1C9A:3ABA
				ObjectID si = *(bp08++);
				
				do {
					//^1C9A:3AC4
					if (si.DBType() == dbCreature) {
						//^1C9A:3AD1
						Creature *bp0c = GET_ADDRESS_OF_RECORD4(si);
						//^1C9A:3AE2
						if (bp0c->b5 != 0xff)
							//^1C9A:3AE7
							break;
						//^1C9A:3AE9
						if (QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp0c->CreatureType())->IsStaticObject() == 0) {
							//^1C9A:3B02
							ALLOC_CAII_TO_CREATURE(si, bp0e, di);
							//^1C9A:3B0E
							break;
						}
						//^1C9A:3B10
						U16 bp10 = bp0c->w10;
						//^1C9A:3B1A
						_1c9a_09db(si);
						//^1C9A:3B20
						bp0c->w10 |= bp10 & 0x6000;
						//^1C9A:3B2D
						if ((bp10 & 0x803f) == 0x8001) {
							//^1C9A:3B38
							bp0c->w10 &= 0xffc0;
							bp0c->w10 |= 0x8001;
						}
						//^1C9A:3B44
						break;
					}
					//^1C9A:3B46
					si = GET_NEXT_RECORD_LINK(si);
					//^1C9A:3B4F
				} while (si != OBJECT_END_MARKER);
			}
			//^1C9A:3B57
		}
		//^1C9A:3B61
	}
	//^1C9A:3B70
	return;
}

//^13AE:0009
void SkWinCore::LOAD_NEWMAP(U8 newmap)
{
	//^13AE:0009
	ENTER(0);
	//^13AE:000C
	if (_4976_5c8a == 0) {
		//^13AE:0013
		FIRE_HIDE_MOUSE_CURSOR();
		//^13AE:0018
		_3a15_38b6(0);
	}
	//^13AE:0020
	LOAD_LOCALLEVEL_GRAPHICS_TABLE(newmap);
	//^13AE:0029
	LOAD_LOCALLEVEL_DYN();
	//^13AE:002E
	if (_4976_5c8a == 0) {
		//^13AE:0035
		_3a15_38b6(1);
		//^13AE:003D
		FILL_CAII_CUR_MAP();
		//^13AE:0042
		RECALC_LIGHT_LEVEL();
		//^13AE:0047
		if (_4976_5bee[0] == 0)
			//^13AE:0050
			_1031_098e();
		//^13AE:0055
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^13AE:005A
	return;
}

//^12B4:0141
// SPX: _12b4_0141 renamed PERFORM_TURN_SQUAD
void SkWinCore::PERFORM_TURN_SQUAD(Bit16u xx)
{
	//^12B4:0141
	ENTER(6);
	//^12B4:0146
	if (xx == 0)
		//^12B4:014C
		//^12B4:023C
		return;
	//^12B4:014F
	_4976_4e5c = 1;
	//^12B4:0155
	RESET_SQUAD_DIR();
	//^12B4:0159
	U16 si = GET_TILE_VALUE(glbPlayerPosX, glbPlayerPosY);
	//^12B4:016C
	if (si >> 5 == ttStairs) {
		//^12B4:0173
		_12b4_00af(si & 4);
		//^12B4:017E
		//^12B4:023C
		return;
	}
	//^12B4:0181
	TELE_inf bp06;
	if (GET_TELEPORTER_DETAIL(&bp06, U8(glbPlayerPosX), U8(glbPlayerPosY)) != 0) {
		//^12B4:019A
		CHANGE_CURRENT_MAP_TO(glbPlayerMap);
		//^12B4:01A4
		MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, -1, 0);
		//^12B4:01BA
		LOAD_NEWMAP(bp06.b4);
		//^12B4:01C6
		MOVE_RECORD_TO(OBJECT_NULL, -1, 0, bp06.b2, bp06.b3);
		//^12B4:01E0
		ROTATE_SQUAD(bp06.b1);
		//^12B4:01EB
		//^12B4:023C
		return;
	}
	//^12B4:01ED
	PLACE_OR_REMOVE_OBJECT_IN_ROOM(glbPlayerPosX, glbPlayerPosY, OBJECT_NULL, 1, FCT_REMOVE_OFF, 0);
	//^12B4:0205
	ROTATE_SQUAD((glbPlayerDir + ((xx == 2) ? 1 : 3)) & 3);
	//^12B4:0224
	PLACE_OR_REMOVE_OBJECT_IN_ROOM(glbPlayerPosX, glbPlayerPosY, OBJECT_NULL, 1, FCT_PLACE_ON, 0);
	//^12B4:023C
	return;
}

//^2405:00E7
void SkWinCore::_2405_00e7()
{
	//^2405:00E7
	ENTER(0);
	//^2405:00EA
	return;
}

//^2C1D:073D
ObjectID SkWinCore::REMOVE_OBJECT_FROM_HAND()
{
	// CSBwinSimilarity: TAG01576a,RemoveObjectFromHand

	//^2C1D:073D
	ENTER(0);
	//^2C1D:0741
	ObjectID si = glbLeaderHandPossession.object;
	//^2C1D:0746
	if (si != OBJECT_NULL) {
		//^2C1D:074B
		glbLeaderItemFlags = 0;
		glbLeaderItemWeight = 0;
		glbLeaderHandPossession.object = OBJECT_NULL;
		_4976_57de = 0xff;
		//^2C1D:0762
		FIRE_HIDE_MOUSE_CURSOR();
		_2405_00e7();
		_443c_0434();
		FIRE_SHOW_MOUSE_CURSOR();
		//^2C1D:0776
		PROCESS_ITEM_BONUS(glbChampionLeader, si, -1, -1);
// SPX: that part is for giving item sound when put it back to inventory or on ground
		if (SkCodeParam::bUseExtendedSound)
			QUEUE_NOISE_GEN2(QUERY_CLS1_FROM_RECORD(si), QUERY_CLS2_FROM_RECORD(si), SOUND_ITEM_PUT_DOWN, 0xFE, glbPlayerPosX, glbPlayerPosY, 1, 0, 0);
	}
	//^2C1D:079E
	return si;
}

//^2405:04F4
// SPX: _2405_04f4 renamed DRAW_ITEM_IN_HAND
void SkWinCore::DRAW_ITEM_IN_HAND(LeaderPossession *ref)
{
	//^2405:04F4
	ENTER(8);
	//^2405:04F8
	U8 bp05 = QUERY_CLS1_FROM_RECORD(ref->object);
	//^2405:0507
	U8 bp06 = QUERY_CLS2_FROM_RECORD(ref->object);
	//^2405:0516
	U8 bp07 = _2405_014a(ref->object, -1, 1);
	//^2405:052A
	U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(bp05, bp06, bp07);
	//^2405:0541
	COPY_MEMORY(
		QUERY_GDAT_IMAGE_LOCALPAL(bp05, bp06, bp07),
		ref->b6,
		16
		);
	//^2405:056D
	FIRE_BLIT_PICTURE(
		bp04,
		ref->pb2,
        ALLOC_TEMP_ORIGIN_RECT(_4976_0106, _4976_0108),
		0,
		0,
		READ_I16(bp04,-4),
		_4976_0106,
		-1,
		0,
		4,
		4,
		NULL
		);
	//^2405:05B2
	return;
}

//^00EB:069A
void SkWinCore::_00eb_069a(SRECT *prc, i16 yy)
{
	//^00EB:069A
	ENTER(0);
	//^00EB:069F
	LOADDS(0x0C48);
	i16 si = prc->y + yy;
	while (prc->y +prc->cy -1 >= si) {
		//^00EB:06B3
		MOVE_MEMORY(
			&pbVram[si * 320],
			&pbVram[(si -yy) * 320],
			prc->x +prc->cx -1 -prc->x +1
			);
		//^00EB:06F7
	}
	//^00EB:0708
	return;
}

//^44C8:1C99
void SkWinCore::_44c8_1c99()
{
	//^44C8:1C99
	ENTER(8);
	//^44C8:1C9D
	FIRE_HIDE_MOUSE_CURSOR();
	SRECT bp08;
	QUERY_EXPANDED_RECT(15, &bp08);
	_00eb_069a(&bp08, _4976_0140) INDIRECT_CALL;
	bp08.y = bp08.y +bp08.cy -1 - _4976_0130 +1;
	FIRE_BLIT_PICTURE(
		_4976_5c08,
		NULL,
		&bp08,
		0,
		0,
		_4976_013e,
		glbScreenWidth,
		-1,
		0,
		8,
		8,
		NULL
		);
	FIRE_SHOW_MOUSE_CURSOR();
	//^44C8:1D0F
	return;
}

//^3929:07E1
void SkWinCore::_3929_07e1(U16 xx, U16 yy)
{
	//^3929:07E1
	ENTER(0);
	//^3929:07E6
	i16 di = xx;
	U16 si = yy;
	//^3929:07EC
	if (di < 0)
		//^3929:07F0
		di = 0;
	//^3929:07F2
	_4976_475c = min_value(di * _4976_0126, _4976_013e - _4976_0126);
	//^3929:080B
	if (si < 0 || si >= 1)
		//^3929:0816
		si = 0;
	//^3929:0818
	_4976_5c0c = si;
	_4976_5c06 = 0;
	//^3929:0822
	return;
}

//^3929:0826
void SkWinCore::_3929_0826()
{
	//^3929:0826
	ENTER(0);
	//^3929:082A
	FIRE_HIDE_MOUSE_CURSOR();
	//^3929:082F
	FIRE_FILL_SCREEN_RECT(15, glbPaletteT16[COLOR_BLACK]);
	//^3929:0842
	FIRE_SHOW_MOUSE_CURSOR();
	//^3929:0847
	_3929_07e1(0, 0);
	//^3929:0851
	for (U16 si = 0; si < 1; si++) {
		//^3929:0855
		_4976_5c02[si] = -1;
		//^3929:0866
	}
	//^3929:086C
	return;
}

//^3929:0914
void SkWinCore::_3929_0914()
{
	//^3929:0914
	ENTER(0);
	//^3929:0917
	_3929_0826();
	//^3929:091B
	_4976_5c02[0] = -1;
	//^3929:0927
	return;
}

//^3929:0BA6
void SkWinCore::PRINT_SYSERR_TEXT(Bit16u dstx, Bit16u dsty, Bit16u clr1, Bit16u clr2, Bit8u *str)
{
	//^3929:0BA6
	DRAW_STRING(_4976_4964, -1, glbScreenWidth, dstx, dsty+1, clr1, clr2, str, 8);
}

//^3929:0929
void SkWinCore::_3929_0929(U16 clr1, U8 *str)
{
	//^3929:0929
	ENTER(8);
	//^3929:092D
	SRECT bp08;
	QUERY_EXPANDED_RECT(15, &bp08);
	//^3929:093C
	if (_4976_5c06 != 0) {
		//^3929:0943
		DRAW_STRING(
			_4976_5c08,
			-1,
			_4976_013e,
			_4976_475c,
			_4976_0140 -2 -((QUERY_MBCS_PRESENCE(str) != 0) ? _4976_0136 : _4976_0124),
			clr1,
			glbPaletteT16[COLOR_BLACK],
			str,
			8
			);
	}
	else {
		//^3929:0996
		FIRE_HIDE_MOUSE_CURSOR();
		//^3929:099B
		PRINT_SYSERR_TEXT(
			bp08.x + _4976_475c,
			_4976_5c0c * _4976_013a +bp08.y + _4976_0130 - _4976_0136 + _4976_5c12 -1,
			clr1,
            glbPaletteT16[COLOR_BLACK],
			str
			);
		//^3929:09D8
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^3929:09DD
	_4976_5c02[_4976_5c0c] = glbGameTick +70;
	//^3929:09F9
	return;
}

//^3929:09FB
// SPX: _3929_09fb renamed DISPLAY_HINT_TEXT
void SkWinCore::DISPLAY_HINT_TEXT(Bit16u color, const U8 *str) //#DS=4976
{
	//^3929:09FB
	ENTER(102);
	//^3929:0A01
	U16 si = color;
	//^3929:0A04
	if (_4976_5c06 != 0) {
		//^3929:0A0B
		_44c8_1c99();
		//^3929:0A10
		FILL_ENTIRE_PICT(_4976_5c08, glbPaletteT16[COLOR_BLACK]);
		//^3929:0A2A
		_4976_5c06 = 0;
	}
	//^3929:0A30
	si = glbPaletteT16[si];
	//^3929:0A3B
	for (U16 bp02 = 0; str[bp02] != 0; ) {
		//^3929:0A43
		U8 bp66[100];
		U16 di = _3929_04e2(str, bp66, &bp02, _4976_013e - _4976_475c);
		//^3929:0A64
		if (str[bp02] == '\n') {
			//^3929:0A70
			_3929_0914();
			//^3929:0A74
			_3929_0929(si, bp66);
			//^3929:0A81
			_4976_475c = 0;
			//^3929:0A87
			bp02++;
			//^3929:0A8A
			continue;
		}
		//^3929:0A8C
		if (str[bp02] != 0) {
			//^3929:0A98
			_3929_0929(si, bp66);
			//^3929:0AA5
			_3929_0914();
			//^3929:0AA9
			_4976_475c = 12;
			//^3929:0AAF
			continue;
		}
		//^3929:0AB1
		_3929_0929(si, bp66);
		//^3929:0ABE
		_4976_475c += di;
		//^3929:0AC2
	}
	//^3929:0AD1
	if (_4976_5c06 != 0) {
		//^3929:0AD8
		_44c8_1c99();
		//^3929:0ADD
		FILL_ENTIRE_PICT(_4976_5c08, glbPaletteT16[COLOR_BLACK]);
	}
	//^3929:0AFD
	return;
}

//^3929:0B5A
// SPX : _3929_0b5a renamed DISPLAY_HINT_NEW_LINE
void SkWinCore::DISPLAY_HINT_NEW_LINE()
{
	//^3929:0B5A
	ENTER(0);
	//^3929:0B5D
	DISPLAY_HINT_TEXT(COLOR_BLACK, const_cast<U8 *>(strEndLine));
	//^3929:0B6A
	return;
}

//^2405:00C9
// SPX: _2405_00c9 renamed DISPLAY_TAKEN_ITEM_NAME
void SkWinCore::DISPLAY_TAKEN_ITEM_NAME(ObjectID rl)
{
	//^2405:00C9
	ENTER(0);
	//^2405:00CC
	DISPLAY_HINT_NEW_LINE();
	//^2405:00D1
	DISPLAY_HINT_TEXT(COLOR_LIGHTER_GRAY, GET_ITEM_NAME(rl));
	//^2405:00E5
	return;
}

//^2C1D:06B5
void SkWinCore::TAKE_OBJECT(ObjectID rl, U16 xx)
{
	// CSBwinSimilarity: TAG0156c4,TakeObject

	//^2C1D:06B5
	ENTER(0);
	//^2C1D:06B9
	ObjectID si = rl;
	//^2C1D:06BC
	if (si != OBJECT_NULL) {
		//^2C1D:06C1
		si.ClearDir();
		//^2C1D:06C8
		glbLeaderItemFlags = QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0);
		//^2C1D:06D5
		glbLeaderItemWeight = QUERY_ITEM_WEIGHT(si);
		glbLeaderHandPossession.object = si;
		//^2C1D:06E3
		DRAW_ITEM_IN_HAND(&glbLeaderHandPossession);
		//^2C1D:06EE
		FIRE_HIDE_MOUSE_CURSOR();
		//^2C1D:06F3
		DISPLAY_TAKEN_ITEM_NAME(si);
		//^2C1D:06FA
		if (xx != 0) {
			//^2C1D:0700
			glbShowMousePointer = 1;
		}
		else {
			//^2C1D:0708
			_443c_0434();
		}
		//^2C1D:070D
		FIRE_SHOW_MOUSE_CURSOR();
		//^2C1D:0712
		PROCESS_ITEM_BONUS(glbChampionLeader, si, -1, 1);
		//^2C1D:0722
		PLACE_OR_REMOVE_OBJECT_IN_ROOM(glbPlayerPosX, glbPlayerPosY, -1, 1, FCT_PLACE_ON, 0);

// SPX: that part is for giving item sound when taking it
		if (SkCodeParam::bUseExtendedSound)
			QUEUE_NOISE_GEN2(QUERY_CLS1_FROM_RECORD(si), QUERY_CLS2_FROM_RECORD(si), SOUND_ITEM_TAKE, 0xFE, glbPlayerPosX, glbPlayerPosY, 1, 0, 0);
	}
	//^2C1D:073A
	return;
}

//^2E62:0CFA
void SkWinCore::_2e62_0cfa(U16 xx)
{
	//^2E62:0CFA
	ENTER(4);
	//^2E62:0CFF
	for (U16 si = 0; si < glbChampionsCount; si++) {
		//^2E62:0D03
		if (si +1 != glbChampionInventory) {
			//^2E62:0D0C
			REFRESH_PLAYER_STAT_DISP(si);
		}
		//^2E62:0D12
	}
	//^2E62:0D19
	if (glbChampionInventory != 0) {
		//^2E62:0D20
		U16 si = glbChampionInventory -1;
		//^2E62:0D26
		Champion *champion = &glbChampionSquad[si];
		//^2E62:0D34
		if (champion->enchantmentPower != 0 && champion->enchantmentAura >= ENCHANTMENT_AURA_FIRST && champion->enchantmentAura <= ENCHANTMENT_AURA_LAST) {
			//^2E62:0D4F
			champion->heroFlag |= (glbShowItemStats != 0 && glbLeaderHandPossession.object == OBJECT_NULL) ? CHAMPION_FLAG_3000 : CHAMPION_FLAG_1000;	// 0x3000 or 0x1000
		}
		//^2E62:0D6C
		REFRESH_PLAYER_STAT_DISP(glbChampionInventory -1);
	}
	//^2E62:0D76
	UPDATE_RIGHT_PANEL(xx);
	//^2E62:0D7F
	return;
}

//^443C:0004
void SkWinCore::_443c_0004(U8 *buffSrc, U8 *buffDst, U8 *localpal)
{
	//^443C:0004
	ENTER(20);
	//^443C:0009
	U8 *bp04 = ALLOC_PICT_BUFF(16, 16, afDefault, 4);
	//^443C:001F
	U8 bp14[16];
	for (i16 si = 0; si < 16; si++) {
		//^443C:0023
		bp14[si] = glbPaletteT16[COLOR_BLACK];
		//^443C:002D
	}
	//^443C:0033
	bp14[12] = localpal[12];
	//^443C:003D
	FILL_ENTIRE_PICT(buffDst, localpal[12]);
	//^443C:0052
	DRAW_DIALOGUE_PICT(buffSrc, buffDst, &_4976_4942, 0, 0, 12, bp14);
	//^443C:0075
	DRAW_DIALOGUE_PICT(buffSrc, buffDst, &_4976_494a, 0, 0, 12, localpal);
	//^443C:0099
	FREE_PICT_BUFF(bp04);
	//^443C:00A6
	return;
}

//^443C:0434
void SkWinCore::_443c_0434()
{
	//^443C:0434
	ENTER(4);
	//^443C:0438
	_4976_5dac = (glbLeaderHandPossession.object != OBJECT_NULL) ? 1 : 0;
	//^443C:0449
	if (_4976_5dac != 0) {
		//^443C:044D
		U8 *bp04 = ALLOC_PICT_BUFF(18, 18, afDefault, 8);
		//^443C:0463
		_443c_0004(glbLeaderHandPossession.pb2, bp04, glbLeaderHandPossession.b6);
		//^443C:047C
		IBMIO_SET_CURSOR_PATTERN(2, bp04, 8, 8, 18, 18, 8, NULL, glbLeaderHandPossession.b6[12]) INDIRECT_CALL;
		//^443C:04A3
		FREE_PICT_BUFF(bp04);
	}
	//^443C:04B0
	_443c_040e();
	//^443C:04B4
	return;
}

//^2C1D:0889
// SPX: _2c1d_0889 renamed CLICK_ITEM_SLOT
void SkWinCore::CLICK_ITEM_SLOT(Bit16u xx)
{
	//^2C1D:0889
	ENTER(4);
	//^2C1D:088F
	if (glbChampionLeader == -1)
		//^2C1D:0896
		return;
	//^2C1D:0899
	U16 si;
	U16 di;
	// SPX: xx < 8 => item slot for champions hand (2*4)
	if (xx < 8) {
		//^2C1D:089F
		if (glbNextChampionNumber != 0)
			//^2C1D:08A6
			return;
		//^2C1D:08A9
		di = xx >> 1;
		//^2C1D:08B0
		if (di >= glbChampionsCount)
			//^2C1D:08B6
			return;
		//^2C1D:08B9
		if (di +1 == glbChampionInventory)
			//^2C1D:08C0
			return;
		//^2C1D:08C3
		if (glbChampionSquad[di].curHP() == 0)
			//^2C1D:08D3
			return;
		//^2C1D:08D6
		si = xx & 1;
	}
	else {
		//^2C1D:08E0
		// SPX: translate to have the inventory position
		si = xx -8;
		//^2C1D:08E8
		di = ((si >= INVENTORY_MAX_SLOT) ? glbChampionIndex : glbChampionInventory) -1;
	}
	//^2C1D:08F8
	ObjectID bp02 = glbLeaderHandPossession.object;
	//^2C1D:08FE
	ObjectID bp04 = (si >= INVENTORY_MAX_SLOT) ? glbCurrentContainerItems[si - INVENTORY_MAX_SLOT] : glbChampionSquad[di].Possess(si);
	//^2C1D:0926
	if (bp04 == OBJECT_NULL && bp02 == OBJECT_NULL)
		//^2C1D:0932
		return;
	//^2C1D:0935
	if (bp02 != OBJECT_NULL) {
		//^2C1D:093B
		if (IS_ITEM_FIT_FOR_EQUIP(bp02, si, 0) == 0)
			//^2C1D:094D
			return;
	}
	//^2C1D:0950
	FIRE_HIDE_MOUSE_CURSOR();
	//^2C1D:0955
	if (bp02 != OBJECT_NULL)
		//^2C1D:095B
		REMOVE_OBJECT_FROM_HAND();
	//^2C1D:095F
	if (bp04 != OBJECT_NULL) {
		//^2C1D:0965
		REMOVE_POSSESSION(di, si);
		//^2C1D:096D
		TAKE_OBJECT(bp04, 1);
	}
	//^2C1D:0978
	if (bp02 != OBJECT_NULL) {
		//^2C1D:097E
		EQUIP_ITEM_TO_INVENTORY(di, bp02, si);
	}
	//^2C1D:098A
	_2e62_0cfa(0);
	//^2C1D:0992
	//if (si == 11 || si == 6 || si == 12 || ((si < 7 || si > 9) && si >= 30)) {
	if (si == INVENTORY_POUCH_1 || si == INVENTORY_POUCH_2 || si == INVENTORY_SCABBARD_1 
		|| ((si < INVENTORY_SCABBARD_2 || si > INVENTORY_SCABBARD_4) && si >= INVENTORY_MAX_SLOT)) {
		//^2C1D:09B0
		glbSomeChampionPanelFlag = 1;
		//^2C1D:09B6
		UPDATE_RIGHT_PANEL(0);
	}
	//^2C1D:09BE
	if (glbShowMousePointer != 0) {
		//^2C1D:09C5
		glbShowMousePointer = 0;
		//^2C1D:09CB
		_443c_0434();
	}
	//^2C1D:09D0
	FIRE_SHOW_MOUSE_CURSOR();
	//^2C1D:09D5
	return;
}

//^2C1D:0654
void SkWinCore::PUT_ITEM_TO_PLAYER(Bit16u championIndex)
{
	// click player panel to store leader's holding item into your back pack.

	//^2C1D:0654
	ENTER(0);
	//^2C1D:0659
	if (glbLeaderHandPossession.object != OBJECT_NULL) {
		//^2C1D:0660
		if (glbChampionSquad[championIndex].curHP() != 0) {
			X16 si;
			//^2C1D:0671  
			for (si=INVENTORY_BACKPACK_1; si<=INVENTORY_BACKPACK_LAST; si++) {	// (si=13; si<30; si++)
				//^2C1D:0676
				if (glbChampionSquad[championIndex].Possess(si) == OBJECT_NULL)
					break;
				//^2C1D:068D  
			}
			//^2C1D:0693
			if (si != (INVENTORY_BACKPACK_LAST+1)) {	// (si != 30)
				//^2C1D:0698
				ObjectID di = REMOVE_OBJECT_FROM_HAND();
				//^2C1D:069F
				if (di != OBJECT_NULL) {
					//^2C1D:06A4
					EQUIP_ITEM_TO_INVENTORY(championIndex, di, si);
				}
			}
		}
	}
	//^2C1D:06B1
	return;
}

//^0CEE:2902
ObjectID SkWinCore::TAKE_COIN_FROM_WALLET(ObjectID rl, i16 xx)
{
	//^0CEE:2902
	ENTER(10);
	//^0CEE:2908
	U16 bp0a = glbMoneyItemsIDTable[xx];
	Container *bp08 = GET_ADDRESS_OF_RECORD9(rl);
	ObjectID di = bp08->GetContainedObject();
	ObjectID si = OBJECT_NULL;
	//^0CEE:292C
	for (; di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
		//^0CEE:292E
		if (di.DBType() == dbMiscellaneous_item) {
			if (GET_DISTINCTIVE_ITEMTYPE(di) == bp0a)
				si = di;
			continue;
		}
		//^0CEE:294A
		return OBJECT_NULL;
		//^0CEE:294F
	}
	//^0CEE:295C
	if (si != OBJECT_NULL) {
		//^0CEE:2961
		Miscellaneous_item *bp04 = GET_ADDRESS_OF_RECORDA(si);
		if (bp04->Charge() == 0) {
			//^0CEE:297B
			CUT_RECORD_FROM(si, &bp08->w2, -1, 0);
		}
		else {
			//^0CEE:2992
			bp04->Charge(bp04->Charge() -1);
			si = ALLOC_NEW_DBITEM(bp0a);
		}
	}
	//^0CEE:29B3
	return si;
}

//^2759:28DB
void SkWinCore::CLICK_MONEYBOX(Bit16u xx) 
{
	// you clicked the money box.
	// 1) put in the hodling coin
	// 2) take out the hold coin

	//^2759:28DB
	ENTER(2);
	//^2759:28E1
	if (glbRightPanelType != RIGHT_PANEL_MONEY_BOX)	// 4
		return;
	//^2759:28E8
	X16 bp02 = glbChampionIndex -1;
	ObjectID si = glbChampionSquad[bp02].Possess(glbSelectedHandAction);
	ObjectID di;
	if (glbLeaderHandPossession.object != OBJECT_NULL) {
		//^2759:2909
		if (ADD_COIN_TO_WALLET(si, glbLeaderHandPossession.object) != 0) {
			REMOVE_OBJECT_FROM_HAND();
			goto _2945;
		}
	}
	else {
		//^2759:2920
		di = TAKE_COIN_FROM_WALLET(si, GET_ITEM_ORDER_IN_CONTAINER(si, xx));
		if (di != OBJECT_NULL) {
			//^2759:293B
			TAKE_OBJECT(di, 0);
			//^2759:2945
_2945:
			glbSomeChampionPanelFlag = 1;
			UPDATE_RIGHT_PANEL(0);
		}
	}
	//^2759:2952
	CALC_PLAYER_WEIGHT(bp02);
	//^2759:295B
	return;
}

//^1031:16A0
// SPX: _1031_16a0 renamed SELECT_CHAMPION_LEADER
void SkWinCore::SELECT_CHAMPION_LEADER(Bit16u xx)
{
	//^1031:16A0
	ENTER(0);
	//^1031:16A4
	U16 si = xx;
	//^1031:16A7
	if (si == glbChampionLeader)
		//^1031:16A7
		return;
	//^1031:16AD
	if (si != 0xffff && glbChampionSquad[si].curHP() == 0)
		//^1031:16C0
		return;
	//^1031:16C2
	if (glbChampionLeader != -1) {
		//^1031:16C9
		glbChampionSquad[glbChampionLeader].heroFlag |= CHAMPION_FLAG_1400;	// 0x1400
	}
	//^1031:16D9
	glbChampionLeader = si;
	//^1031:16DD
	if (si == 0xffff)
		//^1031:16E0
		return;
	//^1031:16E2
	if (si +1 == glbNextChampionNumber)
		//^1031:16E9
		return;
	//^1031:16EB
	glbChampionSquad[si].heroFlag |= CHAMPION_FLAG_1400;	// 0x1400
	//^1031:16FA
	return;
}

//^2F3F:0000
void SkWinCore::ADD_ITEM_TO_PLAYER(U16 player, ObjectID rl)
{
	//^2F3F:0000
	ENTER(0);
	//^2F3F:0005
	for (U16 si = 0; si < 5; si++) {
		//^2F3F:000A
		U16 di = _4976_404d[si][0];
		//^2F3F:0017
		for (; _4976_404d[si][1] >= di; di++) {
			//^2F3F:0019
			if (true
				&& glbChampionSquad[player].Possess(di) == OBJECT_NULL
				&& IS_ITEM_FIT_FOR_EQUIP(rl, di, 0) != 0
				&& (false
					|| _4976_404d[si][2] == 0xffff
					|| rl.DBType() == _4976_404d[si][2]
				)
			) {
				//^2F3F:006C
				EQUIP_ITEM_TO_INVENTORY(player, rl, di);
				//^2F3F:007B
				return;
			}
			//^2F3F:007D
		}
		//^2F3F:008D
	}
	//^2F3F:0096
	return;
}

//^2F3F:04EA
// SPX: _2f3f_04ea renamed _2f3f_04ea_CHAMPION
void SkWinCore::_2f3f_04ea_CHAMPION(Bit16u xx, Bit16u yy, Bit16u dir, Bit16u zz, Bit16u ee)
{
	//^2F3F:04EA
	ENTER(142);
	//^2F3F:04F0
	U16 si = glbNextChampionNumber -1;
	//^2F3F:04F6
	Champion *bp04 = &glbChampionSquad[si];
	//^2F3F:0504
	U16 bp0c = glbCurrentMapIndex;
	//^2F3F:050A
	CHANGE_CURRENT_MAP_TO(zz);
	//^2F3F:0513
	ObjectID bp0e = REMOVE_OBJECT_FROM_HAND();
	//^2F3F:051B
	if (ee == 161) {
		//^2F3F:0525
		INTERFACE_CHAMPION(4);
		//^2F3F:052D
		FIRE_HIDE_MOUSE_CURSOR();
		//^2F3F:0532
        if (glbChampionsCount == 1)
			//^2F3F:0539
			SELECT_CHAMPION_LEADER(0xffff);
		//^2F3F:0541
		if (glbNextChampionNumber >= glbChampionsCount)
			//^2F3F:054A
			glbChampionsCount--;
		//^2F3F:054E
		glbNextChampionNumber = 0;
		//^2F3F:0554
		bp04->curHP(0);
		//^2F3F:055D
		glbChampionAlive[si] = 0;
		//^2F3F:0567
		_4976_3de2[si] = 0xff;
		_4976_3dde[RCJ(4,si)] = 0xff;
		//^2F3F:0571
		glbChampionHandCoolingDown[si][1] = 0;
		_4976_3de6[RCJ(4,si)][1] = 0xffff;
		//^2F3F:058A
		glbChampionHandCoolingDown[si][0] = 0;
		_4976_3de6[RCJ(4,si)][0] = 0xffff;
		//^2F3F:05A3
		glbChampionHandCoolingDown[si][2] = 0;
		//^2F3F:05B1
		FIRE_FILL_SCREEN_RECT(si +161, glbPaletteT16[COLOR_BLACK]);
		//^2F3F:05C8
		_38c8_0060();
		//^2F3F:05CD
		FIRE_SHOW_MOUSE_CURSOR();
	}
	else {
		//^2F3F:05D5
		if (_4976_404b == 0)
			//^2F3F:05DC
			DRAW_CRYOCELL_LEVER(1);
		//^2F3F:05E4
		if (bp0e != OBJECT_NULL)
			//^2F3F:05EA
			ADD_ITEM_TO_PLAYER(si, bp0e);
		//^2F3F:05F4
		glbNextChampionNumber = 0;
		//^2F3F:05FA
		xx += glbXAxisDelta[dir];
		//^2F3F:0606
		yy += glbYAxisDelta[dir];
		//^2F3F:0612
		for (U16 bp0a = 0; bp0a < 30; bp0a++) {
			//^2F3F:0619
			ObjectID di = bp04->Possess(bp0a);
			//^2F3F:062A
			if (di != OBJECT_NULL) {
				//^2F3F:062F
				CUT_RECORD_FROM(di, NULL, xx, yy);
			}
			//^2F3F:0642
		}
		//^2F3F:064B
		ObjectID di = GET_TILE_RECORD_LINK(xx, yy);
		while (true) {
			//^2F3F:0658
			if (di.DBType() == dbActuator) {
				//^2F3F:0667
				Actuator *bp08 = GET_ADDRESS_OF_ACTU(di);
				//^2F3F:0674
				if (bp08->ActuatorType() == ACTUATOR_TYPE_RESURECTOR)
				{
					//^2F3F:0683
					bp08->OnceOnlyActuator(0);
					//^2F3F:0688
					break;
				}
				else if (bp08->ActuatorType() == ACTUATOR_TYPE_CHAMPION_MIRROR) // SPX: handle DM1 Champion Mirror too
				{
					bp08->ActiveStatus(1); // change to "inactive", different from the "once only" status
					break;
				}
			}
			//^2F3F:068A
			di = GET_NEXT_RECORD_LINK(di);
		}
		//^2F3F:0693
		if (glbChampionsCount == 1) {
			//^2F3F:069A
			_4976_4b80 = glbGameTick;
		}
		//^2F3F:06A8
		if (_4976_404b == 0) {
			//^2F3F:06AF
			glbChampionBonesIndex = si;
			//^2F3F:06B3
			DISPLAY_HINT_NEW_LINE();
			//^2F3F:06B8
			U8 bp008e[128];
			// SPX: Text : AWAKENED
			DISPLAY_HINT_TEXT(glbChampionColor[si], QUERY_GDAT_TEXT(0x01, 0x00, 0x0e, bp008e));
			//^2F3F:06DD
			if (glbChampionInventory != 0) {
				//^2F3F:06E4
				INTERFACE_CHAMPION(4);
				//^2F3F:06EC
				_38c8_0060();
			}
		}
	}
	//^2F3F:06F1
	CHANGE_CURRENT_MAP_TO(bp0c);
	//^2F3F:06FA
	return;
}

//^24A5:1798
// SPX: _24a5_1798 renamed INTERFACE_CHAMPION (not sure of what's inside)
void SkWinCore::INTERFACE_CHAMPION(Bit16u xx)
{
	//^24A5:1798
	ENTER(8);
	//^24A5:179E
	i16 di = xx;
	//^24A5:17A1
	U16 bp06 = 0;
	glbInventorySubpanel = 0;
	_4976_3d30 = OBJECT_NULL;
	//^24A5:17B2
	if (di < 4 && glbChampionSquad[di].curHP() == 0)
		//^24A5:17C7
		return;
	//^24A5:17CA
	if (_4976_4c3e != 0 || _4976_4ddc != 0 || _4976_4bfe != 0 || glbShowItemStats != 0)
		//^24A5:17EF
		return;
	//^24A5:17F2
	_4976_4e5c = 1;
	//^24A5:17F8
	U16 si = glbChampionInventory;
	//^24A5:17FC
	if (di +1 == si)
		//^24A5:1803
		di = 4;
	//^24A5:1806
	if (si == 0 || di == 4) {
		//^24A5:180F
		bp06 = 1;
		//^24A5:1814
		FIRE_HIDE_MOUSE_CURSOR();
	}
	//^24A5:1819
	if (si != 0) {
		//^24A5:1820
		glbChampionInventory = 0;
		//^24A5:1826
		Champion *bp04 = &glbChampionSquad[si -1];
		//^24A5:1837
		if (bp04->curHP() != 0 && glbNextChampionNumber == 0) {
			//^24A5:1848
			bp04->heroFlag |= CHAMPION_FLAG_4000;	// 0x4000
			//^24A5:184E
			REFRESH_PLAYER_STAT_DISP(si -1);
		}
		//^24A5:1858
		for (i16 bp08 = 0; bp08 < 4; bp08++) {
			//^24A5:185F
			glbChampionMajorSkillsLevel[si -1][bp08] -= _4976_52c0[bp08];
			//^24A5:1875
		}
		//^24A5:187E
		if (glbIsPlayerSleeping != 0) {
			//^24A5:1885
			if (bp06 != 0) {
				//^24A5:188E
				_443c_040e();
				FIRE_SHOW_MOUSE_CURSOR();
			}
			//^24A5:1898
			goto _1913;
		}
		//^24A5:189A
		if (di == 4) {
			//^24A5:189F
			if (_4976_3d59 != 0)
				//^24A5:18A6
				_29ee_000f();
			//^24A5:18AB
			if (bp06 != 0)
				//^24A5:18B1
				FIRE_SHOW_MOUSE_CURSOR();
			//^24A5:18B6
			INIT_BACKBUFF();
			//^24A5:18BB
			goto _1913;
		}
	}
	//^24A5:18BD
	glbChampionInventory = di +1;
	//^24A5:18C3
	if (si == 0)
		//^24A5:18C7
		FIRE_FILL_HALFTONE_RECTI(9, 0);
	//^24A5:18D2
	ZERO_MEMORY(_4976_52c0, 4);
	//^24A5:18E2
	glbChampionSquad[di].heroFlag |= CHAMPION_FLAG_FC00;	// 0xFC00
	_4976_581a = 0;
	//^24A5:18F7
	REFRESH_PLAYER_STAT_DISP(di);
	//^24A5:18FE
	if (bp06 != 0)
		//^24A5:1904
		FIRE_SHOW_MOUSE_CURSOR();
	//^24A5:1909
	_1031_0541(8);
	//^24A5:1911
	return;
	//^24A5:1913
_1913:
	_1031_0667();
	//^24A5:1918
	return;
}

//^32CB:06CF
void SkWinCore::INIT_BACKBUFF()
{
	//^32CB:06CF
	ENTER(0);
	//^32CB:06D2
	if (_4976_5be6 != 0) {
		//^32CB:06D9
		FIRE_FILL_BACKBUFF_RECT(&_4976_5938, glbPaletteT16[COLOR_BLACK]);
	}
	//^32CB:06EF
	WRITE_UI16(_4976_4c16,-4,_4976_00f6); // width
	//^32CB:06FA
	WRITE_UI16(_4976_4c16,-2,_4976_00f8); // height
	//^32CB:0701
	WRITE_UI16(_4976_4c16,-6,8); // bpp
	//^32CB:0707
	_4976_022c = 0;
	//^32CB:070D
	return;
}

//^2759:213D
SpellDefinition *SkWinCore::FIND_SPELL_BY_RUNES(U8 *runes)
{
	// CSBwinSimilarity: TAG01c88e,Incantation2Spell

	//^2759:213D
	ENTER(10);
	//^2759:2141
	if (runes[1] == 0)
		//^2759:214B
		//^2759:21EF
		return NULL;
	//^2759:214E
	i16 bp06 = 24;
	U32 bp0a = 0;

	do {
		//^2759:215D
		bp0a |= U32(*(runes++)) << bp06;
		//^2759:2178
	} while (runes[0] != 0 && (bp06 -= 8) >= 0);
	//^2759:2187
	SpellDefinition *bp04 = const_cast<SpellDefinition *>(dSpellsTable);
	U32 iLocalMaxSpell = MAXSPELL_ORIGINAL;	// SPX added this to prevent overflow when switching tables

	// SPX : Use extended spells table read from GDAT if we are in custom mode
	if (SkCodeParam::bUseCustomSpells)
	{
		bp04 = const_cast<SpellDefinition *>(dSpellsTableCustom);
		iLocalMaxSpell = MAXSPELL_CUSTOM;
	} // end SPX

	//^2759:218F
	for (bp06 = iLocalMaxSpell; bp06-- != 0; bp04++) {	// (bp06 = MAXSPELL; bp06-- != 0; bp04++)
		//^2759:2196
		if ((bp04->dw0 & 0xff000000) != 0) {
			//^2759:21AB
			if (bp04->dw0 != bp0a)
				//^2759:21BA
				continue;
			//^2759:21BC
			return bp04;
		}
		//^2759:21C4
        if ((bp0a & 0x00ffffff) == bp04->dw0)
			//^2759:21DF
			//^2759:21BC
			return bp04;
		//^2759:21E1
	}
	//^2759:21EF
	return NULL;
}

//^1C9A:121D
ObjectID SkWinCore::ALLOC_NEW_CREATURE(U16 creaturetype, U16 healthMultiplier_1to31_baseIs8, U16 dir, U16 xx, U16 yy)
{
	// arrange for a new creature record.

	// (creature += 0x8000) if you wanna create minion map's minion creature. then new missile record is attached to the minion creature.

	//^1C9A:121D
	ENTER(12);
	//^1C9A:1223
	U16 si = healthMultiplier_1to31_baseIs8;
	//^1C9A:1226
	U16 bp0c = creaturetype & 0x8000;
	//^1C9A:122F
	ObjectID bp0a;
	if (bp0c != 0) {
		//^1C9A:1233
		creaturetype &= 0x7fff;
		//^1C9A:1238
		bp0a = ALLOC_NEW_RECORD(dbMissile);
		//^1C9A:1243
		if (bp0a == OBJECT_NULL) {
			//^1C9A:1248
			return OBJECT_NULL;
		}
	}
	//^1C9A:124E
	ObjectID di = ALLOC_NEW_RECORD(dbCreature);
	//^1C9A:1258
	if (di == OBJECT_NULL || _4976_1a68 >= glbCreaturesCount) {
		//^1C9A:1266
		if (bp0c != 0)
			//^1C9A:126C
			DEALLOC_RECORD(bp0a);
		//^1C9A:1275
		//^1C9A:1248
		return OBJECT_NULL;
	}
	//^1C9A:1277
	Creature *creature = GET_ADDRESS_OF_RECORD4(di);	//*bp04
	//^1C9A:1284
	creature->CreatureType(U8(creaturetype));
	//^1C9A:128E
	AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(U8(creaturetype));
	//^1C9A:129B
	creature->SetPossessionObject(OBJECT_END_MARKER);
	//^1C9A:12A4
	creature->b15 = 0xfb;
	//^1C9A:12A9
	creature->b15_0_1(dir);
	//^1C9A:12B8
	creature->b5_0_7(0xff);
	//^1C9A:12BD
	if (bp0c != 0) {
		//^1C9A:12C3
		APPEND_RECORD_TO(bp0a, &creature->possession, -1, 0);
	}
	//^1C9A:12DB
	si = min_value(si, 31);
	//^1C9A:12E8
	// SPX: bp08->w4 = Hit Points
	si = (si * bp08->BaseHP) >> 3;
	//^1C9A:12F4
	creature->HP1(RAND16((si >> 3) +1) +si);
	//^1C9A:130A
	creature->HP3(0);
	//^1C9A:1310
	creature->SetTriggerXPos(xx);
	//^1C9A:131F
	creature->SetTriggerYPos(yy);
	//^1C9A:1332
	creature->SetTriggerMap(glbCurrentMapIndex);
	//^1C9A:1344
	creature->w8 = 0xffff;
	//^1C9A:134A
	if (MOVE_RECORD_TO(di, -4, 0, xx, yy) == 1) {
		//^1C9A:1362
		//^1C9A:1248
		return OBJECT_NULL;
	}
	//^1C9A:1365
	creature->w8 = 0;
	//^1C9A:136E
	return di;
}

//^1C9A:103A
ObjectID SkWinCore::CREATE_MINION(U16 creatureType, U16 healthMultiplier_1to31_baseIs8, U16 creatureDir, U16 xx, U16 yy, U16 zz, ObjectID ww, i16 dir)
{
	//^1C9A:103A
	ENTER(20);
	//^1C9A:1040
	U16 bp08 = glbCurrentMapIndex;
	//^1C9A:1046
	CHANGE_CURRENT_MAP_TO(zz);
	//^1C9A:104F
	ObjectID si = OBJECT_NULL;
	//^1C9A:1052
	U16 bp0a = (ww != OBJECT_NULL) ? 1 : 0;
	//^1C9A:1062
	U16 bp0e = xx;
	//^1C9A:1068
	U16 bp10 = yy;
	//^1C9A:106E
	U16 bp14 = (dir < 0) ? 0 : 4;
	//^1C9A:107E
	i16 bp12 = (RAND01() != 0) ? 1 : -1;
	do {
		//^1C9A:1092
		U16 bp06 = GET_TILE_VALUE(bp0e, bp10);
		//^1C9A:10A4
		U16 bp0c = bp06 >> 5;
		//^1C9A:10AC
		if (true
			&& bp0c != ttWall 
			&& bp0c != ttStairs
			&& (bp0c != ttTrickWall || (bp06 & 5) != 0)
			&& (bp0c != ttDoor || (bp06 = bp06 & 7, bp06 == 0) || bp06 == 5)
			&& GET_CREATURE_AT(bp0e, bp10) == OBJECT_NULL
		) {
			//^1C9A:10EE
			si = ALLOC_NEW_CREATURE(
				((bp0a != 0) ? 0x8000 : 0)|creatureType,
				healthMultiplier_1to31_baseIs8,
				creatureDir,
				bp0e,
				bp10
				);
			//^1C9A:1117
			if (si != OBJECT_NULL)
				//^1C9A:111A
				break;
		}
		//^1C9A:111C
		if (bp14 != 0) {
			//^1C9A:1122
			bp0e = xx + glbXAxisDelta[dir];
			//^1C9A:1134
			bp10 = yy + glbYAxisDelta[dir];
			//^1C9A:1146
			dir = (dir +bp12) & 3;
		}
		//^1C9A:1151
	} while (bp14-- != 0);
	//^1C9A:115E
	if (bp0a != 0 && si != OBJECT_NULL) {
		//^1C9A:1169
		Creature *bp04 = GET_ADDRESS_OF_RECORD4(si);
		//^1C9A:1176
		ObjectID di = bp04->GetPossessionObject();
		//^1C9A:117D
		while (di != OBJECT_END_MARKER && di.DBType() != dbMissile)
			//^1C9A:117F
			di = GET_NEXT_RECORD_LINK(di);
		//^1C9A:119A
		ATLASSERT(di != OBJECT_END_MARKER);
		GET_ADDRESS_OF_RECORDE(di)->SetMissileObject(ww);
	}
	//^1C9A:11AC
	CHANGE_CURRENT_MAP_TO(bp08);
	//^1C9A:11B5
	return si;
}

//^2759:21F5
i16 SkWinCore::FIND_HAND_WITH_EMPTY_FLASK(Champion *ref)
{
	// CSBwinSimilarity: TAG01c9b2,GetFlaskInHand

	// return -1 if you've not.
	// return 0 if you've at right hand.
	// return 1 if you've at left hand.

	//^2759:21F5
	ENTER(0);
	//^2759:21FA
	i16 si;
	for (si = 2; --si >= 0; ) {
		//^2759:21FF
		ObjectID di = ref->Possess(si);
		//^2759:220F
		if (true
			&& di.DBType() == dbPotion
			&& QUERY_CLS2_FROM_RECORD(di) == 0x14
		) {
			//^2759:2223
			break;
		}
		//^2759:2225
	}
	//^2759:2228
	return si;
}

//^2C1D:0B2C
// SPX: zz = base experience to gain
void SkWinCore::ADJUST_SKILLS(U16 player, U16 yy, U16 zz)
{
	// CSBwinSimilarity: TAG01605a,AdjustSkills
	// SPX: Should really compare with CSBWin LevelUp

	//^2C1D:0B2C
	ENTER(142);
	//^2C1D:0B32
	U16 di = yy;	// main skill
	//^2C1D:0B35
	if (true
		&& di >= 4 
		&& di <= 11
		&& (glbGameTick -150 > _4976_0090)
	) {
		//^2C1D:0B5B
		zz >>= 1;
	}
	//^2C1D:0B5E
	if (zz == 0)
		//^2C1D:0B64
		return;
	//^2C1D:0B67
	U16 bp06 = dunMapLocalHeader->Difficulty();	// map XP multiplicator
	U16 xpMapMultiplicator = bp06;	// SPX: added for reusage
	//^2C1D:0B78
	if (bp06 != 0) {
		//^2C1D:0B7C
		zz = zz * bp06;
	}
	//^2C1D:0B85
	Champion *champion = &glbChampionSquad[player]; //*bp04
	//^2C1D:0B96
	U16 si = (di >= 4) ? ((di -4) >>2) : di;
	//^2C1D:0BA9
	bp06 = QUERY_PLAYER_SKILL_LV(player, si, 0);	// Current skill level
	//^2C1D:0BB9
	if (true
		&& di >= 4
		&& ((i32)glbGameTick -25 < (i32)_4976_0090)
	) {
		//^2C1D:0BD9
		zz <<= 1;
	}
	//^2C1D:0BDC
	champion->skills[di] += zz;
	//^2C1D:0BF2
	if (di >= 4) {
		//^2C1D:0BF7
		champion->skills[si] += zz;
	}
	if (SkCodeParam::bUsePowerDebug)
	{
		U8 message[64];
		sprintf((char*)message, "%s: +%d XP %s (XP=%d)!\n"
			, glbChampionTable[player+1].firstName, zz
			, getSkillName(di), champion->skills[di]);
		DISPLAY_HINT_TEXT(glbChampionColor[player], message);
		SkD((DLV_XP, "%s", message));
	}
	//^2C1D:0C0A
	zz = QUERY_PLAYER_SKILL_LV(player, si, 0);	// Compare with new skill level
	//^2C1D:0C1A
	if (zz <= bp06)
		//^2C1D:0C1F
		return;
	//^2C1D:0C22
	U16 bp0c = zz;
	//^2C1D:0C25
	U16 bp08 = RAND01();		// 0 - 1
	//^2C1D:0C2D
	U16 bp0a = RAND01() +1;		// 1 - 2
	//^2C1D:0C36
	bp06 = RAND01();			// 0 - 1
	//^2C1D:0C3E
	if (si != 2)
		//^2C1D:0C43
		bp06 &= zz;
	//^2C1D:0C49
	champion->maxVit(champion->maxVit() +U8(bp06));
	//^2C1D:0C57
	bp06 = champion->curStamina();
	//^2C1D:0C5E
	champion->maxAntiF(champion->maxAntiF() + (RAND01() & (~zz)));
	//^2C1D:0C77
	U8 bp0d;
	switch (si) {
		case 0:
			//^2C1D:0C88
			bp0d = 6;		// 0x06 -> "<01>' JUST GAINED A FIGHTER LEVEL.<00>"
			//^2C1D:0C8C
			bp06 /= 16;		// Stamina increase
			//^2C1D:0C90
			// SPX: This is strange
			//zz = bp06 * zz;
			zz *= 3;
			//^2C1D:0C9B
			champion->maxStr(champion->maxStr() +U8(bp0a));	// STR + { 1 - 2 }
			//^2C1D:0CA9
			champion->maxDex(champion->maxDex() +U8(bp08));	// DEX + { 0 - 1 }
			//^2C1D:0CB7
			break;

		case 1:
			//^2C1D:0CBA
			bp0d = 7;		// 0x07 -> "<01>' JUST GAINED A NINJA LEVEL.<00>"
			//^2C1D:0CBE
			bp06 = bp06 / 21;
			//^2C1D:0CCB
			zz <<= 1;
			//^2C1D:0CCE
			champion->maxStr(champion->maxStr() +U8(bp08));	// STR + { 0 - 1 }
			//^2C1D:0CDC
			champion->maxDex(champion->maxDex() +U8(bp0a));	// DEX + { 1 - 2 }
			//^2C1D:0CE3
			//^2C1D:0CB0
			//^2C1D:0CB7
			break;

		case 3:
			//^2C1D:0CE5
			bp0d = 9;		// 0x09 -> "<01>' JUST GAINED A WIZARD LEVEL.<00>"
			//^2C1D:0CE9
			bp06 >>= 5;
			//^2C1D:0CED
			champion->maxMP(zz + (zz >> 1) + champion->maxMP());
			//^2C1D:0D02
			champion->maxWiz(champion->maxWiz() +U8(bp0a));	// WIS + { 1 - 2 }
			//^2C1D:0D09
			goto _0d3a;

		case 2:
			//^2C1D:0D0B
			bp0d = 8;		// 0x08 -> "<01>' JUST GAINED A PRIEST LEVEL.<00>"
			//^2C1D:0D0F
			bp06 = bp06 / 25;
			//^2C1D:0D1C
			champion->maxMP(champion->maxMP() +zz);
			//^2C1D:0D2A
			zz += (zz +1) >> 1;
			//^2C1D:0D33
			champion->maxWiz(champion->maxWiz() +U8(bp08));	// WIS + { 0 - 1 }
			//^2C1D:0D41
// SPX: label _0d3a = end of check for wizard/priest
_0d3a:
			champion->maxMP(champion->maxMP() +min_value(RAND02(), bp0c -1));
			//^2C1D:0D5E
			// SPX: Removed hard coded 900
			if (champion->maxMP() > MAXMP)
				//^2C1D:0D63
				champion->maxMP(MAXMP);
			//^2C1D:0D69
			champion->maxAntiM(champion->maxAntiM() +RAND02());

			break;
	}
	//^2C1D:0D7B
	// SPX: This is not the good formula -- wait ... this is the same, why did I wrote that ?
	//bp04->maxHP(RAND16((zz >> 1) +1) +zz +bp04->maxHP());
	// SPX: From CSBWin11 LevelUp, it should be more like this:
	champion->maxHP(RAND16((zz / 2) +1) +zz +champion->maxHP());
	//^2C1D:0D98
	if (champion->maxHP() > MAXHP)
		//^2C1D:0D9F
		champion->maxHP(MAXHP);
	//^2C1D:0DA5
	champion->maxStamina(RAND16((bp06 / 2) +1) +bp06 +champion->maxStamina());
	//^2C1D:0DC2
	if (champion->maxStamina() > MAXSP)
		//^2C1D:0DC9
		champion->maxStamina((__int16)MAXSP);
	//^2C1D:0DCF
	champion->heroFlag |= CHAMPION_FLAG_3800;	// 0x3800
	//^2C1D:0DD8
	glbChampionMajorSkillsLevel[player][si]++;
	//^2C1D:0DE2
	DISPLAY_HINT_NEW_LINE();
	//^2C1D:0DE7
	glbChampionBonesIndex = player;
	//^2C1D:0DED
	U8 bp008e[128];
	DISPLAY_HINT_TEXT(glbChampionColor[player], QUERY_GDAT_TEXT(GDAT_CATEGORY_INTERFACE_GENERAL, 0x00, bp0d, bp008e));
	//^2C1D:0E17
	return;
}

//^075F:000B
// SPX: TODO I wonder if aa is rather direction
void SkWinCore::SHOOT_ITEM(ObjectID rlItemThrown, U16 xx, U16 yy, U16 dir, U16 aa, U16 energyVal, U16 ene2Val, U16 dd)
{
	ATLASSERT(rlItemThrown.DBType() != dbDoor); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != dbTeleporter); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != dbText); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != dbActuator); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != dbCreature); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != db11); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != db12); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.DBType() != db13); // you cannot throw this kind of objects.
	ATLASSERT(rlItemThrown.IsMissile() || (!rlItemThrown.IsMissile() && rlItemThrown.DBType() != dbCloud)); // you cannot throw this kind of objects.

	//^075F:000B
	ENTER(14);
	//^075F:0011
	ObjectID di = rlItemThrown;
	//^075F:0014
	ObjectID si = ALLOC_NEW_RECORD(dbMissile);
	//^075F:001E
	if (si == OBJECT_NULL) {
		//^075F:0023
		if (di.DBType() != dbCloud) {
			//^075F:0033
			MOVE_RECORD_TO(ObjectID(di, dir), -1, 0, xx, yy);
		}
		//^075F:0054
		return;
	}
	//^075F:0057
	QUEUE_NOISE_GEN2(
		QUERY_CLS1_FROM_RECORD(di),
		QUERY_CLS2_FROM_RECORD(di),
		SOUND_STD_THROW,
		0xfe,
		xx,
		yy,
		1,
		0x6e,
		0x80
		);
	//^075F:0082
	si = ObjectID(si, dir);
	//^075F:0092
	Missile *missile = GET_ADDRESS_OF_RECORDE(si);	//*bp04
	//^075F:009F
	missile->SetMissileObject(di);
	//^075F:00A6
	missile->EnergyRemaining(U8(min_value(energyVal, 255)));
	//^075F:00BD
	missile->EnergyRemaining2(U8(ene2Val));
	//^075F:00C4
	APPEND_RECORD_TO(si, NULL, xx, yy);
	//^075F:00D7
	if (missile->GetMissileObject() == OBJECT_EFFECT_FIREBALL && glbCurrentMapIndex == glbPlayerMap)	// oFF80
		//^075F:00EA
		glbDoLightCheck = 1;
	//^075F:00F0
	Timer bp0e;
	bp0e.SetMap(glbCurrentMapIndex);
	bp0e.SetTick(glbGameTick +1);
	//^075F:0113
	bp0e.TimerType((_4976_4b7e != 0) ? tty1E : tty1D);
	//^075F:0124
	bp0e.actor = 0;
	//^075F:0128
	bp0e.value = si;
	//^075F:012B
	bp0e.w8_0_4(xx);
	//^075F:0138
	bp0e.w8_5_9(yy);
	//^075F:0149
	bp0e.w8_c_f(dd);
	//^075F:015B
	bp0e.w8_a_b(aa);
	//^075F:016B
	missile->TimerIndex(QUEUE_TIMER(&bp0e));
	//^075F:017E
	return;
}

//^2C1D:1CF3
// SPX: _2c1d_1cf3 renamed SHOOT_CHAMPION_MISSILE
void SkWinCore::SHOOT_CHAMPION_MISSILE(Champion *ref, ObjectID rl, U16 yy, U16 zz, U16 ww)
{
	//^2C1D:1CF3
	ENTER(0);
	//^2C1D:1CF7
	U16 si = ref->playerDir();
	//^2C1D:1D02
	SHOOT_ITEM(
		rl,
		glbPlayerPosX,
		glbPlayerPosY,
		((((ref->playerPos() -si +1) & 2) >> 1) +si) & 3,
		si,
		min_value(yy, 255),
		min_value(zz, 255),
		min_value(ww, 255)
		);

	SkD((DLV_TWEET, "Tweet: You (x:%d, y:%d, map:%d) have thrown %s by cast! \n"
		, glbPlayerPosX, glbPlayerPosY, glbCurrentMapIndex, static_cast<LPCSTR>(getRecordNameOf(rl))
		));
	//^2C1D:1D57
	glbPlayerThrowCounter = 4;
	//^2C1D:1D5D
	_4976_4c0c = si;
	//^2C1D:1D61
	return;
}

//^2C1D:1D64
// SPX: _2c1d_1d64 renamed CAST_CHAMPION_MISSILE_SPELL
U16 SkWinCore::CAST_CHAMPION_MISSILE_SPELL(U16 xx, ObjectID rl, i16 zz, U16 ww)
{
	//^2C1D:1D64
	ENTER(4);
	//^2C1D:1D6A
	U16 di = zz;
	//^2C1D:1D6D
	Champion *champion = &glbChampionSquad[xx];	// *bp04
	//^2C1D:1D7E
	if (champion->curMP() < ww)
		//^2C1D:1D8A
		return 0;
	//^2C1D:1D8E
	champion->curMP(champion->curMP() -ww);
	//^2C1D:1D9C
	champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
	//^2C1D:1DA2
	U16 si = 10 - min_value(8, champion->maxStamina() >> 3);
	//^2C1D:1DBA
	if ((si << 2) > di) {
		//^2C1D:1DC3
		di += 3;
		//^2C1D:1DC6
		si--;
	}
	//^2C1D:1DC7
	SHOOT_CHAMPION_MISSILE(champion, rl, di, 90, si);
	//^2C1D:1DDB
	return 1;
}

//^2759:15D0
// SPX: _2759_15d0 replaced by PROCEED_LIGHT
// CSBWin: part of TAG01ca0c / CastSpell
void SkWinCore::PROCEED_LIGHT(U16 cmdNum, U16 yy)
{
	//^2759:15D0
	ENTER(12);
	//^2759:15D6
	i16 bp0c = 1;
	//^2759:15DB
	yy = BETWEEN_VALUE(32, yy +1, 256);
	//^2759:15F0
	i16 si = yy >> 3;
	//^2759:15F5
	si = max_value(8, si);
	//^2759:1601
	U16 di ;
	switch (cmdNum) {
		case CmDarkness: // 6
			//^2759:1615
			di = ((si -8) << 4) +16;
			//^2759:1622
			bp0c = -2;
			//^2759:1627
			//^2759:1649
			si >>= 1;
			si--;
			break;

		case CmLight: // 38
			//^2759:1629
			di = ((si -3) << 7) +2000;
			//^2759:1636
			si >>= 2;
			si++;
			//^2759:163A
			break;

		case CmLongLight: // 39	Long light
			//^2759:163C
			di = ((si -8) << 9) +10000;
			//^2759:1649
			si >>= 1;
			si--;

			break;
	}
	//^2759:164C
	Timer bp0a;
	bp0a.TimerType(ttyLight);
	//^2759:1650
	bp0a.value = (cmdNum == CmDarkness) ? si : -si;
	//^2759:1661
	bp0a.SetMap(glbPlayerMap);
	bp0a.SetTick(glbGameTick +di);
	//^2759:1683
	bp0a.actor = 0;
	//^2759:1687		
	QUEUE_TIMER(&bp0a);
	//^2759:1693
	//glbGlobalSpellEffects.Light = tLightLevelItem[RCJ(16,si)] * bp0c;
	// SPX: fix, to add new effect to current, still problem with DES IR SAR effect --> fixed using signed value in RECALC_LIGHT_LEVEL instead of unsigned.
	glbGlobalSpellEffects.Light += (tLightLevelItem[RCJ(16,si)] * bp0c);
	//^2759:16A3
	RECALC_LIGHT_LEVEL();
	//^2759:16A8
	return;
}








	//^2C1D:0186
// SPX: _2c1d_0186 replaced by CALL_SELF_ENCHANTMENT
U16 SkWinCore::CALL_ENCHANTMENT_SELF(Champion *ref, i16 xx, U16 yy, U16 zz)
{
	//^2C1D:0186
	ENTER(0);
	//^2C1D:018B
	X16 di = yy;
	X16 si = 1;
	if (zz != 0) {
		//^2C1D:0197
		if (ref->curMP() == 0)
			return 0;
		//^2C1D:01A5
		if (ref->curMP() < 4) {
			//^2C1D:01AF
			di >>= 1;
			ref->curMP(0);
			si = 0;
		}
		else {
			//^2C1D:01BB
			ref->curMP(4);
		}
	}
	//^2C1D:01C3
	PROCEED_ENCHANTMENT_SELF(15, xx, di >> 5, di);
	//^2C1D:01D7
	return si;
}

//^2759:0F39
// SPX: _2759_0f39 renamed ADJUST_HAND_COOLDOWN
void SkWinCore::ADJUST_HAND_COOLDOWN(U16 player, U16 yy, U16 zz)
{
	//^2759:0F39
	ENTER(6);
	//^2759:0F3F
	U16 di = yy;
	U16 si = zz;
	//^2759:0F45
	Champion *champion = &glbChampionSquad[player];
	//^2759:0F56
	U16 bp06;
	(si == 0xffff) ? (bp06 = 3, si = 0) : (bp06 = 1);
	//^2759:0F69
	if (glbGlobalSpellEffects.AuraOfSpeed != 0)
		//^2759:0F70
		di >>= 2;
	//^2759:0F73
	di += 2;

	do {
		//^2759:0F75
		U16 cx = champion->handCooldown[si];
		//^2759:0F80
		if (cx < di) {
			//^2759:0F84
			cx = (cx >> 1) +di;
		}
		else {
			//^2759:0F8E
			cx += di >> 1;
		}
		//^2759:0F94
		if (cx > 255)
			//^2759:0F9A
			cx = 255;
		//^2759:0F9D
		champion->handCooldown[si] = U8(cx);
		//^2759:0FA6
		si++;
		//^2759:0FA7
	} while (--bp06 != 0);

	//^2759:0FAC
	return;
}

//^2759:222E
// SPX: _2759_222e replaced by CAST_SPELL_PLAYER
// CSBWin: partially TAG01ca0c
U16 SkWinCore::CAST_SPELL_PLAYER(U16 player, SpellDefinition *ref, U16 power)
{
	// CSBwinSimilarity: TAG01ca0c,CastSpell

	// 0 if succeeds
	// not 0 if fails

	//^2759:222E
	ENTER(30);
	//^2759:2234
	Champion *champion = &glbChampionSquad[player];	//*bp04
	//^2759:2245
	U16 bp0e = (ref->w6_a_f() * (power +18)) / 24;
	//^2759:2264
	U16 bp08 = ref->difficulty +power; // global difficulty of the spell
	//^2759:2273
	U16 bp0c = 0
		+((RAND() & 7) + (bp08 << 4))
		+((ref->difficulty * (power -1)) << 3)
		+(bp08 * bp08)
		;
	//^2759:22A6
	U16 bp06 = QUERY_PLAYER_SKILL_LV(player, ref->requiredSkill, 1);
	//^2759:22BD
	U16 di;
	i16 bp0a;
	for (bp0a = bp08 -bp06; (bp0a--) > 0; ) {
		//^2759:22C8
		if ((RAND() & 127) > min_value(GET_PLAYER_ABILITY(champion, abWiz, 0) +15, 115)) {
			//^2759:22F5
			ADJUST_SKILLS(player, ref->requiredSkill, bp0c << (bp08 -bp06));
			//^2759:2316
			di = 16;
			//^2759:2319
			goto _26fe; // go to end, spell failed ?
		}
		//^2759:231C
	}
	//^2759:2326
	U16 bp1a;
	//SPX: SPELL TYPE => 16 possible spell types!
	switch (ref->w6 & 15) {
		case SPELL_TYPE_POTION: // 1: transform flask to potion
			{
				//^2759:2341
				bp0a = FIND_HAND_WITH_EMPTY_FLASK(champion);
				//^2759:2350
				if (bp0a < 0) {
					//^2759:2354
					di = 48;		// SPX: for displaying graphics : needs flask in hand
					//^2759:2357
					goto _26fe;
				}
				//^2759:235A
				ObjectID si = REMOVE_POSSESSION(player, bp0a);
				//^2759:2369
				SET_ITEMTYPE(si, ref->SpellCastIndex());
				//^2759:237E
				GET_ADDRESS_OF_RECORD8(si)->PotionPower((RAND() & 15) + (power * 40));
				//^2759:23AC
				EQUIP_ITEM_TO_INVENTORY(player, si, bp0a);
				//^2759:23BB
				break;
			}
		case SPELL_TYPE_MISSILE: // 2: shoot spell
			{
				//^2759:23BE
				if (ref->SpellCastIndex() == 4) // zo spell ?
					//^2759:23D0
					bp06 <<= 1; // multiply by 2
				//^2759:23D3
				CAST_CHAMPION_MISSILE_SPELL(
					player,
					ObjectID::MissileRecord(ref->SpellCastIndex()),
					BETWEEN_VALUE(21, ((bp06 << 1) +4) * (power +2), 255),
					0
					);
				//^2759:2411
				break;
			}
		case SPELL_TYPE_SUMMON: // 4: summon creature
			{
				//^2759:2414
				// SPX: beware, hard test for U-Haul minion (0x35)
				if (ref->SpellCastIndex() == CREATURE_GOOD_U_HAUL_MINION) {
					//^2759:2426
					Creature *bp1e = reinterpret_cast<Creature *>(glbDBObjectData[dbCreature]);
					//^2759:2433
					for (bp08 = dunHeader->nRecords[dbCreature]; (bp08--) != 0; bp1e++) {
						//^2759:2440
						if (true
							&& bp1e->w0 != OBJECT_NULL 
							&& bp1e->CreatureType() == CREATURE_GOOD_U_HAUL_MINION
							&& (bp0a = bp1e->b5) != 0x00ff
							&& glbTabCreaturesInfo[bp0a].Command != ccmDestroy	// 0x13
						) {
							//^2759:2470
							glbTabCreaturesInfo[bp0a].Command2 = ccmDestroy;	// 0x13
							//^2759:2483
							goto _26cf;
						}
						//^2759:2486
					}
				}
				//^2759:2494
				ObjectID si = CREATE_MINION(
					ref->SpellCastIndex(),
					((RAND02() + (bp06 << 1)) * power) / 6,
					(glbPlayerDir +2) &3,
					glbPlayerPosX,
					glbPlayerPosY,
					glbPlayerMap,
					-1,
					glbPlayerDir
					);
				//^2759:24E0
				if (si == OBJECT_NULL)	// SPX: Summon failed? create a cloud
					//^2759:24E8
					CREATE_CLOUD(OBJECT_EFFECT_CLOUD, 0x6e, glbPlayerPosX, glbPlayerPosY, 255);	// oFFA8
				//^2759:24FF
				break;
			}
		case SPELL_TYPE_GENERAL: // 3: enchantments + general
			{
				//^2759:2502
				Timer bp18;
				bp18.actor = 0;
				//^2759:2506
				bp08 = (power +1) << 2; // (power+1)*4
				//^2759:2513
				ObjectID si;
				switch (ref->SpellCastIndex()) {
				case  0:		// Long Light (OH IR RA)
					//^2759:252D
					bp0a = CmLongLight;
					//^2759:2532
					goto _2540;

				case  1:		// Darkness (DES IR SAR)
					//^2759:2534
					bp0a = CmDarkness;
					//^2759:2539
					goto _2540;

				case  5:		// Light (FUL)
					//^2759:253B
					bp0a = CmLight;
					//^2759:2540
_2540:	// Do light
					PROCEED_LIGHT(bp0a, bp08 * 9);
					//^2759:2550
					//^2759:25AC
					//^2759:2696
					break;

				case  3:		// Invisibility (OH EW SAR)
					//^2759:2553
					bp18.TimerType(ttyInvisibility);
					//^2759:2557
					if (glbGlobalSpellEffects.Invisibility++ == 0 && glbChampionInventory != 0) {
						//^2759:256B
						glbChampionTable[glbChampionInventory].heroFlag |= CHAMPION_FLAG_4000;	// 0x4000
					}
					//^2759:257B
					bp08 <<= 3;
					//^2759:257F
					bp18.SetMap(glbPlayerMap);
					bp18.SetTick(glbGameTick +bp08);
					//^2759:25A2
					QUEUE_TIMER(&bp18);
					//^2759:25AC
					//^2759:2696
					break;

				// SPX: (DM1 : OH EW RA See thru walls, used TT_71)
				case  2:	// Spell shield
					//^2759:25AF
					bp0a = ENCHANTMENT_SPELL_SHIELD;	// type shield = 1
					//^2759:25B4
_25b4:
					bp08 = bp08 * bp08 + 100;
					//^2759:25C0
					goto _25e8;

				case  8:	// Fire shield
					//^2759:25C2
					bp0a = ENCHANTMENT_FIRE_SHIELD;		// type shield = 0
					//^2759:25C7
					goto _25b4;

				case  4:	// Party shield (YA IR)
					//^2759:25C9
					bp0a = ENCHANTMENT_PARTY_SHIELD;	// type shield = 2
					//^2759:25CE
					bp08 = bp08 * bp08;
					//^2759:25D4
					//^2759:25BD
					//^2759:25C0
					goto _25e8;

					// SPX: DM1: Was YA-BRO-ROS Foot prints
				case  6:	// Aura of Wisdom
					//^2759:25D6
					bp0a = ENCHANTMENT_AURA_WISDOM;		// type = 5
					//^2759:25DB
_25db:
					bp08 += 3;
					//^2759:25DF
					bp08 = bp08 * bp08;
					//^2759:25E8
_25e8:
					CALL_ENCHANTMENT_SELF(champion, bp0a, bp08, 0);
					//^2759:25FC
					//^2759:2664
					//^2759:2667
					break;
				// SPX DM1 : Was ZO KATH RA
				case  7:	// Aura of Dexterity
					//^2759:25FE
					bp0a = ENCHANTMENT_AURA_DEXTERITY;	// type = 4
					//^2759:2603
					goto _25db;

				case  9:	// Aura of Vitality
					//^2759:2605
					bp0a = ENCHANTMENT_AURA_VITALITY;	// type = 6
					//^2759:260A
					goto _25db;

				case 10:	// Aura of Strength
					//^2759:260C
					bp0a = ENCHANTMENT_AURA_STRENGTH;	// type = 3
					//^2759:2611
					goto _25db;

				case 11:	// Aura of Speed
					//^2759:2613
					glbGlobalSpellEffects.AuraOfSpeed = U8(min_value((bp08 << 3) + glbGlobalSpellEffects.AuraOfSpeed, 255));
					//^2759:262F
					break;

				case 14:	// Spell reflector : oFF8E
					//^2759:2632
					CREATE_CLOUD(
						OBJECT_EFFECT_REFLECTOR, 
						BETWEEN_VALUE(21, ((bp06 << 1) +4) * (power +2), 255),
						glbPlayerPosX,
						glbPlayerPosY,
						255
						);
					//^2759:2667
					break;

				case 15:	// Magical Marker => Item creator!
					//^2759:2669
					bp1a = QUERY_GDAT_ENTRY_DATA_INDEX(0x0d, 0x0f, dtWordValue, 0x42);
					//SPX query missile (0x0D) number 0x0F, read bin0B (dtWordValue) entry 0x42.
					//--> In the GDAT, it holds the value 013E (from item activation list) which targets the misc 0x3E = YaEw marker.
					//--> To change the generated value, the GDAT entry must be changed!

					//^2759:267C
					si = ALLOC_NEW_DBITEM(bp1a);
					//^2759:2687
					if (glbLeaderHandPossession.object == OBJECT_NULL) {
						//^2759:268E
						TAKE_OBJECT(si, 1);
						//^2759:2698
						break;
					}
					else {
						//^2759:269A
						bp08 = (RAND01() + glbPlayerDir) & 3;
						//^2759:26AC
						MOVE_RECORD_TO(
							ObjectID(si, bp08),
							-1,
							0,
							glbPlayerPosX,
							glbPlayerPosY
							);

						break;
					}
					// SPX: Two unused cases, would be nice to have Window spell back. Can we do this here?
					// In a more general way, the effects should not be hard coded ...
				/*case 12:	// NEW, used for restoring all party health
					if (SkCodeParam::bUseDM2ExtendedMode)
					{
						Champion*	ch;
						for (int championIndex = 0; championIndex < glbChampionsCount; championIndex++) {
							ch = &glbChampionSquad[championIndex];
							if (ch->curHP() == 0)
								continue;
							ch->curHP(ch->maxHP());
							ch->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
						}
						// This only does not refresh the HP bar.
					}
					break;
				case 13:	// NEW, used for restoring current champion health
					if (SkCodeParam::bUseDM2ExtendedMode)
					{
						champion->curHP(champion->maxHP());
						champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
						// This only does not refresh the HP bar.
					}
					break;*/
#if DM2_EXTENDED_MODE == 1
				case 12: // SPX: Reimplementation of OH EW RA See thru walls, use TT_71)
					bp18.TimerType(ttySeeThruWalls);
					glbGlobalSpellEffects.SeeThruWalls++;
					bp08 /= 2;
					// csbwin tag01cda4
					bp08 = bp08 * bp08;
					// csbwin tag01cdaa (not yet correctly done, see below)
					bp18.SetMap(glbPlayerMap);
					bp18.SetTick(glbGameTick + bp08);
					QUEUE_TIMER(&bp18);
					break;
					/*
tag01cdaa:
          D0L = d.Time;
          D6L &= 0xffff;
          D0L += D6L;
          D1L = d.partyLevel << 24;
          timer_20.timerTime = D1L | D0L;
          gameTimers.SetTimer(&timer_20);
		  */
#endif
				}

				break;
			}
	}
	//^2759:26CF
_26cf:
	di = 0;
	//^2759:26D1
	if (bp0e != 0) {
		//^2759:26D7
		ADJUST_SKILLS(player, ref->requiredSkill, bp0c);
		//^2759:26EF
		ADJUST_HAND_COOLDOWN(player, bp0e, 2);
	}
	//^2759:26FE
_26fe:
	if (di != 0) {
		//^2759:2702
		bp08 = ref->requiredSkill;
		//^2759:270E
		// SPX: if it is beyond the 4 global skills
		if (bp08 > 3) {
			//^2759:2713
			bp08 = (bp08 -4) >> 2;
			// SPX: Set to 1st detailed skill?
		}
		//^2759:271C
		di |= bp08;
	}
	//^2759:271F
	return di;
}

//^0B36:1757
// SPX: ressembles pretty much DRAW_STATIC_PIC (_0B36_1688) 
// SPX: _0B36_1757 renamed DRAW_TRANSPARENT_STATIC_PIC
void SkWinCore::DRAW_TRANSPARENT_STATIC_PIC(U8 cls1, U8 cls2, U8 cls4, U16 rectno, U16 colorkey)
{
	//^0B36:1757
	ENTER(314);
	//^0B36:175B
	ExtendedPicture bp013a;
	QUERY_GDAT_SUMMARY_IMAGE(&bp013a, cls1, cls2, cls4);
	//^0B36:1774
	bp013a.colorKeyPassThrough = colorkey;
	bp013a.rectNo = rectno;
	//^0B36:1782
	DRAW_PICST(QUERY_PICST_IT(&bp013a));
	//^0B36:1796
	return;
}

//^48AE:0001
U16 SkWinCore::GET_GLOB_VAR(U16 var)
{
	// 0x00-0x3f: 1bit value
	// 0x40-0x7f: byte value
	// 0x80-0xbf: word value

	//^48AE:0001
	ENTER(0);
	//^48AE:0004
	if (var <= 0x3f) {
		//^48AE:000A
		if ((glbIngameGlobVarFlags[var >> 3] & (1 << (var & 7))) == 0)
			//^48AE:0023
			//^48AE:0054
			return 0;
		//^48AE:0025
		return 1;
	}
	//^48AE:002A
	if (var <= 0x7f) {
		//^48AE:0030
		return glbIngameGlobVarBytes[var -0x40];
	}
	//^48AE:003E
	if (var <= 0xbf) {
		//^48AE:0045
		return glbIngameGlobVarWords[var -0x80];
	}
	//^48AE:0054
	return 0;
}

//^48AE:0058
U16 SkWinCore::UPDATE_GLOB_VAR(U16 var, U16 newval, U16 op)
{
	// op == 0: var = 1
	// op == 1: var = 0
	// op == 2: var = !var
	// op == 3: var += newval
	// op == 4: var -= newval
	// op == 6: var = newval

	//^48AE:0058
	ENTER(0);
	//^48AE:005D
	U16 di = newval;
	//^48AE:0060
	U16 si = GET_GLOB_VAR(var);
	//^48AE:006A
	switch (op) {
		case 0:
			//^48AE:0079
			si = 1;
			//^48AE:007C
			break;

		case 1:
			//^48AE:007E
			//^48AE:0084
			si = 0;
			//^48AE:0086
			break;

		case 2:
			//^48AE:0080
			si = (si != 0) ? 0 : 1;
			//^48AE:008B
			break;

		case 3:
			//^48AE:008D
			si += di;
			//^48AE:008F
			break;

		case 4:
			//^48AE:0091
			si -= di;
			//^48AE:0093
			break;

		case 5:
			break;

		case 6:
			//^48AE:0095
			si = di;
			break;
	}
	//^48AE:0097
	// var x00 - x3F => FLAGS 0 to 8 (in fact var = #FLAG*8 ...)
	if (var <= 0x3f) {
		//^48AE:009D
		op = 1 << (var & 7);
		//^48AE:00AB
		var >>= 3;
		//^48AE:00AF
		if (si != 0) {
			//^48AE:00B3
			si = 1;
			//^48AE:00B6
			glbIngameGlobVarFlags[var] |= U8(op);
			//^48AE:00C0
			//^48AE:0106
			return si;
		}
		else {
			//^48AE:00C2
			glbIngameGlobVarFlags[var] &= ~U8(op);
			//^48AE:00CE
			//^48AE:0106
			return si;
		}
	}
	//^48AE:00D0
	// var x40 - x7F => BYTE 00 to 64
	if (var <= 0x7f) {
		//^48AE:00D6
		si = BETWEEN_VALUE(0, si, 255);
		//^48AE:00E6
		glbIngameGlobVarBytes[var -0x40] = U8(si);
		//^48AE:00F0
		//^48AE:0106
		return si;
	}
	//^48AE:00F2
	// var x80 - xbf => WORD 00 to 64
	if (var <= 0xbf) {
		//^48AE:00F9
		glbIngameGlobVarWords[var -0x80] = si;
	}
	//^48AE:0106
	return si;
}

//^29EE:0B4A
// SPX: _29ee_0b4a renamed PROCEED_SPELL_FAILURE
void SkWinCore::PROCEED_SPELL_FAILURE(U16 xx)
{
	//^29EE:0B4A
	ENTER(0);

	//^29EE:0B4F
	U16 di = 1;
	//^29EE:0B52
	U16 si;
	switch (xx & 0xfff0) {
		case 0x0010:
			//^29EE:0B69
			if ((xx & 15) == 3) {
				//^29EE:0B74
				glbChampionAttackDamage = ATTACK_FAILURE_WIZARD;	// -4
			}
			else {
				//^29EE:0B7C
				glbChampionAttackDamage = ATTACK_FAILURE_PRIEST;	// -5
			}
			//^29EE:0B82
			si = 0x45;
			//^29EE:0B85
			goto _0baa;

		case 0x0020:
			//^29EE:0B87
			glbChampionAttackDamage = ATTACK_MEANINGLESS_SPELL;	// -3
			//^29EE:0B8D
			si = 0x46;
			//^29EE:0B90
			goto _0baa;

		case 0x0030:	// need flask in hand 
			//^29EE:0B92
			//DRAW_TRANSPARENT_STATIC_PIC(0x01, 0x05, 0x0B, 0x5c, -1);
			DRAW_TRANSPARENT_STATIC_PIC(GDAT_CATEGORY_INTERFACE_GENERAL, GDAT_INTERFACE_CLASS_SPELLING, GDAT_IMG_NEED_FLASK, 0x5c, -1);
			//^29EE:0BA4
			si = 0x44;
			di = 0x03;
			//^29EE:0BAA
_0baa:
			glbSomeChampionPanelFlag = max_value(di, 8 - UPDATE_GLOB_VAR(si, 1, 3));

			break;
	}
	//^29EE:0BC8
	return;
}

//^2759:274D
Bit16u SkWinCore::TRY_CAST_SPELL()
{
	//^2759:274D
	ENTER(10);
	//^2759:2753
	U16 bp0a = glbChampionIndex -1;
	//^2759:275A
	Champion *bp04 = &glbChampionSquad[bp0a];
	//^2759:2768
	SpellDefinition *bp08 = FIND_SPELL_BY_RUNES(bp04->GetRunes());
	//^2759:277E
	// SPX: then si = 32 means a "meaningless spell", not existing spell
	U16 si = (bp08 == NULL) 
		? 32
		: CAST_SPELL_PLAYER(bp0a, bp08, i16(bp04->GetRunes()[0]) -0x5f);
	//^2759:27A5
	// SPX: di = 0 : spell ok / di = 1 : spell failed
	U16 di = (si != 0) ? 1 : 0;
	//^2759:27B2
	if (di != 0)
		//^2759:27B6
		PROCEED_SPELL_FAILURE(si);
	//^2759:27BD
	si &= 0x00f0;
	//^2759:27C1
	if (si != 0x0030) {
		//^2759:27C8
		bp04->GetRunes()[0] = 0;
		bp04->runesCount = 0;
		//^2759:27D5
		DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
	}
	//^2759:27D9
	return di;
}

//^2759:289C
void SkWinCore::REMOVE_RUNE_FROM_TAIL()
{
	//^2759:289C
	ENTER(4);
	//^2759:28A0
	Champion *champion = &glbChampionTable[glbChampionIndex];	//*bp04
	//^2759:28B1
	champion->RuneCnt(champion->RuneCnt() -1);
	//^2759:28BE
	champion->GetRunes()[champion->RuneCnt()] = 0;
	//^2759:28C7
	glbSomeChampionPanelFlag = 1;
	//^2759:28CD
	UPDATE_RIGHT_PANEL(0);
	//^2759:28D4
	_1031_0667();
	//^2759:28D9
	return;
}

//^2759:27DF
void SkWinCore::ADD_RUNE_TO_TAIL(Bit16u symbol_0to5)
{
	//^2759:27DF
	ENTER(6);
	//^2759:27E5
	Champion *champion = &glbChampionTable[glbChampionIndex];	//*bp04
	//^2759:27F6
	U16 si = champion->RuneCnt();
	//^2759:2801
	U16 di = RuneManaPower[si * 6 +symbol_0to5];
	//^2759:2813
	if (si != 0) {	// if not on POWER rune (any other : INFLUENCE, FORM, ..)
		//^2759:2817
		di = (RunePowerMultiplicator[i8(champion->GetRunes()[0]) -RUNE_FIRST] * di) >> 3;
	}
	//^2759:2832
	U16 bp06 = 0;
	//^2759:2837
	if (champion->curMP() >= di) {
		//^2759:2840
		champion->curMP(champion->curMP() -di);
		//^2759:284A
		champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
		//^2759:2850
		champion->GetRunes()[si] = si * 6 +symbol_0to5 +RUNE_FIRST; si++;
		//^2759:2861
		champion->RuneCnt(U8(si));
		//^2759:2867
		champion->GetRunes()[si] = 0;
		//^2759:2870
		bp06 = 1;
	}
	//^2759:2875
	glbSomeChampionPanelFlag = 1;
	//^2759:287B
	UPDATE_RIGHT_PANEL(0);
	//^2759:2882
	_1031_0667();
	//^2759:2887
	if (bp06 != 0) {
		//^2759:288D
		REFRESH_PLAYER_STAT_DISP(glbChampionIndex -1);
	}
	//^2759:2898
	return;
}

//^2759:01E3
U16 SkWinCore::QUERY_CUR_CMDSTR_ENTRY(U16 cmdNum)
{
	//^2759:01E3
	ENTER(0);
	//^2759:01E6
	return QUERY_CMDSTR_ENTRY(glbItemGDATCategory, glbItemGDATIndex, glbItemGDATEntry, cmdNum);
}

//^2C1D:111E
// SPX: _2c1d_111e renamed USE_DEXTERITY_ATTRIBUTE
U16 SkWinCore::USE_DEXTERITY_ATTRIBUTE(U16 player)
{
	//^2C1D:111E
	ENTER(4);
	//^2C1D:1123
	Champion *champion = &glbChampionSquad[player];
	//^2C1D:1134
	i16 si = (RAND() & 7) + GET_PLAYER_ABILITY(champion, abDex, 0);
	//^2C1D:1153
	si -= (GET_PLAYER_WEIGHT(player) * i32(si >> 1)) / MAX_LOAD(champion);
	//^2C1D:1182
	si = max_value(2, si);
	//^2C1D:118E
	if (glbIsPlayerSleeping != 0)
		//^2C1D:1195
		si >>= 1;
	//^2C1D:1197
	return BETWEEN_VALUE((RAND() & 7) +1, (si >> 1), 100 - (RAND() & 7));
}

//^2C1D:0F67
// SPX: _2c1d_0f67 renamed USE_LUCK_ATTRIBUTE
U16 SkWinCore::USE_LUCK_ATTRIBUTE(Champion *ref, U16 xx)
{
	//^2C1D:0F67
	ENTER(0);
	//^2C1D:0F6B
	U16 si = xx;
	//^2C1D:0F6E
	if (RAND01() != 0 && RAND16(100) > si) {
		//^2C1D:0F83
		return 1;
	}
	//^2C1D:0F88
	si = (RAND16(GET_PLAYER_ABILITY(ref, ATTRIBUTE_LUCK, 0) << 1) > si) ? 1 : 0;
	//^2C1D:0FAF
	ref->attributes[ATTRIBUTE_LUCK][ATTRIBUTE_CURRENT] = U8(BETWEEN_VALUE(10, ref->attributes[ATTRIBUTE_LUCK][ATTRIBUTE_CURRENT] +((si != 0) ? -2 : 2), min_value(220, GET_PLAYER_ABILITY(ref, 0, 1))));
	//^2C1D:0FF9
	return si;
}

//^075F:1F33
U16 SkWinCore::CALC_PLAYER_ATTACK_DAMAGE(Champion *ref, U16 player, ObjectID rlEnemy, U16 xx, U16 yy, U16 valPb, U16 valDM, U16 valSk, U16 valAt)
{
	//^075F:1F33
	ENTER(16);
	//^075F:1F39
	if (player >= glbChampionsCount)
		//^075F:1F42
		return 0;
	//^075F:1F47
	if (ref->curHP() == 0)
		//^075F:1F51
		//^075F:1F42
		return 0;
	//^075F:1F53
	U16 bp0c = dunMapLocalHeader->Difficulty() << 1;
	//^075F:1F66
	Creature *bp08 = GET_ADDRESS_OF_RECORD4(rlEnemy);
	//^075F:1F75
	AIDefinition *bp04 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp08->CreatureType());
	//^075F:1F89
	i16 si;
	i16 di;
	if (true
		&& bp04->Defense != 255
		&& ((bp04->w24 & 0x1000) == 0 || valAt == 1)
	) {
		//^075F:1FAA
		ObjectID bp10 = GET_CREATURE_AT(xx, yy);
		//^075F:1FBA
		if (bp10 == OBJECT_NULL || _1c9a_0958(bp10) == 0) {
			//^075F:1FCF
			U16 bp0e = valPb & 0x8000;
			//^075F:1FD8
			valPb &= 0x7fff;
			//^075F:1FDD
			if (bp04->w0_5_5() == 0 || bp0e != 0) {
				//^075F:1FF0
				if (false
					|| USE_DEXTERITY_ATTRIBUTE(player) > (((RAND() & 31) + bp04->Defense +bp0c +(glbLightLevel << 1) -16) >> 1)
					|| RAND02() == 0
					|| USE_LUCK_ATTRIBUTE(ref, 75 -valPb) != 0
				) {
					//^075F:2047
					si = COMPUTE_PLAYER_ATTACK_OR_THROW_STRENGTH(player, glbSelectedHandAction, valSk);
					//^075F:205B
					if (si != 0) {
						//^075F:205F
						si = RAND16((si >> 1) +1) +si;
						//^075F:2071
						si = (i32(si) * valDM) >> 5;
						//^075F:208B
						U16 bp0a = bp04->ArmorClass +(RAND() & 31) +bp0c;
						//^075F:20A4
						di = si = (RAND() & 31) +si -bp0a;
						//^075F:20B5
						if (di > 1)
							//^075F:20B8
							goto _2112;
					}
					//^075F:20BA
					si = RAND02();
					//^075F:20C1
					if (si != 0) {
						//^075F:20C8
						si++;
						//^075F:20C9
						di = (RAND() & 15) +di;
						//^075F:20D7
						if (di > 0 || RAND01() != 0) {
							//^075F:20E6
							si = RAND02() +si;
							//^075F:20F1
							if (RAND02() == 0) {
								//^075F:20FA
								si += max_value(0, (RAND() & 15) +di);
							}
						}
						//^075F:2112
_2112:
						si >>= 1;
						//^075F:2114
						si = RAND16(si) +RAND02() +si;
						//^075F:2128
						si = RAND16(si) +si;
						//^075F:2135
						si >>= 2;
						//^075F:2138
						si = RAND02() +si +1;
						//^075F:2142
						if ((RAND() & 63) < QUERY_PLAYER_SKILL_LV(player, valSk, 1)) {
							//^075F:2160
							si += si +10;
						}
						//^075F:2167
						//SPX: Something to do with POISON
						di = QUERY_GDAT_DBSPEC_WORD_VALUE(ref->Possess(glbSelectedHandAction), GDAT_ITEM_STATS_POISONOUS);	// 13
						//^075F:2181
						if (di != 0 && (RAND() & 31) < si) {
							//^075F:2191
							// Add poison damage
							si = APPLY_CREATURE_POISON_RESISTANCE(rlEnemy, di) +si;
						}
						//^075F:21A2
						ADJUST_SKILLS(player, valSk, ((bp04->w22_8_b() * si) >> 4) +3);
						//^075F:21CA
						ADJUST_STAMINA(player, RAND02() +4);
						//^075F:21D2
						goto _21dd;
					}
				}
			}
		}
	}
	//^075F:21D4
	si = 0;
	//^075F:21D6
	ADJUST_STAMINA(player, RAND01() +2);
	//^075F:21E8
_21dd:
	ATTACK_CREATURE(rlEnemy, xx, yy, 0x6002, 0x5a, si);
	//^075F:21FF
	return si;
}

//^2759:14C8
U16 SkWinCore::WIELD_WEAPON(U16 player, U16 valPa, U16 xx, U16 yy, U16 valSk, U16 valAt)
{
	// returns 0 if no target, 1 if hits a creature.

	//^2759:14C8
	ENTER(4);
	//^2759:14CE
	Champion *champion = &glbChampionSquad[player];	//*bp04
	//^2759:14DF
	if (glbObjectID_4976_534c == OBJECT_NULL)
		//^2759:14E6
		//^2759:15CA
		return 0;
	//^2759:14E9
	if (GET_CREATURE_AT(xx, yy) == OBJECT_NULL)
		//^2759:14FB
		//^2759:15CA
		return 0;
	//^2759:14FE
	U16 di = champion->playerPos();
	//^2759:1509
	U16 si;
	switch ((di +4 -champion->playerDir()) & 3) {
		case 2:
			//^2759:1526
			si = 3;
			//^2759:1529
			goto _152e;

		case 3:
			//^2759:152B
			si = 1;
			//^2759:152E
_152e:
			if (GET_PLAYER_AT_POSITION((di + si) & 3) != -1) {
				//^2759:1541
				glbChampionAttackDamage = ATTACK_FAILURE_NOT_FRONT; // -1
				//^2759:1547
				glbSomeChampionPanelFlag = max_value(1, 8 - UPDATE_GLOB_VAR(66, 1, 3));
				//^2759:1567
				//^2759:15CA
				return 0;
			}

			break;
	}
	//^2759:1569
	if (valPa == 1) {
		//^2759:156F
		if ((QUERY_CREATURE_AI_SPEC_FLAGS(glbObjectID_4976_534c) & 0x0020) == 0)
			//^2759:157C
			//^2759:15CA
			return 0;
	}
	//^2759:157E
	si = QUERY_CUR_CMDSTR_ENTRY(CnPB);
	//^2759:1587
	di = QUERY_CUR_CMDSTR_ENTRY(CnDM);
	//^2759:1590
	if (QUERY_CUR_CMDSTR_ENTRY(CnHN) != 0)
		//^2759:159B
		si |= 0x8000;	// Hurt non material
	//^2759:159F
	glbChampionAttackDamage = CALC_PLAYER_ATTACK_DAMAGE(champion, player, glbObjectID_4976_534c, xx, yy, si, di, valSk, valAt);
	//^2759:15C5
	return 1;
}

//^2759:1451
U16 SkWinCore::CONFUSE_CREATURE(U16 ww, U16 xx, U16 yy)
{
	//^2759:1451
	ENTER(8);
	//^2759:1457
	X16 si = 0;
	if (glbObjectID_4976_534c != OBJECT_NULL) {
		//^2759:1460
		Creature* creature = GET_ADDRESS_OF_RECORD4(glbObjectID_4976_534c);	//*bp04
		AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(creature->CreatureType());
		U16 di;
		if (RAND16(ww) >= (di = bp08->w16_4_7()) && di != 15) {
			//^2759:14A6
			ATTACK_CREATURE(glbObjectID_4976_534c, xx, yy, 0x2005, 0x64, 0);
			//^2759:14BF
			si = 1;
		}
	}
	//^2759:14C4
	return si;
}

//^2C1D:0E57
i16 SkWinCore::STAMINA_ADJUSTED_ATTR(Champion *ref, i16 quantity)
{
	// CSBwinSimilarity: TAG0163c8,StaminaAdjustedAttribute

	//^2C1D:0E57
	ENTER(2);
	//^2C1D:0E5D
	i16 si = quantity;
	//^2C1D:0E60
	i16 bp02 = ref->curStamina();
	//^2C1D:0E6A
	U16 di = ref->maxStamina() >> 1;
	//^2C1D:0E72
	if (bp02 < di) {
		//^2C1D:0E76
		si >>= 1;
		//^2C1D:0E78
		return (i32(si) * i32(bp02)) / i32(di) +si;
	}
	//^2C1D:0E9C
	return si;
}

//^2C1D:11BF
//SPX: _2c1d_11bf renamed COMPUTE_PLAYER_ATTACK_OR_THROW_STRENGTH
U16 SkWinCore::COMPUTE_PLAYER_ATTACK_OR_THROW_STRENGTH(U16 xx, U16 yy, i16 zz)
{
	//^2C1D:11BF
	ENTER(8);
	//^2C1D:11C5
	Champion *bp04 = &glbChampionSquad[xx];
	//^2C1D:11D6
	i16 si = (RAND() & 15) + GET_PLAYER_ABILITY(bp04, abStr, 0);
	//^2C1D:11F5
	ObjectID bp08 = bp04->Possess(yy);
	//^2C1D:1207
	U16 bp06 = QUERY_ITEM_WEIGHT(bp08);
	//^2C1D:1211
	U16 di = MAX_LOAD(bp04) >> 4;
	//^2C1D:1222
	si = (bp06 -12) +si;
	//^2C1D:122E
	if (bp06 > di) {
		//^2C1D:1233
		si = si - ((bp06 -di) >> 1);
		//^2C1D:123E
		di += (di -12) >> 1;
		//^2C1D:1249
		if (di < bp06) {
			//^2C1D:124E
			si = si -((bp06 -di) << 1);
		}
	}
	//^2C1D:1259
	if (zz >= 0) {
		//^2C1D:125F
		si = (QUERY_PLAYER_SKILL_LV(xx, zz, 1) << 1) +si;
		//^2C1D:1276
		di = 0;
		//^2C1D:1278
		switch (zz) {
			case  0:	// fighter 0	(global)
			case  4:	// fighter 1	swing
			case  5:	// fighter 2	thrust
			case  6:	// fighter 3	club
			case  7:	// fighter 4	parry
			case  9:	// ninja 2		fight
				//^2C1D:1287
				di = QUERY_GDAT_DBSPEC_WORD_VALUE(bp08, GDAT_ITEM_WEAPON_MELEE_STRENGTH);
				//^2C1D:1295
				break;

			case  1:	// ninja 0		(global)
			case 10:	// ninja 3		throw
			case 11:	// ninja 4		shoot
				//^2C1D:1297
				di = QUERY_GDAT_DBSPEC_WORD_VALUE(bp08, GDAT_ITEM_WEAPON_THROW_STRENGTH);
				//^2C1D:12A5
				if (di == 0)
					//^2C1D:12A7
					break;
				//^2C1D:12A9
				// SPX: x8000 = is a weapon that shoots items
				if ((QUERY_GDAT_DBSPEC_WORD_VALUE(bp08, GDAT_ITEM_WEAPON_PROJECTILE_FLAG) & 0x8000) != 0) {
					//^2C1D:12BA
					if (zz != 11)
						//^2C1D:12C0
						di = 0;
					//^2C1D:12C2
					break;
				}
				//^2C1D:12C4
				if (zz == 11)
					//^2C1D:12CA
					di = 0;

				break;

			case  2:	// priest 0		(global)
			case  3:	// wizard 0		(global)
			case  8:	// ninja 1		steal

				break;
		}
		//^2C1D:12CC
		si = si + di;
	}
	//^2C1D:12D2
	si = STAMINA_ADJUSTED_ATTR(bp04, si);
	//^2C1D:12E2
	if ((bp04->bodyFlag & ((yy == 0) ? 1 : 2)) != 0)
		//^2C1D:12FD
		si >>= 1;
	//^2C1D:12FF
	return BETWEEN_VALUE(0, si >> 1, 100);
}

//^2C1D:0E23
U16 SkWinCore::_2c1d_0e23(U16 xx)
{
	//^2C1D:0E23
	ENTER(0);
	//^2C1D:0E28
	i16 di;
	U16 si = BETWEEN_VALUE(1, di = (QUERY_ITEM_WEIGHT(xx) >> 1), 10);
	//^2C1D:0E44
	while ((di -= 10) > 0) {
		//^2C1D:0E46
		si += di >> 1;
	}
	//^2C1D:0E51
	return si;
}

//^2C1D:1DE2
//SPX: About shooting?
U16 SkWinCore::_2c1d_1de2(U16 xx, i16 yy, U16 zz)
{
	//^2C1D:1DE2
	ENTER(16);
	//^2C1D:1DE8
	U16 di = xx;
	//^2C1D:1DEB
	Champion *bp04 = &glbChampionSquad[di];
	//^2C1D:1DFB
	U16 bp0e = 0;
	//^2C1D:1E00
	ObjectID bp0c ;
	ObjectID si ;
	if (yy < 0) {
		//^2C1D:1E06
		if (glbLeaderHandPossession.object == OBJECT_NULL)
			//^2C1D:1E0D
			return 0;
		//^2C1D:1E12
        bp0c = bp04->Possess(1);
		//^2C1D:1E1D
		si = REMOVE_OBJECT_FROM_HAND();
		//^2C1D:1E23
		bp04->Possess(1, si);
		//^2C1D:1E2B
		yy = 1;
		//^2C1D:1E30
		bp0e = 1;
	}
	//^2C1D:1E35
	i16 bp0a = COMPUTE_PLAYER_ATTACK_OR_THROW_STRENGTH(di, yy, 10);
	//^2C1D:1E45
	if (bp0e != 0) {
		//^2C1D:1E4B
		bp04->Possess(1, bp0c);
	}
	else {
		//^2C1D:1E58
		si = REMOVE_POSSESSION(di, yy);
		//^2C1D:1E64
		if (si == OBJECT_NULL)
			//^2C1D:1E69
			//^2C1D:1E0D
			return 0;
	}
	//^2C1D:1E6B
	QUEUE_NOISE_GEN2(
		QUERY_CLS1_FROM_RECORD(si),
		QUERY_CLS2_FROM_RECORD(si),
		SOUND_STD_THROW,
		0xfe,
		glbPlayerPosX,
		glbPlayerPosY,
		1,
		0x6e,
		0x80);
	//^2C1D:1E98
	ADJUST_STAMINA(di, _2c1d_0e23(si));
	//^2C1D:1EA6
	ADJUST_HAND_COOLDOWN(di, 4, yy);
	//^2C1D:1EB4
	U16 bp08 = 8;
	U16 bp06 = 1;
	//^2C1D:1EBE
	U16 bp10 = QUERY_GDAT_DBSPEC_WORD_VALUE(si, 9);
	//^2C1D:1ECB
	if (bp10 != 0) {
		//^2C1D:1ECF
		bp08 = (bp10 >> 2) +bp08 +4;
		bp06 = bp10;
	}
	//^2C1D:1EE1
	ADJUST_SKILLS(di, 10, bp08);
	//^2C1D:1EEE
	bp0a += bp06;
	//^2C1D:1EF4
	bp06 = QUERY_PLAYER_SKILL_LV(di, SKILL_NINJA_THROW, 1);
	//^2C1D:1F03
	bp0a = RAND16((bp0a >> 2) +8) +bp06 +bp0a;
	//^2C1D:1F1C
	bp0a = min_value(bp0a, 255);
	//^2C1D:1F2C
	bp08 = BETWEEN_VALUE(40, (RAND() & 31) + (bp06 << 3), 200);
	//^2C1D:1F4D
	bp10 = QUERY_GDAT_DBSPEC_WORD_VALUE(si, 12);
	//^2C1D:1F5A
	bp06 = (bp10 != 0) ? bp06 : max_value(5, 11 -bp06);
	//^2C1D:1F70
	//^2C1D:1F73
	SHOOT_ITEM(si, glbPlayerPosX, glbPlayerPosY, (glbPlayerDir +zz) & 3, glbPlayerDir, bp0a, bp08, bp06);

	SkD((DLV_TWEET, "Tweet: You (x:%d, y:%d, map:%d) have thrown %s! \n"
		, glbPlayerPosX, glbPlayerPosY, glbCurrentMapIndex, static_cast<LPCSTR>(getRecordNameOf(si))
		));

	//^2C1D:1F9E
	glbPlayerThrowCounter = 4;
	//^2C1D:1FA4
	_4976_4c0c = glbPlayerDir;
	//^2C1D:1FAA
	return 1;
}

//^0CEE:2F2F
U16 SkWinCore::SET_DESTINATION_OF_MINION_MAP(ObjectID rlContainer, i16 xx, i16 yy, U16 zz)
{
	//^0CEE:2F2F
	ENTER(4);
	//^0CEE:2F35
	U16 di = glbCurrentMapIndex;
	//^0CEE:2F39
	CHANGE_CURRENT_MAP_TO(zz);
	//^0CEE:2F41
	U16 si = (xx >= 0 && xx < glbCurrentMapWidth && yy >= 0 && yy < glbCurrentMapHeight) ? 1 : 0;
	//^0CEE:2F66
	if (si != 0) {
		//^0CEE:2F6C
		Container *bp04 = GET_ADDRESS_OF_RECORD9(rlContainer);
		//^0CEE:2F7A
		bp04->SetDestX(xx);
		//^0CEE:2F8C
		bp04->SetDestY(yy);
		//^0CEE:2F9F
		bp04->SetDestMap(zz);
	}
	//^0CEE:2FB1
	CHANGE_CURRENT_MAP_TO(di);
	//^0CEE:2FB7
	return si;
}

//^1C9A:0CF7
void SkWinCore::QUEUE_THINK_CREATURE(U16 xx, U16 yy)
{
	// force call THINK_CREATURE by timer system.

	//^1C9A:0CF7
	ENTER(14);
	//^1C9A:0CFC
	ObjectID si = GET_CREATURE_AT(xx, yy);
	//^1C9A:0D0A
	Creature *bp04 = GET_ADDRESS_OF_RECORD4(si);
	//^1C9A:0D17
	if (glbTabCreaturesInfo[bp04->b5_0_7()].TimerIndex() != 0xffff) {
		//^1C9A:0D32
		RELEASE_CREATURE_TIMER(si);
	}
	//^1C9A:0D39
	Timer bp0e;
	bp0e.SetMap(glbCurrentMapIndex);
	bp0e.SetTick(glbGameTick +1);
	//^1C9A:0D5C
	bp0e.TimerType((bp04->w8 == 0xffff) ? tty21 : tty22);
	//^1C9A:0D6F
	bp0e.actor = bp04->CreatureType();
	//^1C9A:0D7C
	bp0e.XcoordB(U8(xx));
	bp0e.YcoordB(U8(yy));

#if UseAltic
	bp0e.Value2(0);
	bp0e.ActionType(0);
#endif
	//^1C9A:0D85
	glbTabCreaturesInfo[bp04->b5_0_7()].TimerIndex(QUEUE_TIMER(&bp0e));
	//^1C9A:0DAD
	return;
}

//^13E4:0360
void SkWinCore::_13e4_0360(ObjectID rlCreature, U16 xx, U16 yy, U8 ss, U16 tt)
{
	//^13E4:0360
	ENTER(6);
	//^13E4:0365
	ObjectID si = rlCreature;
	//^13E4:0368
	if (si == OBJECT_NULL) {
		//^13E4:036D
		si = GET_CREATURE_AT(xx, yy);
		//^13E4:037C
		if (si == OBJECT_NULL)
			//^13E4:037F
			return;
	}
	//^13E4:0381
	U8 bp01 = GET_ADDRESS_OF_RECORD4(si)->b5_0_7();
	//^13E4:0393
	if (bp01 == 0xff)
		//^13E4:0395
		return;
	//^13E4:0397
	CreatureInfoData *bp06 = &glbTabCreaturesInfo[bp01];
	//^13E4:03B1
	if (bp06->Command2 == ccmDestroy || bp06->Command == ccmDestroy)
		//^13E4:03C0
		return;
	//^13E4:03C2
	bp06->Command2 = ss;
	//^13E4:03CC
	if (tt == 0)
		//^13E4:03D0
		return;
	//^13E4:03D2
#if UseAltic
	if ((_4976_37a6[RCJ(86, max(bp06->Command, 0))] & 0x10) != 0) {
		//^13E4:03E0
		bp06->b33 = 1;
		//^13E4:03E8
		return;
	}
#else
	if ((_4976_37a6[RCJ(86,bp06->b26)] & 0x10) != 0) {
		//^13E4:03E0
		bp06->b33 = 1;
		//^13E4:03E8
		return;
	}
#endif
	//^13E4:03EA
	RELEASE_CREATURE_TIMER(si);
	//^13E4:03F1
	QUEUE_THINK_CREATURE(xx, yy);
	//^13E4:03FE
	return;
}

//^1C9A:11BB
void SkWinCore::RELEASE_MINION(ObjectID rlCreature)
{
	//^1C9A:11BB
	ENTER(4);
	//^1C9A:11C0
	Missile *bp04 = GET_MISSILE_REF_OF_MINION(rlCreature, OBJECT_NULL);
	//^1C9A:11D2
	if (bp04 != NULL) {
		//^1C9A:11D6
		U16 si = glbCurrentMapIndex;
		//^1C9A:11DA
		CHANGE_CURRENT_MAP_TO(bp04->GetMap());
		//^1C9A:11EE
		_13e4_0360(rlCreature, bp04->GetX(), bp04->GetY(), 19, 1);
		//^1C9A:1213
		CHANGE_CURRENT_MAP_TO(si);
	}
	//^1C9A:121A
	return;
}

//^2FCF:183C
void SkWinCore::TRANSFER_PLAYER(i16 xx, i16 yy, U16 zz, U16 dir)
{
	SkD((DLV_DBM, "DBM: TRANSFER_PLAYER(%2d,%2d,%2d,%d)\n"
		, (Bitu)xx, (Bitu)yy, (Bitu)zz, (Bitu)dir));

	//^2FCF:183C
	ENTER(0);
	//^2FCF:1841
	i16 di = yy;
	//^2FCF:1844
	U16 si = (zz != glbPlayerMap) ? 1 : 0;
	//^2FCF:1856
	if (si != 0)
		//^2FCF:185A
		CHANGE_CURRENT_MAP_TO(zz);
	//^2FCF:1863
	if (xx >= 0 && xx < glbCurrentMapWidth && di >= 0 && di < glbCurrentMapHeight) {
		//^2FCF:187C
		if (si != 0) {
			//^2FCF:1880
			CHANGE_CURRENT_MAP_TO(glbPlayerMap);
			//^2FCF:188A
			MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, -1, 0);
			//^2FCF:189F
			LOAD_NEWMAP(U8(zz));
			//^2FCF:18A8
			//^2FCF:18BE
			MOVE_RECORD_TO(OBJECT_NULL, -1, 0, xx, di);
		}
		else {
			//^2FCF:18B2
			MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, xx, di);
		}
		//^2FCF:18C7
		ROTATE_SQUAD(dir);
		//^2FCF:18CF
		return;
	}
	//^2FCF:18D1
	if (si != 0)
		//^2FCF:18D5
		CHANGE_CURRENT_MAP_TO(glbPlayerMap);
	//^2FCF:18DF
	return;
}

//^2FCF:2DA7
// SPX: _2fcf_2da7 renamed SEARCH_DUNGEON_FOR_SPECIAL_MARKER
// Called when falling from "the void" zone
// This looks to be also called by the X teleporter
// tt is 0 in general cases. only some random value for ss = 2; this is a number of "tries" to find a valid destination
i16 SkWinCore::SEARCH_DUNGEON_FOR_SPECIAL_MARKER(U16 ss, U16 tt, U16 uu, i16 *xx, i16 *yy)
{
	//^2FCF:2DA7
	ENTER(24);
	//^2FCF:2DAD
	U16 bp16 = 0;
	U16 bp18 = 0xffff;
	SkD((DLV_FSM, "Search for special markers: type %d (tries:%d, uu:%d)\n"
		,ss, tt, uu));
	//^2FCF:2DB7
	for (U16 si = 0; dunHeader->nMaps > si; si++) {
		//^2FCF:2DBC
		U16 bp12 = dunMapsHeaders[si].RawColumn();
		//^2FCF:2DD4
		U16 bp14 = dunMapsHeaders[si].RawRow();
		//^2FCF:2DEC
		U8 *bp04 = glbMapTileValue[si][0];	// pointer on tile
		//^2FCF:2E07
		U16 *bp0c = &dunGroundStacks[dunMapTilesObjectIndexPerColumn[dunMapColumnsSumArray[si]]];
		//^2FCF:2E31
		for (U16 bp10 = 0; bp10 <= bp12; bp10++) {
			//^2FCF:2E39
			for (U16 di = 0; di <= bp14; di++) {
				//^2FCF:2E3E
				if ((*(bp04++) & 0x10) != 0) {	// is there an object on tile ? (0x10 flag)
					//^2FCF:2E4D
					ObjectID bp0e = *(bp0c++);
					do {
						//^2FCF:2E5A
						switch (ss) {	// SPX: but ... there is no distinctive case then ?
							case SDFSM_CMD_FIND_MAP_OFFVOID: // 2: 2nd pass void fall : stop on one special marker
							case SDFSM_CMD_COUNT_MARKERS: // 3: 1st pass void fall : count how many special markers
							case SDFSM_CMD_X_TELEPORTER:	// 4: x teleporter
							case SDFSM_CMD_X_ANCHOR:	// 5: anchor x teleporter
								//^2FCF:2E6E
								if (bp0e.DBType() == dbText) {
									//^2FCF:2E7F
									Text *bp08 = GET_ADDRESS_OF_RECORD2(bp0e);
									//^2FCF:2E8E
									if (bp08->TextMode() == 1) {
										//^2FCF:2EA2
										switch (bp08->SimpleTextExtUsage()) {
											case 11:	// SPX: This is a special marker for LAND POINT after falling from void
														// This correspond to the 0x5800 value in DMDC2
												//^2FCF:2EC4
												if ((bp08->TextIndex() & 0xff) != uu)	// ??
													//^2FCF:2ED7
													break;
												//^2FCF:2ED9
												// SPX: Increment the number of special markers found
												if (ss == SDFSM_CMD_COUNT_MARKERS) {
													//^2FCF:2EDF
													bp16++;
													//^2FCF:2EE2
													break;
												}
												//^2FCF:2EE4
												tt--;	// Decrements the number of tries
												//^2FCF:2EE7
												//if (tt != 0)	// If this is not yet 0, break = continue searching next marker
												if (tt <= 0)	// SPX: FIX, this is good when tt becomes 0 or less!
													//^2FCF:2EEC
													break;
												//^2FCF:2EEE
_2eee:	// logically when we get here, we have found the required marker, then, return the current map (si) where this marker is
												*xx = bp10;
												//^2FCF:2EF7
												*yy = di;
												//^2FCF:2EFD
												return si;

											case 16:
												//^2FCF:2F02
												if ((bp08->TextIndex() & 0xff) != uu)
													//^2FCF:2F15
													break;
												//^2FCF:2F17
												*xx = bp10;
												//^2FCF:2F20
												*yy = di;
												//^2FCF:2F26
												bp18 = si;
												//^2FCF:2F29
												break;

											case 15:
												//^2FCF:2F2B
												if (ss == SDFSM_CMD_X_TELEPORTER) {
													//^2FCF:2F31
													bp08->TextVisibility(0);
													//^2FCF:2F39
													break;
												}
												//^2FCF:2F3B
												if (ss != SDFSM_CMD_X_ANCHOR)
													//^2FCF:2F3F
													break;
												//^2FCF:2F41
												if (bp08->TextVisibility() == 0)
													//^2FCF:2F4D
													break;
												//^2FCF:2F4F
												goto _2eee;
										}
									}
								}

								break;
						}
						//^2FCF:2F51
						bp0e = GET_NEXT_RECORD_LINK(bp0e);
						//^2FCF:2F5D
					} while (bp0e != OBJECT_END_MARKER && bp0e.DBType() <= dbActuator);
				}
				//^2FCF:2F70
			}
			//^2FCF:2F79
		}
		//^2FCF:2F87
	}
	//^2FCF:2F99
	CHANGE_CURRENT_MAP_TO(glbPlayerMap);
	//^2FCF:2FA3
	if (ss == SDFSM_CMD_X_TELEPORTER) {	// 4 = cross teleporter
		//^2FCF:2FA9
		return bp18;	// must be the map returned
	}
	//^2FCF:2FAE
	if (ss == SDFSM_CMD_X_ANCHOR) {	// 5 = anchor teleporter (the one in the sun clan village)
		//^2FCF:2FB4
		return -1;
	}
	//^2FCF:2FB9
	return bp16;	// return the number of special markers found (should be only for ss = 3)
}

//^2FCF:18E3
U16 SkWinCore::ENGAGE_X_TELEPORTER()
{
	// activates the X mark floor teleporter at squad's position.

	// return 0 if failed.
	// return 1 if succeeded.

	//^2FCF:18E3
	ENTER(10);
	//^2FCF:18E9
	ObjectID si = GET_TILE_RECORD_LINK(glbPlayerPosX, glbPlayerPosY);
	//^2FCF:18F8
	U16 bp06;
	for (; si != OBJECT_END_MARKER && (bp06 = si.DBType()) <= dbActuator; si = GET_NEXT_RECORD_LINK(si)) {
		//^2FCF:18FB
		if (bp06 == dbText) {
			//^2FCF:1904
			Text *bp04 = GET_ADDRESS_OF_RECORD2(si);
			//^2FCF:1911
			if (bp04->TextMode() == 1) {
				//^2FCF:1925
				U16 di;
				switch (bp04->SimpleTextExtUsage()) {
					case 16: // 16 -> Teleporter with flag
						//^2FCF:1942
						di = SDFSM_CMD_X_ANCHOR;	// 5
						//^2FCF:1945
						goto _194a;

					case 15: // 15 -> Teleporter
						//^2FCF:1947
						di = SDFSM_CMD_X_TELEPORTER;	// 4
						//^2FCF:194A
_194a:
						i16 bp08;
						i16 bp0a;
						// SPX: FIX added a variable for destination map
						i16 destMap;
						// SPX: There this function should change the destination map (to bp06)
//							if (SEARCH_DUNGEON_FOR_SPECIAL_MARKER(di, 0, bp04->TextIndex() & 0xff, &bp08, &bp0a) >= 0)
						destMap = SEARCH_DUNGEON_FOR_SPECIAL_MARKER(di, 0, bp04->TextIndex() & 0xff, &bp08, &bp0a);
						if (destMap >= 0)
						{
							//^2FCF:1977
							// SPX: There is BUG here, bp06 is the db type instead of required map
//								TRANSFER_PLAYER(bp08, bp0a, bp06, glbPlayerDir);
							TRANSFER_PLAYER(bp08, bp0a, destMap, glbPlayerDir);
							//^2FCF:198B
							// SPX: This is used by the special teleporter ground cross		
							QUEUE_NOISE_GEN2(GDAT_CATEGORY_FLOOR_GFX, bp04->TextIndex() & 0xff, SOUND_STD_ACTIVATION, 0xfe, glbPlayerPosX, glbPlayerPosY, 1, 0x8c, 0x80);
							//^2FCF:19BB
							if (di == SDFSM_CMD_X_TELEPORTER) {	// di == 4
								//^2FCF:19C0
								bp04->TextVisibility(1);
							}
							//^2FCF:19C8
							return 1;
						}

						break;
				}
			}
		}
		//^2FCF:19CD
	}
	//^2FCF:19EE
	return 0;
}

//^2759:16AC
U16 SkWinCore::ENGAGE_COMMAND(U16 player, i16 cmdSlot)
{
	// CSBwinSimilarity: TAG01bf9a,_Attack

	// cmdSlot
	// is 0 if 1st command is selected on right command panel.
	// is 1 if 2nd command is selected on right command panel.
	// is 2 if 3rd command is selected on right command panel.

	//^2759:16AC
	ENTER(84);
	//^2759:16B2
	U16 di = player;
	//^2759:16B5
	U16 bp4a = 0;
	//^2759:16BA
	U16 bp48 = cmdSlot & 0x8000;
	//^2759:16C3
	cmdSlot &= 0x7fff;
	//^2759:16C8
	glbItemGDATCategory = glbItemSelected[cmdSlot].category;
	//^2759:16D5
	glbItemGDATIndex = glbItemSelected[cmdSlot].index;
	//^2759:16E2
	glbItemGDATEntry = glbItemSelected[cmdSlot].entry;
	//^2759:16EF
	U16 bp34 = glbSelectedHandAction;
	//^2759:16F5
	U16 bp3a = bp34 ^ 1;
	//^2759:16FB
	Champion *champion = &glbChampionSquad[di];	//*bp04
	//^2759:170B
	if (champion->curHP() == 0)
		//^2759:1715
		return 0;
	//^2759:171A
	U16 bp1c = QUERY_CUR_CMDSTR_ENTRY(CnCM);		// Command
	//^2759:1724
	U8 cmdSound = U8(QUERY_CUR_CMDSTR_ENTRY(CnSD));		// bp36 Sound
	//^2759:172E
	U16 bp38 = 0;
	//^2759:1733
	champion->handCommand[bp34] = U8(bp1c);
	//^2759:1740
	Container *bp08 = NULL;
	//^2759:174A
	ObjectID bp2e = champion->Possess(bp34);
	//^2759:175C
	if (bp2e != OBJECT_NULL) {
		//^2759:1761
		bp08 = GET_ADDRESS_OF_RECORD9(bp2e);
	}
	//^2759:1770
	U16 bp22 = champion->playerDir();
	//^2759:177C
	U16 bp1e = glbPlayerPosX + glbXAxisDelta[bp22];
	//^2759:178A
	U16 bp20 = glbPlayerPosY + glbYAxisDelta[bp22];
	//^2759:1799
	glbObjectID_4976_534c = GET_CREATURE_AT(bp1e, bp20);
	//^2759:17A9
	U8 bp35;
	AIDefinition *bp1a;
	if (glbObjectID_4976_534c != OBJECT_NULL) {
		//^2759:17AE
		bp1a = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp35 = QUERY_CLS2_FROM_RECORD(glbObjectID_4976_534c));
	}
	//^2759:17C8
	U16 bp26 = QUERY_CUR_CMDSTR_ENTRY(CnBZ);	// Blitz
	//^2759:17D2
	U16 bp2a = QUERY_CUR_CMDSTR_ENTRY(CnSK);	// Skill used
	//^2759:17DC
	U16 bp28 = QUERY_CUR_CMDSTR_ENTRY(CnTR) + RAND01();	// Fatigue
	//^2759:17EF
	i16 bp2c = QUERY_CUR_CMDSTR_ENTRY(CnEX);	// Experience
    //^2759:17F9
	U16 si = QUERY_CUR_CMDSTR_ENTRY(CnST);		// Spell Strength
	//^2759:1802
	i16 bp46 = QUERY_CUR_CMDSTR_ENTRY(CnAT);	// ?
	//^2759:180C
	champion->handDefenseClass[bp34] = U8(QUERY_CUR_CMDSTR_ENTRY(CnTA));	// Armor modified
	//^2759:181D
	U16 bp24 = GET_TILE_VALUE(bp1e, bp20);
	//^2759:182F
	U16 bp0e = 1;
	//^2759:1834
	ObjectID bp44;
	U16 bp42;
	i16 bp0c;
	U16 bp40;
	ObjectID bp32;
	U16 bp0a;
	ObjectID bp3e;
	U16 bp50;
	ObjectID bp30;
	U16 bp3c;
	switch (bp1c) {
		case CmConfuse: // 5
			//^2759:1848
			si = si + QUERY_PLAYER_SKILL_LV(di, SKILL_PRIEST_INFLUENCE, 1);
			//^2759:185B
			bp0e = CONFUSE_CREATURE(si, bp1e, bp20);
			//^2759:186C
			if (bp0e == 0)
				//^2759:1870
				bp2c >>= 2;
			//^2759:1874
			bp38 = 0;
			//^2759:1879
			break;

		case CmInvisibility: // 2
			//^2759:187C
			si = max_value(32, si);
			//^2759:1888
			bp50 = 0x47;
			//^2759:188C
			if (glbGlobalSpellEffects.Invisibility++ == 0 && glbChampionInventory != 0) {
				//^2759:18A0
				glbChampionTable[glbChampionInventory].heroFlag |= CHAMPION_FLAG_4000;	// 0x4000
			}
			//^2759:18B0
			Timer bp54;
			bp54.SetMap(glbPlayerMap);
			bp54.SetTick(glbGameTick +si);
			//^2759:18D8
			QUEUE_TIMER(&bp54);
			//^2759:18E4
			break;

		case CmLaunchMissile: // 3 magical missile
			//^2759:18E7
			bp44 = ObjectID::MissileRecord(QUERY_CUR_CMDSTR_ENTRY(CnPA));
			//^2759:18F4
			//bp42 = 7 - min_value(6, QUERY_PLAYER_SKILL_LV(di, bp2a, 1));
			bp42 = 7 - min_value(SkLvlCraftsman, QUERY_PLAYER_SKILL_LV(di, bp2a, 1));
			//^2759:1914
			if (champion->curMP() < bp42) {
				//^2759:1920
				si = max_value(2, (champion->curMP() * si) / bp42);
				//^2759:1936
				bp42 = champion->curMP();
			}
			//^2759:1940
			bp0e = CAST_CHAMPION_MISSILE_SPELL(di, bp44, si, bp42);
			//^2759:1953
			if (bp0e == 0)
				//^2759:195A
				bp2c >>= 1;
			//^2759:195D
			break;

		case CmPhysicalDamage4: // 4
		case CmPhysicalDamage8: // 8
			//^2759:1960
			if ((bp24 >> 5) == ttDoor && (bp24 & 7) == 4) {
				//^2759:1973
				ATTACK_DOOR(
					bp1e,
					bp20,
					COMPUTE_PLAYER_ATTACK_OR_THROW_STRENGTH(di, bp34, bp2a), 
					0, 
					2
					);

				//^2759:1995
				bp26 = 6;
				//^2759:199A
				Door *bp12 = GET_ADDRESS_OF_TILE_RECORD(U8(bp1e), U8(bp20))->castToDoor();
				//^2759:19AD
				// SPX: Sound made by the door when hit?
				QUEUE_NOISE_GEN2(
					GDAT_CATEGORY_DOORS,
					GET_GRAPHICS_FOR_DOOR(bp12),
					SOUND_OBJECT_GETHIT,
					0xfe,
					bp1e,
					bp20,
					bp38 +1,
					0x3c,
					0xc8
					);
				//^2759:19DB
				break;
			}
			//^2759:19DE
			if (true
				&& glbObjectID_4976_534c != OBJECT_NULL 
				&& bp1a->IsStaticObject() != 0 
				&& bp1a->ArmorClass == AI_DEF_ARMOR_MAX 
				&& bp1a->Defense == 255
			) {
				//^2759:19FD
				bp2c >>= 1;
			}
			else {
				//^2759:1A02
				bp44 = QUERY_CUR_CMDSTR_ENTRY(CnPA);		// Spell missile
				//^2759:1A0C
				bp0e = WIELD_WEAPON(di, bp44, bp1e, bp20, bp2a, bp46);
				//^2759:1A26
				if (bp0e == 0) {
					//^2759:1A2A
					bp2c >>= 1;
					//^2759:1A2D
					bp26 >>= 1;
					//^2759:1A30
					break;
				}
				//^2759:1A33
				if (glbObjectID_4976_534c == OBJECT_NULL)
					//^2759:1A3A
					break;
			}
			//^2759:1A3D
			QUEUE_NOISE_GEN1(GDAT_CATEGORY_CREATURES, bp35, SOUND_OBJECT_GETHIT, 0x3c, 0xc8, bp1e, bp20, bp38 +1);
			//^2759:1A5E
			break;

		case CmSpellReflection: // 7
			//^2759:1A61
			CREATE_CLOUD(OBJECT_EFFECT_REFLECTOR, max_value(2, si), glbPlayerPosX, glbPlayerPosY, 255);
			//^2759:1A81
			break;

		case CmAuraOfSpeed: // 9
			//^2759:1A84
			si = max_value(32, si);
			//^2759:1A90
			glbGlobalSpellEffects.AuraOfSpeed = U8(min_value(glbGlobalSpellEffects.AuraOfSpeed +si, 255));
			//^2759:1AA5
			break;

		case CmLaunchProjectile: // 32
			//^2759:1AA8
			if (IS_MISSILE_VALID_TO_LAUNCHER(di, bp34, champion->Possess(bp3a)) == 0) {
				//^2759:1AC6
				if (bp48 == 0) {
					//^2759:1ACC
					glbSomeChampionPanelFlag = max_value(1, 8 - UPDATE_GLOB_VAR(67, 1, 3));
					//^2759:1AEC
					glbChampionAttackDamage = ATTACK_REQUIRES_HAND_ITEM;	// -2
					//^2759:1AF2
					glbWeaponShooterNum = QUERY_GDAT_DBSPEC_WORD_VALUE(bp2e, GDAT_ITEM_WEAPON_PROJECTILE_FLAG);	// 5
					//^2759:1B01
					glbWeaponMissileHand = bp3a;
					//^2759:1B07
					bp2c = 0;
				}
				//^2759:1B0C
				bp0e = 0;
				//^2759:1B11
				break;
			}
			//^2759:1B14
			bp30 = REMOVE_POSSESSION(di, bp3a);
			//^2759:1B22
			bp0a = QUERY_PLAYER_SKILL_LV(di, SKILL_NINJA_SHOOT, 1);
			//^2759:1B32
			// SPX: bp2e is the SHOOTER/LAUNCHER, bp30 is the PROJECTILE
			// param3 = energy (max 255) / param4 = energy2 / param5 = dd
			SHOOT_CHAMPION_MISSILE(
				champion,
				bp30,
				QUERY_GDAT_DBSPEC_WORD_VALUE(bp2e, GDAT_ITEM_WEAPON_ACCURACY) + QUERY_GDAT_DBSPEC_WORD_VALUE(bp30, GDAT_ITEM_WEAPON_THROW_STRENGTH) + bp0a,
				(bp0a << 1) + QUERY_GDAT_DBSPEC_WORD_VALUE(bp30, GDAT_ITEM_STATS_0x0C),	// 12
				QUERY_GDAT_DBSPEC_WORD_VALUE(bp30, GDAT_ITEM_STATS_0x0C)
				);
			//^2759:1B84
			bp4a = 1;
			//^2759:1B89
			break;

		case CmSpellshield: // 33
		case CmFireshield: // 34
		case CmShield: // 35
			//^2759:1B8C
			U16 enchantmentType;
//				bp0c = (bp1c == CmSpellshield) ? 1 : ((bp1c == CmFireshield) ? 0 : 2);
			enchantmentType = (bp1c == CmSpellshield) ? ENCHANTMENT_SPELL_SHIELD : ((bp1c == CmFireshield) ? ENCHANTMENT_FIRE_SHIELD : ENCHANTMENT_PARTY_SHIELD);
			//^2759:1BAB
			si = max_value(32, si) * 3;
			//^2759:1BBC
			if (CALL_ENCHANTMENT_SELF(champion, enchantmentType, si, 1) != 0)
				//^2759:1BD5
				break;
			//^2759:1BD8
			bp2c >>= 2;
			//^2759:1BDC
			bp26 >>= 1;
			//^2759:1BDF
			break;

		case CmConsume: // 16
			//^2759:1BE2
			PLAYER_CONSUME_OBJECT(di, bp2e, bp34);
			//^2759:1BF1
			break;

		case CmPouch: // 17
			//^2759:1BF4
			bp4a = 1;
			//^2759:1BF9
			bp46 = FIND_POUCH_OR_SCABBARD_POSSESSION_POS(di, bp34);
			//^2759:1C06
			if (bp46 < 0)
				//^2759:1C0C
				break;
			//^2759:1C0F
			bp2e = REMOVE_POSSESSION(di, bp46);
			//^2759:1C1D
			EQUIP_ITEM_TO_INVENTORY(di, bp2e, bp34);
			//^2759:1C2C
			break;

		case CmHealing: // 36
			//^2759:1C2F
			bp0c = champion->maxHP() - champion->curHP();	// how much HP missing
			//^2759:1C3D
			if (bp0c <= 0)
				break;
			//^2759:1C44
			if (champion->curMP() == 0)
				//^2759:1C4B
				break;
			//^2759:1C4E
			bp0a = min_value(SkLvlMasterLo, QUERY_PLAYER_SKILL_LV(di, SKILL_PRIEST_HEAL, 1));	// skill, caped 10
			//^2759:1C68
			bp2c = 2;

			do {
				//^2759:1C6D
				bp0e = min_value(bp0c, bp0a);	// Minimum step between initial HP missing and skill level (max = 10)
				//^2759:1C7D
				champion->curHP(champion->curHP() +bp0e);
				//^2759:1C84
				bp2c += 2;
				//^2759:1C88
				champion->curMP(champion->curMP() -2);
				//^2759:1C8D
			} while (champion->curMP() > 0 && (bp0c -= champion->curMP()) != 0);

			//^2759:1C94
			if (champion->curMP() < 0)
				//^2759:1C9E
				champion->curMP(0);
			//^2759:1CA4
			champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800 Refresh bar stat?
			//^2759:1CAD
			bp0e = 1;
			//^2759:1CB2
			break;

		case CmUseRope: // 10
			//^2759:1CB5
			bp1e = glbPlayerPosX + glbXAxisDelta[glbPlayerDir];
			//^2759:1CC5
			bp20 = glbPlayerPosY + glbYAxisDelta[glbPlayerDir];
			//^2759:1CD5
			bp40 = 1;
			//^2759:1CDA
			bp32 = GET_CREATURE_AT(bp1e, bp20);
			//^2759:1CEA
			if (bp32 != OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp32) & 0x8000) == 0) {
				//^2759:1CFD
				bp40 = 0;
			}
			//^2759:1D02
			if ((GET_TILE_VALUE(bp1e, bp20) >> 5) == 2 && bp40 != 0) {
				//^2759:1D1E
				_4976_5824 = 1;
				//^2759:1D24
				MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, bp1e, bp20);
				//^2759:1D3C
				_4976_5824 = 0;
				//^2759:1D42
				break;
			}
			//^2759:1D45
			bp26 = 0;
			//^2759:1D4A
			break;

		case CmFreezeLife: // 11
			//^2759:1D4D
			glbGlobalSpellEffects.FreezeCounter = U8(min_value(EFFECT_FREEZE_MAX, glbGlobalSpellEffects.FreezeCounter +si));
			//^2759:1D62
			break;

		case CmAuraOfDex: // 12
			//^2759:1D65
			bp0c = 5;
			//^2759:1D6A
_1d6a:
			si = max_value(32, si) << 2;
			//^2759:1D79
			if (CALL_ENCHANTMENT_SELF(champion, bp0c, si, 0) != 0)
				//^2759:1D92
				break;
			//^2759:1D95
			bp2c >>= 2;
			bp26 >>= 1;
			//^2759:1D9C
			break;

		case CmAuraOfWiz: // 13
			//^2759:1D9F
			bp0c = 4;
			//^2759:1DA4
			goto _1d6a;

		case CmAuraOfVit: // 14
			//^2759:1DA6
			bp0c = 6;
			//^2759:1DAB
			goto _1d6a;

		case CmAuraOfStr: // 15
			//^2759:1DAD
			bp0c = 3;
			//^2759:1DB2
			goto _1d6a;

		case CmDarkness:	// 6
		case CmLight:		// 38
		case CmLongLight:	// 39
			//^2759:1DB4
			PROCEED_LIGHT(bp1c, si);
			//^2759:1DBE
			break;

		case CmThrow: // 42
			//^2759:1DC1
			bp0e = _2c1d_1de2(
				di,
				bp34,
				(champion->playerPos() != ((glbPlayerDir +1) & 3))
					? (champion->playerPos() == ((glbPlayerDir +2) & 3))
						? 1
						: 0
					: 1
				);
			//^2759:1E02
			break;

		case CmMark: // 44
			//^2759:1E05
			bp0e = SET_DESTINATION_OF_MINION_MAP(bp2e, glbPlayerPosX, glbPlayerPosY, glbPlayerMap);
			//^2759:1E1F
			if (bp0e != 0)
				//^2759:1E23
				break;
			//^2759:1E26
			bp2c = 0;
			bp26 = 1;
			//^2759:1E30
			break;

		case CmCallScout: // 47
			//^2759:1E33
			bp35 = CREATURE_GOOD_SCOUT_MINION;		// SPX: 0x30 = Scout Minion
			//SPX: bp35 holds creature to generate
			//^2759:1E37
			goto _1ebe;

		case CmCallCarry: // 45
		case CmCallFetch: // 46
			//^2759:1E3A
			if (GET_MISSILE_REF_OF_MINION(bp08->GetContainedObject(), bp2e) != NULL) {
				//^2759:1E4F
				GET_ADDRESS_OF_RECORD4(bp08->GetContainedObject())->CreatureType((bp1c == CmCallCarry) ? 0x32 : 0x33);
				//^2759:1E70
				_1c9a_0247(bp08->GetContainedObject());
			}
			//^2759:1E7F
			else if (bp1c == CmCallFetch) {
				//^2759:1E85
				bp35 = CREATURE_GOOD_FETCH_MINION;	// SPX: Fetch Minion
				//^2759:1E89
				bp0a = glbPlayerDir;
				//^2759:1E8F
				bp1e = bp08->GetDestX();
				//^2759:1E9C
				bp20 = bp08->GetDestY();
				//^2759:1EA9
				bp22 = 0xffff;
				//^2759:1EAE
				bp0c = bp08->GetDestMap();
				//^2759:1EB8
				goto _1ed8;
			}
			else {
				//^2759:1EBA
				bp35 = CREATURE_GOOD_CARRY_MINION;	// SPX: Carry Minion
				//^2759:1EBE
_1ebe:
				bp1e = glbPlayerPosX;
				//^2759:1EC4
				bp20 = glbPlayerPosY;
				//^2759:1ECA
				bp0a = (glbPlayerDir +2) & 3;
				//^2759:1ED5
				bp0c = glbPlayerMap;
				//^2759:1EDB
_1ed8:
				bp3e = CREATE_MINION(
					bp35,
					QUERY_PLAYER_SKILL_LV(di, bp2a, 1),
					bp0a,
					bp1e,
					bp20,
					bp0c,
					bp2e,
					bp22
					);
				//^2759:1F0E
				bp0e = (bp3e != OBJECT_NULL) ? 1 : 0;
				//^2759:1F1E
				if (bp0e != 0) {
					//^2759:1F22
					if (bp1c == CmCallScout) {
						//^2759:1F28
						SET_DESTINATION_OF_MINION_MAP(bp2e, _4976_5826, _4976_5828, _4976_581c);
					}
					//^2759:1F3F
					bp08->SetContainedObject(bp3e);
					//^2759:1F49
					break;
				}
				//^2759:1F4C
				bp2c >>= 2;
				bp26 >>= 1;
				//^2759:1F53
				CREATE_CLOUD(OBJECT_EFFECT_CLOUD, 0x6e, bp1e, bp20, 255);
				//^2759:1F68
				break;

				//^2759:1F6B
//_1f6b:
_ReleaseMinion:
				RELEASE_MINION(bp08->GetContainedObject());
			}
			//^2759:1F77
			//^2759:1F78
			break;

		case CmKillMinion: // 48
			goto _ReleaseMinion;

		case CmGuardMinion: // 50
			//^2759:1F7B
			bp3c = CREATURE_GOOD_GUARD_MINION;	// Guard Minion
			//^2759:1F80
			goto _CreateMinion;

		case CmUHaulMinion: // 51
			//^2759:1F82
			bp3c = CREATURE_GOOD_U_HAUL_MINION;	// U-Haul Minion
			//^2759:1F87
			goto _CreateMinion;

		case CmAttackMinion: // 49
			//^2759:1F89
			bp3c = CREATURE_GOOD_ATTACK_MINION;	// Attack Minion
			//^2759:1F8E
//_1f8e:
_CreateMinion:
			if (CREATE_MINION(bp3c, si >> 3, (glbPlayerDir +2) & 3, glbPlayerPosX, glbPlayerPosY, glbPlayerMap, bp2e, glbPlayerDir) != OBJECT_NULL)
				//^2759:1FBE
				break;
			//^2759:1FC0
			CREATE_CLOUD(OBJECT_EFFECT_CLOUD, 0x6e, glbPlayerPosX, glbPlayerPosY, 255);
			//^2759:1FD7
			break;

		case CmTeleport: // 54
			//^2759:1FD9
			if (ENGAGE_X_TELEPORTER() != 0)
				//^2759:1FE0
				break;
			//^2759:1FE2
			glbSomeChampionPanelFlag = max_value(1, 8 - UPDATE_GLOB_VAR(0x47, 1, 3));
			glbChampionAttackDamage = ATTACK_FAILURE_X_TELEPORT;

			break;

// SPX: All this set of unused commands. It makes some possibilities here.
		case 18:
		case 19:
		case 20:
		case 21:
		case 22:
		case 23:
		case 24:
		case 25:
		case 26:
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:
		case 37:
		case 40:
		case 41:
		case 43:
		case 52:
		case 53:

			break;
	}
	//^2759:2008
	if (bp4a == 0) {
		//^2759:200E
		QUEUE_NOISE_GEN2(glbItemGDATCategory, glbItemGDATIndex, cmdSound, 0xfe, glbPlayerPosX, glbPlayerPosY, bp38, 0x73, 0xc8);
	}
	//^2759:2035
	if (champion->curHP() == 0 || bp48 != 0)
		//^2759:2048
		return bp0e;
	//^2759:204B
	if (bp26 != 0) {
		//^2759:2051
		ADJUST_HAND_COOLDOWN(di, bp26, bp34);
	}
	//^2759:205F
	if (bp28 != 0) {
		//^2759:2065
		ADJUST_STAMINA(di, bp28);
	}
	//^2759:2070
	if (bp2c != 0) {
		//^2759:2076
		ADJUST_SKILLS(di, bp2a, bp2c);
	}
	//^2759:2085
	if (bp0e != 0) {
		//^2759:208B
		sk536e *bp16 = &glbChampionEngagingHandCommand[di][bp34];
		//^2759:20A8
		bp16->w0 = QUERY_CUR_CMDSTR_ENTRY(CnRP);
		//^2759:20B5
		if (bp16->w0 != 0) {
			//^2759:20B9
			bp16->b2 = 1;
			//^2759:20BE
			bp16->id4 = bp2e;
			bp16->b3 = i8(cmdSlot);
		}
	}
	//^2759:20CC
	return bp0e;
}

//^2759:1204
// SPX: _2759_1204 renamed PROCEED_COMMAND_SLOT
Bit16u SkWinCore::PROCEED_COMMAND_SLOT(i16 cmdSlot)
{
	//^2759:1204
	ENTER(6);
	SkD((DLV_TWEET, "Tweet: Command slot %d for object %s. \n"
		, cmdSlot, static_cast<LPCSTR>(getRecordNameOf(glbChampionItemInUse))
		));
	
	//^2759:120A
	U16 bp06 = 0;
	//^2759:120F
	if (glbChampionIndex != 0) {
		//^2759:1219
		U16 di = glbChampionIndex -1;
		//^2759:121F
		Champion *champion = &glbChampionSquad[di];	//*bp04
		//^2759:122D
		if (cmdSlot == -1) {
			//^2759:1233
			glbMagicalMapFlags = 0;
		}
		else {
			//^2759:123C
			champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
			//^2759:1245
			bp06 = ENGAGE_COMMAND(di, cmdSlot);
			//^2759:1253
			i16 si = QUERY_CMDSTR_ENTRY(glbItemGDATCategory, glbItemGDATIndex, glbItemGDATEntry, CnNC);
			//^2759:126A
			if (si == 16) {
				//^2759:126F
				si = 15;
			}
			//^2759:1272
			if (si != 17 && si != 18) {
				//^2759:127C
				ADD_ITEM_CHARGE(glbChampionItemInUse, -si);
			}
			//^2759:128C
			if (true
				&& ADD_ITEM_CHARGE(glbChampionItemInUse, 0) == 0
				&& (QUERY_GDAT_DBSPEC_WORD_VALUE(glbChampionItemInUse, 0x00) & 0x0800) != 0
			) {
				//^2759:12AF
				REMOVE_POSSESSION(di, glbSelectedHandAction);
				//^2759:12BB
				DEALLOC_RECORD(glbChampionItemInUse);
			}
		}
		//^2759:12C5
		if (glbMagicalMapFlags != 0) {
			//^2759:12CC
			glbMagicalMapFlags &= 0xfbff;
		}
		else {
			//^2759:12D4
			DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
		}
		//^2759:12D8
		UPDATE_RIGHT_PANEL(0);
	}
	//^2759:12DF
	return bp06;
}

//^2759:0589
// SPX: _2759_0589 renamed ACTIVATE_ACTION_HAND
void SkWinCore::ACTIVATE_ACTION_HAND(Bit16u xx, Bit16u yy)
{
	//^2759:0589
	ENTER(4);
	//^2759:058F
	U16 si = xx;	// champion no
	U16 di = yy;	// hand
	//^2759:0595
	Champion *champion = &glbChampionSquad[si];	//*bp04
	//^2759:05A9
	if (champion->curHP() == 0)
		//^2759:05B0
		return;
	//^2759:05B2
	if (IS_ITEM_HAND_ACTIVABLE(si, champion->Possess(di), di) == 0)
		//^2759:05CB
		return;
	//^2759:05CD
	glbSelectedHandAction = glbSelectedHand_2 = di;
	//^2759:05D5
	glbChampionIndex = glbSomeChampionIndex = si +1;
	//^2759:05DE
	glbSomeChampionPanelFlag = 1;
	glbMagicalMapFlags = 0;
	//^2759:05EA
	CHAMPION_SQUAD_RECOMPUTE_POSITION();
	//^2759:05EF
	UPDATE_RIGHT_PANEL(0);
	//^2759:05F7
	REFRESH_PLAYER_STAT_DISP(si);
	//^2759:05FE
	return;
}

//^2759:0602
//SPX: _2759_0602 renamed SET_SPELLING_CHAMPION
// Called when a champion is selected to spell runes
void SkWinCore::SET_SPELLING_CHAMPION(Bit16u iChampionNo)	// Bit16u xx
{
	//^2759:0602
	ENTER(0);
	//^2759:0605
	if (glbChampionSquad[iChampionNo].curHP() == 0)
		//^2759:0614
		return;
	//^2759:0616
	glbSelectedHandAction = glbSelectedHand_2 = 2;
	//^2759:061F
	glbChampionIndex = glbSomeChampionIndex = iChampionNo +1;
	//^2759:0629
	glbSomeChampionPanelFlag = 1;
	glbMagicalMapFlags = 0;
	//^2759:0635
	CHAMPION_SQUAD_RECOMPUTE_POSITION();
	//^2759:063A
	UPDATE_RIGHT_PANEL(0);
	//^2759:0642
	return;
}

//^01B0:087A
void SkWinCore::IBMIO_MOUSE_SET_CAPTURE() //#DS=04BF
{
#if UseAltic
	sysMousePositionCaptured++;
#else
//		//^01B0:087A
//		ENTER(0);
//		//^01B0:087D
//		LOADDS(0x3083);
//		//^01B0:0883
//		__asm pushf
//		__asm cli
//		__asm inc ds:[sysMousePositionCaptured]
//		__asm popf
//		//^01B0:088B
//		return;
#endif
}

//^443C:03F4
void SkWinCore::FIRE_MOUSE_SET_CAPTURE()
{
	//^443C:03F4
	ENTER(0);
	//^443C:03F7
	IBMIO_MOUSE_SET_CAPTURE() INDIRECT_CALL;
	//^443C:03FF
	return;
}

//^443C:08AB
void SkWinCore::_443c_08ab(i16 *xx, i16 *yy, i16 *zz)
{
	//^443C:08AB
	ENTER(0);
	//^443C:08AE
	_01b0_0d39(xx, yy, zz, 0) INDIRECT_CALL;
	//^443C:08CD
	return;
}



//==============================================================================

//^0CEE:2ABC
U16 SkWinCore::QUERY_GDAT_FOOD_VALUE_FROM_RECORD(ObjectID rl)
{
	//^0CEE:2ABC
	ENTER(0);
	//^0CEE:2ABF
	return QUERY_GDAT_DBSPEC_WORD_VALUE(rl, 3);
}

//^24A5:10B3
U16 SkWinCore::IS_MISCITEM_DRINK_WATER(ObjectID rlMiscItem)
{
	//^24A5:10B3
	ENTER(0);
	//^24A5:10B7
	ObjectID si = rlMiscItem;
	//^24A5:10BA
	if (true
		&& (QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0) & 1) != 0
		&& ADD_ITEM_CHARGE(si, 0) != 0
	) {
		//^24A5:10D7
		ADD_ITEM_CHARGE(si, -1);
		//^24A5:10E1
		if (si == glbLeaderHandPossession.object) {
			//^24A5:10E7
			TAKE_OBJECT(si, 0);
		}
		//^24A5:10F1
		return 1;
	}
	//^24A5:10F6
	return 0;
}

//^2C1D:1BB5
// SPX: _2c1d_1bb5 replaced by CURE_POISON
void SkWinCore::CURE_POISON(U16 player)
{
	//^2C1D:1BB5
	ENTER(4);
	//^2C1D:1BBB
	i16 di = player;
	//^2C1D:1BBE
	if (di != -1) {
		U16 si = 0;
		Timer *bp04 = glbTimersTable;
		for (; si < glbTimersActiveCount; bp04++, si++) {
			//^2C1D:1BD4
			if (bp04->TimerType() == ttyPoison) {
				//^2C1D:1BDE  
				if (bp04->actor == di) {
					//^2C1D:1BE8  
					DELETE_TIMER(si);
				}
			}
			//^2C1D:1BEF  
		}
		//^2C1D:1BFA  
		glbChampionSquad[di].PoisonValue = 0;
	}
	//^2C1D:1C08
	return;
}

// SPX: New function CURE_PLAGUE, similar to CURE_POISON
void SkWinCore::CURE_PLAGUE(U16 player)
{
	i16 di = player;
	if (di != -1) {
		U16 si = 0;
		Timer *bp04 = glbTimersTable;
		for (; si < glbTimersActiveCount; bp04++, si++) {
			if (bp04->TimerType() == ttyPlague) {
				if (bp04->actor == di) {
					DELETE_TIMER(si);
				}
			}
		}
		glbChampionSquad[di].PlagueValue = 0;
	}
	return;
}

//^2C1D:0009
// SPX: _2c1d_0009 replaced by PROCEED_ENCHANTMENT_SELF
void SkWinCore::PROCEED_ENCHANTMENT_SELF(U16 mask, U16 yy, U16 zz, U16 tick) 
{
	//^2C1D:0009
	ENTER(18);
	//^2C1D:000F
	Timer bp12;
	X16 bp08 = 0;
	i16 bp06 = 0;
	//^2C1D:0019
	for (; bp06 < 4; bp06++) {
		//^2C1D:001C
		X16 di = 1 << bp06;
		if ((mask & di) != 0) {
			//^2C1D:002E
			if (glbChampionSquad[bp06].curHP() == 0) {
				//^2C1D:003F
				mask &= ~di;
			}
			if (glbChampionSquad[bp06].enchantmentAura != U8(yy) || glbChampionSquad[bp06].curHP() == 0) {
				glbChampionSquad[bp06].enchantmentPower = 0;
				i16 si = 0;
				Timer *bp04 = glbTimersTable;
				for (; si < glbTimersActiveCount; bp04++, si++) {
					//^2C1D:008B
					if (bp04->TimerType() == ttyEnchantment && (mask & bp04->actor) != 0) {
						if ((bp04->actor & (~mask)) == 0) {
							//^2C1D:00AF
							DELETE_TIMER(si);
						}
						else {
							//^2C1D:00B8
							bp04->actor = bp04->actor & (~U8(mask));
						}
					}
					//^2C1D:00CA
				}
			}
		}
		//^2C1D:00D5
		if (glbChampionSquad[bp06].enchantmentPower > 0x32)
			bp08 = 1;
		//^2C1D:00EB
	}
	//^2C1D:00F7
	if (bp08 != 0)
		zz >>= 2;
	//^2C1D:0101
	for (bp06 = 0; bp06 < glbChampionsCount; bp06++) {
		//^2C1D:0108
		if ((mask & (1 << bp06)) != 0) {
			glbChampionSquad[bp06].enchantmentAura = U8(yy);
			glbChampionSquad[bp06].enchantmentPower += zz;
		}
		//^2C1D:0137
	}
	//^2C1D:0143
	bp12.value = zz;
	bp12.TimerType(ttyEnchantment);
	bp12.actor = U8(mask);
	bp12.SetMap(U8(glbPlayerMap));
	bp12.SetTick(glbGameTick +tick);
	QUEUE_TIMER(&bp12);
	//^2C1D:0182
	return;
}

//^24A5:10FB
void SkWinCore::PLAYER_CONSUME_OBJECT(U16 player, ObjectID rlConsume, i16 possess)
{
	// SPX: Default values
	U16 PotionType = 0;
	U16 WaterValue = WATER_DEFAULT_ITEM_VALUE;	// 800


	//^24A5:10FB
	ENTER(18);
	//^24A5:1101
	ObjectID di = rlConsume;
	//^24A5:1104
	U16 bp12 = 1;
	//^24A5:1109
	if (di != OBJECT_NULL) {
		//^24A5:110E
		bp12 = 0;
	}
	//^24A5:1115
	else if (glbLeaderHandPossession.object == OBJECT_NULL) {
		//^24A5:111C
		FIRE_MOUSE_SET_CAPTURE();
		//^24A5:1121
		_4976_4bfe = 1;
		//^24A5:1127
		//^24A5:113B
		if ((_4976_5dae.rc4.cy & 2) == 0) {
			//^24A5:1143
			FIRE_MOUSE_RELEASE_CAPTURE();
			//^24A5:1148
			_4976_4bfe = 0;
			//^24A5:114E
			return;
		}
		//^24A5:1151
		FIRE_HIDE_MOUSE_CURSOR();
		//^24A5:1156
		glbMouseVisibility = 1;
		//^24A5:115C
		return;
	}
	else {
		//^24A5:115F
		player = glbChampionInventory -1;
		//^24A5:1166
		di = glbLeaderHandPossession.object;
		//^24A5:116A
		possess = -1;
	}
	//^24A5:116F
	if (glbNextChampionNumber != 0)
		//^24A5:1176
		return;
	//^24A5:1179
	Champion *champion = &glbChampionSquad[player];
	//^24A5:118A
	U16 bp10 = QUERY_GDAT_FOOD_VALUE_FROM_RECORD(di);
	//^24A5:1194
	U16 bp0c;
	U16 si;
	Potion *bp08;
	if (bp10 != 0) {
		//^24A5:119B
		if (bp12 != 0) {
			//^24A5:11A1
			FIRE_HIDE_MOUSE_CURSOR();
			//^24A5:11A6
			REMOVE_OBJECT_FROM_HAND();
			//^24A5:11AB
			for (bp0c = 5; (--bp0c) != 0; ) {
				//^24A5:11B2
				DRAW_STATIC_PIC(0x07, 0x00, ((bp0c & 1) != 0) ? 0x25 : 0x26, 545, -1);
				//^24A5:11D1
				CHANGE_VIEWPORT_TO_INVENTORY(0);
				//^24A5:11D9
				SLEEP_SEVERAL_TIME(8);
				//^24A5:11E1
			}
			//^24A5:11EB
			FIRE_SHOW_MOUSE_CURSOR();
		}
		//^24A5:11F0
		//SPX: Eating food item
		champion->curFood(min_value(champion->curFood() +bp10, FOOD_MAX));
		//^24A5:120C
		PROCESS_ITEM_BONUS(player, di, possess, 2);
		//^24A5:121D
		DEALLOC_RECORD(di);
		//^24A5:1224
		if (possess != -1) {
			//^24A5:122D
			champion->Possess(possess, OBJECT_NULL);
		}
		//^24A5:123E
		goto _14a9;
	}
	//^24A5:1241
	U16 bp0a;
	if (IS_MISCITEM_DRINK_WATER(di) != 0) {
		// SPX: This assume that any misc item gives 800 water per drink
		WaterValue = WATER_DEFAULT_ITEM_VALUE;

		// SPX: Custom Water value
		if (SkCodeParam::bUseDM2ExtendedMode)
			WaterValue = QUERY_GDAT_WATER_VALUE_FROM_RECORD(di);

		//^24A5:124B
		champion->curWater(min_value(champion->curWater() +WaterValue, WATER_MAX));
		//^24A5:1267
		if (possess != -1) {
			//^24A5:1270
			champion->Possess(possess, di);
		}
		//^24A5:127C
		goto _14a9;
	}
	//^24A5:127F
	bp0a = di.DBType();
	//^24A5:128A
	if (bp0a == dbPotion) {
		//^24A5:1292
		bp08 = GET_ADDRESS_OF_RECORD8(di);
		//^24A5:129F
		si = bp08->PotionPower();
		//^24A5:12AB
		// SPX: Degressive divisor => bp0c = 08 (lowest power) to 02 (highest power)
		bp0c = ((511 -si) / (((si +1) >> 3) +32)) >> 1;
		//^24A5:12C2
		si = (si / 25) +8;
		//^24A5:12D0
		U16 bp0e;
		switch (bp08->PotionType())
		{
			//// SPX, note: there is finally room to have potions that boost antimagic and antifire.
			/// We could think of the potion with FUL symbol to boost antifire.
			/// And the potion with ZO symbol would boost antimagic
			default:
				//^24A5:12E3
				return;

			case  6:			// {ROS}
				//^24A5:12ED
				BOOST_ATTRIBUTE(champion, ATTRIBUTE_DEXTERITY, si);	// 2 = DEX
				//^24A5:12FE
				break;

			case  7:			// {KU}
				//^24A5:1301
				//^24A5:1318
				BOOST_ATTRIBUTE(champion, ATTRIBUTE_STRENGTH, bp08->PotionPower() / 35 +5);	// 1 = STR
				//^24A5:12FE
				break;

			case  8:			// {DAIN}
				//^24A5:131A
				//^24A5:131D
				BOOST_ATTRIBUTE(champion, ATTRIBUTE_WISDOM, si);	// 3 = WIS
				//^24A5:12FE
				break;

			case  9:			// {NETA}
				//^24A5:131F
				//^24A5:1322
				BOOST_ATTRIBUTE(champion, ATTRIBUTE_VITALITY, si);	// 4 = DAIN
				//^24A5:12FE
				break;

			case 10:			// {VEN}
				//^24A5:1324
				// SPX: immediate cure? not like in PC DM2 where poisons have different strengths?
				CURE_POISON(player);
				//^24A5:132D
				break;

			case 11:			// {MON}	Regain stamina
				//^24A5:1330
				champion->curStamina(champion->curStamina() +min_value(champion->maxStamina() -champion->curStamina(),champion->maxStamina() / bp0c));
				//^24A5:1354
				break;

			case 12:			// {YA}		Cast party shield
				//^24A5:1357
				si += (si >> 1);
				//^24A5:135D
				PROCEED_ENCHANTMENT_SELF(1 << player, ENCHANTMENT_PARTY_SHIELD, si, si * si);
				//^24A5:1373
				break;

			case 13:			// {EE}		Regain mana
				//^24A5:1375
				bp0a = min_value(champion->curMP() +si +(si -8), MAXMP);
				//^24A5:1393
				if (champion->maxMP() < bp0a) {
					//^24A5:139F
					bp0a -= (bp0a -max_value(champion->curMP(), champion->maxMP())) >> 1;
				}
				//^24A5:13B8
				champion->curMP(bp0a);
				//^24A5:13C2
				break;

			case 14:			// {VI}		Regain health
				//^24A5:13C5
				bp0a = bp08->PotionPower() / 42;
				//^24A5:13E3
				champion->curHP(champion->curHP() + (champion->maxHP() / bp0c));
				//^24A5:13FB
				bp0e = champion->bodyFlag;
				//^24A5:1402
				if (bp0e == 0)
					//^24A5:1404
					break;
				//^24A5:1406
				bp0c = 10;
				do {
					//^24A5:140B
					for (si = 0; si < bp0a; si++) {
						//^24A5:140F
						champion->bodyFlag &= RAND();
						//^24A5:141B
					}
					//^24A5:1421
					bp0a = 1;
					//^24A5:1426
					if (champion->bodyFlag != bp0e)
						//^24A5:1430
						break;
					//^24A5:1432
					bp0c--;
					//^24A5:1435
				} while (bp0c != 0);
				//^24A5:143C
				break;

			case 15:			// WATER FLASK
				WaterValue = WATER_FLASK_VALUE;	// Default value 1600

				if (SkCodeParam::bUseDM2ExtendedMode)
					WaterValue = QUERY_GDAT_WATER_VALUE_FROM_RECORD(di);
				
				//^24A5:143E
				champion->curWater(min_value(champion->curWater() +WaterValue, WATER_MAX));

				break;
		}
		//^24A5:145A
		if (possess == -1)
			//^24A5:1460
			REMOVE_OBJECT_FROM_HAND();
		//^24A5:1465
		DEALLOC_RECORD(di);
		//^24A5:146C
		di = ALLOC_NEW_RECORD(dbPotion);
		//^24A5:1476
		if (di == OBJECT_NULL)
			//^24A5:147B
			return;
		//^24A5:147E
		SET_ITEMTYPE(di, 0x14);
		//^24A5:1488
		if (possess == -1) {
			//^24A5:148E
			TAKE_OBJECT(di, 0);
		}
		else {
			//^24A5:149A
			champion->Possess(possess, di);
		}
		//^24A5:14A9
_14a9:
		if (champion->curStamina() > champion->maxStamina()) {
			//^24A5:14B6
			champion->curStamina(champion->maxStamina());
		}
		//^24A5:14BE
		if (champion->curHP() > champion->maxHP()) {
			//^24A5:14CB
			champion->curHP(champion->maxHP());
		}
		//^24A5:14D3
		// SPX: Sound made when eating/drinking
		// 0x16 = Champion category, 0x83 = sound for eat/drink, 0xFE = default index
		// So there could be a sound for eat and one for drink
		QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, champion->HeroType(), SOUND_CHAMPION_EAT_DRINK, 0xfe, glbPlayerPosX, glbPlayerPosY, 0, 0x96, 0x80);
		//^24A5:14FC
		champion->heroFlag |= CHAMPION_FLAG_3800;	// 0x3800
		//^24A5:1505
		if (possess != -1) {
			//^24A5:150B
			champion->heroFlag |= CHAMPION_FLAG_4000;	// 0x4000
			//^24A5:1511
			CALC_PLAYER_WEIGHT(player);
		}
	}
	//^24A5:151A
	return;
}

//^24A5:174D
// SPX: _24a5_174d renamed CLICK_INVENTORY_EYE
void SkWinCore::CLICK_INVENTORY_EYE()
{
	//^24A5:174D
	ENTER(0);
	//^24A5:1750
	FIRE_MOUSE_SET_CAPTURE();
	//^24A5:1755
	glbShowItemStats = 1;
	//^24A5:175B
	_443c_08ab(&_4976_5da0, &_4976_5da2, &_4976_5dae.rc4.cy);
	//^24A5:176F
	if ((_4976_5dae.rc4.cy & 2) == 0) {
		//^24A5:1777
		FIRE_MOUSE_RELEASE_CAPTURE();
		//^24A5:177C
		glbShowItemStats = 0;
	}
	else {
		//^24A5:1784
		_1031_098e();
		//^24A5:1789
		FIRE_HIDE_MOUSE_CURSOR();
		//^24A5:178E
		SLEEP_SEVERAL_TIME(8);
	}
	//^24A5:1796
	return;
}

//^12B4:0AA5
void SkWinCore::PUSH_PULL_RIGID_BODY(U16 arrowPos) 
{
	// move rigid body like boulder

	//          0
	//  5 <--+  A  +--> 1
	//       |  |  |
	//       |  |  |
	//  4 <--+  V  +--> 2
	//          3

	//^12B4:0AA5
	ENTER(8);
	//^12B4:0AAB
	X16 di;
	X16 si;
	X16 bp02;
	switch (arrowPos) {
		default:
			//^12B4:0AB3
			return;
		case 0://^0ABD
			//^12B4:0ABD
			di = glbPlayerDir;
			si = 0;
			goto _0adf;
		case 5://^0AC5 // forward and left
			//^12B4:0AC5
			di = (glbPlayerDir -1) & 3;
			si = 1;
			goto _0adf;
		case 1://^0AD3 // forward and right
			//^12B4:0AD3
			di = (glbPlayerDir +1) & 3;
			si = 2;
			goto _0adf;
			//^12B4:0ADF
_0adf:
			bp02 = 3;
			break;
		case 3://^0AE6 // back
			//^12B4:0AE6
			bp02 = 5;
			si = 0;
			goto _0b01;
		case 4://^0AEF // back and left
			//^12B4:0AEF
			bp02 = 6;
			si = 2;
			goto _0b01;
		case 2://^0AF9 // back and right
			//^12B4:0AF9
			bp02 = 4;
			si = 1;
			//^12B4:0B01
_0b01:
			di = (glbPlayerDir +2) & 3;
			break;
	}
	//^12B4:0B0B
	X16 bp04 = glbPlayerPosX + glbXAxisDelta[glbPlayerDir];
	X16 bp06 = glbPlayerPosY + glbYAxisDelta[glbPlayerDir];
	ObjectID bp08;
	if (IS_CREATURE_MOVABLE_THERE(bp04, bp06, di, &bp08) == 0)
		return;
	//^12B4:0B46
	if (_12b4_099e(bp08) == 0) {
		//^12B4:0B52
		U16 bp02;
		for (bp02 = 0; bp02 < glbChampionsCount; bp02++) {
			//^12B4:0B59
			if (glbChampionSquad[bp02].curHP() != 0) {
				//^12B4:0B6D
				if (bp02 == glbChampionLeader || RAND02() == 0) {
					//^12B4:0B7C
					// SPX: Sound made by champion when moving large object
					QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, U8(bp02), SOUND_CHAMPION_GETHIT, 0xfe, glbPlayerPosX, glbPlayerPosY, 1, 0x69, 0xc8);
				}
			}
			//^12B4:0B9F
		}
	}
	else {
		//^12B4:0BAD
		glbTargetPosXTest = bp04;
		glbTargetPosYTest = bp06;
		glbPosX_4976_4eae = glbPlayerPosX;
		glbPosY_4976_4eb0 = glbPlayerPosY;
		_4976_4eac = di;
		glbMap_4976_4eaa = glbPlayerMap;
		_4976_4eb2 = si;
		glbTableToMove = bp08;
		PERFORM_MOVE(bp02);
	}
	//^12B4:0BE1
	return;
}

//^0CEE:317F
U16 SkWinCore::IS_WALL_ORNATE_ALCOVE_FROM_RECORD(ObjectID rl)
{
	//^0CEE:317F
	ENTER(0);
	//^0CEE:3182
	return (IS_WALL_ORNATE_ALCOVE(QUERY_CLS2_FROM_RECORD(rl)) == 1) ? 1 : 0;
}

//^0CEE:0AE1
ObjectID SkWinCore::GET_WALL_TILE_ANYITEM_RECORD(U16 xx, U16 yy)
{
	//^0CEE:0AE1
	ENTER(0);
	//^0CEE:0AE5
	ObjectID si = GET_TILE_RECORD_LINK(xx, yy);
	//^0CEE:0AF1
	while (si.DBType() <= dbActuator) {
		//^0CEE:0AF3
		si = GET_NEXT_RECORD_LINK(si);
		//^0CEE:0AF9
	}
	//^0CEE:0B08
	return si;
}

//^0CEE:31D7
U16 SkWinCore::IS_WALL_ORNATE_SPRING(ObjectID rl)
{
	//^0CEE:31D7
	ENTER(2);
	//^0CEE:31DB
	U8 bp01 = QUERY_CLS2_FROM_RECORD(rl);
	//^0CEE:31E6
	if (bp01 == 0xff)
		//^0CEE:31EA
		return 0;
	//^0CEE:31EE
	return QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp01, dtWordValue, GDAT_WALL_ORNATE__IS_WATER_SPRING);
}

//^2F3F:009A
void SkWinCore::REVIVE_PLAYER(X16 heroType, X16 player, X16 dir)
{
	//^2F3F:009A
	ENTER(148);
	//^2F3F:00A0
	Champion *champion = &glbChampionSquad[player = glbChampionsCount];	//*bp04
	champion->HeroType(U8(heroType));
	champion->handCommand[1] = champion->handCommand[0] = 0xff;
	champion->timerIndex = TIMER_NONE;
	champion->playerDir(U8(dir));
	X16 bp0e;
	for (bp0e = 0; GET_PLAYER_AT_POSITION((bp0e + glbPlayerDir) & 3) != -1; bp0e++);
	//^2F3F:00F6
	champion->playerPos(bp0e + glbPlayerDir);
	champion->direction = U8(glbPlayerDir);
	for (bp0e = 0; bp0e < INVENTORY_MAX_SLOT; bp0e++)
		champion->Possess(bp0e, OBJECT_NULL);
	//^2F3F:012E
	U8 bp0094[0x80];
	// SPX: get HERO NAME
	U8 *bp0c = QUERY_GDAT_TEXT(GDAT_CATEGORY_CHAMPIONS, U8(heroType), 0x18, bp0094);
	X16 bp10;
	for (bp0e = 0; (bp10 = i8(*(bp0c++))) != 0x20 && bp10 != 0 && bp0e < 7; bp0e++) {
		//^2F3F:0151
		champion->firstName[bp0e] = U8(bp10);
		//^2F3F:015D
	}
	//^2F3F:017E
	champion->firstName[bp0e] = 0;
	bp0e = 0;
	if (bp10 != 0) {
		//^2F3F:0193
		while (true) {
			bp10 = *(bp0c++);
			if (bp10 == 0)
				break;
			if ((champion->lastName[bp0e++] = U8(bp10)) == 0x13)
				break;
		}
	}
	//^2F3F:01BC
	champion->lastName[bp0e] = 0;
//DEBUG_DUMP_ULP();
	skhero *bp08 = reinterpret_cast<skhero *>(QUERY_GDAT_ENTRY_DATA_PTR(GDAT_CATEGORY_CHAMPIONS, U8(heroType), dt08, 0x00));
#if DM2_EXTENDED_MODE == 1	// TODOTo be replaced with fixedmode + checkmem
	if (bp08 == NULL)
		RAISE_SYSERR(SYSTEM_ERROR__NO_PLAYER_DATA);
#endif
	champion->maxHP(bp08->maxHP());
	champion->curHP(bp08->maxHP());
	champion->maxStamina(bp08->maxStamina());
	champion->curStamina(bp08->maxStamina());
	champion->maxMP(bp08->maxMP());
	champion->curMP(bp08->maxMP());
	for (bp0e = 0; bp0e <= 6; bp0e++) {
		//^2F3F:0220
		champion->attributes[bp0e][ATTRIBUTE_MAX] = champion->attributes[bp0e][ATTRIBUTE_CURRENT] = U8(max_value(0x1e, bp08->herodata[bp0e +3]));
		champion->attributesEnhanced[bp0e] = 0;
		//^2F3F:0260
	}
	//^2F3F:0269
	for (bp0e = 4; bp0e <= 19; bp0e++) {
		//^2F3F:0270
		bp10 = bp08->herodata[bp0e +10 -4];
		champion->skills[bp0e] = (bp10 != 0) ? (U32(0x40) << bp10) : 0;
		//^2F3F:02B0
	}
	//^2F3F:02B9
	for (bp0e = 0; bp0e <= 3; bp0e++) {
		//^2F3F:02C0
		X32 bp14 = 0;
		bp10 = (bp0e +1) << 2;
		U16 si;
		for (si = 0; si < 4; si++) {
			bp14 += champion->skills[bp10 +si];
		}
		//^2F3F:02F9
		champion->skills[bp0e] = bp14;
		//^2F3F:0312
	}
	//^2F3F:031B
	champion->curFood((RAND() & 255) + START_BASE_FOOD);
	champion->curWater((RAND() & 255) + START_BASE_WATER);
	//^2F3F:033F

	// SPX: Like a debugging character, make it strong from the beginning!
	if (SkCodeParam::bUseSuperMode)
	{
		U16	statHP		= 800;
		U16	statStamina = 8500;
		U16	statMP		= 650;

		if (SkCodeParam::bUseDM2ExtendedMode)
		{
			statHP		= 2500;
			statStamina = 28000;
			statMP		= 1700;
			//PROCESS_POISON(player, 10);
			//PROCESS_PLAGUE(player, 10);
		}

		champion->maxHP(statHP);
		champion->curHP(champion->maxHP());
		champion->maxStamina(statStamina);
		champion->curStamina(champion->maxStamina());
		champion->maxMP(statMP);
		champion->curMP(champion->maxMP());
		for (int i = 0; i < SKILL_COUNT; i++)
			champion->skills[i] = SKILL_EXPERIENCE_BASE_LEVEL<<(SkLvlMasterLo-2);
	} // End super/debug block

	return;
}

//^2F3F:0343
// SPX: _2f3f_0343 renamed SELECT_CHAMPION. Called when clicking on "mirror/cell" or at the beginning for
// automatic selection of Thoram
X16 SkWinCore::SELECT_CHAMPION(U16 xx, U16 yy, U16 dir, U16 mm)
{
	//^2F3F:0343
	ENTER(10);
	//^2F3F:0349
	U16 iChampionNumber = 0;	// di
	if (glbLeaderHandPossession.object != OBJECT_NULL || (iChampionNumber = glbChampionsCount) >= MAX_CHAMPIONS)
		//^2F3F:035A
		return 0;
	//^2F3F:035F
	X16 iCurrentMap = glbCurrentMapIndex;	// bp08
	CHANGE_CURRENT_MAP_TO(mm);
	xx += glbXAxisDelta[dir];
	yy += glbYAxisDelta[dir];
	//^2F3F:0386
	ObjectID xObject; // si
	X16 iHeroType = 0; // bp0a
	for (xObject = GET_TILE_RECORD_LINK(xx, yy); xObject != OBJECT_END_MARKER; xObject = GET_NEXT_RECORD_LINK(xObject)) {
		//^2F3F:0395
		Actuator *refActuator; // bp04
		if (xObject.DBType() == dbActuator && (refActuator = GET_ADDRESS_OF_ACTU(xObject))->ActuatorType() == ACTUATOR_TYPE_RESURECTOR) { // 0x7E
			//^2F3F:03BE
			iHeroType = refActuator->ActuatorData();
			break;
		}
		// SPX: Add for 0x7F :Activator, champion mirror
		else if (xObject.DBType() == dbActuator && (refActuator = GET_ADDRESS_OF_ACTU(xObject))->ActuatorType() == ACTUATOR_TYPE_CHAMPION_MIRROR) { // 0x7F
			//^2F3F:03BE
			iHeroType = refActuator->ActuatorData();
			break;
		}
		//^2F3F:03CD
	}
	//^2F3F:03DB
	xx += glbXAxisDelta[(dir +2) & 3];
	yy += glbYAxisDelta[(dir +2) & 3];
	REVIVE_PLAYER(iHeroType, iChampionNumber, dir);
	if (iChampionNumber != 0) {
		//^2F3F:0412
		DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
		UPDATE_RIGHT_PANEL(0);
	}
	//^2F3F:041F
	glbNextChampionNumber = iChampionNumber + 1;
	glbChampionsCount++;
	if (iChampionNumber == 0)	// First champion, then select it as leader
		//^2F3F:042D
		SELECT_CHAMPION_LEADER(0);
	//^2F3F:0435
	X16 iWallDir = (dir +2) & 3; // bp06
	xx += glbXAxisDelta[dir];
	yy += glbYAxisDelta[dir];
	// Take items from wall and add them to player
	for (xObject = GET_TILE_RECORD_LINK(xx, yy); xObject != OBJECT_END_MARKER; xObject = GET_NEXT_RECORD_LINK(xObject)) {
		//^2F3F:0467
		if (xObject.DBType() > dbActuator && xObject.Dir() == iWallDir) {
			//^2F3F:047E
			ADD_ITEM_TO_PLAYER(iChampionNumber, xObject);
		}
		//^2F3F:0486
	}
	//^2F3F:0494
	xx += glbXAxisDelta[(dir +2) & 3];
	yy += glbYAxisDelta[(dir +2) & 3];
	if (_4976_404b == 0) {
		//^2F3F:04BF
		INTERFACE_CHAMPION(iChampionNumber);
		_1031_0541(7);
		_38c8_0002();
	}
	//^2F3F:04D3
	CHANGE_CURRENT_MAP_TO(iCurrentMap);
	CALC_PLAYER_WEIGHT(iChampionNumber);
	//^2F3F:04E3
	return iChampionNumber + 1;
}

//^2FCF:16B8
ObjectID SkWinCore::FIND_DISTINCTIVE_ITEM_ON_TILE(U16 xx, U16 yy, i16 dir, U16 disit)
{
	//^2FCF:16B8
	ENTER(0);
	//^2FCF:16BC
	for (ObjectID si = GET_WALL_TILE_ANYITEM_RECORD(xx, yy); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^2FCF:16CB
		if (GET_DISTINCTIVE_ITEMTYPE(si) == disit) {
			//^2FCF:16D7
			if (dir == -1 || si.Dir() == dir) {
				//^2FCF:16E7
				return si;
			}
		}
		//^2FCF:16EB
	}
	//^2FCF:16F9
	return OBJECT_NULL;
}

//^2FCF:19F4
void SkWinCore::MOVE_RECORD_AT_WALL(U16 xx, U16 yy, U16 dir, ObjectID rlUnk, ObjectID rlWhatYouPlace)
{
	// 1) call when you place an apple to the ornate wall (alcove, keyhole, shop panel)
	// # xx=wall-x, yy=wall-y, dir=wall-side, rlUnk=FFFF, rlWhatYouPlace=your-holding-item

	// 2) call if you pick a torch at wall
	// # xx=wall-x, yy=wall-y, dir=wall-side, rlUnk=FFFF, rlWhatYouPlace=FFFF

	// e.g. you place a torch at wall. _2fcf_19f4( 8, 4, 2,FFFF,1502)
	// e.g. you take a torch at wall.  _2fcf_19f4( 8, 4, 2,FFFF,FFFF)

	//^2FCF:19F4
	ENTER(68);
	//^2FCF:19FA
	ObjectID si = rlWhatYouPlace;
	U16 bp26 = 0;
	U16 bp2a = 0;
	ObjectID bp34 = OBJECT_NULL;
	//^2FCF:1A0C
	ObjectID bp0e = GET_TILE_RECORD_LINK(xx, yy);
	printf("Click on wall : ---------------\n");
	//^2FCF:1A1C
	for (U16 bp28 = 0; bp0e != OBJECT_END_MARKER && bp28 == 0; bp0e = GET_NEXT_RECORD_LINK(bp0e)) {
		//^2FCF:1A24
		U16 bp10 = bp0e.Dir();
		//^2FCF:1A2D
		if (bp10 != dir)
			//^2FCF:1A32
			continue;
		//^2FCF:1A35
		if (IS_WALL_ORNATE_ALCOVE_FROM_RECORD(bp0e) != 0) {
			printf("Click on wall : this is a wall alcove!\n");
			//^2FCF:1A45
			if (si == OBJECT_NULL) {
				//^2FCF:1A4A
				ObjectID bp32 = GET_WALL_TILE_ANYITEM_RECORD(xx, yy);
				//^2FCF:1A5A
				ObjectID bp30 = OBJECT_NULL;
				//^2FCF:1A5F
				for (; bp32 != OBJECT_END_MARKER; bp32 = GET_NEXT_RECORD_LINK(bp32)) {
					//^2FCF:1A61
					if (bp32.Dir() == bp10) {
						//^2FCF:1A6C
						bp30 = bp32;
					}
					//^2FCF:1A72
				}
				//^2FCF:1A84
				if (bp30 == OBJECT_NULL)
					//^2FCF:1A8A
					break;
				//^2FCF:1A8D
				U16 bp2e = bp30.DBType();
				//^2FCF:1A99
				if (bp2e < dbWeapon || bp2e > dbMiscellaneous_item)
					//^2FCF:1AA8
					break;
				//^2FCF:1AAB
				MOVE_RECORD_TO(bp30, xx, yy, -1, 0);
				//^2FCF:1ABF
				bp34 = bp30;
				//^2FCF:1AC5
				break;
			}
			//^2FCF:1AC8
			bp2a = 1;
			//^2FCF:1ACD
			MOVE_RECORD_TO(ObjectID(si, bp10), -1, 0, xx, yy);
			
			// SPX: Actually, DM2 code seems not to like multiple wall actuators on the same side and breaks after triggering the first one, unlike DM1 which
			// sometimes needs several wall actuators on same side for mechanism. Then try not to break in case of DM1.
			if (SkCodeParam::bDM1Mode)
				continue;
			//^2FCF:1AED
			break;
		}
		//^2FCF:1AF0
		if (IS_WALL_ORNATE_SPRING(bp0e) != 0) {
			printf("Click on wall : this is a wall fountain!\n");
			//^2FCF:1B00
			if (si == OBJECT_NULL) {
				//^2FCF:1B05
				if (glbChampionLeader == -1)
					//^2FCF:1B0C
					break;
				//^2FCF:1B0F
				for (i16 championIndex = 0; championIndex < MAX_CHAMPIONS; championIndex++) {
					//^2FCF:1B16
					if (glbChampionSquad[championIndex].curHP() != 0) {
						//^2FCF:1B27
						glbChampionSquad[championIndex].curWater(WATER_MAX);
					}
					//^2FCF:1B37
				}
				//^2FCF:1B40
				// SPX: Sound when drinking from wall
				QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, glbChampionSquad[glbChampionLeader].HeroType(), SOUND_CHAMPION_EAT_DRINK, 0xfe, glbPlayerPosX, glbPlayerPosY, 0, 0x96, 0x80);
				//^2FCF:1B6F
				break;
			}
			//^2FCF:1B72
			if ((QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0) & 1) != 0) {
				//^2FCF:1B81
				ADD_ITEM_CHARGE(si, 15);
				//^2FCF:1B8B
				bp2a = 1;
				bp34 = si;
				//^2FCF:1B93
				break;
			}
			//^2FCF:1B96
			if (GET_DISTINCTIVE_ITEMTYPE(si) != 0x0194)
				//^2FCF:1BA2
				break;
			//^2FCF:1BA5
			SET_ITEMTYPE(si, 15);
			//^2FCF:1BAF
			bp2a = 1;
			bp34 = si;
			//^2FCF:1BB7
			break;
		}
		//^2FCF:1BBA
		U16 bp1c = bp0e.DBType();
		//^2FCF:1BC6
		U16 bp16;
		if (bp1c == dbActuator) {
			//^2FCF:1BCE
			Actuator *bp04 = GET_ADDRESS_OF_ACTU(bp0e);
			//^2FCF:1BDD
			bp16 = bp04->ActuatorType();
			//^2FCF:1BEA
			U16 bp18 = bp04->ActuatorData();
			//^2FCF:1BF7
			U16 bp1a = bp04->ActionType();
			printf("Clicking on wall Actuator ACT=%02d action=%04x data=%04x\n", bp16, bp1a, bp18);
			//^2FCF:1C04
			//if (glbChampionLeader == -1 && bp16 != 0x7e)
			if (glbChampionLeader == -1 && (bp16 != ACTUATOR_TYPE_RESURECTOR && bp16 != ACTUATOR_TYPE_CHAMPION_MIRROR)) // SPX : Add 0x7F
				//^2FCF:1C11
				continue;
			//^2FCF:1C14
			U8 bp23 = GET_WALL_DECORATION_OF_ACTUATOR(bp04);
			//^2FCF:1C24
			if (bp16 == 0)
				//^2FCF:1C2A
				continue;
			//^2FCF:1C2D
			U16 di = 1;
			//^2FCF:1C30
			U16 bp44 = bp16;
			//^2FCF:1C36
			U16 bp2c;
			Door *bp14;
			U16 bp1e;
			U16 bp36;
			switch (bp44) {
				default:
					//^2FCF:1C48
					continue;


				case ACTUATOR_TYPE_SHOP_PANEL: // 0x3F -> 'Shop panel'
					//^2FCF:1C4F
					if (si == OBJECT_NULL)
						//^2FCF:1C57
						bp04->ActiveStatus(0);
					//^2FCF:1C5F
					break;

				// SPX: removed native DM2 x01 case for activating back DM1 push button x01
					/*
				case ACTUATOR_TYPE_X01: // 0x01 -> ?
					//^2FCF:1C62
					di = 0;
					//^2FCF:1C64
					if (bp04->ActionType() != 3)
						//^2FCF:1C74
						//^2FCF:1C79
						continue;
					//^2FCF:1C76
					break;
					*/

				case ACTUATOR_TYPE_X02: // 0x02 -> ?
					//^2FCF:1C7C
					di = (bp04->RevertEffect() != ((si == OBJECT_NULL) ? 1 : 0)) ? 1 : 0;
					//^2FCF:1CA2
					//^2FCF:1E65
					//^2FCF:1E67
					break;

				case ACTUATOR_TYPE_CHARGED_ITEM_WATCHER: // 0x15 -> 'Activator, charged item watcher'
					//^2FCF:1CA5
					if (ADD_ITEM_CHARGE(si, 0) == 0)
						//^2FCF:1CB3
						break;

					goto _1cb6;

				case ACTUATOR_TYPE_ITEM_WATCHER: // 0x03 -> 'Activator, item watcher
					//^2FCF:1CB6
_1cb6:
					bp2c = (GET_DISTINCTIVE_ITEMTYPE(si) == bp18) ? 1 : 0;
					//^2FCF:1CCC
					di = (bp04->RevertEffect() == bp2c) ? 1 : 0;
					//^2FCF:1CE7
					if (bp2c == 0 || bp04->OnceOnlyActuator() == 0)
						//^2FCF:1D01
						break;
					//^2FCF:1D04
					DEALLOC_RECORD(REMOVE_OBJECT_FROM_HAND());
					//^2FCF:1D10
					break;

				// SPX: addition for DM1 retrocompatibility
				case ACTUATOR_TYPE_DM1_ITEM_EATER: // 0x04 -> 'Activator, item eater
					printf("ITEM EATER: expected = %d / in hand = %d\n", bp18, GET_DISTINCTIVE_ITEMTYPE(si));
					bp2c = (GET_DISTINCTIVE_ITEMTYPE(si) == bp18) ? 1 : 0;
					di = (bp04->RevertEffect() == bp2c) ? 1 : 0;
					if (bp2c == 0 || bp04->OnceOnlyActuator() == 0)
						break;
					DEALLOC_RECORD(REMOVE_OBJECT_FROM_HAND());
					break;

				case ACTUATOR_TYPE_PUSH_BUTTON_WALL_SWITCH: // 0x46 -> 'Activator, seal-able push button wall switch'
					//^2FCF:1D13
					bp14 = GET_ADDRESS_OF_TILE_RECORD(bp04->Xcoord(), bp04->Ycoord())->castToDoor();
					//^2FCF:1D39
					if (bp14->Bit13C() == 0)
						//^2FCF:1D4A
						continue;

					goto _1d4d;

				case ACTUATOR_TYPE_DM1_WALL_SWITCH: // SPX: Add DM1 retrocompatibility : 0x01
				case ACTUATOR_TYPE_WALL_SWITCH: // 0x18 -> 'Activator, push button wall switch'
					//^2FCF:1D4D
_1d4d:
					if (si != OBJECT_NULL || bp04->ActiveStatus() != 0)
						//^2FCF:1D52
						continue;
					//^2FCF:1D66
					Timer bp40;
					bp40.SetMap(glbCurrentMapIndex);
					bp40.SetTick(glbGameTick +bp18 +2);
					//^2FCF:1D8F
					bp40.TimerType(ttyWallButton);
					bp40.actor = 0;
					//^2FCF:1D97
					bp40.value = bp0e;
					//^2FCF:1D9D
					QUEUE_TIMER(&bp40);
					//^2FCF:1DA9
					bp04->ActiveStatus(1);
					//^2FCF:1DB1
					di = 0;
					//^2FCF:1DB3
					if (di != 0 || bp1a != 3)
						//^2FCF:1DC0
						break;
					//^2FCF:1DC3
					bp26 = 1;
					//^2FCF:1DC8
					if (bp04->SoundEffect() != 0) {
						//^2FCF:1DD6
						QUEUE_NOISE_GEN2(GDAT_CATEGORY_WALL_GFX, bp23, SOUND_STD_ACTIVATION, 0xfe, glbPlayerPosX, glbPlayerPosY, 1, 0x8c, 0x80);
					}
					//^2FCF:1DFA
					INVOKE_ACTUATOR(bp04, 0, 0);
					//^2FCF:1E0B
					INVOKE_ACTUATOR(bp04, 1, bp18 +1);
					//^2FCF:1E1F
					continue;

				case ACTUATOR_TYPE_2_STATE_WALL_SWITCH: // 0x17 -> 'Activator, 2 state wall switch'
					//^2FCF:1E22
					if (si != OBJECT_NULL)
						//^2FCF:1E27
						continue;
					//^2FCF:1E2A
					bp04->OnceOnlyActuator(bp04->OnceOnlyActuator() ^ 1);
					//^2FCF:1E49
					di = !(bp04->OnceOnlyActuator() ^ bp04->RevertEffect());
					//^2FCF:1E65
					//^2FCF:1E67
					break;

				case ACTUATOR_TYPE_RESURECTOR: // 0x7E -> 'Activator, resuscitation'
					//^2FCF:1E6A
					if (bp04->OnceOnlyActuator() == 0 || ((glbPlayerDir +2) & 3) != dir)
						//^2FCF:1E8B
						break;
					//^2FCF:1E8E
					SELECT_CHAMPION(glbPlayerPosX, glbPlayerPosY, glbPlayerDir, glbPlayerMap);
					//^2FCF:1EA6
					bp28 = 1;
					//^2FCF:1EAB
					di = 0;
					//^2FCF:1EAD
					break;

				// SPX: addition for DM1 retrocompatibility
				case ACTUATOR_TYPE_CHAMPION_MIRROR: // 0x7F -> DM1 'Activator, resuscitation'

					if (bp04->ActiveStatus() == 1 || ((glbPlayerDir +2) & 3) != dir) // for DM1, just take condition of direction
						break;
					SELECT_CHAMPION(glbPlayerPosX, glbPlayerPosY, glbPlayerDir, glbPlayerMap);
					bp28 = 1;
					di = 0;
					break;


				case ACTUATOR_TYPE_KEY_HOLE: // 0x1A -> 'Activator, key hole'
					//^2FCF:1EB0
					bp1e = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp23, dtWordValue, GDAT_WALL_ORNATE__IS_ITEM_TRIGGERED);
					//^2FCF:1EC5
					if (bp04->OnceOnlyActuator() != 0) {
						//^2FCF:1ED6
						if (si != OBJECT_NULL)
							//^2FCF:1EDB
							goto _22b1;
						//^2FCF:1EDE
						si = FIND_DISTINCTIVE_ITEM_ON_TILE(xx, yy, bp10, bp1e);
						//^2FCF:1EF3
						if (si == OBJECT_END_MARKER) {
							//^2FCF:1EF8
							si = ALLOC_NEW_DBITEM(bp1e);
							//^2FCF:1F03
							if (si == OBJECT_NULL)
								//^2FCF:1F08
								continue;
							//^2FCF:1F0B
							APPEND_RECORD_TO(si = ObjectID(si, bp10), NULL, xx, yy);
						}
						//^2FCF:1F30
						ADD_ITEM_CHARGE(si, 15);
						//^2FCF:1F3A
						MOVE_RECORD_TO(si, xx, yy, -1, 0);
						//^2FCF:1F4C
						bp34 = si;
					}
					else {
						//^2FCF:1F51
						if (si == OBJECT_NULL || GET_DISTINCTIVE_ITEMTYPE(si) != bp1e)
							//^2FCF:1F65
							continue;
						//^2FCF:1F68
						bp2a = 1;
						//^2FCF:1F6D
						MOVE_RECORD_TO(ObjectID(si, bp10), -1, 0, xx, yy);
					}
					//^2FCF:1F8D
					si = OBJECT_NULL;
					//^2FCF:1F90
					goto _22ab;

				case ACTUATOR_TYPE_X1B: // 0x1b -> ?
					//^2FCF:1F96
					if (bp18 == 0)
						//^2FCF:1F9C
						continue;
					//^2FCF:1F9F
					bp1e = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp23, dtWordValue, 0x0e);
					//^2FCF:1FB4
					if (GET_DISTINCTIVE_ITEMTYPE(si) != bp1e)
						//^2FCF:1FC0
						continue;
					//^2FCF:1FC3
					bp2a = 1;
					//^2FCF:1FC8
					si = OBJECT_NULL;
					//^2FCF:1FCB
					if (--bp18 == 0) {
						//^2FCF:1FD5
						di = 0;
						//^2FCF:1FD7
						bp04->ActiveStatus(1);
					}
					//^2FCF:1FDF
					bp04->ActuatorData(bp18);
					//^2FCF:1FF5
					break;

				case ACTUATOR_TYPE_SIMPLE_LADDER: // 0x1c -> ? (comes from BETA)
					if (SkCodeParam::bUseFixedMode == false)	// SPX: this actuator type seems to be used only in BETA dungeon, as a ladder. Though with the original code here, it does not trigger.
					{
					//^2FCF:1FF8
					if (si != OBJECT_NULL || bp04->OnceOnlyActuator() != 0)
						//^2FCF:2011
						continue;
					}
					else	// SPX: I am not sure here, I keep the condition in another way so that the ladder triggers when player click on it.
						if (si == OBJECT_NULL && bp04->OnceOnlyActuator() == 0)
							continue;
					//^2FCF:2014
					bp36 = (bp04->RevertEffect() != 0) ? bp04->ActionType() : ((bp04->ActionType() + glbPlayerDir) & 3);
					//^2FCF:204E
					TRANSFER_PLAYER(bp04->Xcoord(), bp04->Ycoord(), bp18 & 0x3f, bp36);
					//^2FCF:2078
					_1031_098e();

					break;
			}
			//^2FCF:207D
			if (bp1a == 3) {
				//^2FCF:2083
				bp1a = (di != 0) ? 1 : 0;
				//^2FCF:2091
				di = 0;
			}
			//^2FCF:2093
			if (di != 0)
				//^2FCF:2097
				continue;
			//^2FCF:209A
			bp26 = 1;
			//^2FCF:209F
			if (bp04->SoundEffect() != 0) {
				//^2FCF:20B0
				QUEUE_NOISE_GEN2(GDAT_CATEGORY_WALL_GFX, bp23, SOUND_STD_ACTIVATION, 0xfe, glbPlayerPosX, glbPlayerPosY, 1, 0x8c, 0x80);
			}
			//^2FCF:20D4
			INVOKE_ACTUATOR(bp04, bp1a, 0);
			//^2FCF:20E6
			continue;
		}
		//^2FCF:20E9
		U8 bp23;
		Text *bp0c;
		if (rlUnk == OBJECT_NULL && bp1c == dbText) {
			//^2FCF:20FB
			bp0c = GET_ADDRESS_OF_RECORD2(bp0e);
			//^2FCF:210A
			if (bp0c->TextMode() != 1)
				//^2FCF:211B
				continue;
			//^2FCF:211E
			bp23 = bp0c->TextIndex() & 0xff;
			//^2FCF:212D
			if (glbChampionLeader == -1)
				//^2FCF:2134
				continue;
			//^2FCF:2137
			i16 bp20;
			i16 bp22;
			i16 bp36;
			U16 bp1e;
			switch (bp16 = bp0c->SimpleTextExtUsage()) {
				case  4: // Holder (Torch holder)
				case  8: // Recharge (Blue gem crop)
					//^2FCF:2161
					bp1e = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp23, dtWordValue, GDAT_WALL_ORNATE__SWITCH_ITEM);
					//^2FCF:2176
					if (bp0c->TextVisibility() != 0) {
						//^2FCF:2187
						if (si != OBJECT_NULL)
							//^2FCF:218C
							goto _22b1;
						//^2FCF:218F
						si = FIND_DISTINCTIVE_ITEM_ON_TILE(xx, yy, bp10, bp1e);
						//^2FCF:21A4
						if (si == OBJECT_NULL) {
							//^2FCF:21A9
							si = ALLOC_NEW_DBITEM(bp1e);
							//^2FCF:21B4
							if (si == OBJECT_NULL)
								//^2FCF:21B9
								continue;
							//^2FCF:21BC
							APPEND_RECORD_TO(si = ObjectID(si, bp10), NULL, xx, yy);
						}
						//^2FCF:21E1
						ADD_ITEM_CHARGE(si, 15);
						//^2FCF:21EB
						MOVE_RECORD_TO(si, xx, yy, -1, 0);

						SkD((DLV_TWEET, "Tweet: You (x:%d, y:%d, map:%d) have taken %s from wall \n"
							, glbPlayerPosX, glbPlayerPosY, glbCurrentMapIndex
							, static_cast<LPCSTR>(getRecordNameOf(si))
							));
						//^2FCF:21FD
						bp34 = si;
						//^2FCF:2200
						si = OBJECT_NULL;
						//^2FCF:2203
						if (bp16 != 8)
							//^2FCF:2209
							goto _22ab;
						//^2FCF:220C
						Timer bp40;
						bp40.SetMap(glbCurrentMapIndex);
						// SPX: 0x12 is the RESPAWN value, then trigger a timer to setup again the ornate (gem)
						bp40.SetTick(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp23, dtWordValue, GDAT_WALL_ORNATE__RESPAWN_COOLDOWN) + glbGameTick +2);
						//^2FCF:224A
						bp40.TimerType(ttySimpleActuTurnOn);
						bp40.actor = 0;
						//^2FCF:2252
						bp40.value = bp0e;
						//^2FCF:2258
						QUEUE_TIMER(&bp40);
					}
					//^2FCF:2266
					else if (bp16 != 8) {	// Is not Recharge (8), then it is Torch Holder (4)
						//^2FCF:226C
						if (si == OBJECT_NULL)
							//^2FCF:2271
							continue;
						//^2FCF:2274
						if (GET_DISTINCTIVE_ITEMTYPE(si) != bp1e)
							//^2FCF:2280
							continue;
						//^2FCF:2283
						bp2a = 1;
						//^2FCF:2288
						MOVE_RECORD_TO(ObjectID(si, bp10), -1, 0, xx, yy);

						SkD((DLV_TWEET, "Tweet: You (x:%d, y:%d, map:%d) have placed %s at wall \n"
							, glbPlayerPosX, glbPlayerPosY, glbCurrentMapIndex
							, static_cast<LPCSTR>(getRecordNameOf(si))
							));

						//^2FCF:22A8
						si = OBJECT_NULL;
					}
					//^2FCF:22AB
_22ab:
					glbDoLightCheck = 1;
					//^2FCF:22B1
_22b1:
					bp28 = 1;
					//^2FCF:22B6
					continue;

				case  7:	// ladder disabled
					//^2FCF:22B9
					if (bp0c->TextVisibility() != 0)
						//^2FCF:22C7
						continue;

					goto _22ca;

				case  6:	// ladder enabled
					//^2FCF:22CA
_22ca:
					if (si != OBJECT_NULL)
						//^2FCF:22CF
						continue;
					//^2FCF:22D2
					bp36 = (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp23, dtWordValue, GDAT_WALL_ORNATE__IS_LADDER_UP) != 0) ? -1 : 1;
					//^2FCF:22F4
					bp20 = glbPlayerPosX;
					bp22 = glbPlayerPosY;
					//^2FCF:2300
					bp36 = LOCATE_OTHER_LEVEL(glbPlayerMap, bp36, &bp20, &bp22, NULL);
					//^2FCF:2320
					if (bp36 < 0)
						//^2FCF:2322
						continue;
					//^2FCF:2324
					TRANSFER_PLAYER(bp20, bp22, bp36, glbPlayerDir);
					//^2FCF:2338
					_1031_098e();
					//^2FCF:233D
					continue;

				case 13:	// 2 state ornate (such as window)
					//^2FCF:233F
					if (si != OBJECT_NULL)
						//^2FCF:2342
						continue;
					//^2FCF:2344
					bp0c->TextVisibility(bp0c->TextVisibility() ^ 1);

					break;

				case  5:
				case  9:
				case 10:
				case 11:
				case 12:
					continue;
			}
		}
		//^2FCF:235F
		// TODO DM2_EXTENDED_DATABASE
		if (bp1c >= dbActuator)
			//^2FCF:2363
			break;
		//^2FCF:2365
	}
	//^2FCF:2380
	if (rlUnk == OBJECT_NULL) {
		//^2FCF:2386
		if (bp2a != 0)
			//^2FCF:238C
			REMOVE_OBJECT_FROM_HAND();
		//^2FCF:2391
		if (bp34 != OBJECT_NULL) {
			//^2FCF:2397
			TAKE_OBJECT(bp34, 1);
		}
		//^2FCF:23A3
		_4976_4e5c = bp26;
		//^2FCF:23A9
		return;
	}
	//^2FCF:23AB
	GenericContainerRecord *bp08 = GET_ADDRESS_OF_GENERIC_CONTAINER_RECORD(rlUnk);
	//^2FCF:23BA
	if (bp2a == 0 && rlWhatYouPlace != OBJECT_NULL) {
		//^2FCF:23C6
		APPEND_RECORD_TO(rlWhatYouPlace, &bp08->possession, -1, 0);
	}
	//^2FCF:23DE
	if (bp34 != OBJECT_NULL) {
		//^2FCF:23E4
		APPEND_RECORD_TO(bp34, &bp08->possession, -1, 0);
	}
	//^2FCF:23FC
	return;
}

//^098D:0CD7
// SPX: _098d_0cd7 renamed QUERY RECTNO FOR WALL ORNATE
// ornateOffsetPos between 0 and 24
U16 SkWinCore::QUERY_RECTNO_FOR_WALL_ORNATE(i16 cellPos, U16 ornateOffsetPos, U16 zz) // (i16 xx, U16 yy, U16 zz)
{
	//^098D:0CD7
	ENTER(0);
	//^098D:0CDA
	if (zz != 0) {	// taking side ornate
		//^098D:0CE0
		return tRectnoOffsetsWallOrnates[RCJ(16, cellPos)] + ornateOffsetPos;	// limiting cellpos to 16 means taking only Distance 0 to Distance 3
	}
	//^098D:0CEE
	return cellPos * 25 + ornateOffsetPos + 3100;	// taking front ornate
}

//^32CB:08C1
void SkWinCore::QUERY_TEMP_PICST(
	U16 mirrorflip, U16 horzStretch, U16 vertStretch, i16 offx, i16 offy, i16 uu, U16 rectno, U16 pp, 
	i16 colorkey1, i16 colorkey2, U8 cls1, U8 cls2, U8 cls4)
{
	SkD((DLV_DBG_GETPIC, "DBG: QUERY_TEMP_PICST(%X,%3d,%3d,%3d,%3d,%04X,%04X,%04X,%2d,%2d,%02X,%02X,%02X)\n"
		, (Bitu)mirrorflip, (Bitu)horzStretch, (Bitu)vertStretch, (Bitu)offx, (Bitu)offy
		, (Bitu)uu, (Bitu)rectno, (Bitu)pp, (Bitu)colorkey1, (Bitu)colorkey2, (Bitu)cls1, (Bitu)cls2, (Bitu)cls4));

	//^32CB:08C1
	ENTER(2);
	//^32CB:08C7
	i16 di = uu;
	QUERY_GDAT_SUMMARY_IMAGE(&glbTempPicture, cls1, cls2, cls4);
	//^32CB:08E2
	if (horzStretch != vertStretch) {
		//^32CB:08EA
		U8 bp01;
		if (di == 2) {
			//^32CB:08EF
			bp01 = 0x14;
			//^32CB:08F3
			goto _08fe;
		}
		//^32CB:08F5
		else if (di == 3) {
			//^32CB:08FA
			bp01 = 0x15;
			//^32CB:08FE
_08fe:
			U16 si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtWordValue, bp01);
			//^32CB:0916
			if (si != 0) {
				//^32CB:091A
				horzStretch = ((((si >> 8) << 7) / (si & 255)) +1) >> 1;
			}
		}
	}
	//^32CB:0932
	glbTempPicture.mirrorFlip = mirrorflip;
	glbTempPicture.w52 = horzStretch;
	glbTempPicture.w54 = vertStretch;
	glbTempPicture.w28 += offx;
	glbTempPicture.w30 += offy;
	glbTempPicture.rectNo = rectno;
	glbTempPicture.w26 = pp;
	glbTempPicture.pb44 = _4976_4c16;
	glbTempPicture.colorKeyPassThrough = colorkey1;
	//^32CB:0972
	_32cb_0804(glbTempPicture.b58, di, colorkey1, colorkey2, glbTempPicture.w56);
	//^32CB:0988
	QUERY_PICST_IT(&glbTempPicture);
	//^32CB:0993
	return;
}

//^32CB:0997
void SkWinCore::DRAW_TEMP_PICST()
{
	//^32CB:0997
	ENTER(0);
	//^32CB:099A
	DRAW_PICST(&glbTempPicture);
	//^32CB:09A5
	return;
}

//^32CB:0A4C
// SPX: _32cb_0a4c renamed MAKE_BUTTON_CLICKABLE
void SkWinCore::MAKE_BUTTON_CLICKABLE(SRECT *prc, U8 xx, U8 yy)
{
	//^32CB:0A4C
	ENTER(0);
	//^32CB:0A4F
	COPY_MEMORY(prc, &_4976_4d1a[RCX(13,_4976_4dde)].rc0, sizeof(SRECT));
	//^32CB:0A6E
	_4976_4d1a[_4976_4dde].b11 = xx;
	_4976_4d1a[_4976_4dde].b10 = yy;
	_4976_4d1a[_4976_4dde].w8 = 0xffff;
	//^32CB:0AA0
	_4976_4dde++;
	//^32CB:0AA4
	return;
}

//^3E74:5AD9
void SkWinCore::QUERY_GDAT_IMAGE_METRICS(U8 cls1, U8 cls2, U8 cls4, i16 *pcx, i16 *pcy)
{
	//^3E74:5AD9
	ENTER(4);
	//^3E74:5ADE
	U16 si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtImage, cls4);
	//^3E74:5AF5
	if (glbShelfMemoryTable[si].Absent()) {
		//^3E74:5B10
		U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(cls1, cls2, cls4);
		//^3E74:5B29
		*pcx = READ_I16(bp04,-4);
		*pcy = READ_I16(bp04,-2);
	}
	else {
		//^3E74:5B3F
		U8 *bp04 = QUERY_GDAT_ENTRY_DATA_PTR(cls1, cls2, dtImage, cls4);
		//^3E74:5B5A
		*pcx = READ_I16(bp04,+0) & 1023;
		*pcy = READ_I16(bp04,+2) & 1023;
	}
	//^3E74:5B79
	return;
}

//^32CB:158F
U8 SkWinCore::SKCHR_TO_SCRIPTCHR(U8 xx)
{
	//^32CB:158F
	ENTER(0);
	//^32CB:1592
	U8 dl = xx;
	if (dl >= 'A' && dl <= 'Z')
		//^32CB:159F
		return dl +0xBF;
	//^32CB:15A5
	if (dl == '.')
		return 0x1B;
	//^32CB:15B4
	return 0x1A;
}

//^0B36:037E
// TODO: gfx related
U8 *SkWinCore::_0b36_037e(U8 *localpal, i8 xx, i16 colorkey1, i16 colorkey2, i16 palentcnt)
{
	//^0B36:037E
	ENTER(8);
	//^0B36:0384
	if (localpal != NULL && xx != 0) {
		//^0B36:0398
		xx = U8(max_value(0, 64 -xx));
		//^0B36:03AF
		for (i16 bp02 = 0; bp02 < palentcnt; bp02++) {
			//^0B36:03B7
			if (bp02 != colorkey1 && bp02 != colorkey2) {
				//^0B36:03CA
				U16 di = _4976_4be2[RCX(256,localpal[bp02])].b0;
				i16 si = 0;
				//^0B36:03E6
				i16 bp04 = max_value((_4976_4bde[RCX(16,di)].pv1[_4976_4be2[localpal[bp02]].b1] * xx) >> 6, 0);
				//^0B36:0433
				for (; _4976_4bde[di].b0 -1 > si; si++) {
					//^0B36:0435
					if (true
						&& _4976_4bde[di].pv1[si] <= bp04
						&& _4976_4bde[di].pv1[si +1] >= bp04
					) {
						//^0B36:046C
						i16 bp06 = bp04 - _4976_4bde[di].pv1[si   ];
						//^0B36:048A
						i16 bp08 = _4976_4bde[di].pv1[si +1] -bp04;
						//^0B36:04A7
						if (bp06 > bp08)
							//^0B36:04AF
							si++;
						//^0B36:04B0
						break;
					}
					//^0B36:04B2
				}
				//^0B36:04CD
				si = min_value(si, _4976_4bde[di].b0 -1);
				//^0B36:04EB

				localpal[bp02] = _4976_4bde[di].pv5[si];
			}
			//^0B36:0508
		}
	}
	//^0B36:03AF
	return localpal;
}

//^32CB:0804
void SkWinCore::_32cb_0804(U8 *localpal, i16 cls4, U16 colorkey1, i16 colorkey2, U16 palentcnt)
{
	//^32CB:0804
	ENTER(0);
	//^32CB:0809
	U16 di = palentcnt;
	//^32CB:080C
	i16 si;
	if (glbIsPlayerMoving != 0) {
		//^32CB:0813
		if (cls4 < 0) {
			//^32CB:0819
			si = max_value(-_4976_5a88, _4976_421b[RCJ(6,-cls4)]);
			//^32CB:0833
			cls4 = 1;
		}
		else {
			//^32CB:083A
			si = _4976_4221[RCJ(5,cls4)];
			//^32CB:0844
			cls4 += 9;
		}
	}
	else {
		//^32CB:084A
		si = _4976_4226[RCJ(5,cls4)];
	}
	//^32CB:0854	// SPX: That part is for translating palette in case of 'fog'
	if (!SkCodeParam::bDisableFogEffect && QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dt07, U8(cls4)) != 0) {
		//^32CB:086C
		TRANSLATE_PALETTE(localpal, GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, U8(cls4), di);
		//^32CB:0885
		_0b36_037e(localpal, i8(_4976_5a88), colorkey1, colorkey2, di);
	}
	else {
		//^32CB:0892
		_0b36_037e(localpal, 64 -U8(((64 -si) * (64 - _4976_5a88)) >> 6), colorkey1, colorkey2, di);
	}
	//^32CB:08BD
	return;
}

//^32CB:09A7
// SPX: _32cb_09a7 renamed QUERY_MULTILAYERS_PIC
U16 SkWinCore::QUERY_MULTILAYERS_PIC(ExtendedPicture *ref, U8 cls1, U8 cls2, U8 cls4, U16 horzRes, U16 vertRes, i16 zz, U16 mirrorflip, i16 colorkey1, U16 colorkey2)
{
	//^32CB:09A7
	ENTER(0);
	//^32CB:09AB
	QUERY_TEMP_PICST(mirrorflip, horzRes, vertRes, 0, 0, zz, -1, -1, colorkey1, -1, cls1, cls2, cls4);
	//^32CB:09D7
	COPY_MEMORY(&glbTempPicture, ref, sizeof(ExtendedPicture));
	//^32CB:09EE
	ALLOC_PICT_MEMENT(ref);
	//^32CB:09FB
	ref->colorKeyPassThrough = colorkey2;
	//^32CB:0A05
	SET_ORIGIN_RECT(&ref->rc36, ref->width, ref->height);
	//^32CB:0A1F
	U16 si;
	ref->pb44 = ALLOC_NEW_PICT(si = ALLOC_TEMP_CACHE_INDEX(), ref->width, ref->height, 8);
	//^32CB:0A47
	return si;
}

//^32CB:0AA6
void SkWinCore::QUERY_RAINFALL_PARAM(U8 *cls4, U16 *isMirrored)
{
	//^32CB:0AA6
	ENTER(0);
	//^32CB:0AA9
	*isMirrored = (glbRainDirection - _4976_5aa0) & 3;
	//^32CB:0ABB
	// SPX: 0x71 is vertical rain view / 0x6D is side rain view
	U8 cl = (*isMirrored == 0 || *isMirrored == 2) ? GFX_ENVIRONMENT_IMG_RAIN_STRAIGHT : GFX_ENVIRONMENT_IMG_RAIN_SLANTED;
	//^32CB:0ACF
	U16 rainLevel = 0;	// dx
	//^32CB:0AD1
	if (glbRainStrength >= RAIN_THRESHOLD_LEVEL_3) {
		//^32CB:0AD8
		rainLevel = 3;
	}
	//^32CB:0ADD
	else if (glbRainStrength >= RAIN_THRESHOLD_LEVEL_2) {
		//^32CB:0AE4
		rainLevel = 2;
	}
	//^32CB:0AE9
	else if (glbRainStrength >= RAIN_THRESHOLD_LEVEL_1) {
		//^32CB:0AF0
		rainLevel = 1;
	}
	//^32CB:0AF5
	else if (glbRainStrength > RAIN_THRESHOLD_LEVEL_0 && glbRainStrength < RAIN_THRESHOLD_LEVEL_1) {
		//^32CB:0B03
		rainLevel = 0;
	}
	//^32CB:0B05
	*cls4 = cl + U8(rainLevel);
	//^32CB:0B0F
	return;
}

//^32CB:0649
// TODO: image related
U8 *SkWinCore::_32cb_0649(U8 cls1, U8 cls2, U8 cls4, i16 colorkey)
{
	//^32CB:0649
	ENTER(6);
	//^32CB:064D
	U8 *bp04 = QUERY_GDAT_IMAGE_LOCALPAL(cls1, cls2, cls4);
	//^32CB:0667
	i16 bp06;
	if (bp04 == NULL) {
		//^32CB:066B
		if (_4976_5a88 == 63)
			//^32CB:0672
			return NULL;
		//^32CB:0678
		for (bp06 = 0; bp06 < 256; bp06++) {
			//^32CB:067F
			_4976_582a[bp06] = U8(bp06);
			//^32CB:0689
		}
		//^32CB:0693
		bp06 = 256;
	}
	else {
		//^32CB:069A
		COPY_MEMORY(bp04, _4976_582a, 16);
		//^32CB:06B0
		bp06 = 16;
	}
	//^32CB:06B5
	return _0b36_037e(_4976_582a, U8(_4976_5a88), colorkey, -1, bp06);
}

//^44C8:0762
void SkWinCore::FIRE_UPDATE_BLIT_PALETTE(const U8 *localpal)
{
	//^44C8:0762
	ENTER(0);
	//^44C8:0767
	U8 *di = glbBlitPalette16;
	//^44C8:0771
	const U8 *si = localpal;
	//^44C8:0774
	memcpy(di, si, 16);
	//^44C8:078D
	return;
}

//^44C8:0791
void SkWinCore::FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP_NOKEY(U16 offSrc, U16 offDst, U16 size)
{
	//^44C8:0791
	ENTER(0);
	//^44C8:0796
	//^44C8:0798
	U8 *bx = glbBlitPalette16;
	//^44C8:079B
	U8 *di = &_4976_5e6a[offDst];
	//^44C8:07A4
	U16 cx = size;
	//^44C8:07A7
	U8 *si = _4976_5e64;
	//^44C8:07AB
	bool carry = (offSrc & 1) ? true : false;
	si += (offSrc >>= 1);
	//^44C8:07B4
	if (carry) {
		//^44C8:07B6
		U8 al = lodsb(si);
		stosb(di, bx[al & 15]);
		cx--;
		//^44C8:07BD
		if (cx == 0) goto _080a;
	}

	{
		//^44C8:07BF
		bool carry = (cx & 1) ? true : false;
		cx >>= 1;
		//^44C8:07C1
		if (cx != 0) {
			//^44C8:07C3
			bool carry = (cx & 1) ? true : false;
			cx >>= 1;
			//^44C8:07C6
			if (cx != 0) {
				//^44C8:07C8
				U16 bp = 0x0f0f;
				do {
					//^44C8:07CD
					U16 ax = lodsw(si);
					U16 dx = ax >> 4;
					dx &= bp;
					ax &= bp;
					//^44C8:07D7
					stosb(di, bx[U8(ax >> 8)]);
					stosb(di, bx[U8(dx >> 8)]);
					stosb(di, bx[U8(ax &255)]);
					stosb(di, bx[U8(dx &255)]);
					//^44C8:07E9
				} while (--cx != 0);
			}
			//^44C8:07ED
			if (carry) {
				//^44C8:07EF
				U8 al = lodsb(si);
				stosb(di, bx[al >> 4     ]);
				stosb(di, bx[al      &255]);
			}
		}
		//^44C8:0801
		if (carry) {
			//^44C8:0803
			U8 al = lodsb(si);
			stosb(di, bx[al >> 4]);
		}
	}
	//^44C8:080A
_080a:
	//^44C8:080D
	return;
}

//	//^44C8:08AE
//	void _44c8_08ae(U16 offSrc, U16 offDst, U16 size, U8 colorkey)
//	{
//		//^44C8:08AE
//		ENTER(0);
//		//^44C8:08B3
//		U8 *bx = glbBlitPalette16;
//		//^44C8:08B8
//		U8 *di = &_4976_5e6a[offDst];
//		//^44C8:08C1
//		U8 dh = colorkey;
//		//^44C8:08C4
//		U16 cx = size;
//		//^44C8:08C7
//		U16 ax = offSrc;
//		bool carry = (ax & 1) ? true : false;
//		ax >>= 1;
//		//^44C8:08CD
//		U8 *si = &_4976_5e64[ax];
//		//^44C8:08D4
//		if (carry) {
//			//^44C8:08D6
//			U8 al = lodsb(si);
//			al &= 15;
//			if (al == dh) {
//				//^44C8:08DD
//				di++;
//			}
//			else {
//				stosb(di, bx[al]);
//			}
//			//^44C8:08E3
//			if (--cx == 0) goto _0931;
//		}
//
//		{
//			//^44C8:08E6
//			bool carry = (cx & 1) ? true : false;
//			cx >>= 1;
//			//^44C8:08E9
//			if (cx != 0) {
//				do {
//					//^44C8:08EB
//					U8 al = lodsb(si);
//					U8 ah = al & 15;
//					al >>= 4;
//					//^44C8:08F4
//					if (al != dh) {
//						//^44C8:08F8
//						if (ah != al) {
//							//^44C8:08FC
//							stosb(di, bx[al]);
//							stosb(di, bx[ah]);
//							//^44C8:0904
//							if (--cx != 0) continue;
//							break;
//						}
//						//^44C8:091D
//						stosb(di, bx[al]);
//						di++;//^44C8:0921
//						if (--cx != 0) continue;
//						break;
//					}
//					//^44C8:0908
//					if (ah != dh) {
//						//^44C8:090C
//						di++;
//						//^44C8:090D
//						stosb(di, bx[ah]);
//						//^44C8:0912
//						if (--cx != 0) continue;
//						break;
//					}
//					//^44C8:0916
//					di += 2;
//					//^44C8:0918
//				} while (--cx != 0);
//			}
//			//^44C8:0923
//			if (carry) {
//				//^44C8:0926
//				U8 al = lodsb(si) >> 4;
//				//^44C8:0927
//				if (al != dh) {
//					//^44C8:092E
//					stosb(di, bx[al]);
//				}
//			}
//		}
//		//^44C8:0931
//_0931:
//		//^44C8:0932
//		return;
//	}

//^44C8:1E1A
U16 SkWinCore::_44c8_1e1a(U8 *xx, U16 yy)
{
	//^44C8:1E1A
	ENTER(0);
	//^44C8:1E1E
	U8 *di = xx;
	bool carry = (yy & 1) ? true : false;
	{
		yy >>= 1;
		di += yy;
		U8 al = *di;
		if (!carry) {
			al &= 0xf0;
		}
		else {
			al &= 0x0f;
		}
		return (al != 0) ? 1 : 0;
	}
}

//^44C8:1E43
// Todo : teleporter gfx ???
void SkWinCore::_44c8_1e43(U8 *src, U8 *dst, U8 *zz, SRECT *prc, U16 ss, U16 tt, U16 aa, U16 bb, U16 hazeWidth, U16 dstWidth, i16 colorkey, U8 *localpal)
{
	//^44C8:1E43
	ENTER(16);
	//^44C8:1E49
	FIRE_UPDATE_BLIT_PALETTE(localpal);
	//^44C8:1E55
	hazeWidth = (hazeWidth +1) & 0xfffe;
	//^44C8:1E5F
	i16 bp08 = prc->cx;
	i16 bp06 = prc->cy;
	i16 bp02 = (prc->y * dstWidth) +prc->x;
	i16 bp04 = (bb * hazeWidth) +aa;
	//^44C8:1E89
	U16 di = tt;
	U16 si = ss -tt;
	//^44C8:1E94
	_4976_5e64 = src;
	_4976_5e6a = dst;
	//^44C8:1EAE
	if (zz == NULL) {
		//^44C8:1EB9
		for (U16 bp0a = 0; bp0a < bp06; bp02 += dstWidth, bp0a++) {
			//^44C8:1EC1
			i16 bp0e = bp08;
			//^44C8:1EC7
			U16 bp0c;
			for (bp0c = 0; bp0e >= si; bp0e -= si, bp0c += si, si = ss, di = 0) {
				//^44C8:1ECE
				if (colorkey < 0) {
					//^44C8:1ED4
					FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP_NOKEY(di, bp02 +bp0c, si);
					//^44C8:1EE4
					continue;
				}
				//^44C8:1EE6
				FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP(di, bp02 +bp0c, si, U8(colorkey));
				//^44C8:1EFA
			}
			//^44C8:1F0A
			if (bp0e > 0) {
				//^44C8:1F10
				if (colorkey < 0) {
					//^44C8:1F16
					FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP_NOKEY(di, bp02 +bp0c, bp0e);
				}
				else {
					//^44C8:1F2A
					FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP(di, bp02 +bp0c, bp0e, U8(colorkey));
				}
				//^44C8:1F40
				si -= bp0e;
				di += bp0e;
			}
			//^44C8:1F46
			if ((bp08 & 1) != 0) {
				//^44C8:1F4D
				if (--si != 0) {
					//^44C8:1F54
					di++;
				}
				else {
					//^44C8:1F57
					si = ss;
					di = 0;
				}
			}
			//^44C8:1F5C
		}
		//^44C8:1F70
		return;
	}
	//^44C8:1F73
	for (U16 bp0a = 0; bp0a < bp06; bp0a++) {
		//^44C8:1F7B
		for (U16 bp10 = bp08; bp10 > 0; ) {
			//^44C8:1F84
			U16 bp0c;
			for (bp0c = 0; bp10 > 0 && _44c8_1e1a(zz, bp04 +bp0c) == 0; ) {
				//^44C8:1F8B
				--bp10;
				++bp0c;
				++di;
				--si;
				//^44C8:1F93
				if (si == 0) {
					//^44C8:1F99
					di = 0;
					si = ss;
				}
				//^44C8:1F9E
			}
			//^44C8:1FBC
			U16 bp0e;
			for (bp0e = 0; bp10 > 0 && _44c8_1e1a(zz, bp04 +bp0c) != 0; ) {
				//^44C8:1FC3
				++bp0e;
				--bp10;
				//^44C8:1FC9
			}
			//^44C8:1FE7
			if (bp0e > 0) {
				//^44C8:1FED
				while (bp0e >= si) {
					//^44C8:1FEF
					if (colorkey < 0) {
						//^44C8:1FF5
						FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP_NOKEY(di, bp02 +bp0c, si);
					}
					else {
						//^44C8:2007
						FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP(di, bp02 +bp0c, si, U8(colorkey));
					}
					//^44C8:201B
					bp0e -= si;
					bp0c += si;
					//^44C8:2021
					si = ss;
					di = 0;
					//^44C8:2026
				}
				//^44C8:202B
				if (bp0e > 0) {
					//^44C8:2031
					if (colorkey < 0) {
						//^44C8:2037
						FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP_NOKEY(di, bp02 +bp0c, bp0e);
					}
					else {
						//^44C8:204B
						FIRE_BLIT_TO_MEMORY_ROW_4TO8BPP(di, bp02 +bp0c, bp0e, U8(colorkey));
					}
					//^44C8:2061
					si -= bp0e;
					di += bp0e;
				}
			}
			//^44C8:2067
			if ((bp08 & 1) != 0) {
				//^44C8:206E
				if (--si != 0) {
					//^44C8:2075
					++di;
				}
				else {
					//^44C8:2078
					si = ss;
					di = 0;
				}
			}
			//^44C8:207D
			bp04 += hazeWidth;
			bp02 += dstWidth;
			//^44C8:2089
		}
		//^44C8:2092
	}
	//^44C8:20A0
	return;
}

//^44C8:20A4
void SkWinCore::_44c8_20a4(U8 *src, U8 *dst, U8 *zz, SRECT *prc, U16 ss, U16 tt, U16 oo, i16 pp, U8 *localpal)
{
	//^44C8:20A4
	ENTER(0);
	//^44C8:20A7
	_44c8_1e43(src, dst, zz, prc, ss, tt, 0, 0, prc->cx, oo, pp, localpal);
	//^44C8:20E3
	return;
}

//^32CB:0C7D
void SkWinCore::_32cb_0c7d(ExtendedPicture *ref, U16 xx, U16 yy)
{
	//^32CB:0C7D
	ENTER(16);
	//^32CB:0C83
	if (glbRainStrength == 0) {
		//^32CB:0C8A
		FILL_ENTIRE_PICT(reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(xx)), ref->b58[yy]);
		//^32CB:0CAA
		return;
	}
	//^32CB:0CAD
	U8 bp0b;
	U16 bp0a;
	QUERY_RAINFALL_PARAM(&bp0b, &bp0a);
	//^32CB:0CBE
	i16 bp06;
	i16 bp08;
	QUERY_GDAT_IMAGE_METRICS(0x17, glbMapGraphicsSet, bp0b, &bp06, &bp08);
	//^32CB:0CDA
	U16 di = ALLOC_TEMP_CACHE_INDEX();
	//^32CB:0CE1
	ALLOC_NEW_PICT(di, ref->rc36.cx, bp08, 4);
	//^32CB:0CF6
	U16 si = (ref->rc36.cx +1) & 0xfffe;
	//^32CB:0D03
	U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x17, glbMapGraphicsSet, bp0b);
	//^32CB:0D1B
	FIRE_BLIT_PICTURE(bp04, QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(di), ALLOC_TEMP_ORIGIN_RECT(si, READ_I16(bp04,-2)), 
		0, 0, READ_I16(bp04,-4), si, -1, (bp0a == 1) ? 1 : 0, 4, 4, NULL);
	//^32CB:0D64
	bp04 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(di));
	//^32CB:0D71
	U8 *bp10 = _32cb_0649(0x17, glbMapGraphicsSet, bp0b, 0);
	//^32CB:0D8A
	bp10[0] = ref->b58[yy];
	//^32CB:0D9A
	si = READ_I16(bp04,-4) * READ_I16(bp04,-2);
	//^32CB:0DA7
	_44c8_20a4(bp04, reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(xx)), NULL, &ref->rc36, 
		si -(RAND() & 31) -16, RAND16(60), ref->width, -1, bp10);
	//^32CB:0DF8
	FREE_TEMP_CACHE_INDEX(di);
	//^32CB:0DFF
	return;
}

//^3E74:5163
Bit8u *SkWinCore::QUERY_GDAT_ENTRY_DATA_BUFF(Bit8u cls1, Bit8u cls2, Bit8u cls3, Bit8u cls4)
{
LOGX(("%40s: C%02d=I%02X=E%02X=T%03d to %08X", "QUERY_GDAT_ENTRY_DATA_BUFF from ", cls1, cls2, cls4, cls3 ));
	//^3E74:5163
	i16 si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4);
	//^3E74:5181
	if (si == -1) {
		//^3E74:5186
		return NULL;
	}
	//^3E74:518C
	if (glbShelfMemoryTable[si].Absent()) {
		//^3E74:51A9
		if (IS_CLS1_CRITICAL_FOR_LOAD(cls1) == 0) {
			//^3E74:51C7
			//^3E74:5186
			return NULL;
		}
		//^3E74:51B6
		Bit16u bp02;
		return QUERY_GDAT_DYN_BUFF(si, &bp02, 0);
	}
	else {
		//^3E74:51C9
		return REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]);
	}
}

//^0CEE:26CF
U8 SkWinCore::QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(U16 actuatorData)
{
	//^0CEE:26CF
	ENTER(0);
	//^0CEE:26D2
	return QUERY_CLS1_FROM_RECORD(ObjectID(0, GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(actuatorData), 0));
}

//^0CEE:1513
ObjectID SkWinCore::ALLOC_NEW_DBITEM_DEEPLY(U16 actuatorData)
{
	//^0CEE:1513
	ENTER(6);
	//^0CEE:1519
	U8 bp05 = GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(actuatorData);
	X16 di;
	ObjectID si = RECYCLE_A_RECORD_FROM_THE_WORLD(di = GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(actuatorData), bp05);
	if (si == OBJECT_NULL) {
		//^0CEE:153F
		si = ALLOC_NEW_RECORD(di);
		if (si == OBJECT_NULL)
			return si;
	}
	//^0CEE:154C
	GenericRecord *bp04;
	ZERO_MEMORY(bp04 = GET_ADDRESS_OF_RECORD(si), glbItemSizePerDB[di]);
	bp04->w0 = OBJECT_END_MARKER;
	SET_ITEMTYPE(si, bp05);
	//^0CEE:1581
	return si;
}

//^32CB:0EE5
U16 SkWinCore::IS_DISTINCTIVE_ITEM_ON_ACTUATOR(Actuator *ref, U16 disit, U16 onTile)
{
	//^32CB:0EE5
	ENTER(2);
	//^32CB:0EEB
	for (ObjectID si = GET_TILE_RECORD_LINK(ref->Xcoord(), ref->Ycoord()); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^32CB:0F0D
		U16 bp02 = si.DBType();
		//^32CB:0F18
		if (onTile != 0 && bp02 >= dbWeapon && bp02 <= dbMiscellaneous_item) {
			//^32CB:0F2A
			if (GET_DISTINCTIVE_ITEMTYPE(si) != disit)
				//^32CB:0F34
				continue;
			//^32CB:0F36
			return 1;
		}
		//^32CB:0F3B
		if (bp02 == dbCreature) {
			//^32CB:0F41
			for (ObjectID di = GET_ADDRESS_OF_RECORD4(si)->GetPossessionObject(); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
				//^32CB:0F52
				if (GET_DISTINCTIVE_ITEMTYPE(di) == disit)
					//^32CB:0F5E
					//^32CB:0F36
					return 1;
				//^32CB:0F60
			}
		}
		//^32CB:0F6E
	}
	//^32CB:0F7C
	return 0;
}

//^32CB:0E03
void SkWinCore::DRAW_TEXT_TO_BACKBUFF(i16 xx, i16 yy, U8 *str)
{
	//^32CB:0E03
	ENTER(24);
	//^32CB:0E07
	if (QUERY_MBCS_PRESENCE(str) == 0) {
		//^32CB:0E18
		for (U8 *bp04 = str; *bp04 != 0; bp04++) {
			//^32CB:0E26
			if (*bp04 >= 'A' && *bp04 <= 'Z') {
				//^32CB:0E35
				*bp04 = *bp04 -0x40;
			}
			//^32CB:0E42
			else if (*bp04 >= 0x7b) {
				//^32CB:0E4B
				*bp04 = *bp04 -0x60;
			}
			//^32CB:0E52
		}
	}
	//^32CB:0E5E
	i16 bp06;
	i16 bp08;
	if (QUERY_STR_METRICS(str, &bp06, &bp08) != 0) {
		//^32CB:0E7A
		U8 bp18[16];
		COPY_MEMORY(glbPaletteT16, bp18, 16);
		//^32CB:0E93
		_0b36_037e(bp18, U8(_4976_5a88), -1, -1, 16);
		//^32CB:0EAA
		DRAW_STRONG_TEXT(_4976_4c16, -1, _4976_00f6, xx -(bp06 >> 1), yy, bp18[15], bp18[0]|0x4000, str);
	}
	//^32CB:0EE3
	return;
}

//^48AE:05AE
U16 SkWinCore::_48ae_05ae(i16 disit, U8 yy, U16 zz, U16 ss, U16 tt, i16 ww)
{
	//^48AE:05AE
	ENTER(10);
	//^48AE:05B4
	U8 bp03 = GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(disit);
	//^48AE:05C0
	U8 bp04 = QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(disit);
	//^48AE:05CC
	U16 si = QUERY_GDAT_ENTRY_DATA_INDEX(bp04, bp03, dtWordValue, 0x02); // 0x02 -> Money value
	//^48AE:05E2
	U8 *bp08 = ALLOC_MEMORY_RAM(64, afDefault, 1024);
	//^48AE:05F9
	U16 bp0a = zz * 3 +18;
	//^48AE:0607
	U16 bp02 = QUERY_GDAT_CREATURE_WORD_VALUE(yy, U8(bp0a * 3 +0xa2));
	//^48AE:0620
	if (true
		&& bp02 != 0
		&& QUERY_CREATURES_ITEM_MASK(yy, U8(bp0a), bp08, 0) != 0
		&& (bp08[disit >> 3] & (1 << (disit & 7))) != 0
	) {
		//^48AE:0658
        si = si * bp02 / 100;
	}
	//^48AE:0666
	bp0a = zz * 3 +17;
	//^48AE:0674
	bp02 = QUERY_GDAT_CREATURE_WORD_VALUE(yy, zz *3 +0xa1);
	//^48AE:068D
	if (true
		&& bp02 != 0
		&& QUERY_CREATURES_ITEM_MASK(yy, U8(bp0a), bp08, 0) != 0
		&& (bp08[disit >> 3] & (1 << (disit & 7))) != 0
	) {
		//^48AE:06C5
		si = si * bp02 / 100;
	}
	//^48AE:06D3
	DEALLOC_UPPER_MEMORY(64);
	//^48AE:06DE
	if (ww < 0) {
		//^48AE:06E4
		ww = GET_MAX_CHARGE(ObjectID(0, GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(disit), 0));
	}
	//^48AE:06FA
	si += QUERY_GDAT_ENTRY_DATA_INDEX(
		QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(disit),
		GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(disit),
		dtWordValue,
		GDAT_ITEM_BONUS_MONEY_PER_CHARGE
		) * ww; // 0x35 -> Additional money value per charge
	//^48AE:0723
	if (tt != 0) {
		//^48AE:0729
		U16 di = QUERY_GDAT_CREATURE_WORD_VALUE(yy, U8(zz * 3) +0xa0);
		//^48AE:0741
		if (di == 0)
			//^48AE:0745
			di = 10;
		//^48AE:0748
		di = si * di / 100;
		//^48AE:0755
		if (ss != 0) {
			//^48AE:075B
			si += di;
		}
		else {
			//^48AE:075F
			si -= di;
		}
	}
	//^48AE:0761
	return si;
}

//^48AE:0767
U16 SkWinCore::_48ae_0767(i16 xx, i16 yy, U8 *zz, i16 *vv, i16 ww)
{
	//^48AE:0767
	ENTER(0);
	//^48AE:076C
	i16 si = 0;
	//^48AE:076E
	i16 dx = glbCountMoneyItems -1;
	U16 cx = 0;
	//^48AE:0776
	*vv = 0;
	//^48AE:077E
	i16 di;
	while (si < yy && xx > 0 && dx >= 0 && (di = glbMoneyItemsValueTable[dx]) > 0) {
		//^48AE:0780
		if (xx >= di) {
			//^48AE:0785
			zz[si] = U8(dx);
			//^48AE:078D
			si++;
			//^48AE:078E
			xx -= di;
			//^48AE:0791
			cx += di;
			//^48AE:0793
			(*vv)++;
		}
		else {
			//^48AE:079B
			dx--;
		}
        //^48AE:079C
	}
	//^48AE:07B9
	return cx;
}

//^32CB:0F82
void SkWinCore::_32cb_0f82(Actuator *ref, U8 cls4, i16 bb, i16 cellPos, U16 horzStretch, U16 vertStretch, U16 rectno, U16 gg, U16 colorkey1)
{
	//^32CB:0F82
	ENTER(58);
	//^32CB:0F88
	Actuator *bp0c = NULL;
	//^32CB:0F92
	U16 bp26;
	for (ObjectID di = GET_TILE_RECORD_LINK(ref->Xcoord(), ref->Ycoord()); di != OBJECT_END_MARKER && (bp26 = di.DBType()) <= dbActuator; di = GET_NEXT_RECORD_LINK(di)) {
		//^32CB:0FB4
		if (bp26 == dbActuator) {
			//^32CB:0FBA
			bp0c = GET_ADDRESS_OF_ACTU(di);
			//^32CB:0FC7
			if (bp0c->ActuatorType() == ACTUATOR_FLOOR_TYPE__SHOP) // 0x30 -> 'Shop exhibition'
				//^32CB:0FD4
				break;
		}
		//^32CB:0FD6
	}
	//^32CB:0FF4
	i16 si = bp0c->ActuatorData();
	U16 bp24 = si;
	//^32CB:1006
	U8 bp11 = U8(ref->ActuatorData());
	//^32CB:1016
	if (ref->ActiveStatus() == 0 || ref->OnceOnlyActuator() != 0) {
		//^32CB:1032
		U16 bp14 = (ref->Delay() * 3) +16;
		//^32CB:104A
		U8 *bp04 = ALLOC_MEMORY_RAM(64, afDefault, 1024);
		//^32CB:1061
		if (QUERY_CREATURES_ITEM_MASK(bp11, U8(bp14), bp04, 0) != 0) {
			//^32CB:107F
			U16 *bp10 = reinterpret_cast<U16 *>(QUERY_GDAT_ENTRY_DATA_BUFF(GDAT_CATEGORY_WALL_GFX, cls4, dt08, GDAT_WALL_ORNATE__DATA_13));
			//^32CB:1097
			i16 bp28;
			if (bp10 != NULL) {
				//^32CB:109B
				bp28 = QUERY_GDAT_ENTRY_DATA_LENGTH(GDAT_CATEGORY_WALL_GFX, cls4, dt08, GDAT_WALL_ORNATE__DATA_13) >> 1;
				//^32CB:10B2
				for (si = 0; si < bp28; si++) {
					//^32CB:10B6
					if ((bp10[si] & 511) == bp24)
						//^32CB:10C8
						break;
				}
			}
			do {
				//^32CB:10D0
				si += (ref->OnceOnlyActuator() != 0 || _4976_5a96 < 0) ? 1 : -1;
				//^32CB:10F2
				if (bp10 != NULL) {
					//^32CB:10FA
					if (si < 0) {
						//^32CB:10FE
						si = bp28 -1;
					}
					//^32CB:1106
					else if (si >= bp28) {
						//^32CB:110B
						si = 0;
					}
					//^32CB:110D
					bp24 = bp10[si] & 511;
				}
				else {
					//^32CB:111E
					si &= 511;
					bp24 = si;
				}
				//^32CB:1124
				//^32CB:1127
			} while (false
				|| (bp04[bp24 >> 3] & (1 << (bp24 & 7))) == 0
				|| (true
					&& (QUERY_GDAT_ENTRY_DATA_INDEX(QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(bp24), GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(bp24), dtWordValue, 0) & 0x1000) != 0
					&& IS_DISTINCTIVE_ITEM_ON_ACTUATOR(ref, bp24, 1) == 0
					&& IS_DISTINCTIVE_ITEM_ON_ACTUATOR(bp0c, bp24, 0) == 0
					&& _2fcf_16ff(bp24) == 0
					)
				);
			//^32CB:11A2
			ref->OnceOnlyActuator(0);
		}
		//^32CB:11AA
		ref->ActiveStatus(1);
		//^32CB:11B2
		bp0c->ActiveStatus(1);
		//^32CB:11BA
		bp0c->ActuatorData(bp24);
		//^32CB:11CD
		DEALLOC_UPPER_MEMORY(64);
	}
	//^32CB:11D8
	U16 bp18 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, cls4, dtImageOffset, GDAT_WALL_ORNATE__DATA_FD);	// 0xFD
	//^32CB:11EE
	QUERY_TEMP_PICST(0, horzStretch, vertStretch, i8(bp18 >> 8), i8(bp18), bb, rectno, gg, colorkey1, -1, QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(bp24),
		GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(bp24), 0x00);
	//^32CB:122E
	DRAW_TEMP_PICST();
	//^32CB:1232
	if (true
		&& IS_DISTINCTIVE_ITEM_ON_ACTUATOR(ref, bp24, 1) == 0
		&& IS_DISTINCTIVE_ITEM_ON_ACTUATOR(bp0c, bp24, 0) == 0
	) {
		//^32CB:1264
		U16 *bp10 = reinterpret_cast<U16 *>(QUERY_GDAT_ENTRY_DATA_BUFF(GDAT_CATEGORY_WALL_GFX, cls4, dt08, GDAT_WALL_ORNATE__DATA_13));
		//^32CB:127C
		if (bp10 != NULL) {
			//^32CB:1280
			i16 bp28 = QUERY_GDAT_ENTRY_DATA_LENGTH(GDAT_CATEGORY_WALL_GFX, cls4, dt08, GDAT_WALL_ORNATE__DATA_13) >> 1;
			//^32CB:1297
			for (si = 0; si < bp28; si++) {
				//^32CB:129B
				if ((bp10[si] & 511) == bp24)
					//^32CB:12AD
					break;
			}
			//^32CB:12B5
			ObjectID di;
			if ((bp10[si] & 0x8000) != 0 && (di = ALLOC_NEW_DBITEM_DEEPLY(bp24)) != OBJECT_NULL) {
				//^32CB:12D5
				APPEND_RECORD_TO(di, NULL, ref->Xcoord(), ref->Ycoord());
			}
		}
		else {
			//^32CB:12FD
			QUERY_TEMP_PICST(0, horzStretch, vertStretch, i8(bp18 >> 8), i8(bp18), bb, rectno, gg, colorkey1, -1, 9, cls4, 0x11); // sold out icon
			//^32CB:132F
			DRAW_TEMP_PICST();
		}
	}
	//^32CB:1333
	QUERY_TEMP_PICST(0, horzStretch, vertStretch, 0, 0, bb, rectno, gg, colorkey1, -1, 9, cls4, 0x0f); // shop panel nav board
	//^32CB:135C
	DRAW_TEMP_PICST();
	//^32CB:1360
	if (cellPos == 3) {
		//^32CB:1366
		i16 bp2a;
		i16 bp2c;
		QUERY_TOPLEFT_OF_RECT(rectno, &bp2a, &bp2c);
		//^32CB:137B
		U16 bp18 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, cls4, dtImageOffset, 0xf2);
		//^32CB:1391
		bp2a += i8(bp18 >> 8);
		bp2c += i8(bp18);
		//^32CB:139F
		DRAW_TEXT_TO_BACKBUFF(bp2a, bp2c, QUERY_GDAT_ITEM_NAME(QUERY_ITEMDB_FROM_DISTINCTIVE_ITEMTYPE(bp24), GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(bp24)));
	}
	//^32CB:13C9
	if (cellPos == 3) {
		//^32CB:13D2
		U16 bp22 = _48ae_05ae(bp24, bp11, ref->ShopItemPoolNo(), 1, 1, -1); // price for buy?
		//^32CB:13F8
		U16 bp20 = _48ae_05ae(bp24, bp11, ref->ShopItemPoolNo(), 0, 1, -1); // price for sell?
		//^32CB:141E
		for (i16 bp16 = 0; bp16 < 2; bp16++) {
			//^32CB:1426
			U16 bp18 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, cls4, dtImageOffset, (bp16 != 0) ? GDAT_WALL_ORNATE__DATA_F0 : GDAT_WALL_ORNATE__DATA_F1);
			//^32CB:1446
			i16 bp2a = i8(bp18 >> 8);
			i16 bp2c = i8(bp18);
			//^32CB:1454
			U16 bp1a = (bp16 != 0) ? bp22 : bp20;
			//^32CB:1465
			if (bp1a <= 0)
				//^32CB:1469
				continue;
			//^32CB:146C
			U8 bp3a[16];
			i16 bp1e;
			_48ae_0767(bp1a, 6, bp3a, &bp1e, bp16);
			//^32CB:1486
			if (bp1e <= 0)
				//^32CB:148C
				continue;
			//^32CB:148F
			U16 bp1c = ALLOC_TEMP_CACHE_INDEX();
			//^32CB:1497
			ALLOC_NEW_PICT(bp1c, bp1e << 3, 7, 4);
			//^32CB:14AD
			QUERY_TEMP_PICST(0, 64, 64, 0, 0, bb, -1, gg, -1, -1, 0x09, cls4, 0x10);
			//^32CB:14D2
			U8 *bp08 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp1c));
			//^32CB:14E1
			SRECT bp34;
			SET_ORIGIN_RECT(&bp34, 8, 7);
			//^32CB:14F2
			for (si = 0; si < bp1e; si++) {
				//^32CB:14F6
				DRAW_DIALOGUE_PICT(glbTempPicture.pb0, bp08, &bp34, bp3a[si] << 3, 0, -1, NULL);
				//^32CB:1522
				bp34.x += 8;
				//^32CB:1526
			}
			//^32CB:152C
			DRAW_DIALOGUE_PICT(bp08, _4976_4c16, QUERY_BLIT_RECT(bp08, &bp34, rectno|0x8000, &bp2a, &bp2c, gg), 
				0, 0, colorkey1, glbTempPicture.b58);
			//^32CB:1576
			FREE_TEMP_CACHE_INDEX(bp1c);
			//^32CB:157F
		}
	}
	//^32CB:158B
	return;
}

//^32CB:3F0D
// SPX: _32cb_3f0d renamed DRAW_ALCOVE_ITEMS
void SkWinCore::DRAW_ALCOVE_ITEMS(U16 xx)
{
	//^32CB:3F0D
	ENTER(14);
	//^32CB:3F13
	X16 si = xx;
	ObjectID di = tblCellTilesRoom[si].xsrd.id4();
	if (di == OBJECT_END_MARKER)
		return;
	//^32CB:3F2F
	X16 bp08 = 2;
	//^32CB:3F34
	do {
		if (di.Dir() != ((glbPlayerDir +2) & 3))
			return;
		//^32CB:3F4A
		X16 bp0a = di.DBType();
		if (bp0a >= dbWeapon && bp0a <= dbMiscellaneous_item) {
			//^32CB:3F61
			DRAW_ITEM(di, si, 0, 0, bp08, NULL, 1, 0, 1);
			bp08++;
			if (bp08 >= 0xe)
				bp08 = 2;
			if (si == 3)
				//^32CB:3F91
				MAKE_PUT_DOWN_ITEM_CLICKABLE_ZONE(8, di, si, 3);
		}
		//^32CB:3FA1
		else if (bp0a == dbCloud && _4976_4463[RCJ(23,si)] != 0xff) {
			//^32CB:3FB4
			Cloud *bp04 = GET_ADDRESS_OF_RECORDF(di);
			U8 bp05 = bp04->CloudType();
			X16 bp0c = RAND02();
			if (bp05 == 0x64) {
				//^32CB:3FDC
				X16 bp0e = _4976_41ed[RCJ(17,_4976_4463[RCJ(23,si)])];
				QUERY_TEMP_PICST(bp0c, bp0e, bp0e, 0, 0, 0, QUERY_RECTNO_FOR_WALL_ORNATE(si, 0, 0xffff), 0xffff, 10, -1, 0x0d, bp05, 0xc);
				DRAW_TEMP_PICST();
			}
			//^32CB:4020
			else if (bp05 == 0x65) {
				_32cb_2cf3(bp05, _4976_41e6[RCJ(7,_4976_4463[RCJ(23,si)])], bp0c, QUERY_RECTNO_FOR_WALL_ORNATE(si, 12, 0));
				DRAW_TEMP_PICST();
			}
		}
		//^32CB:4054
	} while ((di = GET_NEXT_RECORD_LINK(di)) != OBJECT_END_MARKER);
	//^32CB:4065
	return;
}

//^32CB:15B8
// SPX: _32cb_15b8 renamed DRAW_WALL_ORNATE
i16 SkWinCore::DRAW_WALL_ORNATE(i16 cellPos, i16 yy, i16 zz)
{
	//^32CB:15B8
	ENTER(854);

#if DM2_EXTENDED_MODE == 1
	{
		if (glbGlobalSpellEffects.SeeThruWalls > 0 && cellPos == 3)	// front D1 wall
		{
			return -1;	// in case of see thru, don't show ornate at all
		}
	}
#endif


	//^32CB:15BE
	i16 bp14 = (yy <= -1)
		? 4
		: ((yy >= 1)
			? 6
			: 5
		);
	//^32CB:15DD
	bp14 = tblCellTilesRoom[cellPos].xsrd.w6[RCJ(4,bp14 -3)];	// get the ornate gfx id ?
	//^32CB:15F9
	i16 bp28 = bp14 >> 8;	// upper part (flags)
	//^32CB:15FF
	i16 iYDist = glbTabYAxisDistance[RCJ(23,cellPos)];	// i16 di
	//^32CB:1609
	U8 bp1f = U8(bp14) & 0xff; // lower part : gfx id
	//^32CB:1611
	if (bp1f == 0xff)
		//^32CB:1617
		return -1;
	//^32CB:161D
	U16 bp2a = (bp1f == 0) ? 1 : 0;
	//^32CB:162D
	U16 alcoveType = IS_WALL_ORNATE_ALCOVE(bp1f);	// U16 bp22
	//^32CB:163A
	U16 iDoNotFlip = 0; // U16 bp24 = 0; SPX: fixed value init
	if (bp2a == 0) {
		//^32CB:1640
		iDoNotFlip = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp1f, dtWordValue, GDAT_WALL_ORNATE__DO_NOT_FLIP);	// Has some role for general graphics flip
	}
	//^32CB:1655
	U16 iFlipImage = 0;	// U16 bp0e = 0; use flip or not
	//^32CB:165A
	U16 si = 0; // defaulting to 0
	if (bp2a != 0 || (si = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp1f, dtWordValue, GDAT_IMG_COLORKEY_1)) == 0)
		//^32CB:1678
		si = glbSceneColorKey;
	//^32CB:167C
	U16 iOrnatePos = 0;	// U16 bp1a
	U16 iRefPoint = 0;	// U16 bp1e
	if (bp2a != 0 || (iOrnatePos = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp1f, dtWordValue, GDAT_WALL_ORNATE__POSITION)) == 0) {
		//^32CB:169B
		iOrnatePos = ORNATE_POS__VCENTERED_HCENTERED;	// SPX: that must be the default ornate position (default = 12)
		iRefPoint = 0;	// 0 = point is centered
	}
	else {	// values in GDAT are 1 to 25. shift it back to 0 to 24.
		//^32CB:16A7
		iRefPoint = iOrnatePos >> 8;	 // SPX: value in GDAT is 2 byte. Upper byte is how to draw image from ornate position
		iOrnatePos = (iOrnatePos & 255) -1;
	}
	//^32CB:16BA
	U16 iRectno = QUERY_RECTNO_FOR_WALL_ORNATE(cellPos, iOrnatePos, (yy != 0) ? 1 : 0);	// U16 bp1c; recto
	//^32CB:16D9
	U16 iStretchVertical = 0;	// U16 bp18
	U16 iStretchHorizontal = 0;	// U16 bp16
	iStretchVertical = iStretchHorizontal = tlbDistanceStretch[RCJ(5,iYDist)];
	
	//^32CB:16E5
	if (alcoveType == WALL_ORNATE_OBJECT__CRYOCELL && yy == 0) {	// bp22 == 3
		//^32CB:16F7
		U16 bp34 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp1f, dtImageOffset, GDAT_GFXSET_DATA_FD);	// 0x09 .. .. 0xFD
		//^32CB:170D
		// SPX: U8(_4976_5a80[cellPos].x2.w14) holds the portrait Champion ID to be displayed under the Champion Cell/Mirror
		QUERY_TEMP_PICST(iFlipImage, iStretchHorizontal, iStretchVertical, i8(bp34 >> 8), i8(bp34), iYDist, iRectno, iRefPoint, -1, -1, GDAT_CATEGORY_CHAMPIONS, U8(tblCellTilesRoom[cellPos].xsrd.xvalue), 1);
		//^32CB:174C
		if (zz == 0)
			//^32CB:1752
			glbTempPicture.colorKeyPassThrough = -2;
		//^32CB:1758
		DRAW_TEMP_PICST();
		//^32CB:175C
		if (zz == 0)
			//^32CB:1762
			//^32CB:1F38
			return si;
		//^32CB:1765
		if (iYDist == 1) {
			//^32CB:176A
			MAKE_BUTTON_CLICKABLE(&glbTempPicture.rc36, 6, U8(cellPos));
		}
	}
	//^32CB:177A
	if (iYDist == 2 && (yy <= -2 || yy >= 2))
		//^32CB:178B
		iStretchHorizontal = 0x72;	// 0x72 = 114	=> 178%
	//^32CB:1792
	else if (iYDist == 3 && (yy <= -2 || yy >= 2))
		//^32CB:17A3
		iStretchHorizontal = 0x4C;	// 0x4C = 76 => 118%
	//^32CB:17A8
	if (bp2a != 0) {
		//^32CB:17B1
		U8 bp20;
		if (yy == 0) {
			//^32CB:17B7
			bp20 = 0xFC;
		}
		else if (yy <= -1) {
			//^32CB:17C3
			bp20 = 0xFD;
		}
		else {
			//^32CB:17C9
			if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtImage, 0xFE) != 0) { // SPX: GDAT2 never has 0xFE image ???
				//^32CB:17E0
				bp20 = 0xFE;
			}
			else {
				//^32CB:17E6
				bp20 = 0xFD;
				iFlipImage = 1;	// do flip
			}
		}
		//^32CB:17EF
		QUERY_TEMP_PICST(iFlipImage, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, iRectno, iRefPoint, si, -1, GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, bp20);
		//^32CB:1817
		if (zz == 0)
			//^32CB:181D
			glbTempPicture.colorKeyPassThrough = -2;
		//^32CB:1823
		DRAW_TEMP_PICST();
		//^32CB:1827
		if (yy != 0)
			//^32CB:182D
			//^32CB:1F38
			return si;
		//^32CB:1830
		ObjectID bp32 = tblCellTilesRoom[cellPos].xsrd.xvalue;
		//^32CB:1845
		if (bp32 == OBJECT_NULL)
			//^32CB:184A
			//^32CB:1F38
			return si;
		//^32CB:184D
		ExtendedPicture bp01d6;
		QUERY_GDAT_SUMMARY_IMAGE(&bp01d6, GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, bp20);
		//^32CB:1865
		i16 bp2c = bp01d6.w28;
		i16 bp2e = bp01d6.w30;
		//^32CB:1873
		i16 bp48;
		i16 bp4a;
		QUERY_GDAT_IMAGE_METRICS(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, bp20, &bp48, &bp4a);
		//^32CB:188F
		U16 bp26 = ALLOC_TEMP_CACHE_INDEX();
		//^32CB:1897
		U8 bp009c[80];
		QUERY_MESSAGE_TEXT(bp009c, bp32, 2);
		//^32CB:18AA
		U16 bp36 = 0;
		U16 bp38 = 1;
		//^32CB:18B4
		U8 bp45;
		while ((bp45 = bp009c[bp36++]) != 0) {
			//^32CB:18B6
			if (bp45 == vbLf)
				//^32CB:18BC
				bp38++;
		}
		//^32CB:18D5
		U16 bp4c = QUERY_MBCS_PRESENCE(bp009c);
		//^32CB:18E5
		U16 bp3a;
		U16 bp3c;
		if (bp4c != 0) {
			//^32CB:18E9
			bp3a = _4976_012e;
			bp3c = _4976_0130 +2;
			si = 0;
		}
		else {
			//^32CB:18FB
			bp3a = _4976_012a;
			bp3c = _4976_012c +2;
		}
		//^32CB:1909
		U8 *bp08 = ALLOC_NEW_PICT(bp26, bp48, bp4a, 4);
		//^32CB:1922
		FILL_ENTIRE_PICT(bp08, si);
		//^32CB:1931
		SRECT rc44;
		rc44.y = (bp4a >> 1) - (bp3c * bp38 >> 1);
		//^32CB:1945
		if (bp4c != 0) {
			//^32CB:194E
			for (U16 bp36 = 0; bp009c[bp36] != 0; ) {
				//^32CB:1956
				if (bp4a - (_4976_0130 + _4976_0136 +1) <= rc44.y)
					//^32CB:1968
					break;
				//^32CB:196B
				U8 bp0356[384];
				i16 bp30 = _3929_04e2(bp009c, bp0356, &bp36, bp48 -1);
				//^32CB:198C
				if (bp30 != 0) {
					//^32CB:1995
					rc44.x = (bp48 >> 1) - (bp30 >> 1);
					//^32CB:19A4
					if (rc44.y >= 0 && rc44.x >= 0 && bp30 <= bp48) {
						//^32CB:19C1
						DRAW_STRING(bp08, bp26, bp48, rc44.x   , rc44.y + _4976_0130 +1, 1, 0x4000, bp0356, 4);
						//^32CB:19EE
						DRAW_STRING(bp08, bp26, bp48, rc44.x +1, rc44.y + _4976_0130 +1, 1, 0x4000, bp0356, 4);
						//^32CB:1A1D
						DRAW_STRING(bp08, bp26, bp48, rc44.x   , rc44.y + _4976_0130   , 2, 0x4000, bp0356, 4);
					}
				}
				//^32CB:1A49
				if (bp009c[bp36] == vbLf)
					//^32CB:1A58
					bp36++;
				//^32CB:1A5B
				rc44.y += bp3c;
				//^32CB:1A61
			}
		}
		else {
			//^_1a76
			U8 *bp0c = QUERY_GDAT_IMAGE_ENTRY_BUFF(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_LETTERS);	// 0x08 .. 0x03
			//^32CB:1A8C
			rc44.cx = bp3a;
			//^32CB:1A92
			rc44.cy = READ_I16(bp0c,-2);
			//^32CB:1A9C
			U8 *bp08 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp26));
			//^32CB:1AAB
			U8 *bp04 = bp009c;

			do {
				//^32CB:1AB5
				U16 bp36 = 0;
				//^32CB:1ABA
				while (bp04[bp36] != 0 && bp04[bp36] != vbLf)
					//^32CB:1ABC
					bp36++;
				//^32CB:1AD7
				i16 bp30 = bp3a * bp36;
				//^32CB:1AE0
				if (bp36 != 0) {
					//^32CB:1AE6
					rc44.x = (bp48 >> 1) - (bp30 >> 1);
					//^32CB:1AF5
					if (rc44.x < 0) {
						//^32CB:1AFB
						bp04 += bp36;
					}
					else {
						//^32CB:1AF9
						while (bp36-- != 0) {
							//^32CB:1B03
							DRAW_DIALOGUE_PICT(
								bp0c,
								bp08,
								&rc44,
								SKCHR_TO_SCRIPTCHR(*(bp04++)) * bp3a,
								0,
								si,
								QUERY_GDAT_IMAGE_LOCALPAL(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_LETTERS)	// 0x08 .. 0x03
								);
							//^32CB:1B46
							rc44.x += bp3a;
							//^32CB:1B49
						}
					}
				}
				//^32CB:1B56
				rc44.y += bp3c;
				//^32CB:1B5C
			} while (*(bp04++) != 0);
		}
		//^32CB:1B6B
		QUERY_GDAT_SUMMARY_IMAGE(&bp01d6, 0xff, 0x00, 0x00);
		//^32CB:1B80
		bp01d6.w12 = bp26;
		bp01d6.w6 = 0xffff;
		bp01d6.w52 = iStretchHorizontal;
		bp01d6.w54 = iStretchVertical;
		//^32CB:1B9B
		if (bp4c != 0) {
			//^32CB:1BA1
			bp01d6.b58[1] = glbPaletteT16[COLOR_BLACK];
			bp01d6.b58[2] = glbPaletteT16[COLOR_BROWN];
		}
		else {
			//^32CB:1BB6
			COPY_MEMORY(
				QUERY_GDAT_IMAGE_LOCALPAL(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_LETTERS),	// 08 .. 03
				bp01d6.b58,
				16
				);
		}
		//^32CB:1BDA
		bp01d6.w56 = 16;
		//^32CB:1BE1
		_32cb_0804(bp01d6.b58, U8(iYDist), si, -1, bp01d6.w56);
		//^32CB:1BF3
		bp01d6.pb44 = _4976_4c16;
		//^32CB:1C02
		bp01d6.rectNo = iRectno;
		bp01d6.w26 = iRefPoint;
		bp01d6.w28 = bp2c;
		bp01d6.w30 = bp2e;
		bp01d6.colorKeyPassThrough = si;
		//^32CB:1C22
		DRAW_PICST(QUERY_PICST_IT(&bp01d6));
		//^32CB:1C38
		FREE_TEMP_CACHE_INDEX(bp26);
		//^32CB:1C41
		//^32CB:1F38
		return si;
	}
	//^32CB:1C44
	U8 iImageEntry;	// U8 bp20; which image entry. 1 = front / 0 = side. Add default init to FRONT
	if (yy == 0) {	// Front image
		//^32CB:1C4A
		iImageEntry = GDAT_WALL_IMAGE__VIEW_FRONT;	// = 1;	front view
		//^32CB:1C4E
		if (iDoNotFlip == 0) {
			//^32CB:1C54
			if ((glbTabYAxisDistance[RCJ(23,cellPos)] & 1) != 0) {
				//^32CB:1C5E
				iFlipImage = glbGeneralFlipGraphics;
			}
			else {
				//^32CB:1C66
				iFlipImage = glbGeneralFlipGraphics ^ 1;
			}
		}
	}
	else {	// Side image
		//^32CB:1C71
		iImageEntry = GDAT_WALL_IMAGE__VIEW_SIDE_LEFT;	// = 0;	 side view on left
		//^32CB:1C75
		if (yy >= 1) {
			//^32CB:1C7B
			if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_WALL_GFX, bp1f, dtImage, U8(bp28) +2) != 0) {
				//^32CB:1C95
				iImageEntry = GDAT_WALL_IMAGE__VIEW_SIDE_RIGHT;	// = 2; side view on right
			}
			else {
				//^32CB:1C9B
				iFlipImage = 1;	// flip image
			}
		}
	}
	//^32CB:1CA0
	iImageEntry = iImageEntry +U8(bp28);
#if DM2_EXTENDED_MODE == 1
	if (SkCodeParam::bUseExtendedSound && bp28 == 4 /*&& SkCodeParam::bForceOrnateSound == true*/)	// 4 = first anim of a loop (if several)
	{
		int iRandNoise = 0;
		int iMaxLoopSoundsAvailable = 9;
		while(iMaxLoopSoundsAvailable > 0)
		{
			if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_WALL_GFX, bp1f, dtSnd, SOUND_ACTIVATION_LOOP + iMaxLoopSoundsAvailable) != 0)
				break;
			iMaxLoopSoundsAvailable--;
		}
		if (iMaxLoopSoundsAvailable > 0)
			iRandNoise = RAND()%iMaxLoopSoundsAvailable;

//		i16 iYDist = glbTabYAxisDistance[RCJ(23,cellPos)];	
		i16 iXDist = glbTabXAxisDistance[RCJ(23,cellPos)];
		QUEUE_NOISE_GEN2(GDAT_CATEGORY_WALL_GFX, bp1f, SOUND_ACTIVATION_LOOP + iRandNoise, 0xFE, glbPlayerPosX+iXDist, glbPlayerPosY+iYDist, 0, 140, 200);
	}
#endif
	//^32CB:1CA9
	SRECT *bp12;
	if (yy == 0 && QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp1f, dtWordValue, GDAT_WALL_ORNATE__WINDOW) != 0) {
		//^32CB:1CCB
		QUERY_TEMP_PICST(iFlipImage, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, iRectno, iRefPoint, -3, -3, GDAT_CATEGORY_WALL_GFX, bp1f, iImageEntry);
		//^32CB:1CF4
		QUERY_TEMP_PICST(iFlipImage, iStretchHorizontal, iStretchVertical, glbTempPicture.w28, glbTempPicture.w30, iYDist, iRectno, iRefPoint, si, -1, GDAT_CATEGORY_WALL_GFX, bp1f, 200);
		//^32CB:1D1F
		if (zz == 0)
			//^32CB:1D25
			glbTempPicture.colorKeyPassThrough = -1;
		//^32CB:1D2B
		DRAW_TEMP_PICST(); // draw window contents (outside)
		//^32CB:1D2F
		ExtendedPicture bp0310;
		U16 bp26 = QUERY_MULTILAYERS_PIC(
			&bp0310, GDAT_CATEGORY_WALL_GFX, bp1f, iImageEntry, iStretchHorizontal, iStretchVertical, iYDist, iFlipImage, si,
			QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp1f, dtWordValue, GDAT_IMG_WALL_COLORKEY_2)	// 0x11 is colorkey2 for seeing outside through window (0xC8 image)
			);
		//^32CB:1D67
		_32cb_0c7d(&bp0310, bp26, si);
		//^32CB:1D78
		bp0310.pb44 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp26));
		//^32CB:1D89
		DRAW_PICST(&bp0310);
		//^32CB:1D96
		FREE_PICT_MEMENT(&bp0310);
		//^32CB:1DA3
		bp0310.colorKeyPassThrough = bp0310.b58[si];
		bp0310.pb44 = _4976_4c16;
		bp0310.rectNo = iRectno;
		bp0310.w26 = iRefPoint;
		bp0310.w56 = 0;
		//^32CB:1DD0
		_0b36_00c3(bp26, &bp0310);
		//^32CB:1DE1
		DRAW_PICST(&bp0310);
		//^32CB:1DEE
		bp12 = &bp0310.rc36;
		//^32CB:1DF8
		FREE_TEMP_CACHE_INDEX(bp26);
	}
	else {	// No window, standard wall ornate to display
		//^32CB:1E03
		QUERY_TEMP_PICST(iFlipImage, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, iRectno, iRefPoint, si, -1, GDAT_CATEGORY_WALL_GFX, bp1f, iImageEntry);
		//^32CB:1E2B
		if (zz == 0)
			//^32CB:1E31
			glbTempPicture.colorKeyPassThrough = -2;
		//^32CB:1E37
		DRAW_TEMP_PICST();
		//^32CB:1E3B
		bp12 = &glbTempPicture.rc36;
		//^32CB:1E43
		if (zz == 0)
			//^32CB:1E49
			//^32CB:1F38
			return si;
	}
	//^32CB:1E4C
	if (alcoveType != WALL_ORNATE_OBJECT__CRYOCELL && (cellPos == 1 || cellPos == 2 || cellPos == 3)) {
		//^32CB:1E64
		MAKE_BUTTON_CLICKABLE(bp12, 6, U8(cellPos));
	}
	//^32CB:1E76
	if (alcoveType == WALL_ORNATE_OBJECT__NONE || yy != 0)	// bp22 == 0
		//^32CB:1E85
		//^32CB:1F38
		return si;
	//^32CB:1E88
	COPY_MEMORY(&glbTempPicture, &_4976_5aa8, 314);
	//^32CB:1E9D
	// SPX: This is an overlay on front of wall decoration. This is only used for the shop panel
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_WALL_GFX, bp1f, dtImage, GDAT_WALL_ORNATE__OVERLAY) != 0) {
		//^32CB:1EB3
		if (alcoveType == WALL_ORNATE_OBJECT__SHOP_GLASS) {	// (bp22 == 2)
			//^32CB:1EB9
			_32cb_0f82(
				GET_ADDRESS_OF_ACTU(tblCellTilesRoom[cellPos].xsrd.xvalue), 
				bp1f, iYDist, cellPos, iStretchHorizontal, iStretchVertical, iRectno, iRefPoint, si
				);
			//^32CB:1EEF
			//^32CB:1F38
			return si;
		}
		//^32CB:1EF1
		QUERY_TEMP_PICST(iFlipImage, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, iRectno, iRefPoint, si, -1, GDAT_CATEGORY_WALL_GFX, bp1f, GDAT_WALL_ORNATE__OVERLAY);
		//^32CB:1F17
		if (zz == 0)
			//^32CB:1F1D
			glbTempPicture.colorKeyPassThrough = -2;
		//^32CB:1F23
		DRAW_TEMP_PICST();
		//^32CB:1F27
		//^32CB:1F38
		return si;
	}
	//^32CB:1F29
	if (alcoveType == WALL_ORNATE_OBJECT__ALCOVE)	// (bp22 == 1)
		DRAW_ALCOVE_ITEMS(cellPos);
	//^32CB:1F38
	return si;
}

//^0B36:1446
i16 SkWinCore::_0b36_1446(Picture *ref, i16 xx, i16 yy, U16 colorkey)
{
	//^0B36:1446
	ENTER(20);
	//^0B36:144C
	U8 *bp04 = QUERY_PICT_BITS(ref);
	//^0B36:145E
	if (bp04 == NULL)
		//^0B36:1466
		return -1;
	//^0B36:146C
	U16 si = ref->w22;
	//^0B36:1473
	U16 bp0e = ALLOC_TEMP_CACHE_INDEX();
	//^0B36:147B
	ALLOC_NEW_PICT(bp0e, (si == 4) ? 2 : 1, 1, si);
	//^0B36:1497
	U16 bp10 = ALLOC_TEMP_CACHE_INDEX();
	//^0B36:149F
	U8 *bp0c = ALLOC_NEW_PICT(bp10, (si == 4) ? 2 : 1, 1, si);
	//^0B36:14C1
	U8 *bp08 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp0e));
	//^0B36:14D0
	FILL_ENTIRE_PICT(bp08, colorkey);
	//^0B36:14E1
	FILL_ENTIRE_PICT(bp0c, colorkey);
	//^0B36:14F2
	FIRE_BLIT_PICTURE(bp04 = QUERY_PICT_BITS(ref), bp08, ALLOC_TEMP_ORIGIN_RECT(1, 1), xx, yy, 
		READ_I16(bp04,-4), (si == 4) ? 2 : 1, colorkey, 0, si, si, NULL);
	//^0B36:1547
	U16 bp14 = 1;
	//^0B36:154C
	U16 bp12 = CALC_IMAGE_BYTE_LENGTH(bp08);
	//^0B36:155B
	for (U16 di = 0; di < bp12; di++) {
		//^0B36:155F
		if (*(bp08++) != *(bp0c++)) {
			//^0B36:1573
			bp14 = 0;
			//^0B36:1578
			break;
		}
		//^0B36:157A
	}
	//^0B36:1580
	FREE_TEMP_CACHE_INDEX(bp0e);
	//^0B36:1589
	FREE_TEMP_CACHE_INDEX(bp10);
	//^0B36:1592
	return bp14;
}

//^32CB:00F1
U16 SkWinCore::_32cb_00f1(U16 xx, U16 yy, i16 zz)
{
	//^32CB:00F1
	ENTER(10);
	//^32CB:00F7
	U16 si = xx;
	U16 di = yy;
	//^32CB:00FD
	if (PT_IN_RECT(&glbTempPicture.rc36, si, di) == 0) {
		//^32CB:010F
		return 0;
	}
	//^32CB:0114
	// SPX: This test mirror flip (horizontal)
	if ((glbTempPicture.mirrorFlip & 1) != 0) {
		//^32CB:011C
		si = glbTempPicture.rc36.x + glbTempPicture.rc36.cx -1 -si + glbTempPicture.w32;
	}
	else {
		//^32CB:0128
		si = si - glbTempPicture.rc36.x + glbTempPicture.w32;
	}
	//^32CB:0134
	// SPX: Try to display mirror flip on y axis .. . This does nothing!!
	//di = glbTempPicture.rc36.y + glbTempPicture.rc36.cy -1 -di + glbTempPicture.w34;
	di = di - glbTempPicture.rc36.y + glbTempPicture.w34;
	//^32CB:0140
	U8 *bp0a = QUERY_PICT_BITS(&glbTempPicture);
	//^32CB:0151
	U16 bp04 = READ_I16(bp0a,-4) >> 1;
	//^32CB:015D
	_4976_5a94 = ((si - glbTempPicture.w14 -bp04) * 100) / bp04;
	//^32CB:0172
	U16 bp06 = READ_I16(bp0a,-2) >> 1;
	//^32CB:017B
	_4976_5a96 = ((di -bp06) * 100) / bp06;
	//^32CB:018C
	i16 bp02 = _0b36_1446(&glbTempPicture, si, di, zz);
	//^32CB:01A0
	if (bp02 == -1 || bp02 == 1)
		//^32CB:01AC
		//^32CB:010F
		return 0;
	//^32CB:01AF
	return 1;
}

//^32CB:0287
// SPX: _32cb_0287 renamed _32cb_0287_DRAW_W_ORNATE
U16 SkWinCore::_32cb_0287_DRAW_W_ORNATE(U16 xx, U16 yy, U16 zz)
{
	//^32CB:0287
	ENTER(10);
	//^32CB:028D
	i16 si = xx;
	//^32CB:0290
	U16 di = 0;
	//^32CB:0292
	if (si > 3)
		//^32CB:0297
		return 0;
	//^32CB:029C
	CellTileDetail *bp0a = tblCellTilesRoom;
	//^32CB:02A9
	tblCellTilesRoom = reinterpret_cast<CellTileDetail *>(ALLOC_MEMORY_RAM(72, afDefault, 1024));
	//^32CB:02C1
	i16 bp04 = _4976_5a9c;
	i16 bp06 = _4976_5a9e;
	//^32CB:02CD
	CALC_VECTOR_W_DIR(_4976_5aa0, _4976_40e8[si][1], _4976_40e8[si][0], &bp04, &bp06);
	//^32CB:02F7
	tblCellTilesRoom[si].posx = U8(bp04);
	//^32CB:030A
	tblCellTilesRoom[si].posy = U8(bp06);
	//^32CB:031E
	SUMMARIZE_STONE_ROOM(&tblCellTilesRoom[si].xsrd, _4976_5aa0, bp04, bp06);
	//^32CB:0344
	i16 bp02 = DRAW_WALL_ORNATE(si, glbTabXAxisDistance[RCJ(23,si)], 0);
	//^32CB:0358
	if (bp02 >= 0) {
		//^32CB:035C
		di = _32cb_00f1(yy, zz, bp02);
	}
	//^32CB:036E
	DEALLOC_UPPER_MEMORY(72);
	//^32CB:0379
	tblCellTilesRoom = bp0a;
	//^32CB:0386
	return (si == 3 || glbTempPicture.width < 32 || glbTempPicture.height < 32) ? 1 : di;
}

//^121E:0003
// SPX: _121e_0003 renamed CLICK_WALL
void SkWinCore::CLICK_WALL(U16 iClickSide)
{
	//^121E:0003
	ENTER(2);
	//^121E:0009
	U16 iDirDelta = 1;	// bp02
	//^121E:000E
	i16 iPosX = glbPlayerPosX;	// di
	i16 iPosY = glbPlayerPosY;	// si
	//^121E:0016
	switch (iClickSide) {
		case 1: // click on left side
			//^121E:002A
			iPosX += glbXAxisDelta[(glbPlayerDir +3) & 3];
			iPosY += glbYAxisDelta[(glbPlayerDir +3) & 3];
			//^121E:004C
			break;

		case 3:	// click in front of player
			//^121E:004E
			iPosX += glbXAxisDelta[glbPlayerDir];
			iPosY += glbYAxisDelta[glbPlayerDir];
			//^121E:0062
			iDirDelta = 2;
			//^121E:0067
			break;

		case 2: // click on right side
			//^121E:0069
			iPosX += glbXAxisDelta[(glbPlayerDir +1) & 3];
			iPosY += glbYAxisDelta[(glbPlayerDir +1) & 3];
			//^121E:0087
			iDirDelta = 3;

			break;
	}
	//^121E:008C
	if (iPosX >= 0 && iPosX < glbCurrentMapWidth && iPosY >= 0 && iPosY < glbCurrentMapHeight) {
		//^121E:00A0
		MOVE_RECORD_AT_WALL(iPosX, iPosY, (glbPlayerDir + iDirDelta) & 3, OBJECT_NULL, glbLeaderHandPossession.object);
	}
	//^121E:00BA
	return;
}

//^32CB:35C1
U16 SkWinCore::_32cb_35c1(i16 *xx, i16 *yy, i16 zz, i16 ww)
{
	//^32CB:35C1
	ENTER(2);
	//^32CB:35C7
	U16 cx = zz;
	i16 di = *xx;
	i16 si = *yy;
	//^32CB:35D6
	if (ww != 0) {
		//^32CB:35DC
		if ((si -= ww * 5) < 0) {
			//^32CB:35E8
			si += 20;
			//^32CB:35EB
			//^32CB:3607
			di = _4976_408c[RCJ(21,di)][2];
		}
		//^32CB:35F6
		else if (si > 24) {
			//^32CB:35FB
			si -= 20;
			//^32CB:35FE
			di = _4976_408c[RCJ(21,di)][3];
		}
		//^32CB:360A
		if (di < 0)
			//^32CB:360E
			return 0;
	}
	//^32CB:3612
	if (cx != 0) {
		//^32CB:3616
		i16 bp02 = (si % 5) + cx;
		//^32CB:3623
		if (bp02 > 4) {
			//^32CB:362A
			si += cx -4;
			//^32CB:3631
			di = _4976_408c[RCJ(21,di)][1];
		}
		//^32CB:363F
		else if (bp02 < 0) {
			//^32CB:3645
			si += cx +4;
			//^32CB:364C
			di = _4976_408c[RCJ(21,di)][0];
		}
		else {
			//^32CB:3657
			si += cx;
		}
		//^32CB:3659
		if (di < 0)
			//^32CB:365D
			//^32CB:360E
			return 0;
	}
	//^32CB:365F
	*xx = di;
	*yy = si;
	//^32CB:366B
	return 1;
}

//^098D:0C50
i16 SkWinCore::ROTATE_5x5_POS(i16 _5x5, U16 dir)
{
	//^098D:0C50
	ENTER(0);
	//^098D:0C55
	i16 di = (_5x5 % 5) -2;
	//^098D:0C63
	i16 si = (_5x5 / 5) -2;
	//^098D:0C6E
	i16 cx;
	switch (dir) {
		case 2:
			//^098D:0C82
			di = -di;
			//^098D:0C88
			//^098D:0C9E
			si = -si;

			break;

		case 3:
			//^098D:0C8C
			cx = di;
			//^098D:0C8E
			di = -si;
			//^098D:0C94
			si = cx;
			//^098D:0C96
			break;

		case 1:
			//^098D:0C98
			cx = di;
			//^098D:0C9A
			di = si;
			//^098D:0C9C
			//^098D:0C9E
			si = -cx;

	}
	//^098D:0CA2
	return di +((si +2) * 5) +2;
}

//^48AE:07FD
i16 SkWinCore::QUERY_OBJECT_5x5_POS(ObjectID rl, U16 reldir)
{
	//^48AE:07FD
	ENTER(4);
	//^48AE:0803
	ObjectID di = rl;
	//^48AE:0806
	U16 si = 12;
	//^48AE:0809
	switch (di.DBType()) {
		case dbCreature:
			{
				//^48AE:0821
				Creature *bp04 = GET_ADDRESS_OF_RECORD4(di);
				//^48AE:082E
				return QUERY_CREATURE_5x5_POS(bp04, (reldir -bp04->b15_0_1()) & 3);
			}
		case dbCloud:
			{
				//^48AE:0852
				if (GET_ADDRESS_OF_RECORDF(di)->b2_7_7() != 0)
					//^48AE:0869
					break;
				//^48AE:086B
				si = _4976_4a04[di.Dir()];

				break;
			}

		case dbWeapon:
		case dbCloth:
		case dbScroll:
		case dbPotion:
		case dbContainer:
		case dbMiscellaneous_item:
		case dbMissile:
			{
				//^48AE:086B
				si = _4976_4a04[di.Dir()];

				break;
			}

		case db11:
		case db12:
		case db13:

			break;
	}
	//^48AE:0878
	return ROTATE_5x5_POS(si, reldir);
}

//^098D:0CB7
i16 SkWinCore::QUERY_CREATURE_BLIT_RECTI(U16 cellPos, i16 _5x5, U16 dir)
{
	//^098D:0CB7
	ENTER(0);
	//^098D:0CBA
	return ROTATE_5x5_POS(_5x5, dir) +(cellPos * 25) +5000;
}

//^32CB:3672
// SPX: _32cb_3672 renamed DRAW_ITEM
void SkWinCore::DRAW_ITEM(ObjectID rl, i16 xx, U16 yy, U16 zz, i16 vv, Creature *ref, U16 ww, U16 ss, U16 tt)
{
	//^32CB:3672
	ENTER(34);
	//^32CB:3678
	U16 si = zz;
	//^32CB:367B
	i16 bp18 = 12; // defaulting to 12
	if (ref != NULL) {
		//^32CB:3686
		AIDefinition *bp04 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(ref->CreatureType());
		//^32CB:369A
		U16 bp22 = bp04->w30;
		//^32CB:36A4
		U16 di = ((bp22 & 15) > 1) ? 0 : 1;
		//^32CB:36B5
		i16 bp20 = QUERY_GDAT_CREATURE_WORD_VALUE(ref->CreatureType(), 0x41);
		//^32CB:36C9
		if (bp20 == 0) {
			//^32CB:36CF
			bp20 = _4976_4398[RCJ(2,di)];
		}
		//^32CB:36D7
		si -= bp20;
		//^32CB:36DA
		U16 bp1e = (rl.Dir() - _4976_5aa0) & 3;
		//^32CB:36EA
		bp18 = (xx == 3 && _4976_5aa2 != 0) ? _4976_41d0[RCJ(7,glbTargetTypeMoveObject)] : 12;
		//^32CB:370A
		if (_32cb_35c1(&xx, &bp18, _4976_4388[RCJ(4,di)][RCJ(4,bp1e)], _4976_4388[RCJ(4,2 +di)][RCJ(4,bp1e)]) == 0)
			//^32CB:373B
			return;
	}
	//^32CB:373E
	else if (tt == 0) {
		//^32CB:3744
		bp18 = QUERY_OBJECT_5x5_POS(rl, _4976_5aa0);
	}
	//^32CB:3755
	i16 bp12 = glbTabYAxisDistance[RCJ(23,xx)];
	//^32CB:3760
	U16 bp0a;
	U16 bp06;
	U16 bp1a;
	if (tt != 0) {
		//^32CB:3766
		bp0a = 0;
		//^32CB:376B
		bp1a = QUERY_GDAT_ENTRY_DATA_INDEX(_4976_5aa8.b8, _4976_5aa8.b9, dtImageOffset, 0xfd);
		//^32CB:3783
		yy = _4976_5aa8.w28 + i8(bp1a >> 8) + _4976_41de[RCJ(8,_4976_41b0[RCJ(16,vv)][0])];
		//^32CB:37A4
		si = _4976_41de[RCJ(8,_4976_41b0[RCJ(16,vv)][1])] + (i8(bp1a) + _4976_5aa8.w30);
		//^32CB:37C6
		bp06 = _4976_5aa8.rectNo;
	}
	else {
		//^32CB:37CB
		bp0a = 4 -(bp18 / 5);
		//^32CB:37DC
		if (xx == 0 && bp0a < 2)
			//^32CB:37E8
			return;
		//^32CB:37EB
		bp06 = QUERY_CREATURE_BLIT_RECTI(xx, bp18, 0) | 0x8000;
	}
	//^32CB:3801
	U16 bp1c = 0;
	//^32CB:3806
	U8 bp0d = QUERY_CLS1_FROM_RECORD(rl);
	//^32CB:3812
	U8 bp0e = QUERY_CLS2_FROM_RECORD(rl);
	//^32CB:381E
	if (bp0d == 0x14 && bp0e < 8) {
		//^32CB:382A
		if (ss == 0) {
			//^32CB:3830
			ss = ss +GET_ADDRESS_OF_RECORD9(rl)->IsOpened();
		}
		//^32CB:384C
		bp1c = 1;
	}
	//^32CB:3851
	U8 bp0f = _4976_4380[RCJ(4,ss)][0];
	//^32CB:385D
	U16 bp08 = 0;
	//^32CB:3862
	i16 bp14 = glbTabXAxisDistance[RCJ(23,xx)];
	//^32CB:386D
	if (bp14 == 0) {
		//^32CB:3871
		i16 bp16 = bp18 % 5;
		//^32CB:387D
		U16 bp10;
		if (true
			&& (bp16 == 2 || tt != 0)
			&& QUERY_GDAT_ENTRY_IF_LOADABLE(bp0d, bp0e, dtImage, U8(bp10 = _4976_4380[RCJ(4,ss)][1])) != 0
		) {
			//^32CB:38AD
			bp0f = U8(bp10);
		}
		//^32CB:38B5
		else if (bp1c != 0 && tt == 0 && bp16 > 2) {
			//^32CB:38C7
			bp08 = 1;
		}
	}
	//^32CB:38CE
	else if (bp1c != 0 && bp14 == 1) {
		//^32CB:38DA
		bp08 = 1;
	}
	//^32CB:38DF
	if (vv != -1) {
		//^32CB:38E5
		yy += _4976_41de[RCJ(8,_4976_41b0[RCJ(16,vv)][0])];
		//^32CB:38FA
		if (ref == NULL) {
			//^32CB:3902
			si += _4976_41de[RCJ(8,_4976_41b0[RCJ(16,vv)][1])];
		}
	}
	//^32CB:3916
	bp1a = QUERY_GDAT_ENTRY_DATA_INDEX(bp0d, 0xfe, dtImageOffset, bp0f);
	//^32CB:392E
	if (bp1a != 0) {
		//^32CB:3932
		yy += i8(bp1a >> 8);
		//^32CB:3939
		si += i8(bp1a);
	}
	//^32CB:393F
	U16 bp0c = _4976_418e[RCJ(6,bp12)][1 +bp0a];
	//^32CB:3951
	QUERY_TEMP_PICST(bp08, bp0c, bp0c, yy, si, bp12, bp06, 0, 10, -1, bp0d, bp0e, bp0f);
	//^32CB:397D
	if (ww == 0)
		//^32CB:3983
		glbTempPicture.colorKeyPassThrough = -2;
	//^32CB:3989
	DRAW_TEMP_PICST();
	//^32CB:398D
	return;
}

//^32CB:03A6
ObjectID SkWinCore::_32cb_03a6(U16 xx, U16 yy, U16 zz, U16 ww, U16 vv, ObjectID ss, U16 tt, U16 uu)
{
	//^32CB:03A6
	ENTER(28);
	//^32CB:03AC
	U16 bp12 = ss.Dir();
	//^32CB:03B5
	Creature *bp04;
	ObjectID si;
	if (tt == 2) {
		//^32CB:03BB
		bp04 = GET_ADDRESS_OF_RECORD4(GET_CREATURE_AT(ww, vv));
		//^32CB:03D5
		si = bp04->GetPossessionObject();
	}
	else {
		//^32CB:03DE
		bp04 = NULL;
		//^32CB:03E8
		si = GET_TILE_RECORD_LINK(ww, vv);
	}
	//^32CB:03F7
	if (si == OBJECT_END_MARKER) {
		//^32CB:03FC
		if (uu != 0)
			//^32CB:0402
			return ss;
		//^32CB:0408
		//^32CB:0634
		return OBJECT_NULL;
	}
	//^32CB:040B
	i16 di = (tt == 3) ? 2 : 0;
	//^32CB:0418
	ObjectID bp0e = OBJECT_NULL;
	//^32CB:041D
	Container *bp0c = NULL;
	U16 bp16;
	Container *bp08;

	do {
		//^32CB:0427
		U16 bp10 = si.DBType();
		//^32CB:0432
		if (bp10 < dbWeapon || bp10 > dbMiscellaneous_item)
			//^32CB:0441
			continue;
		//^32CB:0444
		if (si.Dir() != bp12)
			//^32CB:044E
			continue;
		//^32CB:0451
		U16 bp14 = 0;
		bp08 = NULL;
		//^32CB:0460
		if (true
			&& IS_CONTAINER_CHEST(si) != 0
			&& QUERY_GDAT_ENTRY_IF_LOADABLE(0x14, QUERY_CLS2_FROM_RECORD(si), dtImage, 0x48) != 0
		) {
			//^32CB:0485
			if ((bp08 = GET_ADDRESS_OF_RECORD9(si))->IsOpened() != 0) {
				//^32CB:04A0
				bp14 = 3;
			}
			//^32CB:04A7
			else if (uu == 0) {
				//^32CB:04AD
				bp14 = 2;
			}
		}
		do {
			//^32CB:04B2
			DRAW_ITEM(si, zz, 0, 0, di, bp04, 0, bp14, (tt == 3) ? 1 : 0);
			//^32CB:04DC
			if (_32cb_00f1(xx, yy, 10) == 1) {
				//^32CB:04F0
				bp0c = bp08;
				//^32CB:04FC
				bp0e = si;
				bp16 = bp14;
				//^32CB:0505
				break;
			}
			//^32CB:0507
			if (bp14 == 0)
				//^32CB:050B
				break;
			//^32CB:050D
			bp14 = 0;
			//^32CB:0512
		} while (true);

		//^32CB:0514
		di++;
		//^32CB:0515
		if (tt == 3) {
			//^32CB:051B
			if (di >= 14)
				//^32CB:0520
				di = 2;
		}
		else {
			//^32CB:0525
			di &= 15;
		}
		//^32CB:0529
	} while ((si = GET_NEXT_RECORD_LINK(si)) != OBJECT_END_MARKER);

	//^32CB:053A
	bp08 = bp0c;
	//^32CB:0546
	if (bp08 == NULL)
		//^32CB:054A
		goto _0639;
	//^32CB:054D
	switch (bp16) {
		case 0:
			//^32CB:0561
			if (uu != 0)
				//^32CB:0567
				//^32CB:05FF
				return OBJECT_END_MARKER;
			//^32CB:056A
			if (bp08->IsOpened() == 0)
				//^32CB:0578
				goto _0642;
			//^32CB:057B
			bp08->IsOpened(0);
			//^32CB:0583
			break;

		case 2:
			//^32CB:0586
			bp08->IsOpened(1);
			//^32CB:058E
			break;

		case 3:
			{
			//^32CB:0591
			if (uu != 0 && (QUERY_GDAT_DBSPEC_WORD_VALUE(ss, 4) & 0x8000) != 0)
				//^32CB:05A8
				//^32CB:05FF
				return OBJECT_END_MARKER;
			//^32CB:05AA
			ObjectID bp1c;
			ObjectID bp1a;
			bp1c = bp1a = bp08->GetContainedObject();
			//^32CB:05B7
			i16 bp18;
			for (bp18 = 0; bp1c != OBJECT_END_MARKER; ) {
				//^32CB:05BE
				bp18++;
				bp1a = bp1c;
				bp1c = GET_NEXT_RECORD_LINK(bp1c);
			}
			//^32CB:05D9
			if (uu != 0) {
				//^32CB:05DF
				if (bp18 < 8) {
					//^32CB:05E5
					APPEND_RECORD_TO(ss, &bp08->w2, -1, 0);
					//^32CB:05FD
					break;
				}
				//^32CB:05FF
				return OBJECT_END_MARKER;
			}
			//^32CB:0604
			if (bp18 <= 0)
				//^32CB:0608
				break;
			//^32CB:060A
			CUT_RECORD_FROM(bp1a, &bp08->w2, -1, 0);
			//^32CB:0622
			_4976_57f2 = 1;
			//^32CB:0628
			TAKE_OBJECT(bp1a, 1);

			break;
			}

	}
	//^32CB:0634
	return OBJECT_NULL;

	//^32CB:0639
_0639:
	if (bp0e == OBJECT_NULL)
		//^32CB:063F
		//^32CB:0402
		return ss;
	//^32CB:0642
_0642:
	return bp0e;
}

//^121E:013A
void SkWinCore::_121e_013a(U16 xx, U16 yy, U16 zz)
{
	//^121E:013A
	ENTER(4);
	//^121E:0140
	if (glbChampionLeader == -1)
		//^121E:0147
		return;
	//^121E:014A
	U16 di = glbPlayerPosX;
	U16 si = glbPlayerPosY;
	//^121E:0152
	U16 bp04 = _4976_4d1a[zz].b10;
	//^121E:0165
	if (bp04 != 0) {
		//^121E:0169
		if (bp04 != 3)
			//^121E:016E
			return;
		//^121E:0171
		di += glbXAxisDelta[glbPlayerDir];
		si += glbYAxisDelta[glbPlayerDir];
	}
	//^121E:0185
	ObjectID bp02 = _32cb_03a6(xx, yy, bp04, di, si, _4976_4d1a[zz].w8, _4976_4d1a[zz].b11, 0);
	//^121E:01BC
	if (bp02 != OBJECT_NULL) {
		//^121E:01C1
		if (_4976_4d1a[zz].b11 == 2) {
			//^121E:01D2
			MOVE_RECORD_TO(bp02, di, si, -1, -1);

			SkD((DLV_TWEET, "Tweet: You (x:%d, y:%d, map:%d) have taken %s from %s (a#%03d, x:%d, y:%d) \n"
				, glbPlayerPosX, glbPlayerPosY, glbCurrentMapIndex
				, static_cast<LPCSTR>(getRecordNameOf(bp02))
				, static_cast<LPCSTR>(getRecordNameOf(GET_CREATURE_AT(di, si)))
				, GET_CREATURE_AT(di, si).DBIndex()
				, di
				, si
				));
		}
		else {
			//^121E:01D6
			MOVE_RECORD_TO(bp02, di, si, -1, 0);

			SkD((DLV_TWEET, "Tweet: You (x:%d, y:%d, map:%d) have taken %s! \n"
				, glbPlayerPosX, glbPlayerPosY, glbCurrentMapIndex
				, static_cast<LPCSTR>(getRecordNameOf(bp02))
				));
		}
		//^121E:01E7
		_4976_57f2 = 1;
		//^121E:01ED
		if (IS_CONTAINER_MONEYBOX(bp02) != 0) {
			//^121E:01FA
			GET_ADDRESS_OF_RECORD9(bp02)->b7_2_2(0);
		}
		//^121E:020C
		TAKE_OBJECT(bp02, 1);
	}
	//^121E:0218
	_4976_4e5c = 1;
	//^121E:021E
	return;
}

//^121E:03AE
U16 SkWinCore::_121e_03ae(U16 aa, U16 bb, U16 xx, U16 yy, U16 cc, U16 dd, U16 ee)
{
	//^121E:03AE
	ENTER(0);
	//^121E:03B3
	U16 di = dd;
	//^121E:03B6
	ObjectID si = _32cb_03a6(aa, bb, cc, xx, yy, ObjectID(glbLeaderHandPossession.object, (glbPlayerDir +di) & 3), ee, 1);
	//^121E:03EA
	if (si == OBJECT_NULL) {
		//^121E:03EF
		REMOVE_OBJECT_FROM_HAND();
		//^121E:03F4
		return 1;
	}
	//^121E:03F9
	if (si == OBJECT_END_MARKER) {
		//^121E:03FE
		if (ee == 2) {
			//^121E:0404
			return _121e_0222(xx, yy, di +4);
		}
		else {
			//^121E:040C
			return _121e_0222(xx, yy, di);
		}
	}
	//^121E:041C
	return 0;
}

//^098D:02A2
U16 SkWinCore::_098d_02a2(U16 rectno, i16 xx, i16 yy)
{
	//^098D:02A2
	ENTER(8);
	//^098D:02A6
	SRECT bp08;
	if (QUERY_EXPANDED_RECT(rectno, &bp08) == NULL)
		//^098D:02BA
		return 0;
	//^098D:02BE
	return PT_IN_RECT(&bp08, xx, yy);
}

//^121E:00BE
// SPX: _121e_00be renamed PLAYER_TESTING_WALL
void SkWinCore::PLAYER_TESTING_WALL(U16 ww, U16 xx, U16 yy)
{
	//^121E:00BE
	ENTER(0);
	//^121E:00C1
	if (glbChampionsCount == 0)
		//^121E:00C6
		return;
	//^121E:00C8
	if (ww != 0) {
		//^121E:00CE
		if (_4976_4c3e != 0)
			//^121E:00D3
			return;
		//^121E:00D5
		FIRE_MOUSE_SET_CAPTURE();
		//^121E:00DA
		_4976_4c3e = 1;
		//^121E:00E0
		_443c_08ab(&_4976_5da0, &_4976_5da2, &_4976_5dae.rc4.cy);
		//^121E:00F4
		if ((_4976_5dae.rc4.cy & 2) == 0) {
			//^121E:00FC
			FIRE_MOUSE_RELEASE_CAPTURE();
			//^121E:0101
			_4976_4c3e = 0;
			//^121E:0107
		}
		else {
			//^121E:0109
			FIRE_HIDE_MOUSE_CURSOR();
		}
	}
	else {
		//^121E:0110
		// SPX: Probably sound when testing a wall
		QUEUE_NOISE_GEN2(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, SOUND_STD_DEFAULT, 0xfe, xx, yy, 0, 140, 200);
	}
	//^121E:0132
	_4976_4e5c = 1;
	//^121E:0138
	return;
}

//^0CEE:2E35
i16 SkWinCore::_0cee_2e35(U8 cls2)
{
	//^0CEE:2E35
	ENTER(0);
	//^0CEE:2E39
	U16 si = QUERY_GDAT_CREATURE_WORD_VALUE(cls2, 0x04);
	//^0CEE:2E47
	if (si == 0)
		//^0CEE:2E4B
		return 4;
	//^0CEE:2E4E
	return si;
}

//^32CB:28C7
void SkWinCore::QUERY_CREATURE_PICST(U16 xx, i16 dist, Creature *vv, CreatureInfoData *ww, ObjectID rl)
{
	//^32CB:28C7
	ENTER(28);
	//^32CB:28CD
	U16 di = 0;
	//^32CB:28CF
	sk1c9a02c3 *bp04 = _1c9a_02c3(vv, QUERY_CREATURE_AI_SPEC_FROM_TYPE(vv->CreatureType()));
	//^32CB:28F3
	i16 si = _4937_000f(bp04->w0, &bp04->w2);
	//^32CB:290C
	U16 bp06 = (ww == NULL) ? 0 : ww->b7;
	//^32CB:2924
	U16 bp0a = ((QUERY_CREATURE_AI_SPEC_FLAGS(rl) & 4) != 0) ? 2 : ((_4976_5aa0 - vv->b15_0_1()) & 3);
	//^32CB:2950
	U16 bp08 = _4976_5a98[si][bp0a +10];
	//^32CB:2969
	U8 bp0b = vv->CreatureType();
	//^32CB:2973
	U8 bp0c = _4976_5a98[si][bp0a +2];
	//^32CB:298A
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(0x0f, bp0b, dtImage, bp0c) == 0) {
		//^32CB:299F
		bp0c = (bp0a +2) & 3;
		//^32CB:29A9
		if ((bp0c & 1) != 0)
			//^32CB:29AF
			di = 1;
		//^32CB:29B2
		bp0c = _4976_5a98[si][bp0c +2];
		//^32CB:29CD
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(0x0f, bp0b, dtImage, bp0c) == 0) {
			//^32CB:29E2
			di = 0;
			//^32CB:29E4
			bp0c = _4976_5a98[si][4];
		}
	}
	//^32CB:29FA
	else if (false
		|| (bp08 & 1) != 0
		|| ((bp06 & 64) != 0 && (bp06 & 2) != 0 && (bp06 & 1) == 0)
	) {
		//^32CB:2A16
		di = 1;
	}
	//^32CB:2A19
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(0x0f, bp0b, dtImage, bp0c) == 0) {
		//^32CB:2A31
		bp0c = bp0a -6;
		//^32CB:2A39
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(0x0f, bp0b, dtImage, bp0c) == 0) {
			//^32CB:2A4E
			if (true
				&& bp0c == 0xfb
				&& QUERY_GDAT_ENTRY_IF_LOADABLE(0x0f, bp0b, dtImage, bp0c +2) != 0
			) {
				//^32CB:2A6E
				di = 1;
				//^32CB:2A71
				bp0c = bp0c +2;
			}
			else {
				//^32CB:2A7B
				di = 0;
				//^32CB:2A7D
				bp0c = 0xfc;
			}
		}
	}
	//^32CB:2A81
	i16 bp10 = tlbDistanceStretch[RCJ(5,dist)];
	//^32CB:2A8D
	i16 bp14 = (ww != NULL && ww->Command == ccmDestroy) ? ww->w14 : si;
	//^32CB:2AAB
	U16 bp12 = _4976_5a98[bp14][0];
	//^32CB:2AC1
	if (xx == 3 && _4976_5aa2 != 0) {
		//^32CB:2ACE
		bp12 = _4976_41d0[RCJ(7,glbTargetTypeMoveObject)];
		bp10 = _4976_41d7[RCJ(7,glbTargetTypeMoveObject)];
		bp0a = 0;
	}
	else {
		//^32CB:2AE9
		bp10 = CALC_STRETCHED_SIZE(_4976_5a98[si][bp0a +6], bp10);
	}
	//^32CB:2B0D
	U16 bp0e = QUERY_CREATURE_BLIT_RECTI(xx, bp12, bp0a) | 0x8000;
	//^32CB:2B24
	i16 bp18, bp16;
	bp18 = bp16 = i8(_4976_5a98[bp14][1]);
	//^32CB:2B3D
	if (bp16 != 0) {
		//^32CB:2B44
		i16 bp1c;
		i16 bp1a;
		switch (bp0a) {
		case 0:
			//^32CB:2B50
			bp1c = -7;
			//^32CB:2B55
			//^32CB:2B5C
			bp1a = 0;
			//^32CB:2B61
			break;

		case 2:
			//^32CB:2B57
			bp1c = 7;
			//^32CB:2B5C
			bp1a = 0;
			//^32CB:2B61
			break;

		case 1:
		case 3:
			//^32CB:2B63
			bp1a = -64;
			bp1c = 0;

			break;
		}
		//^32CB:2B6D
		bp1a = CALC_STRETCHED_SIZE(bp1a, bp16);
		//^32CB:2B7D
		bp18 = CALC_STRETCHED_SIZE(bp1c, bp18);
	}
	//^32CB:2B8D
	QUERY_TEMP_PICST(di, bp10, bp10, _4976_41de[RCJ(8,bp06 & 7)] +bp16, _4976_41de[RCJ(8,(bp06 >> 3) & 7)] +bp18, dist,
		bp0e, -1, _0cee_2e35(bp0b), -1, 0x0f, bp0b, bp0c);
	//^32CB:2BDA
	return;
}

//^32CB:01B6
U16 SkWinCore::_32cb_01b6(U16 xx, U16 yy, U16 ss, U16 tt, U16 *ww)
{
	//^32CB:01B6
	ENTER(8);
	//^32CB:01BC
	ObjectID si = GET_CREATURE_AT(ss, tt);
	//^32CB:01CB
	if (si == OBJECT_NULL)
		//^32CB:01D0
		return 0;
	//^32CB:01D5
	Creature *bp04 = GET_ADDRESS_OF_RECORD4(si);
	//^32CB:01E2
	CreatureInfoData *bp08;
	if (bp04->b5 == 255) {
		//^32CB:01EC
		bp08 = NULL;
	}
	else {
		//^32CB:01F8
		bp08 = &glbTabCreaturesInfo[bp04->b5];
	}
	//^32CB:0216
	QUERY_CREATURE_PICST(3, glbTabYAxisDistance[3], bp04, bp08, si);
	//^32CB:0232
	i16 di = glbTempPicture.colorKeyPassThrough;
	//^32CB:0236
	glbTempPicture.colorKeyPassThrough = -2;
	//^32CB:023C
	DRAW_TEMP_PICST();
	//^32CB:0241
	if (_32cb_00f1(xx, yy, di) == 0)
		//^32CB:0253
		//^32CB:01D0
		return 0;
	//^32CB:0256
	if (_4976_5a94 < -75) {
		//^32CB:025D
		*ww = 3;
	}
	//^32CB:0267
	else if (_4976_5a94 > 75) {
		//^32CB:026E
		*ww = 1;
	}
	else {
		//^32CB:0278
		*ww = 0;
	}
	//^32CB:0280
	return 1;
}

//^121E:0222
U16 SkWinCore::_121e_0222(U16 xx, U16 yy, U16 ww)
{
	//^121E:0222
	ENTER(12);
	//^121E:0228
	Creature *bp0c = NULL;
	//^121E:0232
	if (glbChampionLeader == -1)
		//^121E:0239
		return 0;
	//^121E:023E
	U16 bp06 = (glbPlayerDir +ww) & 3;
	//^121E:024A
	ObjectID di = GET_CREATURE_AT(xx, yy);
	//^121E:0259
	if (di != OBJECT_NULL) {
        //^121E:025E
		AIDefinition *bp04 = QUERY_CREATURE_AI_SPEC_FROM_RECORD(di);
		//^121E:026B
		bp0c = GET_ADDRESS_OF_RECORD4(di);
		//^121E:0278
		if (true
			&& bp04->IsStaticObject() != 0
			&& (false
				|| (ww >= 4 && ww <= 7 && (bp04->w30 & 0x0800) == 0)
				|| (ww < 4 && (bp04->w30 & 0x2000) == 0)
			)
		) {
			//^121E:02A7
			//^121E:0239
			return 0;
		}
	}
	const ObjectID rlCreature = di;
	//^121E:02A9
	di = REMOVE_OBJECT_FROM_HAND();
	//^121E:02B0
	if (ww >= 4 && ww <= 7) {
		//^121E:02BC
		U8 bp07 = (ww -4 + glbPlayerDir) & 3;
		//^121E:02CA
		if (bp0c != NULL) {
			//^121E:02D2
			for (ObjectID si = bp0c->GetPossessionObject(); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
				//^121E:02DB
				if (si.Dir() == bp07 && IS_CONTAINER_MONEYBOX(si) != 0) {
					//^121E:02F4
					GET_ADDRESS_OF_RECORD9(si)->b7_2_2(0);
				}
				//^121E:0304
			}
		}
		//^121E:0312
		MOVE_RECORD_TO(ObjectID(di, bp07), -1, -1, xx, yy);

		SkD((DLV_TWEET, "Tweet: You have put %s on %s (a#%03d, x:%d, y:%d) \n"
			, static_cast<LPCSTR>(getRecordNameOf(di))
			, static_cast<LPCSTR>(getRecordNameOf(rlCreature))
			, rlCreature.DBIndex()
			, xx
			, yy
			));
	}
	else{
		//^121E:0323
		MOVE_RECORD_TO(ObjectID(di, bp06), -1, 0, xx, yy);

		SkD((DLV_TWEET, "Tweet: You have put %s! \n"
			, static_cast<LPCSTR>(getRecordNameOf(di))
			));
	}
	//^121E:0344
	_4976_4e5c = 1;
	//^121E:034A
	return 1;
}

//^0CEE:2E09
U16 SkWinCore::_0cee_2e09(ObjectID rl)
{
	//^0CEE:2E09
	ENTER(0);
	//^0CEE:2E0C
	return QUERY_CREATURE_AI_SPEC_FROM_RECORD(rl)->w32;
}

//^2C1D:1FB1
U16 SkWinCore::_2c1d_1fb1(U16 dir)
{
	//^2C1D:1FB1
	ENTER(0);
	//^2C1D:1FB4
	if (glbChampionLeader == -1)
		//^2C1D:1FBB
		return 0;
	//^2C1D:1FBF
	return _2c1d_1de2(glbChampionLeader, -1, dir);
}

//^121E:0351
U16 SkWinCore::_121e_0351(U16 xx, U16 yy)
{
	//^121E:0351
	ENTER(0);
	//^121E:0356
	U16 si = 0;
	//^121E:0358
	U16 di = (_4976_4dda == 17) ? 768 : 765;
	//^121E:0367
	if (_098d_02a2(di, xx, yy) != 0) {
		//^121E:037A
		si = _2c1d_1fb1(0); // throw by left hand
	}
	//^121E:037E
	else if (_098d_02a2(di +1, xx, yy) != 0) {
		//^121E:0394
		si = _2c1d_1fb1(1); // throw by right hand
	}
	//^121E:039E
	if (si != 0)
		//^121E:03A2
		_4976_4e5c = 1;
	//^121E:03A8
	return si;
}

//^121E:0422
void SkWinCore::CLICK_VWPT(i16 xx, i16 yy)
{
	//^121E:0422
	ENTER(38);
	//^121E:0428
	U16 di = yy;
	//^121E:042B
	if (_4976_4ddc != 0) {
		//^121E:0432
		_4976_4ddc = 0;
		//^121E:0438
		PUSH_PULL_RIGID_BODY(glbTargetTypeMoveObject);
		//^121E:0442
		_29ee_000f();
	}
	//^121E:044A
	xx -= _4976_00e8;
	//^121E:0450
	di -= _4976_00ea;
	//^121E:0454
	U16 bp0c = glbPlayerPosX;
	//^121E:045A
	U16 bp0e = glbPlayerPosY;
	//^121E:0460
	bp0c += glbXAxisDelta[glbPlayerDir];
	//^121E:046D
	bp0e += glbYAxisDelta[glbPlayerDir];
	//^121E:047A
	ObjectID bp0a = glbLeaderHandPossession.object;
	//^121E:0480
	Door *bp04;
	U16 si;
	for (si = 0; si < _4976_4dde; si++) {
		//^121E:0485
		if (PT_IN_RECT(&_4976_4d1a[si].rc0, xx, di) != 0) {
			//^121E:04A4
			switch (_4976_4d1a[si].b11 -1) {
				case 3:
					//^121E:04C5
					if (glbChampionLeader == -1)
						//^121E:04CC
						break;
					//^121E:04CF
					U16 bp16;
					U16 bp18;
					if (_4976_4d1a[si].b10 == 3) {
						//^121E:04DF
						bp16 = bp0c;
						bp18 = bp0e;
					}
					else {
						//^121E:04EA
						bp16 = glbPlayerPosX;
						bp18 = glbPlayerPosY;
					}
					//^121E:04F3
					//^121E:04F6
					bp04 = GET_ADDRESS_OF_TILE_RECORD(U8(bp16), U8(bp18))->castToDoor();
					//^121E:0509
					if (bp04->Button() != 0) {
						//^121E:051D
						if (bp0a == OBJECT_NULL) {
							//^121E:0526
							// SPX: This plays the TICK sound when activating a door button
							QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0x00, SOUND_STD_ACTIVATION, 0x8c, 0x80, glbPlayerPosX, glbPlayerPosY, 1);
							//^121E:0545
							Timer bp22;
							INVOKE_MESSAGE(bp16, bp18, 0, 2, glbGameTick +1);
							//^121E:0566
							bp22.SetMap(glbCurrentMapIndex);
							bp22.SetTick(glbGameTick +1);
							//^121E:0589
							bp22.TimerType(ttyDoorButton);
							bp22.actor = 0;
							//^121E:0591
							bp22.id6(GET_TILE_RECORD_LINK(bp16, bp18));
							//^121E:05A1
							QUEUE_TIMER(&bp22);
							//^121E:05AD
							bp04->w2_b_b(1);
							//^121E:05B5
							_4976_4e5c = 1;
						}
						//^121E:05BB
						continue;
					}
					else {
						//^121E:05BE
						bp16 += glbXAxisDelta[(glbPlayerDir +1) & 3];
						//^121E:05D0
						bp18 += glbYAxisDelta[(glbPlayerDir +1) & 3];
						//^121E:05E2
						MOVE_RECORD_AT_WALL(bp16, bp18, (glbPlayerDir + 3) & 3, -1, glbLeaderHandPossession.object);
						//^121E:0600
						continue;
					}

				case 5:
					//^121E:0603
					U16 bp24;
					if (_32cb_0287_DRAW_W_ORNATE(bp24 = _4976_4d1a[si].b10, xx, di) == 0)
						//^121E:0626
						continue;
					//^121E:0629
					CLICK_WALL(bp24);
					//^121E:0631
					return;

				case 0:
				case 1:
				case 2:
					//^121E:0634
					if (bp0a == OBJECT_NULL) {
						//^121E:063A
						if (_4976_4d1a[si].w8 == 0xffff)
							//^121E:0648
							continue;
						//^121E:064A
						_121e_013a(xx, di, si);
						//^121E:0653
						//^121E:07B7
						//^121E:07BA
						return;
					}
					//^121E:0656
					if (_4976_4d1a[si].b11 == 3) {
						//^121E:0666
						if (_121e_03ae(xx, di, bp0c, bp0e, 0, 2, 3) == 0)
							//^121E:067F
							continue;
						//^121E:0681
						return;
					}
					//^121E:0684
					if (_4976_4d1a[si].b11 == 1)
						//^121E:0692
						continue;
					//^121E:0694
					U16 bp26;
					for (bp26 = 0; bp26 <= 1; bp26++) {
						//^121E:069B
						if (_121e_03ae(xx, di, glbPlayerPosX, glbPlayerPosY, 0, bp26, 1) != 0)
							//^121E:06B9
							return;
					}

					break;

				case 4:
					break;
			}
		}
		//^121E:06C5
	}
	//^121E:06CF
	si = GET_TILE_VALUE(bp0c, bp0e);
	//^121E:06E0
	U16 bp12 = ((si >> 5) == ttTrickWall && ((si >> 5) & 1) != 0 && ((si >> 5) & 4) == 0) ? 1 : 0;
	//^121E:06FF
	U16 bp14;
	if (bp0a == OBJECT_NULL) {
		//^121E:0708
		if (_4976_4dda == 0 && (_098d_02a2(765, xx, di) == 0 || _098d_02a2(766, xx, di) != 0)) {
			//^121E:0735
			PLAYER_TESTING_WALL(bp12, bp0c, bp0e);
			//^121E:0742
			//^121E:07B7
			//^121E:07BA
			return;
		}
		//^121E:0744
		ObjectID bp10 = GET_CREATURE_AT(bp0c, bp0e);
		//^121E:0754
		if (bp10 == OBJECT_NULL)
			//^121E:0759
			return;
		//^121E:075C
		AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_RECORD(bp10);
		//^121E:076E
		if (bp08->IsStaticObject() == 0)
			//^121E:0775
			return;
		//^121E:0778
		if (_32cb_01b6(xx, di, bp0c, bp0e, &bp14) == 0)
			//^121E:0793
			return;
		//^121E:0796
		if (GET_CREATURE_WEIGHT(bp10) != 255) {
			//^121E:07A4
			if (bp14 != 0) {
				//^121E:07AA
				ROTATE_CREATURE(bp10, 0, bp14);
				//^121E:07BA
				return;
			}
			//^121E:07BD
			_4976_4ddc = 1;
			//^121E:07C3
			_4976_4dbe = _4976_4dc0 = xx;
			//^121E:07CD
			_29ee_000f();
			//^121E:07D2
			glbTargetTypeMoveObject = 6;
			//^121E:07D8
			return;
		}
		//^121E:07DB
		// SPX: A default sound like punch.
		QUEUE_NOISE_GEN2(GDAT_CATEGORY_CREATURES, QUERY_CLS2_FROM_RECORD(bp10), SOUND_STD_DEFAULT, 0xfe, bp0c, bp0e, 0, 0x8c, 0x80);
		//^121E:0803
		return;
	}
	//^121E:0806
	for (si = 0; si <= 1; si++) {
		//^121E:080A
		if (_121e_03ae(xx, di, glbPlayerPosX, glbPlayerPosY, 0, si, 1) != 0)
			//^121E:0826
			return;
		//^121E:0829
		if (_098d_02a2(si +760, xx, di) != 0 && _121e_0222(glbPlayerPosX, glbPlayerPosY, si) != 0)
			//^121E:0853
			return;
		//^121E:0856
	}
	//^121E:085C
	if (_4976_4dda == 0 && bp12 == 0)
		//^121E:0869
		return;
    //^121E:086C
	for (si = 2; si <= 3; si++) {
		//^121E:0871
		if (_121e_03ae(xx, di, bp0c, bp0e, 3, si, 1) != 0)
			//^121E:088B
			return;
		//^121E:088E
		if (_098d_02a2(si +760, xx, di) != 0 && _121e_0222(bp0c, bp0e, si) != 0)
			//^121E:08B6
			return;
		//^121E:08B9
	}
	//^121E:08BF
	ObjectID bp10 = GET_CREATURE_AT(bp0c, bp0e);
	//^121E:08CF
	if (bp10 != OBJECT_NULL) {
		//^121E:08D4
		AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_RECORD(bp10);
		//^121E:08E3
		if (bp08->IsStaticObject() != 0) {
			//^121E:08ED
			for (si = 0; bp08->w30 > si; si++) {
				//^121E:08F1
				if (_121e_03ae(xx, di, bp0c, bp0e, 3, si +2, 2) != 0)
					//^121E:090D
					return;
				//^121E:090F
				if (_098d_02a2(_0cee_2e09(bp10) +si, xx, di) != 0) {
					//^121E:092B
					if (_121e_0222(bp0c, bp0e, si +6) != 0)
						//^121E:0940
						return;
				}
				//^121E:0942
			}
		}
	}
	//^121E:0951
	_121e_0351(xx, di);
	//^121E:095D
	return;
}

//^1031:16FD
// SPX: _1031_16fd renamed CLICK_MAGICAL_MAP_AT
void SkWinCore::CLICK_MAGICAL_MAP_AT(Bit16u ww, i16 xx, i16 yy)
{
	//^1031:16FD
	ENTER(24);
	//^1031:1703
	i16 di = yy;
	//^1031:1709
	ObjectID bp0c = glbChampionTable[glbChampionIndex].Possess(glbSelectedHandAction);
	//^1031:171F
	Container *bp04 = GET_ADDRESS_OF_RECORD9(bp0c);
	//^1031:172E
	if (ww != UI_EVENTCODE_MAGIC_MAP || bp04->b5_5_7() != 1)
		//^1031:1736
		return;
	//^1031:174E
	SRECT bp18;
	QUERY_EXPANDED_RECT(99, &bp18);
	//^1031:175D
	xx -= bp18.x - _4976_53a0;
	di -= bp18.y - _4976_53a2;
	//^1031:1770
	if (false
		|| xx % (glbMagicMapWidth + glbMagicMapInterlineX) < glbMagicMapInterlineX
		|| di % (glbMagicMapHeight + glbMagicMapInterlineY) < glbMagicMapInterlineY
		|| GET_MISSILE_REF_OF_MINION(bp04->GetContainedObject(), bp0c) == NULL
	) {
		//^1031:17B2
		return;
	}
	//^1031:17B5
	xx = xx / (glbMagicMapWidth + glbMagicMapInterlineX);
	di = di / (glbMagicMapHeight + glbMagicMapInterlineY);
	//^1031:17D5
	i16 bp0e = _4976_5364;
	//^1031:17DC
	i16 bp10 = _4976_5365;
	//^1031:17E3
	CALC_VECTOR_W_DIR(_4976_539f, 3 -di, xx -3, &bp0e, &bp10);
	//^1031:1807
	i16 si = LOCATE_OTHER_LEVEL(_4976_539e, 0, &bp0e, &bp10, NULL);
	//^1031:1826
	if (si < 0)
		//^1031:182A
		return;
	//^1031:182D
	i16 bp0a = glbCurrentMapIndex;
	//^1031:1833
	CHANGE_CURRENT_MAP_TO(si);
	//^1031:183A
	U16 bp06 = GET_TILE_VALUE(bp0e, bp10);
	//^1031:184C
	U16 bp08 = bp06 >> 5;
	//^1031:1854
	if (true
		&& bp08 != ttWall
		&& bp08 != ttMapExit
		&& (bp08 != ttTrickWall || (bp06 & 5) != 0)
	) {
		//^1031:1876
		if (true
			&& bp0e == _4976_536a
			&& bp10 == _4976_536c
			&& si == _4976_5318
		) {
			//^1031:188E
			if (_4976_5326 == 1 && _4976_533c >= 0) {
				//^1031:189C
				bp0e = _4976_5328;
				bp10 = _4976_532a;
				//^1031:18A8
				si = _4976_533c;
			}
			//^1031:18AE
			else if (_4976_533e >= 0 && (_4976_5326 == 1 || _4976_5326 == 3)) {
				//^1031:18C3
				bp0e = _4976_5320;
				bp10 = _4976_5322;
				//^1031:18CC
				si = _4976_533e;
			}
		}
		//^1031:18D3
		SET_DESTINATION_OF_MINION_MAP(bp0c, bp0e, bp10, si);
		//^1031:18E5
		_1c9a_0247(bp04->GetContainedObject());
		//^1031:18F2
		UPDATE_RIGHT_PANEL(0);
	}
	//^1031:18FA
	CHANGE_CURRENT_MAP_TO(bp0a);
	//^1031:1903
	return;
}

//^2759:13F5
// SPX: _2759_13f5 renamed CLICK_MAGICAL_MAP_RUNE
void SkWinCore::CLICK_MAGICAL_MAP_RUNE(Bit16u rune)
{
	//^2759:13F5
	ENTER(4);
	//^2759:13FB
	U16 si = _4976_3e1e[RCJ(4,rune)];
	//^2759:1409
	U16 di = 1 << rune;
	//^2759:1410
	Champion *champion;
	if ((glbMagicalMapFlags & di) != 0) {
		//^2759:1416
		si = -si;
		//^2759:141C
		goto _1445;
	}
	//^2759:141E
	champion = &glbChampionTable[glbChampionIndex];
	//^2759:142F
	if (champion->curMP() >= si) {
		//^2759:1438
		champion->curMP(champion->curMP() -si);
		//^2759:143F
		champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x0800
		//^2759:1445
_1445:
		glbMagicalMapFlags ^= di;
		_4976_531a += si;
	}
	//^2759:144D
	return;
}

//^38C8:0060
void SkWinCore::_38c8_0060()
{
	//^38C8:0060
	ENTER(0);
	//^38C8:0064
	if (_4976_5bec != 0 && glbGameHasEnded == 0) {
		//^38C8:0072
		if (glbIsPlayerSleeping != 0) {
			//^38C8:0079
			DRAW_WAKE_UP_TEXT();
			//^38C8:007E
			CHANGE_VIEWPORT_TO_INVENTORY(0);
		}
		else {
			//^38C8:0088
			_4976_5bec = 0;
			//^38C8:008E
			if (glbChampionIndex == 0)
				//^38C8:0095
				_4976_531c = 1;
			else
				//^38C8:009D
				glbSomeChampionPanelFlag = 1;
			//^38C8:00A3
			U16 si = glbChampionInventory;
			//^38C8:00A8
			if (si != 0) {
				//^38C8:00AC
				glbChampionInventory = 0;
				//^38C8:00B2
				INTERFACE_CHAMPION(si -1);
				//^38C8:00B9
			}
			else {
				//^38C8:00BB
				INIT_BACKBUFF();
				//^38C8:00C0
				_29ee_000f();
			}
		}
	}
	//^38C8:00C5
	return;
}

//^1031:1907
// SPX: _1031_1907 renamed DRAW_WAKE_UP_TEXT
void SkWinCore::DRAW_WAKE_UP_TEXT()
{
	//^1031:1907
	ENTER(40);
	//^1031:190B
	// This fills the main viewport in black
	FILL_ENTIRE_PICT(_4976_4c16, glbPaletteT16[COLOR_BLACK]);
	U8 bp28[40];
	// SPX: drawing the "Wake up" string
	DRAW_VP_RC_STR(
		6, 
		glbPaletteT16[COLOR_CYAN], 
		QUERY_GDAT_TEXT(GDAT_CATEGORY_INTERFACE_GENERAL, 0x00, 0x11, bp28)
		);
	//^1031:194F
	return;
}

//^2C1D:14BA
// SPX: _2c1d_14ba renamed RESUME_FROM_WAKE
void SkWinCore::RESUME_FROM_WAKE() 
{
	//^2C1D:14BA
	ENTER(0);
	//^2C1D:14BD
	_4976_4e5c = 1; // SPX some move flag (viewport refresh?)
	glbIsPlayerSleeping = 0;
	//glbTickSpeed = 12;	// SPX holds tick balance?? 12 was an old value
	glbTickSpeed = stdTickBalance;
	INIT_BACKBUFF();
	_1031_0541(5);
	//^2C1D:14DC
	return;
}

//^476D:00B1
void SkWinCore::FILE_DELETE(const U8 *curf)
{
	fset.fileDelete(reinterpret_cast<const char *>(curf));
}
//^476D:012C
U16 SkWinCore::FILE_WRITE(i16 handle, U32 buffSize, const void *buff)
{
	return fset.fileWrite(handle, buffSize, buff);
}
//^476D:008F
i16 SkWinCore::FILE_CREATE(const U8 *newf)
{
	return fset.fileCreate(reinterpret_cast<const char *>(newf));
}

//^2066:036E
Bit16u SkWinCore::_2066_036e(void *buff, Bit16u buffSize)
{
	//^2066:036E
	Bit32u bp04 = buffSize;

	//^2066:037D
	if (bp04 != 0) {
		//^2066:0386
		return FILE_WRITE(glbDataFileHandle, bp04, buff);
	}
	return 1;
}

//^2066:03C0
U16 SkWinCore::SKSAVE_WRITE(void *buff, U16 buffSize)
{
	//^2066:03C0
	if (_2066_036e(buff, buffSize) == 0)
		return 0;
	//^2066:03DB
	return 1;
}
//^2066:000F
U8 SkWinCore::SUPPRESS_WRITER(const void *pvData, const void *pvMask, U16 cbData, U32 repeat)
{
	// [bp+06] -> data
	// [bp+0A] -> mask
	// [bp+0E] -> xx
	// [bp+10] -> yy

	const Bit8u *data = (const Bit8u *)pvData;
	const Bit8u *mask = (const Bit8u *)pvMask;

	s_testSKSave.Write(pvData, pvMask, cbData, repeat);

	//^2066:000F
	Bit32u bp0a = 0;
	Bit8u bp04 = _4976_5254; // queued nibble
	Bit8u bp05 = _4976_524e; // current bit position
	Bit32u bp0e = 0;
	//^2066:0034
	while (!(bp0e >= repeat)) {
		//^2066:0037
		Bit16u si = 0;
		//^2066:0039
		while (!(si >= cbData)) {
			//^2066:003C
			Bit8u data_nibble = *data; // [bp-03]
			data++;
			Bit8u mask_nibble = *mask; // [bp-02]
			mask++;
			//^2066:0054
			if (mask_nibble != 0) {
				//^2066:005D
				__int8 bp01 = 0x07;
				//^2066:0061
				while (bp01 >= 0) {
					//^2066:0063
					if (((1 << bp01) & mask_nibble) != 0) {
						//^2066:0074
						bp04 <<= 1;
						//^2066:0077
						if (((1 << bp01) & data_nibble) != 0) {
							bp04 |= 1;
						}
						//^2066:008C
						bp0a++;
						//^2066:0094
						bp05 = bp05 + 1;
						//^2066:009C
						if (bp05 == 8) {
							//^2066:00A0
							Bit8u bp0f = bp04;
							if (FILE_WRITE(glbDataFileHandle, 1, &bp0f) == 0)
								return 1;
							//^2066:00C4
							bp05 = bp04 = 0;
						}
					}
					//^2066:00CC
					bp01--;
					//^2066:00CF
				}
			}
			//^2066:00D5
			si++;
			//^2066:00D6
		}
		//^2066:00DE
		mask -= cbData;
		bp0e++;
		//^2066:00EC
	}
	//^2066:0104
	_4976_5254 = bp04;
	_4976_524e = bp05;
	_4976_5258 += bp0a;

	return 0;
}

//^2066:0123
Bit8u SkWinCore::WRITE_1BIT(Bit8u nibble)
{
	//^2066:0123
	Bit8u data = nibble;
	static const Bit8u mask = 0x01;

	return SUPPRESS_WRITER(&data, &mask, 1, 1);
}

//^2066:06E8
Bit8u SkWinCore::WRITE_RECORD_CHECKCODE(ObjectID recordLink, Bit8u writeDir, Bit8u writeFollowing)
{
	// writeDir=(write-direction-in-record-link)
	// yy=(write-subsequent-records)

	//^2066:06E8

	//^2066:0AE6
	while (recordLink != OBJECT_END_MARKER && recordLink != OBJECT_NULL) {
		//^2066:06F4
		Bit8u db = recordLink.DBType();
		if (db > dbActuator) {
			//^2066:0704
			if (WRITE_1BIT(1)) // write#more-record=true
				return 1;
			Bit8u data = db;
			Bit8u mask = 0x0F;
			if (SUPPRESS_WRITER(&data, &mask, 1, 1)) // write#dbtype
				return 1;
			//^2066:073A
			if (writeDir != 0 && db != dbCreature) {
				Bit8u data = recordLink.Dir();
				Bit8u mask = 0x03;
				if (SUPPRESS_WRITER(&data, &mask, 1, 1))
					return 1;
			}
		}
		//^2066:0770
		if (db == dbCloud && _4976_3b55 != 0) {
			Bit16u data = recordLink;
			Bit16u mask = 0x007F;
			if (SUPPRESS_WRITER(&data, &mask, 2, 1))
				return 1;
			break; //->2066:0AF3
		}

		//^2066:07A6
		const void *recordMask = tableMask[db];

		//^2066:07BA
		if (recordMask != NULL) {
			//^2066:07C1
			GenericRecord *record = GET_ADDRESS_OF_RECORD(recordLink);
			//^2066:07CE
			Bit16u _di = 0;
			//^2066:07D0
			switch (db) {
				case dbActuator:	// 3	(or 11-12-13 in extended mode)
					{
						Actuator *bp04 = record->castToActuator();

						//^2066:07E5
						switch (bp04->ActuatorType()) {
						case ACTUATOR_FLOOR_TYPE__CROSS_SCENE: // 0x27: 'Cross scene'
						case ACTUATOR_TYPE_X1B: // 0x1B: '-'
						case ACTUATOR_TYPE_COUNTER: // 0x1D: 'Activator, counter'
						case ACTUATOR_TYPE_ORNATE_STEP_ANIMATOR: // 0x41: 'Ornate step animator'
						case ACTUATOR_FLOOR_TYPE__INFINITE_ORNATE_ANIMATOR: // 0x2C: 'Continuous ornate animator'
						case ACTUATOR_FLOOR_TYPE__ORNATE_ANIMATOR: // 0x32: 'Activator, ornate animator'
						case ACTUATOR_FLOOR_TYPE__SHOP: // 0x30: 'Shop exhibition'
						case ACTUATOR_FLOOR_TYPE__FINITE_ACTIVATOR_RELAY: // 0x2D: 'Activator, finite activator relay'
							{
								//^2066:0825
								Bit16u data = bp04->ActuatorData();
								Bit16u mask = 0x01FF;
								if (SUPPRESS_WRITER(&data, &mask, 2, 1))
									return 1;
								break; //->2066:0926
							}
						default:
							{
								break; //->2066:0926
							}
						}
						break;
					}
				case dbCreature:	// 4
					{
						Creature *bp04 = record->castToCreature();

						//^2066:085B
						Bit8u data = bp04->CreatureType();
						Bit8u mask = 0x7F;
						if (SUPPRESS_WRITER(&data, &mask, 1, 1))
							return 1;
						//^2066:0887
						if (QUERY_CREATURE_AI_SPEC_FLAGS(recordLink) & 1) {
							//^2066:0893
							recordMask = _4976_3ac7;
						}
						//^2066:089B
						_4976_5246[recordLink.DBIndex()] = _4976_3952;
						_4976_3952++;
						break;
					}
				case dbWeapon:		// 5
				case dbCloth:		// 6
				case dbScroll:		// 7
				case dbPotion:		// 8
				case dbMiscellaneous_item: // 10
				case db11:
				case db12:
					{
						break; //->2066:0926
					}
				case dbContainer:	// 9
					{
						Container *bp04 = record->castToContainer();

						//^2066:08B4
						Bit8u data = bp04->ContainerType();
						Bit8u mask = 0x03;
						if (SUPPRESS_WRITER(&data, &mask, 1, 1))
							return 1;
						//^2066:08E5
						if (IS_CONTAINER_MAP(recordLink) != 0) {
							//^2066:08F0
							recordMask = _4976_3aef;
							_di = 1;
						}
						//^2066:08FB
						_4976_5240[recordLink.DBIndex()] = _4976_3950;
						_4976_3950++;
						break; //->2066:0926
					}
				case dbMissile:		// 14
					{
						//^2066:0914
						if (_4976_3b57 == 0)
							break;
						recordMask = _4976_3b0b;
						_di = 1;
						break;
					}
			}
			//^2066:0926  
			if (SUPPRESS_WRITER(record, recordMask, dbSize[db], 1))
				return 1;
			//^2066:094E
			switch (db) {
				case dbWeapon:		// 5
				case dbCloth:		// 6
				case dbScroll:		// 7
				case dbPotion:		// 8
				case dbMiscellaneous_item: // 10
				case db11:
				case db12:
				case db13:
					{
						break; //->2066:0AD7
					}
				case dbCreature:	// 4
					{
						Creature *bp04 = record->castToCreature();

						//^2066:0963
						_4976_3b57 = 0x0001;

						Bit8u res = WRITE_RECORD_CHECKCODE(
							bp04->GetPossessionObject(),
							recordMask != _4976_3ab7,
							1
							);
						if (res)
							return 1;

						//^2066:0996
						_4976_3b57 = 0x0000;
						break; //->2066:0AD7
					}
				case dbContainer:	// 9
					{
						Container *bp04 = record->castToContainer();

						//^2066:099F
						if (_di != 0) {
							//^2066:09A3
							ObjectID bp10 = bp04->GetContainedObject();
							//^2066:09AD
							Bit16u bp18 = (bp10 == OBJECT_NULL || bp10 == OBJECT_END_MARKER) ? 0 : 1;
							//^2066:09C3
							if (WRITE_1BIT((Bit8u)bp18))
								return 1;
							//^2066:09D2
							if (!(bp18 != 0))
								break;
							//^2066:09DB
							ADD_MINION_ASSOC(recordLink);
							break;
						}
						//^2066:09E4
						if (IS_CONTAINER_MONEYBOX(recordLink) != 0) {
							//^2066:09EF
							tableMask[dbMiscellaneous_item] = _4976_3afb;
						}
						//^2066:09F9
						if (WRITE_RECORD_CHECKCODE(bp04->GetContainedObject(), 0, 1))
							return 1;
						//^2066:0A12  
						if (IS_CONTAINER_MONEYBOX(recordLink) != 0) {
							//^2066:0A20
							tableMask[dbMiscellaneous_item] = _4976_3af7;
						}
						//^2066:0A2A  
						break; //->2066:0AD7
					}
				case dbMissile:		// 14
					{
						Missile*bp04 = record->castToMissile();

						//^2066:0A2D  
						if (_di != 0) {
							//^2066:0A31  
							ADD_MINION_ASSOC(recordLink);
							//^2066:0A37  
							break; //->2066:0AD7
						}
						//^2066:0A3A  
						_4976_3b55 = 0x0001;
						Bit8u res = WRITE_RECORD_CHECKCODE(
							bp04->GetMissileObject(),
							0,
							0
							);
						if (res != 0)
							return 1;
						//^2066:0A59
						_4976_3b55 = 0x0000;
						break; //->2066:0AD7
					}
				case dbCloud:		// 15
					{
						//^2066:0A62  
						Timer *bp0c = glbTimersTable;
						Bit16u bp14 = 0;
						//^2066:0AC3
						while (bp14 < glbTimersActiveCount) {
							//^2066:0A76
							if (bp0c->TimerType() == ttyCloud && bp0c->id8() == recordLink) {
								//^2066:0A86
								if (WRITE_1BIT(0x0001))
									return 1;
								//^2066:0A94
                                Bit16u mask = 0x03FF;
								Bit16u data = bp14;
								if (SUPPRESS_WRITER(&data, &mask, 2, 1))
									return 1;
								break; //->2066:0AD7
							}
							//^2066:0ABC
							bp0c++;
							bp14++;
						}
						//^2066:0ACC
						if (WRITE_1BIT(0x0000))
							return 1;
						break; //->2066:0AD7
					}
			}
		}
		//^2066:0AD7
		if (writeFollowing == 0)
			break;
		recordLink = GET_NEXT_RECORD_LINK(recordLink);

	}
	//^2066:0AF3
	if (writeFollowing == 0) {
		//^2066:0AF9
		if (recordLink != OBJECT_NULL)
			return 0;
	}
	//^2066:0AFE
	if (WRITE_1BIT(0))
		return 1;
	//^2066:0B09
	return 0;
}

//^2066:0B44
i16 SkWinCore::_2066_0b44()
{
	//^2066:0B44
	Timer *bp04 = glbTimersTable;
	Bit16u i = 0;
	//^2066:0B58
	while (i < glbTimersCount) {
		switch (bp04->TimerType()) {
			case tty3C:
			case tty3D:
				//^2066:0B6B
				if (WRITE_RECORD_CHECKCODE(bp04->id8(), 0, 0) != 0) {
					//^2066:0B81
					return 1;
				}
				break;
		}
		//^2066:0B86
		bp04++;
		i++;
	}
	//^2066:0B91
	return 0;
}

//^2066:0B96
U16 SkWinCore::STORE_EXTRA_DUNGEON_DATA()
{
	//^2066:0B96
	_4976_5258 = 0;
	if (_2066_0b44() != 0)
		return 0;
	Bit16u bp10 = glbCurrentMapIndex;
	Bit16u currentMap = 0;
	//^2066:0BBB
	while (currentMap < dunHeader->nMaps) {
		CHANGE_CURRENT_MAP_TO(currentMap);
		Bit8u *bp04 = *glbCurrentTileMap;
		Bit16u *bp08 = &dunGroundStacks[*_4976_4c52];
		Bit16u xpos = 0; // word [bp-0C]
        //^2066:0BF4
		while (!(xpos >= glbCurrentMapWidth)) {
			//^2066:0BF7
			Bit16u ypos = 0; // di
			//^2066:0BF9
			while (!(ypos >= glbCurrentMapHeight)) {
				Bit8u tileValue = *bp04; // [bp-0D]
				//^2066:0BFC
				bp04++;
				Bit16u skipSaveRecord = 0; // word [bp-18]
				Bit8u bp0e;
				TELE_inf bp16;
				switch (tileValue >> 5) {
					case ttWall:
					case ttFloor:
					case ttStairs:
					case ttMapExit:
						//^2066:0C22
						bp0e = 0x00;
						break;
					case ttPit:
						//^2066:0C28
						bp0e = 0x08;
						break;
					case ttDoor:
						//^2066:0C2E
						bp0e = 0x07;
						break;
					case ttTeleporter:
						//^2066:0C34
						if (GET_TELEPORTER_DETAIL(&bp16, (Bit8u)xpos, (Bit8u)ypos) != 0) {
							//^2066:0C49
							bp0e = 0x00;
							if (bp16.target_z() >= currentMap)
								break;
							//^2066:0C56
							skipSaveRecord = 0x01;
							break;
						}
						//^2066:0C5D
						bp0e = 0x08;
						break;
					case ttTrickWall:
						//^2066:0C63
						bp0e = 0x04;
						break;
				}
				//^2066:0C67
				if (!(bp0e == 0)) {
					//^2066:0C6D
					if (SUPPRESS_WRITER(&tileValue, &bp0e, 1, 1) != 0)
						return 0;
				}
				//^2066:0C88
				Bit16u tileRecord; // [bp-0A]
				if ((tileValue & 0x10) != 0) {
					//^2066:0C8E
					tileRecord = *bp08;
					bp08++;
				}
				else {
					//^2066:0C9D
					tileRecord = 0xFFFE;
				}
				//^2066:0CA2
				if (skipSaveRecord == 0) {
					if (WRITE_RECORD_CHECKCODE(tileRecord, 1, 1) != 0)
						return 0;
				}
				//^2066:0CBA
				ypos++;
				//^2066:0CBB
			}
			//^2066:0CC4
			xpos++;
			//^2066:0CC7
		}
		currentMap++;
		//^2066:0CD4
	}
	//^2066:0CE5
	CHANGE_CURRENT_MAP_TO(bp10);
	return 1;
}
//^2066:0583
U16 SkWinCore::WRITE_MINION_ASSOC()
{
	// minion assoc: CREATURE MINION 
	//               -> Missile 
	//                  -> Minion map 
	//                    -> CREATURE MINION 
	//                      -> Missile 
	//                         -> Minion map 
	//                            -> ...

	// it is completely circulatory effect. minion assoc stores/recovers its connection.

	//^2066:0583
	Bit16u iLocalCount = glbMinionsAssocCount; // bp0a
	ObjectID *pMinionObjectID = glbMinionsObjectIDTable;	// bp04
	//^2066:059C
	while (iLocalCount-- != 0) {
		//^2066:059E
		ObjectID rCurrentMinionID = *pMinionObjectID;	// di
		pMinionObjectID++;
		//^2066:05A8
		GenericRecord *pRecord = reinterpret_cast<GenericRecord *>(GET_ADDRESS_OF_RECORD(rCurrentMinionID)); // bp08
		//^2066:05B5
		Bit16u ref; // si
		switch (rCurrentMinionID.DBType()) {
			case dbContainer:	// 9
				//^2066:05C9
				//si = _4976_5246[reinterpret_cast<Container *>(pRecord)->w2 & 0x03FF];
				ref = _4976_5246[reinterpret_cast<Container *>(pRecord)->GetContainedObject() & 0x03FF]; // _4976_5246 is allocated by number of creatures ?!
				// SPX: just replaced direct access to w2 by function to access it
				break;
			case dbMissile:		// 14
				//si = _4976_5240[reinterpret_cast<Missile   *>(pRecord)->w2 & 0x03FF];
				ref = _4976_5240[reinterpret_cast<Missile   *>(pRecord)->GetMissileObject() & 0x03FF];
				// SPX: just replaced direct access to w2 by function to access it
				break;
			default:
				//^2066:05C7
				continue;
		}
		//^2066:05EB
		//Bit16u ref = si; // bp0c
		//^2066:05F3
		Bit16u wmask = 0x03FF; // bp0e object id mask
		DEBUG_HELP_WRITER("Minion", &ref, 2, 1);
		if (SUPPRESS_WRITER(&ref, &wmask, 2, 1) != 0)
			return 1;

		//^2066:0613
	}
	//^2066:0620
	return 0;
}
//^2066:0147
U16 SkWinCore::SUPPRESS_FLUSH()
{
	// TODO: VERIFY ME

	//^2066:0147
	Bit8u bp01 = _4976_524e;
	//^2066:0151
	if (bp01 == 0)
		return 0;
	Bit8u bp02 = 8 - bp01;
	Bit8u bp03 = _4976_5254;
	//^2066:0163
	while (bp02-- != 0) {
		//^2066:0165
		bp03 = (((bp03 & 0x80) == 0) ? 0 : 1) | (bp03 << 1);
		//^2066:017B
	}
	//^2066:0185
	Bit8u bp04 = bp03;
	//^2066:018B
	if (FILE_WRITE(glbDataFileHandle, 1, &bp04) == 0)
		return 1;
	//^2066:01A9
	_4976_524e = _4976_5254 = 0;
	_4976_5258 = bp01;
	//^2066:01BF
	return 0;
}

//^2066:046D
void SkWinCore::_2066_046d() { // TODO: Unr
	Unr();
}

//^2066:38D9
void SkWinCore::_2066_38d9()
{
	//^2066:38D9
	ENTER(2);
	//^2066:38DE
	for (i16 bp02 = 0; bp02 < 10; bp02++) {
		//^2066:38E6
		_4976_52e2 = bp02 +0x30;
		//^2066:38EE
		i16 si = OPEN_FILE(FORMAT_SKSTR(ptrSKSave_dat, NULL));
		//^2066:390D
		if (si >= 0) {
			//^2066:3911
			READ_FILE(si, 42, &_4976_5250[bp02]);
			//^2066:3931
			CLOSE_FILE(si);
			//^2066:3938
		}
		else {
			//^2066:393A
			_4976_3b5f[0] = _4976_52e2;
			//^2066:3940
			SK_STRCPY(_4976_5250[bp02].b2, _4976_3b5f);
			//^2066:3961
			_4976_5250[bp02].w38 = 0xBEEF;
			_4976_5250[bp02].w40 = 0xDEAD;
		}
		//^2066:397B
	}
	//^2066:3987
	return;
}

//^2066:3697
// SPX: _2066_3697 renamed __OPEN_DIALOG_PANEL
void SkWinCore::__OPEN_DIALOG_PANEL(U8 cls2, U16 yy)
{
	//^2066:3697
	ENTER(104);
	//^2066:369B
	_4976_5250 = reinterpret_cast<sksave_header_asc *>(ALLOC_MEMORY_RAM(420, afDefault, 1024));
	//^2066:36B4
	U8 bp6a[40];
	// SPX: Get dialog box button 1 text
	U8 *bp18 = QUERY_GDAT_TEXT(0x1a, cls2, 0x00, bp6a);
	//^2066:36CF
	U8 bp40[40];
	// SPX: get dialog box button 2 text
	U8 *bp14 = QUERY_GDAT_TEXT(0x1a, cls2, 0x01, bp40);
	//^2066:36EA
	U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x1a, cls2, 0x00);
	//^2066:3700
	U8 *bp08;
	if (_4976_5d76 != 0) {
		//^2066:3707
		bp08 = QUERY_GDAT_IMAGE_LOCALPAL(0x1a, cls2, 0x00);
	}
	else {
		//^2066:371C
		bp08 = bp04 +CALC_IMAGE_BYTE_LENGTH(bp04);
	}
	//^2066:3737
	SRECT bp10;
	DRAW_DIALOGUE_PARTS_PICT(bp04, QUERY_EXPANDED_RECT(4, &bp10), -1, bp08);
	//^2066:375E
	FREE_PICT_ENTRY(bp04);
	//^2066:376B
	FIRE_FADE_SCREEN(1);
	//^2066:3773
	DRAW_VP_RC_STR(0x1c2, glbPaletteT16[COLOR_GRAY], _4976_3b6f);
	//^2066:378D
	DRAW_VP_RC_STR(0x1d2, glbPaletteT16[COLOR_ORANGE], bp18);
	//^2066:37A9
	DRAW_VP_RC_STR(0x1d3, glbPaletteT16[COLOR_ORANGE], bp14);
	//^2066:37C5
	_2066_38d9();
	//^2066:37CA
	_4976_4bd2 = yy;
	//^2066:37D0
	_1031_0675(4);
	//^2066:37D8
	_4976_523a = 0;
	//^2066:37DE
	while (glbMouseVisibility > 0) {
		//^2066:37E0
		FIRE_SHOW_MOUSE_CURSOR();
		//^2066:37E5
		_4976_523a++;
		//^2066:37E9
	}
	//^2066:37F0
	return;
}

//^2066:33C4
void SkWinCore::_2066_33c4(U8 *str, U16 yy) 
{
	//^2066:33C4
	ENTER(0);
	//^2066:33C7
	SK_STRCPY(str, _4976_3b68);
	str[5] = yy +0x30;
	//^2066:33E5
	return;
}

//^2066:398A
void SkWinCore::_2066_398a(i16 xx)
{
	//^2066:398A
	ENTER(10);
	//^2066:3990
	SRECT bp0a;
	QUERY_EXPANDED_RECT(451, &bp0a);
	//^2066:39A0
	i16 di = bp0a.y +4;
	//^2066:39A8
	for (i16 si = 0; si < 10; si++) {
		//^2066:39AC
		U16 bp02 = (si == xx) ? glbPaletteT16[COLOR_YELLOW] : glbPaletteT16[COLOR_ORANGE];
		//^2066:39C8
		DRAW_VP_STR(bp0a.x, di, bp02, _4976_5250[si].b2);
		//^2066:39EB
		di += glbPanelStatsYDelta;
		//^2066:39EF
	}
	//^2066:39F5
	return;
}
//^2066:3820
void SkWinCore::_2066_3820(U8 *xx, U16 yy)
{
	//^2066:3820
	ENTER(8);
	//^2066:3824
	SRECT bp08;
	QUERY_EXPANDED_RECT(0x1c5, &bp08);
	//^2066:3834
	DRAW_DIALOGUE_PICT(QUERY_GDAT_IMAGE_ENTRY_BUFF(0x1a, 0x81, 0x00), _4976_4c16, &bp08, 
		bp08.x, bp08.y, -1, QUERY_GDAT_IMAGE_LOCALPAL(0x1a, 0x81, 0x00));
	//^2066:3873
	DRAW_VP_STR(bp08.x, bp08.y +4, glbPaletteT16[COLOR_YELLOW], xx);
	//^2066:3896
	if (yy != 0) {
		//^2066:389C
		bp08.x += SK_STRLEN(xx) * _4976_0126;
		bp08.cx = _4976_0126;
		bp08.cy -= 4;
		//^2066:38BA
		FIRE_FILL_BACKBUFF_RECT(&bp08, glbPaletteT16[COLOR_ORANGE]);
	}
	//^2066:38D2
	_0aaf_002f();
	//^2066:38D7
	return;
}

//^3929:0B01
void SkWinCore::_3929_0b01(U16 xx, U16 yy) { // TODO: Unr
	Unr();
}

//^3929:0B20
void SkWinCore::_3929_0b20(U16 xx, U32 yy) { // TODO: Unr
	Unr();
}

//^3E74:5B7C
void SkWinCore::_3e74_5b7c(U16 xx)
{
	//^3E74:5B7C
	ENTER(20);
	//^3E74:5B80
	_476d_05b6(xx);
	//^3E74:5B89
	if (_4976_484d++ == _4976_484f[RCJ(4,_4976_484d)]) {
		//^3E74:5B9F
		if (_4976_484f[RCJ(4,_4976_484d)] != 0)
			//^3E74:5BAA
			return;
		//^3E74:5BAD
		const U8 *bp04 = _4976_4853;
		//^3E74:5BB5
		DISPLAY_HINT_TEXT(COLOR_WHITE, bp04);
		//^3E74:5BC5
		U8 bp14[16];
		DISPLAY_HINT_TEXT(COLOR_WHITE, SK_LTOA10(2, bp14));
		//^3E74:5BE2
		_3929_0b01(15, 46);
		//^3E74:5BED
		_3929_0b20(15, 8);
		//^3E74:5BFB
		_3929_0b20(15, _4976_5e9c);
		//^3E74:5C0D
		_3929_0b20(15, _4976_5ea6);
		//^3E74:5C1F
		_3929_0b20(15, _4976_5d66);
		//^3E74:5C31
		bp04 = _4976_485a;
		//^3E74:5C39
		SK_STRCPY(bp14, bp04);
		//^3E74:5C4C
		if (_4976_5bee[0] != 0)
			//^3E74:5C53
			bp14[0] = 0x47;
		//^3E74:5C57
		if (_4976_5bee[1] != 0)
			//^3E74:5C5E
			bp14[1] = 0x53;
		//^3E74:5C62
		if (_4976_5bee[2] != 0)
			//^3E74:5C69
			bp14[2] = 0x45;
		//^3E74:5C6D
		DISPLAY_HINT_TEXT(COLOR_WHITE, bp14);
	}
	//^3E74:5C7C
	_4976_484d = 0;
	//^3E74:5C82
	return;
}

//^1031:0D36
void SkWinCore::_1031_0d36(U16 xx, U16 yy)
{
	//^1031:0D36
	ENTER(0);
	//^1031:0D3A
	_3e74_5b7c(yy);
	//^1031:0D43
	_4976_19a7 = 1;
	//^1031:0D49
	if (_4976_4e00 < 7) {
		//^1031:0D50
		i16 si = _4976_19a5 +2;
		//^1031:0D57
		if (si > 10)
			//^1031:0D5C
			si -= 11;
		//^1031:0D5F
		if (si-- == 0)
			//^1031:0D66
			si = 10;
		//^1031:0D69
		_4976_19a5 = si;
		//^1031:0D6E
		_4976_4e02[_4976_19a5].MouseButton(xx);
		//^1031:0D7C
		_4976_4e02[_4976_19a5].MouseX(yy);
		//^1031:0D8D
		_4976_4e00++;
	}
	//^1031:0D91
	_4976_19a7 = 0;
	//^1031:0D97
	_1031_0b7e();
	//^1031:0D9B
	return;
}

//^01B0:054A
U8 SkWinCore::_01b0_054a(U16 xx) //#DS=04BF
{
	//^01B0:054A
	ENTER(0);
	//^01B0:054F
	U16 di = xx;
	//^01B0:0552
	LOADDS(0x3083);
	//^01B0:0558
	if ((di & 0x1000) != 0)
		//^01B0:055E
		di = 0;
	//^01B0:0560
	U16 si = ((di & 0x0200) != 0) ? (_04bf_033e[di & 0x007f]) : (_04bf_02be[di & 0x007f]);
    //^01B0:057E
	if (si != 0 && (di & 0x0400) != 0)
		//^01B0:0588
		si &= 0x001f;
	//^01B0:058E
	return U8(si);
}

//^476D:05B6
U8 SkWinCore::_476d_05b6(U16 xx)
{
	//^476D:05B6
	ENTER(0);
	//^476D:05B9
	return _01b0_054a(xx) CALL_IBMIO;
}

//^2066:37F2
void SkWinCore::_2066_37f2()
{
	//^2066:37F2
	ENTER(0);
	//^2066:37F5
	while (_4976_523a-- != 0)
		//^2066:37F7
		FIRE_HIDE_MOUSE_CURSOR();
	//^2066:3807
	_1031_06a5();
	//^2066:380C
	_4976_022c = 1;
	//^2066:3812
	DEALLOC_UPPER_MEMORY(420);
	//^2066:381E
	return;
}

//^2066:33E7
i16 SkWinCore::_2066_33e7()
{
	//^2066:33E7
	ENTER(22);
	//^2066:33ED
	__OPEN_DIALOG_PANEL(0x81, 6);
	//^2066:33F9
	i16 si;
	if (_4976_5bf6 != 0) {
		//^2066:3400
		si = _4976_525c;
		//^2066:3404
		COPY_MEMORY(&_4976_5250[si], &_4976_5266, 42);
	}
	else {
		//^2066:3428
		for (si = 0; si < 10; si++) {
			//^2066:342C
			if (true
				&& _4976_5250[si].w40 == 0xDEAD
				&& _4976_5250[si].w38 == 0xBEEF
			) {
				//^2066:3449
				_2066_33c4(_4976_5268, si);
				//^2066:3455
				break;
			}
			//^2066:3457
		}
	}
	//^2066:345D
	_2066_398a(si);
	//^2066:3464
	U8 *bp04 = _4976_5268;
	//^2066:346C
	if (si != 10) {
		//^2066:3471
		_2066_3820(bp04, 0);
	}
	else {
		//^2066:3483
		_0aaf_002f();
	}
	//^2066:3488
	U16 bp0c = 0;

	do {
		//^2066:348D
		while (_476d_05a9() != 0) {
			//^2066:348F
			_1031_0d36(32, _476d_050e());
			//^2066:349E
		}
		//^2066:34A7
		MAIN_LOOP();
		//^2066:34AC
		SRECT bp14;
		i16 bp06;
		i16 bp08;
		i16 bp0a;
		i16 di = SK_STRLEN(bp04); // defaulting to situational value.
		switch (_4976_4dfc) {
			case 1:
				//^2066:34C0
				si = -1;
				//^2066:34C3
				_4976_4c0a = 0;
				//^2066:34C9
				bp0c = 1;
				//^2066:34CE
				break;

			case 2:
				//^2066:34D1
				_4976_4c0a = 0;
				//^2066:34D7
				if (si == 10)
					//^2066:34DC
					break;
				//^2066:34DF
				if (*bp04 == 0) {
					//^2066:34E8
					_2066_33c4(bp04, si);
				}
				//^2066:34F6
				_2066_3820(bp04, 0);
				//^2066:3506
				bp0c = 1;
				//^2066:350B
				break;

			case 3:
				//^2066:350E
				_4976_4c0a = 0;
				//^2066:3514
				QUERY_EXPANDED_RECT(_4976_4df8, &bp14);
				//^2066:3525
				QUERY_TOPLEFT_OF_RECT(_4976_4e44, &bp06, &bp08);
				//^2066:353B
				bp0a = _4976_4e68;
				//^2066:3541
				bp0a -= bp14.y +bp08;
				//^2066:354A
				si = min_value(bp0a / glbPanelStatsYDelta, 10);
				//^2066:355E
				if (true
					&& _4976_5250[si].w40 == 0xDEAD
					&& _4976_5250[si].w38 == 0xBEEF
				) {
					//^2066:3579
					_2066_33c4(_4976_5268, si);
				}
				else {
					//^2066:3587
					SK_STRCPY(_4976_5268, _4976_5250[si].b2);
				}
				//^2066:35A7
				_2066_398a(si);
				//^2066:35AE
				_2066_3820(bp04, 0);
				//^2066:35BE
				break;

			case 4:
				//^2066:35C0
				if (si != 10 && _4976_4c0a == 0) {
					//^2066:35CC
					_4976_4c0a = 1;
					//^2066:35D2
					_2066_3820(bp04, 1);
					//^2066:35E2
					di = SK_STRLEN(bp04);
				}

				break;
		}
		//^2066:35F1
		//if (_4976_4c0a != 0 && glbUIEventCode >= 0xa5 && glbUIEventCode <= 0xd6) {
		if (_4976_4c0a != 0 && glbUIEventCode >= UI_EVENTCODE_0A5 && glbUIEventCode <= UI_EVENTCODE_0D6) {
			//^2066:3608
			if (_4976_4e9c == 14) {
				//^2066:360F
				if (di > 0) {
					//^2066:3613
					di--;
					//^2066:3614
					bp04[di] = 0;
				}
			}
			//^2066:361D
			else if (_4976_4e9c == 28) {
				//^2066:3624
				_4976_4c0a = 0;
			}
			//^2066:362C
			else if (di < 31) {
				//^2066:3631
				U8 bp15 = _476d_05b6(_4976_4e9c);
				//^2066:363E
				if (bp15 >= 0x61 && bp15 <= 0x7a) {
					//^2066:364A
					bp15 += 0xe0;
				}
				//^2066:364F
				bp04[di] = bp15;
				//^2066:3658
				bp04[++di] = 0;
			}
			//^2066:365D
			_2066_3820(bp04, _4976_4c0a);
		}
		//^2066:366F
		_4976_4dfc = 0;
		glbUIEventCode = 0;
		//^2066:367B
	} while (bp0c == 0);
	//^2066:3684
	_2066_37f2();
	//^2066:3689
	return si;
}

//^1C9A:3BAB
void SkWinCore::_1c9a_3bab()
{
	//^1C9A:3BAB
	ENTER(0);
	//^1C9A:3BAF
	for (U16 si = 0; _4976_1a68 > 0; si++) {
		//^1C9A:3BB3
		if (glbTabCreaturesInfo[si].CreatureIndex() >= 0) {
			//^1C9A:3BC6
			_1c9a_0fcb(si);
		}
	}
	//^1C9A:3BD4
	return;
}

//^1C9A:3B74
void SkWinCore::FILL_ORPHAN_CAII()
{
	//^1C9A:3B74
	ENTER(2);
	//^1C9A:3B7A
	U16 di = glbCurrentMapIndex;
	//^1C9A:3B7E
	U16 bp02 = dunHeader->nMaps;
	//^1C9A:3B8B
	for (i16 si = 0; si < bp02; si++) {
		//^1C9A:3B8F
		CHANGE_CURRENT_MAP_TO(si);
		//^1C9A:3B96
		FILL_CAII_CUR_MAP();
	}
	//^1C9A:3BA0
	CHANGE_CURRENT_MAP_TO(di);
	//^1C9A:3BA7
	return;
}

//^1C9A:3BD7
void SkWinCore::RESET_CAII()
{
	//^1C9A:3BD7
	ENTER(4);
	//^1C9A:3BDC
	_4976_1a68 = 0;
	//^1C9A:3BE2
	U16 si;
	for (si = 0; si < glbCreaturesCount; si++) {
		//^1C9A:3BE6
		glbTabCreaturesInfo[si].CreatureIndex(-1);
		//^1C9A:3BF8
	}
	//^1C9A:3BFF
	Creature *bp04 = reinterpret_cast<Creature *>(static_cast<U8 *>(glbDBObjectData[4]));
	//^1C9A:3C0C
	for (si = dunHeader->nRecords[dbCreature]; si-- != 0; bp04++) {
		//^1C9A:3C16
		bp04->b5 = 0xff;
	}
	//^1C9A:3C29
	FILL_ORPHAN_CAII();
	//^1C9A:3C2D
	return;
}

//^2E62:0CD8
// SPX: _2e62_0cd8 renamed SET_PARTY_HERO_FLAG
void SkWinCore::SET_PARTY_HERO_FLAG(U16 flagvalue)
{
	//^2E62:0CD8
	ENTER(0);
	//^2E62:0CDC
	for (U16 si = 0; si < glbChampionsCount; si++) {
		//^2E62:0CE0
		glbChampionSquad[si].heroFlag |= flagvalue;
	}
	//^2E62:0CF7
	return;
}

//^2F3F:0789
// SPX: _2f3f_0789 renamed INIT_CHAMPIONS
void SkWinCore::INIT_CHAMPIONS() // _2f3f_0789
{
	//^2F3F:0789
	ENTER(8);
	//^2F3F:078F
	if (glbSpecialScreen == 0) {
		//^2F3F:0799
		ObjectID di = glbLeaderHandPossession.object;
		//^2F3F:079E
		if (di == OBJECT_NULL) {
			//^2F3F:07A3
			_4976_57de = 0xff;
			//^2F3F:07A8
			_443c_0434();
		}
		else {
			i16 si = glbChampionLeader;
			//^2F3F:07B3
			glbChampionLeader = -1;
			//^2F3F:07B9
			TAKE_OBJECT(di, 1);
			//^2F3F:07C3
			glbChampionLeader = si;
		}
		//^2F3F:07C7
		Champion *champion = glbChampionSquad;	//*bp04
		//^2F3F:07CF
		U16 si;
		for (si = 0; si < glbChampionsCount; si++, champion++) {
			//^2F3F:07D36
			champion->heroFlag &= 1023;	// 0x3FF
			//^2F3F:07DC
			WRITE_UI8(_4976_3de2,+si,0xff);
			//^2F3F:07E1
			glbChampionAlive[si] = 0;
			//^2F3F:07EB
			_4976_3dde[RCJ(4,si)] = 0xff;
			//^2F3F:07F0
			glbChampionHandCoolingDown[si][1] = 0;
			//^2F3F:07FE
			_4976_3de6[RCJ(4,si)][1] = 0xffff;
			//^2F3F:0809
			glbChampionHandCoolingDown[si][0] = 0;
			//^2F3F:0817
			_4976_3de6[RCJ(4,si)][0] = 0xffff;
			//^2F3F:0822
			glbChampionHandCoolingDown[si][2] = 0;
			//^2F3F:0830
		}
		//^2F3F:083C
		SET_PARTY_HERO_FLAG(0x4000);
		//^2F3F:0845
		si = glbChampionLeader;
		//^2F3F:084A
		if (si == 0xffff)
			//^2F3F:084F
			return;
		//^2F3F:0852
		glbChampionLeader = -1;
		//^2F3F:0858
		SELECT_CHAMPION_LEADER(si);
		//^2F3F:085F
		return;
	}
	//^2F3F:0862
	glbLeaderHandPossession.object = OBJECT_NULL;
	_4976_57de = 0xff;
	//^2F3F:086D
	// SPX: DM2 will check a RESURECTOR at 0,0 (for THORAM), while DM/TQ expects one at 1,0 for THERON.

	// DM2 Original code
	ObjectID di = NULL;
	for (di = GET_TILE_RECORD_LINK(0, 0); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
		//^2F3F:087B
		if (di.DBType() == dbActuator) {
			//^2F3F:0888
			Actuator *bp08 = GET_ADDRESS_OF_ACTU(di);
			//^2F3F:0895
			if (bp08->ActuatorType() == ACTUATOR_TYPE_RESURECTOR) { // 0x007E
				//^2F3F:08A4
				_4976_404b = 1;
				//^2F3F:08AA
				// SPX: Automatic selection of champion (Thoram)
				SELECT_CHAMPION(0, 1, DIR_NORTH, glbPlayerMap);	// player is imaginarily at 0,1 facing north
				//^2F3F:08BB
				_2f3f_04ea_CHAMPION(0, 1, DIR_NORTH, glbPlayerMap, 160);
				//^2F3F:08CF
				_4976_404b = 0;
				//^2F3F:08D5
				glbChampionSquad[0].playerDir(U8(glbPlayerDir));
				//^2F3F:08DB
				glbChampionSquad[0].playerPos(U8(glbPlayerDir));
				//^2F3F:08E1
				SET_PARTY_HERO_FLAG(0x4000);
				//^2F3F:08EA
				SELECT_CHAMPION_LEADER(0);
				//^2F3F:08F2
				return;
			}
		}
		//^2F3F:08F4
	}
	//^2F3F:0905

	// SPX: Second loop to check for DM/TQ at 1,0
	for (di = GET_TILE_RECORD_LINK(1, 0); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
		if (di.DBType() == dbActuator) {
			Actuator *bp08 = GET_ADDRESS_OF_ACTU(di);
			if (bp08->ActuatorType() == ACTUATOR_TYPE_CHAMPION_MIRROR) { // 0x007F
				_4976_404b = 1;
				SELECT_CHAMPION(0, 0, DIR_EAST, glbPlayerMap);	// player is really at 0,0 facing east
				_2f3f_04ea_CHAMPION(0, 0, DIR_EAST, glbPlayerMap, 160);
				_4976_404b = 0;
				glbChampionSquad[0].playerDir(U8(glbPlayerDir));
				glbChampionSquad[0].playerPos(U8(glbPlayerDir));
				SET_PARTY_HERO_FLAG(0x4000);
				SELECT_CHAMPION_LEADER(0);
				return;
			}
		}
	}
	
	
	return;
}

//^0CD5:0039
void SkWinCore::FILL_U16(i16 *buff, X16 cnt, i16 val, i16 delta)
{
	//^0CD5:0039
	ENTER(0);
	//^0CD5:003E
	X16 si = 0;
	delta >>= 1;
	//^0CD5:0043
	for (U16 di = 0; di<cnt; di++) {
		//^0CD5:0047
		buff[si] = val;
		si += delta;
		//^0CD5:0059
	}
	//^0CD5:005F
	return;
}

//^19F0:045A
void SkWinCore::_19f0_045a(i16 xx, i16 yy)
{
	//^19F0:045A
	ENTER(0);
	//^19F0:045D
	if (xx == glbCreatureSomeX && yy == glbCreatureSomeY && glbCurrentMapIndex == glbCreatureSomeZMap)
		//^19F0:0476
		return;
	//^19F0:0478
	glbCreatureSomeZMap = glbCurrentMapIndex;
	_4976_521c = GET_TILE_VALUE(glbCreatureSomeX = xx, glbCreatureSomeY = yy);
	//^19F0:0498
	_4976_5222 = _4976_5220 = _4976_521e = ((_4976_521c & 0x10) != 0) ? OBJECT_NULL : OBJECT_END_MARKER;
	_4976_5224 = _4976_5225 = 0;
	_4976_522c = 0xff;
	//^19F0:04BD
	return;
}

//^19F0:0207
i16 SkWinCore::_19f0_0207(i16 xx, i16 yy, i16 ss, i16 tt, U16 (SkWinCore::*hazardTest)(i16 xx, i16 yy))
{
	// hazardTest returns 0 if tile(xx, yy) is safe, otherwise it returns 1 if tile is in hazard.

	// (xx, yy) is your location. (creature's position.)
	// (ss, tt) is your destination. (player's position.)

	//^19F0:0207
	ENTER(16);
	//^19F0:020D
	if (ABS16(xx -ss) + ABS16(yy -tt) <= 1)
		//^19F0:0230
		return 1;
	//^19F0:0236
	i16 di = (ss -xx);
	di = (di < 0) ? -di : di;
	//^19F0:024B
	i16 si = (tt -yy);
	si = (si < 0) ? -si : si;
	//^19F0:0260
	X16 bp08 = (di < si) ? 1 : 0;
	//^19F0:026E
	X16 bp0e = (di == si) ? 1 : 0;
	//^19F0:027C
	di = ss;
	i16 bp04 = (di -xx > 0) ? -1 : +1;
	//^19F0:0291
	si = tt;
	i16 bp06 = (si -yy > 0) ? -1 : +1;
	//^19F0:02A6
	i16 bp02;
	i16 bp10;
	if (bp08 != 0) {
		//^19F0:02AC
		bp02 = si -yy;
		bp10 = (bp02 != 0) ? ((di -xx) << 6) / bp02 : 128;
	}
	else {
		//^19F0:02CB
		bp02 = di -xx;
		bp10 = (bp02 != 0) ? ((si -yy) << 6) / bp02 : 128;
	}
	do {
		//^19F0:02EB
		i16 bp0a;
		i16 bp0c;
		if (bp0e != 0) {
			//^19F0:02F1
			if (true
				&& ((this->*hazardTest)(di +bp04, si) == 0 || (this->*hazardTest)(di, si +bp06) == 0)
				&& ((this->*hazardTest)(di += bp04, si += bp06) == 0)
			) {
				//^19F0:0326
				continue;
			}
			//^19F0:0329
			//^19F0:041A
			return 0;
		}
		//^19F0:032C
		if (bp08 != 0) {
			//^19F0:0332
			bp02 = si -yy;
			bp02 = ((bp02 != 0) ? ((di +bp04 -xx) << 6) / bp02 : 128) -bp10;
		}
		else {
			//^19F0:0354
			bp02 = di +bp04 -xx;
			bp02 = ((bp02 != 0) ? ((si -yy) << 6) / bp02 : 128) -bp10;
		}
		//^19F0:037A
		bp0a = (bp02 < 0) ? -bp02 : bp02;
		//^19F0:0388
		if (bp08 != 0) {
			//^19F0:038F
			bp02 = si +bp06 -yy;
			bp02 = ((bp02 != 0) ? ((di -xx) << 6) / bp02 : 128) -bp10;
		}
		else {
			//^19F0:03B1
			bp02 = di -xx;
			bp02 = ((bp02 != 0) ? ((si +bp06 -yy) << 6) / bp02 : 128) -bp10;
		}
		//^19F0:03D7
		bp0c = (bp02 < 0) ? -bp02 : bp02;
		//^19F0:03E5
		if (bp0a < bp0c)
			di += bp04;
		else
			si += bp06;
		//^19F0:03F2
		if (true
			&& (this->*hazardTest)(di, si) != 0
			&& (bp0a != bp0c || (this->*hazardTest)(di += bp04, si -= bp06) != 0)
		) {
			//^19F0:041A
			return 0;
		}
		//^19F0:041E
	} while (ABS16(di -xx) + ABS16(si -yy) > 1);

	//^19F0:0442
	return CALC_SQUARE_DISTANCE(xx, yy, ss, tt);
}

//^19F0:00B8
// SPX: this function serves as 'hazardtest'
U16 SkWinCore::_19f0_00b8(i16 xx, i16 yy)
{
	//^19F0:00B8
	ENTER(8);
	//^19F0:00BE
	U16 bp04 = GET_TILE_VALUE(xx, yy);
	U16 bp02 = bp04 >> 5;
	if (bp02 != ttWall) {
		//^19F0:00DF
		if (bp02 == ttDoor) {
			//^19F0:00E5
			U16 di = U8(bp04) & 7;
			if (di == 3 || di == 4) {
				//^19F0:00F8
				if (false
					|| GET_DOOR_STAT_0X10(GET_GRAPHICS_FOR_DOOR(GET_ADDRESS_OF_TILE_RECORD(U8(xx), U8(yy))->castToDoor())) == 0
					|| RAND01() == 0
				) {
					goto _01cf;
				}
			}
		}
		//^19F0:0128
		if (bp02 == ttTrickWall && (bp04 & 4) == 0)
			goto _01cf;
		//^19F0:0138
		if ((bp04 & 0x10) != 0) {
			//^19F0:0141
			for (ObjectID si = GET_WALL_TILE_ANYITEM_RECORD(xx, yy); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
				//^19F0:0150
				U16 bp06 = si.DBType();
				if (bp06 == dbCloud || GET_ADDRESS_OF_RECORDF(si)->CloudType() == 14)
					goto _01cf;
				//^19F0:0177
				if (bp06 == dbCreature) {
					ObjectID bp08 = _1c9a_03cf(&xx, &yy, 255);
					if (bp08 != OBJECT_NULL) {
						//^19F0:019A
						U16 di = QUERY_CREATURE_AI_SPEC_FLAGS(bp08);
						if ((di & 1) != 0) {
							//^19F0:01AA
							if (((di >> 6) & 3) >= 2)
								continue;
							goto _01cf;
						}
						//^19F0:01B7
						if ((di & 0x20) == 0)
							goto _01cf;
					}
				}
				//^19F0:01BD
			}
		}
        //^19F0:01CB
		return 0;
	}
	//^19F0:01CF
_01cf:
	return 1;
}

//^19F0:04BF
ObjectID SkWinCore::_19f0_04bf()
{
	//^19F0:04BF
	ENTER(0);
	//^19F0:04C3
	ObjectID si = _4976_5220;
	if (si == OBJECT_NULL) {
		//^19F0:04CD
		si = _4976_521e;
		if (si == OBJECT_NULL) {
			//^19F0:04D7
			_4976_521e = GET_TILE_RECORD_LINK(glbCreatureSomeX, glbCreatureSomeY);
			//^19F0:04E9
		}
		//^19F0:04F4
		for (si = _4976_521e; si != OBJECT_END_MARKER && si.DBType() <= dbActuator; si = GET_NEXT_RECORD_LINK(si));
		//^19F0:0506
		_4976_5220 = si;
	}
	//^19F0:050A
	return si;
}

//^19F0:0559
U16 SkWinCore::_19f0_0559(X16 xx)
{
	//^19F0:0559
	SkD((DLV_DBG_SED3, "DBG: _19f0_0559 %04X \n", (Bitu)xx));
	ENTER(4);
	//^19F0:055E
	X16 si = xx;
	X16 bp04 = glbCurrentThinkingCreatureRec->b15 & 3;
	X16 bp02;
	//^19F0:056F
	if (((si +2) & 3) == bp04) {
		if (RAND01() != 0)
			goto _059e;
		bp02 = 0xffff;
	}
	//^19F0:058E
	else if (bp04 != si) {
		if (((si -1) & 3) == bp04)
			//^19F0:059E
_059e:
			bp02 = 1;
		else
			bp02 = 0xffff;
	}
	else {
		//^19F0:05A7
		glbCurrentThinkingCreatureData->Command = ccmNeutral;
		_4976_4ee5 = xactrYes;
		//^19F0:05B5
		return 0;
	}
	//^19F0:05B9
	glbCurrentThinkingCreatureData->b29 = (U8(bp04) +U8(bp02)) & 3;
	glbCurrentThinkingCreatureData->Command = (bp02 == 0xffff) ? ccm06 : ccm07;
	_4976_4ee5 = xactrAgain;
	//^19F0:05E2
	return 1;
}

//^075F:1BC2
void SkWinCore::_075f_1bc2(U8 zz[4], U16 xx, U16 yy, i16 ss, i16 tt, X16 ww)
{
	//^075F:1BC2
	ENTER(2);
	//^075F:1BC8
    X16 di = ww;
	U16 si = CALC_VECTOR_DIR(xx, yy, ss, tt);
	//^075F:1BE0
	if (di == 255) {
		//^075F:1BE6
		COPY_MEMORY(&_4976_00dc[RCJ(8,si)], zz, 4);
		if (RAND01() != 0) {
			//^075F:1C06
			U8 bp01 = zz[0];
			zz[0] = zz[1];
			zz[1] = bp01;
		}
		//^075F:1C1D
		if (RAND01() != 0) {
			U8 bp01 = zz[2];
			zz[2] = zz[3];
			zz[3] = bp01;
		}
		return;
	}
	//^075F:1C41
	si <<= 1;
	if ((si & 2) == 0)
		di++;
	//^075F:1C4B
	si += (di >> 1) & 1;
	COPY_MEMORY(&_4976_00bc[si], zz, 4);
	//^075F:1C70
	return;
}

//^2C1D:028C
i16 SkWinCore::_2c1d_028c(i16 xx, i16 yy, X16 ww)
{
	//^2C1D:028C
	ENTER(4);
	//^2C1D:0292
	if (glbChampionsCount != 0) {
		//^2C1D:0299
		if (ABS16(xx - glbSomePosX_4c2e) + ABS16(yy - glbSomePosY_4c30) <= 1) {
			//^2C1D:02BE
			U8 bp04[4];
			_075f_1bc2(bp04, glbSomePosX_4c2e, glbSomePosY_4c30, xx, yy, ww);
			//^2C1D:02DC
			for (U16 si = 0; si < 4; si++) {
				//^2C1D:02E0
				i16 di = GET_PLAYER_AT_POSITION(bp04[si]);
				if (di < 0)
					continue;
				return di;
				//^2C1D:02F3
			}
		}
	}
	//^2C1D:02F9
	return -1;
}

//^1C9A:0551
//SPX: This computes the highest power 4 within val ?
//_1c9a_0551 renamed COMPUTE_POWER_4_WITHIN
U32 SkWinCore::COMPUTE_POWER_4_WITHIN(U32 val, U16 cnt)
{
	//^1C9A:0551
	ENTER(4);
	//^1C9A:0556
	X32 bp04 = 1;
	for (i16 si = 0; si < 32; si++, bp04 <<= 1) {
		//^1C9A:0564
		if ((val & bp04) != 0 && --cnt == 0) {
			break;
		}
	}
	//^1C9A:058F
	return bp04;
}

//^1C9A:0598
U16 SkWinCore::_1c9a_0598(U32 val)
{
	//^1C9A:0598
	ENTER(0);
	//^1C9A:059D
	i16 di = 0;
	U16 si = 0;
	for (; val != 0 && di < 32; di++, val >>= 1) {
		//^1C9A:05A3
        if ((U16(val) & 1) != 0)
			si++;
	}
	//^1C9A:05CD
	return si;
}

//^19F0:0891
U16 SkWinCore::_19f0_0891(i16 zz, X16 xx, X16 yy, i16 ss, X16 tt, X16 ww)
{
	//^19F0:0891
	ENTER(18);
	//^19F0:0897
	i16 di = ss;
	X16 bp02 = zz & 0x80;
	if (bp02 != 0)
		zz &= 0xff7f;	// build an object from spell zz
	//^19F0:08AC
	U16 si = glbAIAttacksSpells;
	if (si != 0) {
		//^19F0:08B8
		if (di == -1) {
			//^19F0:08BD
			di = xx + glbXAxisDelta[ww];
			tt = yy + glbYAxisDelta[ww];
		}
		//^19F0:08DA
		if (di >= 0 && di < glbCurrentMapWidth && tt >= 0 && tt < glbCurrentMapHeight && (xx -di == 0 || yy -tt == 0)) {
			//^19F0:0911
			i16 bp04 = CALC_SQUARE_DISTANCE(xx, yy, di, tt);
			if (bp04 <= 1 || (si &= 0x0ff8) != 0) {
				//^19F0:0938
				if (bp04 != 0 || (si &= 7) != 0) {
					//^19F0:094B
					if (glbAIDef->w20_c_f() >= U16(bp04)) {
						//^19F0:095E
						if (bp04 == 0) {
							i16 bp0e;
							for (bp0e = 0; bp0e < 4; bp0e++) {
								//^19F0:096B
								X16 bp0a = xx;
								X16 bp0c = yy;
								bp0a += glbXAxisDelta[bp0e];
								bp0c += glbYAxisDelta[bp0e];
								if (CREATURE_GO_THERE(0, xx, yy, bp0a, bp0c, bp0e) != 0)
									break;
								//^19F0:09AC
							}
							//^19F0:09B5
							if (bp0e < 4)
								goto _0ccf;
						}
						//^19F0:09BE
						switch (zz) {
							case 2:
								//^19F0:09D1
								_19f0_045a(di, tt);
								if (_19f0_050f() == OBJECT_END_MARKER)
									goto _0ccf;
								break;

							case 0:
							case 1:
								//^19F0:09E7
								if (glbCurrentMapIndex != glbCreatureMap || di != glbCreaturePosX || tt != glbCreaturePosY)
									goto _0ccf;
								break;

							default:
								break;
						}
						//^19F0:0A08
						if (bp04 <= 1 || _19f0_0207(xx, yy, di, tt, &SkWinCore::_19f0_00b8) != 0) {
							//^19F0:0A2C
							if ((_4976_3752[_4976_4efa] & 0x200) != 0) {
								//^19F0:0A3A
								_19f0_045a(di, tt);
								//^19F0:0A48
								for (ObjectID bp10 = _19f0_04bf(); bp10 != OBJECT_END_MARKER; bp10 = GET_NEXT_RECORD_LINK(bp10)) {
									//^19F0:0A4A
									if (bp10.DBType() == dbCloud) {
										if (GET_ADDRESS_OF_RECORDF(bp10)->CloudType() == 14) {
											si += 7;
											if (si != 0)
												break;
											goto _0ccf;
										}
									}
									//^19F0:0A7E
								}

							}
							//^19F0:0A90
							if (bp02 == 0)
								//^19F0:0A96
								//^19F0:0CCA
								return 1;
							//^19F0:0A99
							if (ww == 0xffff) {
								//^19F0:0A9F
								if (bp04 == 0 && glbCurrentMapIndex == glbCreatureMap && di == glbCreaturePosX && tt == glbCreaturePosY) {
									//^19F0:0ABD
									ww = (glbPlayerDir +2) & 3;
								}
								else {
									//^19F0:0AC7
									ww = CALC_VECTOR_DIR(xx, yy, di, tt);
								}
							}
							//^19F0:0ADC
							X16 bp08;
							X16 bp06;
							if (_19f0_0559(ww) == 0) {
								//^19F0:0AEB
								bp08 = RAND01();
								if (bp04 <= 1 && (si & 7) != 0 && ((si & 0xff8) == 0 || RAND01() != 0)) {
									//^19F0:0B0E
									si &= 7;
									if (zz <= 1) {
										//^19F0:0B18
										bp06 = _2c1d_028c(xx, yy, 0x00ff);
										if (bp06 != 0xffff) {
											//^19F0:0B31
											bp06 = glbChampionSquad[bp06].playerPos();
											goto _0bae;
										}
									}
									//^19F0:0B40
									bp06 = (bp08 +ww +2) & 3;
									goto _0bae;
								}
								//^19F0:0B4A
								si &= 0xff8;
								if (zz <= 1 && RAND02() != 0) {
									//^19F0:0B5D
									bp08 = RAND01();
									bp06 = (bp08 != 0) ? ((ww +2) & 3) : ww;
									//^19F0:0B79
									if (GET_PLAYER_AT_POSITION(bp06) -1) {
										if (GET_PLAYER_AT_POSITION((bp06 +3) & 3) == -1) {
											//^19F0:0B9C
											bp08 = 1 -bp08;
										}
									}
								}
								//^19F0:0BA5
								bp06 = (ww +bp08) & 3;
								//^19F0:0BAE
_0bae:
								//^19F0:0BB1
								si = COMPUTE_POWER_4_WITHIN(si, RAND16(_1c9a_0598(si)) +1);
								X16 bp12 = si;
								//^19F0:0BD4
								// SPX: This part seems to work for multispell casters : Vexirks & Dragoth etc ..
								if(SkCodeParam::bUseIngameDebug)
									printf("BP12 = %04X, %d\n", bp12, bp12);
								switch (bp12) {
									case AI_ATTACK_FLAGS__PUSH_BACK:	// 0x0002 Knock back
										//^19F0:0BED
										glbCurrentThinkingCreatureData->Command = ccmPushBack;
										break;
									case AI_ATTACK_FLAGS__MELEE:	// 0x0001 Standard attack
										//^19F0:0BF9
										glbCurrentThinkingCreatureData->Command = ccmMeleeAttack;
										break;
									case AI_ATTACK_FLAGS__STEAL:	// 0x0004 Steal?
										//^19F0:0C04
										glbCurrentThinkingCreatureData->Command = ccmSteal;
										glbCurrentThinkingCreatureData->ItemToThrow = 0x0B;	// ????
										break;
									case AI_ATTACK_FLAGS__FIREBALL:	// 0x0010	- 16
										//^19F0:0C14
//											bp04 = i16(0xff80);		// fireball
										bp04 = i16(OBJECT_EFFECT_FIREBALL);
										goto _0c4a;
									case AI_ATTACK_FLAGS__DISPELL:	// 0x0020	- 32
										//^19F0:0C1B
//											bp04 = i16(0xff83);		// dispell
										bp04 = i16(OBJECT_EFFECT_DISPELL);
										goto _0c4a;
									case AI_ATTACK_FLAGS__LIGHTNING:	// 0x0040	- 64
										//^19F0:0C22
//											bp04 = i16(0xff82);		// lightning
										bp04 = i16(OBJECT_EFFECT_LIGHTNING);
										goto _0c4a;
									case AI_ATTACK_FLAGS__POISON_CLOUD:	// 0x0080	- 128
										//^19F0:0C29
//											bp04 = i16(0xff87);		// poison cloud
										bp04 = i16(OBJECT_EFFECT_POISON_CLOUD);
										goto _0c4a;
									case AI_ATTACK_FLAGS__POISON_BOLT:	// 0x0100	- 256
										//^19F0:0C30
//											bp04 = i16(0xff86);		// poison bolt
										bp04 = i16(OBJECT_EFFECT_POISON_BOLT);
										goto _0c4a;
									case AI_ATTACK_FLAGS__PUSH_SPELL:	// 0x0400	- 1024
										//^19F0:0C37
//											bp04 = i16(0xff89);		// push
										bp04 = i16(OBJECT_EFFECT_PUSH);
										goto _0c4a;
									case AI_ATTACK_FLAGS__PULL_SPELL:	// 0x0800	- 2048
										//^19F0:0C3E
//											bp04 = i16(0xff8a);		// pull
										bp04 = i16(OBJECT_EFFECT_PULL);	
										goto _0c4a;
									case AI_ATTACK_FLAGS__POISON_BLOB:	// 0x0200	- 512
//											bp04 = i16(0xff81);		// what's this??
										bp04 = i16(OBJECT_EFFECT_POISON_BLOB);		// what's this??
										//SPX: It does look like this effect doesn't work (no image)
										// I guess in actual code, we never reach this line.
										//^19F0:0C4A
_0c4a:
										glbCurrentThinkingCreatureData->ItemToThrow = U8(bp04);
										glbCurrentThinkingCreatureData->Command = (bp08 != 0) ? ccmCastSpell2 : ccmCastSpell1;
										break;
									case AI_ATTACK_FLAGS__SHOOT:	// 0x0008 Able to launch item / or maybe take item ? (axe, arrow?)
										//^19F0:0C65
										glbCurrentThinkingCreatureData->Command = (bp08 != 0) ? ccmShootItem2 : ccmShootItem1;
										break;
								}
								//^19F0:0C79
								glbCurrentThinkingCreatureData->w24.SetX(di);
								glbCurrentThinkingCreatureData->w24.SetY(tt);
								glbCurrentThinkingCreatureData->w24.SetMap(glbCurrentMapIndex);
								//^19F0:0CB0
								glbCurrentThinkingCreatureData->b27 = U8(ww);
								glbCurrentThinkingCreatureData->b28 = U8(bp06);
								glbCurrentThinkingCreatureData->b32 = U8(zz);
								_4976_4ee5 = xactrAgain;
							}
							//^19F0:0CCA
							return 1;
						}
					}
				}
			}
		}
	}
	//^19F0:0CCF
_0ccf:
	if (bp02 != 0)
		_4976_4ee5 = xactrNo;
	return 0;
}

//^19F0:0547
X16 SkWinCore::_19f0_0547(ObjectID rl, X16 xx)
{
	//^19F0:0547
	ENTER(0);
	//^19F0:054A
	return CREATURE_CAN_HANDLE_IT(rl, xx);
}

//^19F0:01D6
U16 SkWinCore::_19f0_01d6(i16 xx, i16 yy)
{
	//^19F0:01D6
	ENTER(0);
	//^19F0:01D9
	if (glbCurrentMapIndex == glbCreatureMap && xx == glbCreaturePosX && yy == glbCreaturePosY)
		//^19F0:01F4
		return 1;
	//^19F0:01F9
	return _19f0_00b8(xx, yy);
}

//^19F0:05E8
i16 SkWinCore::_19f0_05e8(X16 aa, DistMapTile (*bb)[1][32], Ax3 *cc, i16 xx, i16 yy, i16 zz, X16 ww)
{
	//^19F0:05E8
	ENTER(16);
	//^19F0:05EE
	i16 si = zz;
	i16 bp06 = ((glbAIAttacksSpells & 0xff8) == 0) ? (glbAIDef->w20 >> 12) : 1;
	i16 bp08 = 0;
	if (si == -1)
		si = 0, bp08 = 3;
	//^19F0:061D
	i16 bp04;
	i16 bp02;
	i16 di;
	do {
		bp02 = xx;
		di = yy;
		for (bp04 = 0; bp04 < bp06; bp04++) {
			//^19F0:062E
			bp02 += glbXAxisDelta[si];
			di += glbYAxisDelta[si];
			//^19F0:0641
			if (bp02 < 0 || bp02 >= glbCurrentMapWidth || di < 0 || di >= glbCurrentMapHeight)
				//^19F0:0663
				continue;
			//^19F0:0666
			U8 bp0d = GET_TILE_VALUE(bp02, di);
			ObjectID bp10;
			if ((bp0d & 0x10) != 0) {
				//^19F0:067B
				if ((bp0d >> 5) == ttWall) {
					//^19F0:0687
					if (ww == 0)
						break;
					//^19F0:0690
					for (bp10 = GET_TILE_RECORD_LINK(bp02, di); bp10 != OBJECT_END_MARKER; bp10 = GET_NEXT_RECORD_LINK(bp10)) {
						//^19F0:069D
						if (bp10.DBType() == dbActuator || bp10.DBType() == dbText) {
							//^19F0:06B9
							if (bp10.Dir() == ((si +2) & 3)) {
								//^19F0:06CB
								U8 bp0e = QUERY_CLS2_FROM_RECORD(bp10);
								if (bp0e != 0xff) {
									//^19F0:06DB
									if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp0e, dtWordValue, GDAT_WALL_ORNATE__DATA_F0) == aa)
										goto _0783;
								}
							}
						}
						//^19F0:06F3
					}
					//^19F0:0705
					continue;
				}
				//^19F0:0707
				if (ww == 0 && (glbCreatureTimer.XcoordB() != bp02 || glbCreatureTimer.YcoordB() != di) && (bp10 = GET_CREATURE_AT(bp02, di)) != OBJECT_NULL) {
					//^19F0:0733
					if (_19f0_0547(bp10, aa) != 0)
						goto _0783;
				}
			}
			//^19F0:0743
			if (bb[bp02][di]->distance != 0 || _19f0_01d6(bp02, di) != 0)
				break;
			//^19F0:0769
		}
		//^19F0:0777
		si++;
	} while (--bp08 >= 0);
	//^19F0:0780
	goto _088b;
	//^19F0:0783
_0783:
	bp08 = bb[xx][yy]->distance;
	si += 2;
	si &= 3;
	while (++bp04 < bp06) {
		//^19F0:07A6
		U8 bp0a = U8(xx);
		U8 bp0c = U8(yy);
		xx += glbXAxisDelta[si];
		yy += glbYAxisDelta[si];
		U8 bp0d = bb[xx][yy]->distance;
		//^19F0:07E1
		if (bp0d != 0 && bp0d <= bp08) {
			//^19F0:07F1
			if (_19f0_01d6(xx, yy) == 0)
				continue;
		}
		//^19F0:0801
		xx = bp0a;
		yy = bp0c;
		break;
		//^19F0:080F
	}
	//^19F0:081A
	si += 2;
	si &= 3;
	if (_19f0_0891((ww != 0) ? 3 : 2, xx, yy, bp02, di, si) != 0) {
		//^19F0:0848
		_19f0_045a(xx, yy);
		cc->SetX(bp02);
		cc->SetY(di);
		cc->SetMap(glbCurrentMapIndex);
		//^19F0:0886
		return 1;
	}
	//^19F0:088B
_088b:
	return 0;
}

//^1C9A:1B16
i16 SkWinCore::_1c9a_1b16(X16 xx, X16 yy)
{
	//^1C9A:1B16
	ENTER(6);
	//^1C9A:1B1C
	ObjectID si = _4976_521e;
	if (si == OBJECT_NULL) {
		//^1C9A:1B26
		_4976_521e = GET_TILE_RECORD_LINK(glbCreatureSomeX, glbCreatureSomeY);
		si = _4976_521e;
	}
	X16 bp06;
	for (; si != OBJECT_END_MARKER && (bp06 = si.DBType()) <= dbActuator; si = GET_NEXT_RECORD_LINK(si)) {
		//^1C9A:1B3A
		if (bp06 == dbText) {
			//^1C9A:1B40
			Text *bp04 = GET_ADDRESS_OF_RECORD2(si);
			//^1C9A:1B4D
			if (bp04->TextMode() == 2 && bp04->w2_c_f() == xx && bp04->w2_8_b() == yy) {
				//^1C9A:1B82
				return bp04->w2_3_7();  // TODO: Complex text use
			}
		}
		//^1C9A:1B89
	}
	//^1C9A:1BA7
	return -1;
}

//^1C9A:1A48
i16 SkWinCore::_1c9a_1a48(X16 xx, X16 yy)
{
	//^1C9A:1A48
	ENTER(8);
	//^1C9A:1A4E
	X16 bp08 = (xx == 1) ? 2 : -1;
	//^1C9A:1A60
	ObjectID si = _4976_521e;
	if (si == OBJECT_NULL) {
		//^1C9A:1A6D
		_4976_521e = GET_TILE_RECORD_LINK(glbCreatureSomeX, glbCreatureSomeY);
		si = _4976_521e;
	}
	//^1C9A:1A7F
	X16 bp06;
	for (; si != OBJECT_END_MARKER && (bp06 = si.DBType()) <= dbActuator; si = GET_NEXT_RECORD_LINK(si)) {
		//^1C9A:1A81
		if (bp06 == dbText) {
			Text *bp04 = GET_ADDRESS_OF_RECORD2(si);
			if (bp04->TextMode() == 2) {
				if (true
					&& ((bp04->w2_c_f() == xx) || (bp04->w2_c_f() == bp08 && bp04->TextVisibility() != 0))
					&& (bp08 & (1 << bp04->w2_8_b())) != 0
				) {
					//^1C9A:1AE7
					return bp04->w2_3_7();
				}
			}
		}
		//^1C9A:1AEE
	}
	//^1C9A:1B0F
	return -1;
}

//^19F0:0081
// SPX: _19f0_0081 renamed IS_TILE_WALL
X16 SkWinCore::IS_TILE_WALL(i16 xx, i16 yy)
{
	//^19F0:0081
	ENTER(0);
	//^19F0:0086
	U16 iTileValue = GET_TILE_VALUE(xx, yy);	// si
	U16 iTileType = iTileValue >> 5;					// di
	return (iTileType == ttWall || iTileType == ttTrickWall || (iTileValue & 5) == 0) ? 1 : 0;
}

//^19F0:1511
X16 SkWinCore::_19f0_1511(ObjectID rl)
{
	//^19F0:1511
	ENTER(0);
	//^19F0:1514
	return CREATURE_CAN_HANDLE_IT(rl, 9);
}

//^075F:1791
X16 SkWinCore::CALC_CLOUD_DAMAGE(ObjectID rlCloud, ObjectID rlTarget)
{
	//^075F:1791
	ENTER(12);
	//^075F:1797
	Cloud *bp04 = GET_ADDRESS_OF_RECORDF(rlCloud);
	i16 si = 0;
	U16 bp0a = bp04->CloudType();
	//^075F:17B5
	if (bp0a >= 8)
		return si;
	//^075F:17BD
	U8 bp0b = _4976_00b4[RCJ(8, bp0a)];
	if (bp0b == 0)
		return si;
	//^075F:17D0
	GenericRecord *bp08;
	U16 di = 0; // defaulting to 0
	if (rlTarget == OBJECT_NULL) {
		if ((bp0b & 4) == 0)
			return si;
	}
	else {
		//^075F:17E4
		di = rlTarget.DBType();
		if (di == dbDoor && (bp0b & 2) != 0) {
			//^075F:17F9
			bp08 = GET_ADDRESS_OF_RECORD(rlTarget);
		}
		else {
			//^075F:180A
			if (di != dbCreature)
				return si;
			//^075F:1812
			if ((bp0b & 8) == 0)
				return si;
		}
	}
	//^075F:1820
	if (di == dbCreature && (QUERY_CREATURE_AI_SPEC_FROM_RECORD(rlTarget)->w24 & 0x1000) != 0 && bp0a != 0)
		return si;
	//^075F:1843
	si = bp04->b3_0_f();
	if ((bp0b & 1) != 0) {
		//^075F:1855
		si = (bp04->b3_0_f() >> 1) +1;
		si = RAND16(si) +si +1;
	}
	//^075F:186D
	switch (bp0a) {
		case missileLightning: // 2
			//^075F:187C
			si >>= 1;
			goto _187e;
		case missileFireball: // 0
			//^075F:187E
_187e:
			if (di == dbDoor && bp08->castToDoor()->DestroyablebyFireball() == 0)
				si = 0;
			break;
		case missileDispell: // 3
			//^075F:1897
			if ((QUERY_CREATURE_AI_SPEC_FLAGS(rlTarget) & 0x20) == 0)
				si = 0;
			break;
		case missilePoisonCloud: // 7
			//^075F:18A9
			si = max_value(1, min_value(bp04->b3_5_f(), 4) + RAND01());
			if (di == 4) {
				si = APPLY_CREATURE_POISON_RESISTANCE(rlTarget, si);
			}
		case missilePoisonBlob: // 1=
		case missileZoSpell:	// 4: // 4=Zo Spell
		case missileFuse:		// 5=
		case missilePoisonBolt: // 6: // 6=Poison bolt
			break;
	}
	//^075F:18E7
	return si;
}

//^19F0:13AA
X16 SkWinCore::_19f0_13aa(i16 xx, i16 yy)
{
	//^19F0:13AA
	ENTER(10);
	//^19F0:13B0
	i16 bp08 = 0;
	do {
		//^19F0:13B5
		if ((_4976_3752[_4976_4efa] & 0x400) != 0 || ((glbCurrentThinkingCreatureRec->w10 & 0x80) == 0 
			&& (glbAIDef->w0_2_2() != 0 || glbCreatureTimer.XcoordB() != xx || glbCreatureTimer.YcoordB() != yy || ((glbCurrentThinkingCreatureRec->b15_0_1() +2) & 3) != bp08) || (RAND() & 7) == 0)) {
			//^19F0:1410
			i16 di = xx;
			i16 si = yy;
			for (i16 bp0a = 0; bp0a++ < 3; ) {
				//^19F0:141E
				di += glbXAxisDelta[bp08];
				si += glbYAxisDelta[bp08];
				//^19F0:1430
				if (di < 0 || di >= glbCurrentMapWidth || si < 0 || si >= glbCurrentMapHeight)
					break;
				//^19F0:1450
				for (ObjectID bp06 = GET_WALL_TILE_ANYITEM_RECORD(di, si); bp06 != OBJECT_END_MARKER; bp06 = GET_NEXT_RECORD_LINK(bp06)) {
					//^19F0:145B
					if (bp06.DBType() == dbMissile) {
						Missile *bp04 = GET_ADDRESS_OF_RECORDE(bp06);
						if (glbTimersTable[bp04->TimerIndex()].Direction() == ((bp08 +2) & 3) && _075f_06bd(bp04, bp04->GetMissileObject()) != 0) {
							//^19F0:14BA
							return 1;
						}
					}
					//^19F0:14BF
				}
				//^19F0:14D1
				if (glbCreatureTimer.XcoordB() != di || glbCreatureTimer.YcoordB() != si) {
					//^19F0:14E3
					if (_19f0_00b8(di, si) != 0)
						break;
				}
				//^19F0:14EF
			}
		}
		//^19F0:14FD
	} while (++bp08 < 4);
	//^19F0:150B
	return 0;
}

//^19F0:1522
i16 SkWinCore::CREATURE_GO_THERE(X16 aa, i16 xx, i16 yy, i16 ss, i16 tt, i16 ww)
{
	// check if you can move from (xx,yy) to (ss,tt)

	// this is not for telling creature to "go there".

	// return 0 if cannot pass
	// return 1 if can pass. also glbCurrentThinkingCreatureData->w24 points next one step.

	//SkD((DLV_CAI, "CAI: CREATURE_GO_THERE(%04X,(%2d,%2d),(%2d,%2d),%2d) \n"
	//	, (Bitu)aa, (Bitu)xx, (Bitu)yy, (Bitu)ss, (Bitu)tt, (Bitu)(i16)ww
	//	));

	//^19F0:1522
	ENTER(50);
	//^19F0:1528
	i16 di = ss;
	X16 bp1a = 0;
	X16 bp16 = 0;
	X16 bp22 = 0;
	X16 bp24 = 0;
	X16 bp1c = aa & 0x80;
	i16 bp08;
	if (bp1c != 0)
		bp08 = ccmInv;
	//^19F0:154B
	X16 bp1e = aa & 0x40;
	X16 bp20 = aa & 0x20;
	aa &= 0xff1f;
	//^19F0:1562
	i16 bp0c;
	X16 bp18;
	U16 bp06;
	i16 bp14;
	X16 si;
	Actuator *bp2e = NULL; // defaulting to NULL
	if (aa != 2) {
		X16 bp28 = (aa == 3 || aa == 7) ? 1 : 0;
		if (bp28 == 0 && _4976_4eec == 0)
			goto _1df6;
		//^19F0:158F
		bp0c = ww;
		if (ww == 6) {
			//^19F0:159B
			bp18 = 0;
			bp0c = glbCurrentThinkingCreatureRec->b15 & 3;
			goto _1811;
		}
		//^19F0:15AE
		if (ww < 4)
			goto _17af;
		//^19F0:15B7
		bp18 = 0;
		if ((_4976_4eec & 0x2000) == 0)
			goto _1df6;
		//^19F0:15C7
		si = 0;
		bp06 = GET_TILE_VALUE(xx, yy);
//			Actuator *bp2e = NULL; // moved before any goto
		switch (bp06 >> 5) {
			case ttPit:
				//^19F0:15F2
				if (ww == 5 && (bp06 & 8) != 0 && (bp06 & 1) == 0) {
					//^19F0:1606
					si = 8;
					bp08 = ccm38;
					bp0c = glbCurrentThinkingCreatureRec->b15_0_1();
					break;
				}
				goto _161f;
			case ttFloor:
			case ttTeleporter:
			case ttTrickWall:
				//^19F0:161F
_161f:
				if ((bp06 & 2) == 0)
					break;
				//^19F0:1629
				bp0c = FIND_LADDER_AROUND(xx, yy, (ww == 4) ? -1 : 1, &bp2e);
				if (bp0c >= 0) {
					bp08 = (ww == 4) ? ccm39 : ccm3A;
					si = 0x100;
					break;
				}
				//^19F0:1668
				bp08 = ccm37;
				si = 0x10;
				bp0c = glbCurrentThinkingCreatureRec->b15_0_1();
				break;
			case ttStairs:
				//^19F0:1680
				if ((bp06 & 4) != 0) {
					if (ww != 4)
						break;
					//^19F0:168D
					bp08 = ccm35;
					goto _169f;
				}
				if (ww == 5) {
					bp08 = ccm36;
_169f:
					bp0c = (_0cee_06dc(xx, yy) +2) & 3;
					si = 0x100;
				}
				break;
			case ttDoor:
				break;
		}
		//^19F0:16B7
		if ((_4976_4eec & si) == 0)
			goto _1df6;
		bp14 = glbCurrentMapIndex;
		//^19F0:16C9
		i16 bp0e;
		if ((bp2e != NULL) && (bp08 == ccm39 || bp08 == ccm3A)) {
			//^19F0:16DA
			xx = bp2e->Xcoord();
			yy = bp2e->Ycoord();
			bp0e = bp2e->ActuatorData();
		}
		else {
			//^19F0:1706
			bp0e = LOCATE_OTHER_LEVEL(glbCurrentMapIndex, (ww == 4) ? -1 : 1, &xx, &yy, NULL);
			if (bp0e < 0)
				goto _1df6;
			if (bp08 == ccm37) {
				//^19F0:173F
				bp06 = glbMapTileValue[bp0e][xx][yy];
				if ((bp06 >> 5) != 2 || (bp06 & 8) == 0)
					goto _1df6;
			}
		}
		//^19F0:1778
		if (IS_CREATURE_ALLOWED_ON_LEVEL(glbCurrentThinkingCreatureID, bp0e) == 0)
			goto _1df6;
		//^19F0:178D
		bp16 = 1;
		_1c9a_0648(bp0e);
		di = xx;
		tt = yy;
		yy = xx = -1;
		//^19F0:17AD
		goto _1811;
		//^19F0:17AF
_17af:
		if (di == -1) {
			bp18 = 0;
			di = xx + glbXAxisDelta[ww];
			tt = yy + glbYAxisDelta[ww];
		}
		else {
			//^19F0:17D8
			bp18 = (xx == di && yy == tt) ? 1 : 0;
			if (bp18 == 0 && ww == -1) {
				//^19F0:17F9
				ww = bp0c = CALC_VECTOR_DIR(xx, yy, di, tt);
			}
		}
		//^19F0:1811
_1811:
		if (di < 0 || di >= glbCurrentMapWidth || tt < 0 || tt >= glbCurrentMapHeight)
			goto _1df6;
		//^19F0:1836
		if (bp28 != 0) {
			if (aa == 3) {
				//^19F0:1842
				bp1a = IS_TILE_WALL(di, tt);
			}
			//^19F0:184C
			else if (aa == 7) {
				bp1a = !_19f0_000a(di, tt);
			}
			//^19F0:1864
			if (bp1a == 0)
				goto _1df6;
			//^19F0:186D
			_19f0_045a(di, tt);
			goto _1df6;
		}
		//^19F0:187A
		_19f0_045a(di, tt);
		i16 bp2a;
		if (_4976_4ef8 == 0 || ww == 6 || (bp2a = _1c9a_1a48(1, _4976_4ef8)) == -1 || (bp2a & (1 << ((ww +2) & 3))) == 0) {
			//^19F0:18BC
			if ((aa == 4 || aa == 5) && (glbAIDef->ArmorClass == AI_DEF_ARMOR_MAX))
				//^19F0:18D3
				aa = 0;
			//^19F0:18D8
			bp06 = _4976_521c;
			switch (bp06 >> 5) {
				case ttWall: // 0
					//^19F0:18F4
					si = 1;
					break;
				case ttFloor: // 1
					//^19F0:18FA
					goto _1a94;
				case ttPit: // 2
					//^19F0:18FD
					if ((bp06 & 8) != 0) {
						if ((bp06 & 1) != 0) {
							si = 0x8024;
							break;
						}
						if (bp16 != 0) {
							si = 0x000c;
							break;
						}
						si = 0x800c;
						break;
					}
					si = 6;
					break;
				case ttStairs: // 3:
					//^19F0:1929
					si = 0x100;
					break;
				case ttDoor: // 4:
					{
					//^19F0:192F
					Door *door;	//*bp04
					bp06 &= 7;
					if (bp06 == 0 && aa != 4 && aa != 5)
						goto _1a94;
					if (bp06 == 5)
						goto _1a94;
					if (bp06 == 4)
						goto _19f9;
					//^19F0:195B
					if (_4976_521e == OBJECT_NULL) {
						//^19F0:1962
						_4976_521e = GET_TILE_RECORD_LINK(di, tt);
					}
					door = GET_ADDRESS_OF_RECORD0(_4976_521e);
					if (bp1e != 0) {
						//^19F0:1986
						if (door->Bit10() != 0) {
							if (door->Bit09() != 0)
								goto _1a94;
							si = 0x4200;
							break;
						}
					}
					//^19F0:19AD
					if (door->Bit10() != 0 && door->Bit09() == 0) {
						si = 0x200;
						break;
					}
					//^19F0:19D1
					if (((door->OpeningDir() != 0) ? glbAIDef->w0_6_7() : 1) < bp06) {
						//^19F0:19F9
_19f9:
						si = 0x4200;
						break;
					}
					//^19F0:19FF
					si = 2;
					break;
					}
				case ttTeleporter: // 5:
					{
					//^19F0:1A05
					if ((bp06 & 8) == 0) {
						if (GET_TELEPORTER_DETAIL(&_4976_5226, U8(di), U8(tt)) != 0) {
							//^19F0:1A20
							_4976_5225 = 1;
							if (IS_CREATURE_ALLOWED_ON_LEVEL(glbCurrentThinkingCreatureID, _4976_5226.b4) == 0)
								goto _1df6;
							si = 0x2000;
							break;
						}
						//^19F0:1A42
						si = 0x402;
						break;
					}
					//^19F0:1A47
					if (_4976_521e == OBJECT_NULL) {
						_4976_521e = GET_TILE_RECORD_LINK(di, tt);
					}
					bp06 = GET_ADDRESS_OF_RECORD1(_4976_521e)->Scope();
					if (bp06 == 1 || bp06 == 3) {
						//^19F0:1A83
						si = 0x400;
						break;
					}
					//^19F0:1A88
					si = 2;
					break;
					}
				case ttTrickWall: // 6:
					{
					//^19F0:1A8D
					if ((bp06 & 4) != 0) {
_1a94:
						si = 2;
						break;
					}
					//^19F0:1A99
					if ((bp06 & 1) != 0) {
						si = 0x80;
						break;
					}
					//^19F0:1AA5
					si = 0x40;
					break;
					}
				case 7:
					goto _1df6;
			}
			//^19F0:1AA8
			si &= _4976_4eec;
			if (si != 0) {
				//^19F0:1AB5
				if (aa != 1 || ABS16(di - glbCreaturePosX) + ABS16(tt - glbCreaturePosY) > 1) {
					//^19F0:1AE2
					X16 bp0a;
					bp0a = 0;
					if (glbCurrentMapIndex == glbCreatureMap && di == glbCreaturePosX && tt == glbCreaturePosY)
						bp0a = 0x800;
					//^19F0:1B04
					if (bp18 == 0) {
						ObjectID bp12;
						bp12 = _19f0_050f();
						if (bp12 != OBJECT_END_MARKER) {
							//^19F0:1B16
							if (bp1e == 0 || QUERY_CREATURE_AI_SPEC_FROM_RECORD(bp12)->w10 == 0) {
								//^19F0:1B30
								if (bp20 == 0 || bp16 != 0 || (bp22 = _19f0_1511(bp12)) == 0) {
									//^19F0:1B4B
                                    bp0a |= 0x1000;
								}
							}
						}
					}
					//^19F0:1B50
					if ((bp0a & _4976_4eec) == bp0a) {
						if (aa == 4 || aa == 5) {
							//^19F0:1B6E
							ObjectID bp12;
							for (bp12 = _19f0_04bf(); bp12 != OBJECT_END_MARKER; bp12 = GET_NEXT_RECORD_LINK(bp12)) {
								//^19F0:1B75
								X16 bp10 = 0;
								bp06 = bp12.DBType();
								if (bp06 == dbCloud) {
									//^19F0:1B8B
									U16 bp26 = GET_ADDRESS_OF_RECORDF(bp12)->CloudType();
									if (bp26 == 7) {
										//^19F0:1BA7
										bp10 = CALC_CLOUD_DAMAGE(bp12, glbCurrentThinkingCreatureID);
									}
									else {
										//^19F0:1BB7
										if (bp26 == 14)
											bp24 = 1;
									}
								}
								//^19F0:1BC4
								else  if (bp06 == dbMissile) {
									//^19F0:1BCA
									if (glbCreatureTimer.XcoordB() != di || glbCreatureTimer.YcoordB() != tt) {
										//^19F0:1BDD
										Missile *bp04 = GET_ADDRESS_OF_RECORDE(bp12);
										bp2a = (ww == 6) ? bp0c : ww;
										if (glbTimersTable[bp04->TimerIndex()].Direction() != bp2a) {
											//^19F0:1C1E
											bp10 = _075f_06bd(bp04, bp04->GetMissileObject());
										}
									}
								}
								//^19F0:1C36
								if (bp10 != 0)
									goto _1df6;
								//^19F0:1C3F
							}
							//^19F0:1C54
							if (aa == 5 && bp24 == 0 && _19f0_13aa(di, tt) != 0)
								goto _1df6;
						}
						//^19F0:1C71
						bp1a = 1;
						if (bp16 != 0 || si == 0x400) {
							//^19F0:1C85
							_2fcf_0434(glbCurrentThinkingCreatureID, xx, yy, di, tt, 0);
							if (glbCurrentMapIndex == _4976_581c && di == _4976_5826 && tt == _4976_5828)
								goto _1df6;
							//^19F0:1CB8
							bp0e = glbCurrentMapIndex;
							if (bp0e != _4976_581c) {
								if ((_4976_4eec & 0x2000) == 0 || IS_CREATURE_ALLOWED_ON_LEVEL(glbCurrentThinkingCreatureID, _4976_581c) == 0) {
									//^19F0:1CDF
									bp1a = 0;
									goto _1df6;
								}
								//^19F0:1CE7
								_1c9a_0648(_4976_581c);
							}
							//^19F0:1CF1
							bp1a = CREATURE_GO_THERE(aa | bp1e, _4976_5826, _4976_5828, _4976_5826, _4976_5828, 6);
							_1c9a_0648(bp0e);
							goto _1df6;
						}
						//^19F0:1D20
						if (bp18 == 0) {
							//^19F0:1D29
							if (si == 0x4000) {
								return _19f0_0d10(bp1c, xx, yy, di, tt, bp0c);
							}
							//^19F0:1D4A
							if ((si & 0x8000) != 0) {
								if (aa == 6) {
									//^19F0:1D59
									bp1a = 0;
								}
								else {
									//^19F0:1D60
									bp0a = _4976_4eec;
									_4976_4eec &= 0x7DB7;
									//^19F0:1D6C
									bp1a = CREATURE_GO_THERE(aa | bp1e, di, tt, di + glbXAxisDelta[bp0c], tt + glbYAxisDelta[bp0c], bp0c);
									_4976_4eec = bp0a;
								}
								//^19F0:1DA3
								if (bp1a != 0) {
									//^19F0:1DA9
									bp08 = ccmJump;
								}
								//^19F0:1DB0
								else if ((_4976_4eec & 8) != 0) {
									_4976_4eec &= 0x7FFF;
									bp1a = CREATURE_GO_THERE(aa | bp1e, xx, yy, di, tt, bp0c);
									if (bp1a != 0)
										bp08 = ccm38;
									_4976_4eec = bp0a;
								}
								//^19F0:1DEB
								if (bp1a == 0)
									_4976_5224 = 1;
							}
						}
					}
				}
			}
		}
	}
	//^19F0:1DF6
_1df6:
	if (bp1c != 0) {
		//^19F0:1DFF
		if (bp1a == 0) {
			//^19F0:1E05
			_4976_4ee5 = xactrNo;
		}
		//^19F0:1E0D
		else if (bp18 != 0) {
			//^19F0:1E13
			_4976_4ee5 = xactrYes;
		}
		//^19F0:1E1B
		else if (bp22 == 0 || _19f0_0891(0x82, xx, yy, di, tt, -1) == 0) {
			//^19F0:1E3E
			if ((_4976_4ef0 & 0x20) != 0) {
				//^19F0:1E46
				for (bp06 = 0; bp06 <= 3; bp06++) {
					//^19F0:1E4D
					if (bp06 != bp0c) {
						X16 bp30 = xx + glbXAxisDelta[bp06];
						X16 bp32 = yy + glbYAxisDelta[bp06];
						if ((GET_TILE_VALUE(bp30, bp32) >> 5) == ttDoor) {
							//^19F0:1E89
							if (_19f0_0d10(0x82, xx, yy, bp30, bp32, bp06) != 0)
								goto _1ff2;
						}
					}
					//^19F0:1EA9
				}
			}
			//^19F0:1EB2
			if (aa == 6) {
				bp0c += 2;
				bp0c &= 3;
				bp08 = ccm09;
			}
			//^19F0:1EC8
			else if (bp08 == i16(ccmInv)) {
				bp08 = (ABS16(xx -di) + ABS16(yy -tt) <= 1) ? ccm02 : ccm01;
			}
			//^19F0:1EFC
			bp06 = glbCurrentThinkingCreatureRec->b15_0_1();
			if (bp06 != bp0c) {
				//^19F0:1F0F
				if (((bp0c +2) & 3) == bp06 || bp08 != ccm02) {
					//^19F0:1F22
					if ((aa == 4 || aa == 5) && (_4976_3752[_4976_4efa] & 0x100) == 0 && RAND02() != 0) {
						//^19F0:1F45
						bp08 = ccm09;
						goto _1f9a;
					}
					else {
						//^19F0:1F4C
						_19f0_0559(bp0c);
						goto _1ff2;
					}
				}
			}
			//^19F0:1F57
			if (bp06 != bp0c && bp08 != ccm09) {
				//^19F0:1F65
				bp08 = (((bp06 +1) & 3) == bp0c) ? ccm04 : ccm03;
			}
			//^19F0:1F7C
			else if ((_4976_37a6[RCJ(86,_4976_4ee4)] & 2) != 0 && aa != 6 && bp16 == 0) {
				bp08 = ccmNeutral;
			}
			//^19F0:1F9A
_1f9a:
			glbCurrentThinkingCreatureData->w24.SetX(di);
			glbCurrentThinkingCreatureData->w24.SetY(tt);
			glbCurrentThinkingCreatureData->w24.SetMap(glbCurrentMapIndex);
			//^19F0:1FD1
			glbCurrentThinkingCreatureData->b27 = X8(ww);
			glbCurrentThinkingCreatureData->b29 = X8(bp0c);
			glbCurrentThinkingCreatureData->b32 = X8(aa);
			glbCurrentThinkingCreatureData->Command = X8(bp08);
			_4976_4ee5 = xactrAgain;
		}
	}
	//^19F0:1FF2
_1ff2:
	if (bp16 != 0)
		_1c9a_0648(bp14);
	//^19F0:2001
	//SkD((DLV_CAI, "CAI: CREATURE_GO_THERE %c \n"
	//	, (Bitu)((bp1a ? 'o' : 'x'))
	//	));
	return bp1a;
}

//^19F0:050F
ObjectID SkWinCore::_19f0_050f()
{
	//^19F0:050F
	ENTER(0);
	//^19F0:0513
	ObjectID si = _4976_5222;
	if (si == OBJECT_NULL) {
		//^19F0:051D
		for (si = _19f0_04bf(); si != OBJECT_END_MARKER && si.DBType() != dbCreature; si = GET_NEXT_RECORD_LINK(si));
        //^19F0:053E
		_4976_5222 = si;
	}
	//^19F0:0542
	return si;
}

//^1C9A:0006
X16 SkWinCore::CREATURE_CAN_HANDLE_IT(ObjectID rlTarget, U16 flags)
{
	// return 0 if he can't.
	// return 1 if he can.

	// flags:

	// 0 to 63 means:                                       0F-4A is a WOLF.
	//   78 is ... (78&0x3F) -> 0xE, 0xE+0x10 -> 0x1E, See (0F-4A-05-1E-00-00) is "J34-36 J50 J58 J61 J8"
	//    5 is ... ( 5&0x3F) -> 0xE, 0x5+0x10 -> 0x15, See (0F-4A-05-15-00-00) is "J58 J61"

	//                       0F-22 is a MERCHANT
	//   16 merchant items. (0F-22-05-(20+3*Delta)-00-00)   Delta: 0=Weapshop, 1,2=Clothshop, 3=Miscitemshop, 4=MagicMerchant spec.
	//   17 merchant items. (0F-22-05-(21+3*Delta)-00-00)
	//   18 merchant items. (0F-22-05-(22+3*Delta)-00-00)
	//   40 ?

	//   41 ? moneybox?
	//   62 ? moneybox?
	//   63 means all items can be done?

	// 0x40: unknown. unused here.

	// 0x80: invert flag. if 1, exclude the items from specified item set.  
	//                    if 0, include the items.

	//^1C9A:0006
	ENTER(14);
	//^1C9A:000C
	i16 si = flags;
	U16 di = si & 0x80;
	U8 bp09;
	U16 bp0e;
	si &= 0x3f;
	if (si == -1 || si == -2)
		return 0;
	//^1C9A:002C
	if (si == 0x3f)
		goto _0238;
	//^1C9A:0034
	if (si == 0x3e) {
		//^1C9A:0039
		if (IS_CONTAINER_MONEYBOX(rlTarget) != 0) {
			if (GET_ADDRESS_OF_RECORD9(rlTarget)->b7_2_2() == 0) {
				return !di;
			}
		}
		return di;
	}
	//^1C9A:006E
	if (si == 0x29) {
		//^1C9A:0073
		if (IS_CONTAINER_MONEYBOX(rlTarget) != 0) {
			//^1C9A:0080
			if (GET_ADDRESS_OF_RECORD9(rlTarget)->b7_2_2() != 0) {
				return !di;
			}
			return di;
		}
		//^1C9A:00A2
		si = 7;
	}
	//^1C9A:00A5
	bp09 = glbCurrentThinkingCreatureRec->CreatureType();
	bp0e = rlTarget.DBType();
	if ((si >= 0x10 && si < 0x13) || si == 0x28) {
		//^1C9A:00CB
		if (si == 0x28) {
			//^1C9A:00D0
			if (IS_CONTAINER_MONEYBOX(rlTarget) != 0 && GET_ADDRESS_OF_RECORD9(rlTarget)->b7_2_2() == 0) {
				goto _0238;
			}
			//^1C9A:00FB
			si = 0x10;
		}
		//^1C9A:00FE
		si = glbCurrentThinkingCreatureRec->w8 * 3 +si;
	}
	//^1C9A:0111
	U8 *bp04;
	bp04 = _4976_5164[si];
	if (bp04 == 0) {
		//^1C9A:0128
		_4976_520c--;
		bp04 = _4976_5164[si] = _4976_520e;
		_4976_520e += 0x40;
		if (QUERY_CREATURES_ITEM_MASK(bp09, U8(si), bp04, (bp0e == dbCreature) ? 1 : 0) == 0)
			return 0;
	}
	//^1C9A:0173
	i16 bp0c;
	if (bp0e == dbCreature) {
		bp0c = GET_ADDRESS_OF_RECORD4(rlTarget)->CreatureType();
		goto _0219;
	}
	//^1C9A:0192
	Actuator *bp08;
	if (bp0e == dbActuator) {
		bp08 = GET_ADDRESS_OF_ACTU(rlTarget);
		switch (bp08->ActuatorType()) {
			case ACTUATOR_TYPE_X1B: // 0x1b -> '?'
				//^1C9A:01BD
				if (bp08->ActuatorData() == 0)
					return 0;
				goto _01d1;
			case ACTUATOR_TYPE_KEY_HOLE: // 0x1a -> 'Activator, key hole'
				//^1C9A:01D1
_01d1:
				bp0c = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, GET_WALL_DECORATION_OF_ACTUATOR(bp08), dtWordValue, GDAT_WALL_ORNATE__IS_ITEM_TRIGGERED);
				goto _0219;
			default:
				//^1C9A:01EF
				bp0c = bp08->ActuatorType();
				goto _0219;
		}
	}
	//^1C9A:01FE
	if (bp0e >= dbWeapon && bp0e <= dbMiscellaneous_item) {
		//^1C9A:020A
		bp0c = GET_DISTINCTIVE_ITEMTYPE(rlTarget);
		goto _0219;
	}
	//^1C9A:0216
	return 0;
	//^1C9A:0219
_0219:
	if ((bp04[bp0c >> 3] & (1 << (bp0c & 7))) != 0) {
		//^1C9A:0238
_0238:
		return !di;
	}
	//^1C9A:0241
	return di;
}
//^1C9A:19D4
void SkWinCore::_1c9a_19d4(ObjectID rl, i16 xx, i16 yy, U16 ww)
{
	//^1C9A:19D4
	ENTER(0);
	//^1C9A:19D9
	U16 si = ww;
	U16 di = si & 0x8000;
	si = si & 0x7fff;
	switch (si) {
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
	case 11:
	case 12:
	case 13:
	case 14:
	case 15:
	case 16:
	case 17:
	case 18:
	case 19:
	case 20:
	case 21:
		//^1C9A:19FB
		ATTACK_CREATURE(rl, xx, yy, (di != 0) ? ((si -6)|0x8000) : (si -6), 0x64, 0);
	}
	//^1C9A:1A24
	return;
}
//^24A5:036A
// SPX: This one in the end compute light depending on champion position
// SPX: This func is called for each tile in the nearby area from the champion
// SPX: _24a5_036a renamed ADD_BACKGROUND_LIGHT_FROM_TILE
void SkWinCore::ADD_BACKGROUND_LIGHT_FROM_TILE(i16 aa, U16 bb, i16 xx, i16 yy, U16 ww)
{
	//^24A5:036A
	ENTER(46);
	//^24A5:0370
	X16 di = 0;
	X16 bp12 = 0;
	X16 bp14 = 0;
	ExtendedTileInfo bp2e;
	//printf("ADD_BACKGROUND_LIGHT_FROM_TILE: aa=%d bb=%d xx=%d yy=%d ww=%d\n", aa, bb, xx, yy, ww);
	SUMMARIZE_STONE_ROOM(&bp2e,bb,xx,yy);	// SPX: light is precomputed within this function
	i16 bp16;
	X8 bp0b;
	U16 si;
	U16 bp10;
	U16 bp1e;
	ObjectID bp0a;
	U16 bp0e;
	switch (bp2e.w0) {
		case 0://^03A4
			//^24A5:03A4
			if ((ww & 4) == 0)
				break;
			bp16 = bp2e.w6[2];
			bp0b = X8(bp16 & 0xff);
			if (bp0b == 0xff)
				break;
			si = QUERY_GDAT_ENTRY_DATA_INDEX(9, bp0b, dtWordValue, 0xf8);	// SPX: A light value (wall actuator)?
			if (si == 0)
				break;
			bp10 = ((si & 0x8000) != 0) ? 1 : 0;
			si &= 0x7fff;
			if (QUERY_GDAT_ENTRY_DATA_INDEX(9, bp0b, dtWordValue, 0x63) != 0) {
				//^24A5:0408
				bp1e = BETWEEN_VALUE(0, glbRainAmbientLightModifier + glbRainSomeLightMod, 5);
				bp12 = (tLightLevelTable[RCJ(6,bp1e)] * si) / 0x64 +bp12;
				break;
			}
			//^24A5:043F
			if (bp10 != 0 && (bp16 >> 8) == 0)
				break;
			//^24A5:0452
			di += si;
			break;
		case 1://^0457
		case 2://^0457
		case 5://^0457
		case 16://^0457
		case 17://^0457
		case 18://^0457
		case 19://^0457
			//^24A5:0457
			if ((ww & 1) == 0)
				break;
			if (bp2e.w0 != 1 && bp2e.w0 != 2 && bp2e.w0 != 5)
				goto _0519;
			//^24A5:0476
			bp16 = bp2e.w6[2];
			bp0b = X8(bp16);
			if (bp0b == 0xff)
				goto _0519;
			si = QUERY_GDAT_ENTRY_DATA_INDEX(10, bp0b, dtWordValue, 0xf8);
			if (si == 0)
				break;
			bp10 = ((si & 0x8000) != 0) ? 1 : 0;
			si &= 0x7fff;
			//^24A5:04BA
			TELE_inf bp1c;
			if (GET_TELEPORTER_DETAIL(&bp1c, U8(xx), U8(yy)) != 0) {
				//^24A5:04D1
				bp1e = BETWEEN_VALUE(0, glbRainAmbientLightModifier + glbRainSomeLightMod, 5);
				bp12 = (tLightLevelTable[RCJ(6,bp1e)] * si) / 0x64 +bp12;
				goto _0519;
			}
			else {
				//^24A5:0507
				if (bp10 == 0 || (bp16 >> 8) != 0)
					di += si;
				//^24A5:0519
_0519:
				bp0a = bp2e.w4;
			}
			for (; bp0a != OBJECT_END_MARKER; bp0a = GET_NEXT_RECORD_LINK(bp0a)) {
				//^24A5:051F
				bp0e = bp0a.DBType();
				if (bp0e == dbCloud) {
					//^24A5:0530
					Cloud *bp04 = GET_ADDRESS_OF_RECORDF(bp0a);
					if (bp04->CloudType() != 2 && bp04->CloudType() != 0 && bp04->CloudType() != 0x30)
						continue;
					//^24A5:0565
					bp14 = (bp04->b3_0_f() >> 1) +bp14;
					continue;
				}
				//^24A5:057B
				if (bp0e == dbMissile) {
					Missile *bp08 = GET_ADDRESS_OF_RECORDE(bp0a);
					if (bp08->GetMissileObject() == OBJECT_EFFECT_FIREBALL) {	// oFF80
						bp14 += (i16(bp08->EnergyRemaining()) >> 1) - _4976_3d6d[3];
					}
				}
				//^24A5:05A9
			}
			//^24A5:05BE
			if ((ww & 2) != 0) {
				bp0a = GET_CREATURE_AT(xx, yy);
				if (bp0a != OBJECT_NULL) {
					si = QUERY_GDAT_DBSPEC_WORD_VALUE(bp0a, 0xf8);
					di = si & 0x7fff;
				}
			}
			break;
		case 3://^05EE
		case 4://^05EE
		case 6://^05EE
		case 7://^05EE
		case 8://^05EE
		case 9://^05EE
		case 10://^05EE
		case 11://^05EE
		case 12://^05EE
		case 13://^05EE
		case 14://^05EE
		case 15://^05EE
			break;
	}
	//^24A5:05EE
	// SPX: aa is distance between player and the current processed tile
	if (aa <= 8 && bp12 != 0) {
		bp12 = max_value(3, bp12 - _4976_3d5b[RCJ(9,aa)]);
	}
	else {
		bp12 = 0;
	}
	//^24A5:061A
	if (aa > 5)
		aa = 5;
	//^24A5:0625
	if (di != 0) {
		//^24A5:0629
		di = max_value(2, di - _4976_3d6d[RCJ(6,aa)]);
	}
	//^24A5:0640
	//printf("Calculting light: %d + %d + %d => %d\n", glbPrecomputedLight, di, bp12, glbPrecomputedLight + di + bp12);
	glbPrecomputedLight += di + bp12;

	//^24A5:0649
	if (bp14 != 0) {
		//^24A5:064F
		bp14 = max_value(2, bp14 - _4976_3d6d[RCJ(6,aa)]);
	}
	//^24A5:0668
	glbLightModifier += bp14;
	//^24A5:066F
	return;
}

//^19F0:266C
ObjectID SkWinCore::_19f0_266c(ObjectID rl, U16 dir, U16 ww, U16 bb)
{
	//^19F0:266C
	ENTER(8);
	//^19F0:2672
	ObjectID si = rl;
	ObjectID di = OBJECT_NULL;
	//^19F0:2678
	for (; si != OBJECT_END_MARKER && si != OBJECT_NULL; si = GET_NEXT_RECORD_LINK(si)) {
		//^19F0:267B
		U16 bp08 = si.DBType();
		if (bp08 == dbActuator) {
			//^19F0:268B
			if (si.Dir() != dir)
				continue;
			Actuator *bp04 = GET_ADDRESS_OF_RECORD(si)->castToActuator();
			U16 bp06 = bp04->ActuatorType();
			if (bp06 == 0 || bp06 == ACTUATOR_TYPE_SWITCH_SIGN_FOR_CREATURE)	// 0x26
				continue;
			//^19F0:26BA
			di = si;
			//^19F0:26BC
			if (bp06 != ACTUATOR_TYPE_KEY_HOLE) // 0x1a: 'Activator, key hole'
				continue;
			//^19F0:26C2
			if (bp04->OnceOnlyActuator() != 0) {
				//^19F0:26D3
				if (ww != 2)
					continue;
				if (CREATURE_CAN_HANDLE_IT(si, bb) == 0)
					continue;
				break;
			}
			else {
				//^19F0:26EA
				if (ww != 1)
					continue;
				if (CREATURE_CAN_HANDLE_IT(si, bb) == 0)
					continue;
				break;
			}
		}
		//^19F0:2701
		if (bp08 > dbActuator)
			break;
		//^19F0:2707
	}
	//^19F0:271D
	return di;
}
//^19F0:2723
X16 SkWinCore::_19f0_2723(ObjectID rl, U16 ww, U16 bb, X16 cc)
{
	//^19F0:2723
	ENTER(6);
	//^19F0:2729
	X16 si = ww;
	X16 di = 0;
	if (rl != OBJECT_END_MARKER && rl != OBJECT_NULL) {
		//^19F0:2740
		ATLASSERT(rl.DBType() == dbActuator);
		Actuator *bp04 = GET_ADDRESS_OF_RECORD(rl)->castToActuator();
		U16 bp06 = bp04->ActuatorType();
		switch (bp06) {
			case ACTUATOR_FLOOR_TYPE__EVERYTHING://^2775 // 0x01: -
			case ACTUATOR_TYPE_WALL_SWITCH://^2775 // 0x18: Activator, push button wall switch
				//^19F0:2775
				if (si == 0)
					//^19F0:2779
					di = 1;
				break;
			case ACTUATOR_TYPE_X02://^277E // 0x02: -
				//^19F0:277E
				if (si == 0 && bb != 0xffff)
					//^19F0:2779
					di = 1;
				break;
			case ACTUATOR_FLOOR_TYPE__PARTY://^278A // 0x03: Activator, trap floor
				//^19F0:278A
				if (si == 0)
					goto _27e2;
				break;
			case ACTUATOR_TYPE_2_STATE_WALL_SWITCH://^2790 // 0x17: Activator, 2 state wall switch
				//^19F0:2790
				if (si == 0) {
					if ((!bp04->OnceOnlyActuator()) != cc)
						//^19F0:2779
						di = 1;
				}
				break;
			case ACTUATOR_TYPE_X1B://^27AD // 0x1B: -
				//^19F0:27AD
				if (si == 1) {
					if (bp04->ActuatorData() != 0)
						//^19F0:27C3
						goto _27e2;
				}
				break;
			case ACTUATOR_TYPE_KEY_HOLE://^27C5 // 0x1A: Activator, key hole
				//^19F0:27C5
				if ((bp04->OnceOnlyActuator() != 0) ? (si == 2) : (si == 1)) {
					//^19F0:27E2
_27e2:
					di = CREATURE_CAN_HANDLE_IT(rl, bb);
				}
				break;
		}
	}
	//^19F0:27F1
	return di;
}

//^19F0:2813
U16 SkWinCore::_19f0_2813(U16 ww, i16 xx, i16 yy, i16 ss, i16 tt, i16 aa, U16 bb)
{
	//^19F0:2813
	ENTER(10);
	//^19F0:2819
	i16 di = ss;
	X16 bp06 = ww & 0x80;
	if (bp06 != 0)
		ww &= ~(0x80);
	//^19F0:282E
	if ((_4976_4ef4 & 1) != 0) {
		//^19F0:2839
		if (di == -1) {
			di = xx + glbXAxisDelta[aa];
			tt = yy + glbYAxisDelta[aa];
			goto _286d;
		}
		//^19F0:285D
		else if (xx != di || yy != tt) {
			//^19F0:286D
_286d:
			if (di >= 0 && di < glbCurrentMapWidth && tt >= 0 && tt < glbCurrentMapHeight) {
				//^19F0:2892
				if ((xx -di) == 0 && (yy -tt) == 0) {
					//^19F0:28A4
					if (aa == -1) {
						aa = CALC_VECTOR_DIR(xx, yy, di, tt);
					}
					//^19F0:28BF
					_19f0_045a(di, tt);
					if ((_4976_521c & 0x10) != 0) {
						//^19F0:28D7
						if (_4976_521e == OBJECT_NULL) {
							_4976_521e = GET_TILE_RECORD_LINK(glbCreatureSomeX, glbCreatureSomeY);
						}
						//^19F0:28F0
						ObjectID si = _4976_521e;
						X16 bp0a = 0;
						//^19F0:28F9
						Actuator *bp04;
						for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
							//^19F0:28FB
							X16 bp08 = si.DBType();
							if (bp08 > dbActuator)
								break;
							if (bp08 != dbActuator)
								continue;
							//^19F0:2911
							if (si.Dir() != ((aa +2)&3))
								continue;
							bp04 = GET_ADDRESS_OF_RECORD(si)->castToActuator();
							bp0a = (bp04->ActuatorType() == ACTUATOR_TYPE_SWITCH_SIGN_FOR_CREATURE) // 0x26 -> 'Switch sign for creature' or 'Activator, missile explosion'
								? 1
								: 0;
							if (bp0a != 0)
								break;
							//^19F0:294D
						}
						//^19F0:295B
						if (bp0a != 0) {
							if (bp04->ActuatorData() == glbCurrentThinkingCreatureRec->CreatureType()) {
								if (bp04->OnceOnlyActuator() != 0) {
									si = _19f0_266c(_4976_521e, (aa+2)&3, ww, bb);
									if (si != OBJECT_NULL) {
										//^19F0:29BA
										if (_19f0_2723(si, ww, bb, bp04->ActionType()) != 0) {
											//^19F0:29DD
											if (bp06 != 0 && _19f0_0559(aa) == 0) {
												//^19F0:29F5
												glbCurrentThinkingCreatureData->w24.SetX(di);
												glbCurrentThinkingCreatureData->w24.SetY(tt);
												glbCurrentThinkingCreatureData->w24.SetMap(glbCurrentMapIndex);
												glbCurrentThinkingCreatureData->b29 = 
												glbCurrentThinkingCreatureData->b27 = (X8)aa;
												glbCurrentThinkingCreatureData->ItemToThrow = (X8)bb;
												glbCurrentThinkingCreatureData->b32 = (X8)ww;
												//^19F0:2A45
												if (ww == 0) {
													glbCurrentThinkingCreatureData->Command = ccm2F;
												}
												//^19F0:2A52
												else if (ww == 1) {
													glbCurrentThinkingCreatureData->Command = ccm30;
												}
												else {
													glbCurrentThinkingCreatureData->Command = ccm31;
												}
												//^19F0:2A6C
												_4976_4ee5 = (ww == 0 && bp04->ActionType() < 2)
													? xactrAgain
													: xactrYes;
											}
											//^19F0:2A90
											return 1;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	//^19F0:2A95
	if (bp06 != 0)
		_4976_4ee5 = xactrNo;
	//^19F0:2AA0
	return 0;
}

//^19F0:0D10
U16 SkWinCore::_19f0_0d10(U16 ww,i16 xx,i16 yy,i16 ss,i16 tt,i16 aa)
{
	//^19F0:0D10
	ENTER(32);
	//^19F0:0D16
	ObjectID bp18;
	i16 di = ss;
	X16 bp06 = 0;
	U16 bp0e = ww & 0x80;
	if (bp0e != 0)
		ww &= 0xff7f;
	X16 si = ((ww == 0) ? 0x6f : 0x73) & _4976_4ef0;
	//^19F0:0D46
	if (si == 0)
		goto _123a;
    //^19F0:0D4F
	if (di == -1) {
		//^19F0:0D54
		di = xx + glbXAxisDelta[aa];
		tt = yy + glbYAxisDelta[aa];
	}
	//^19F0:0D73
	else if (aa == -1) {
		//^19F0:0D79
		aa = CALC_VECTOR_DIR(xx, yy, di, tt);
	}
	//^19F0:0D90
	else if (xx == di && yy == tt) {
		goto _123a;
	}
	//^19F0:0DA0
	if (di < 0 || di >= glbCurrentMapWidth || tt < 0 || tt >= glbCurrentMapHeight)
		goto _123a;
	//^19F0:0DC5
	if ((xx -di) != 0 && (yy -tt) != 0)
		goto _123a;
	//^19F0:0DD7
	X16 bp0a;
	_19f0_045a(di, tt);
	if ((_4976_521c >> 5) != 4)
		goto _123a;
	bp0a = (_4976_521c & 7);
	//^19F0:0DF8
	Door *door;	//*bp04
	if (ww == 0) {
		if (bp0a == 0) {
_0e04:
			bp06 = 1;
			goto _108f;
		}
	}
	//^19F0:0E0C
	else if (bp0a == 5) {
		goto _123a;
	}
	//^19F0:0E15
	else if (bp0a == 4) {
		goto _0e04;
	}
	//^19F0:0E1D
	if (_4976_521e == OBJECT_NULL) {
		//^19F0:0E24
		_4976_521e = GET_TILE_RECORD_LINK(di, tt);
	}
	//^19F0:0E32
	door = GET_ADDRESS_OF_RECORD0(_4976_521e);
	if (ww == 2 && door->Bit12() == 0)
		goto _123a;
	//^19F0:0E5C
	i16 bp10;
	i16 bp12;
	i16 bp14;
	U16 bp16;
	i16 bp08;
	if (door->Bit10() != 0) {
		//^19F0:0E6D
		if (door->Bit09() != 0) {
			if (ww == 0)
				goto _104f;
		}
		//^19F0:0E83
		else if (ww != 0) {
			goto _104f;
		}
		//^19F0:0E8C
		else if ((si &= 0xfff3) == 0) {
			goto _123a;
		}
	}
	//^19F0:0E99
	bp08 = CALC_SQUARE_DISTANCE(xx, yy, di, tt);
	if (bp08 == 1) {
		//^19F0:0EB3
		if ((si & 3) != 0) {
			//^19F0:0EB9
			if (door->Button() != 0)
				goto _0f9d;
			//^19F0:0ECD
			if (door->Bit13() != 0)
				goto _0f9d;
		}
		//^19F0:0EDE
		if (ww == 0) {
			//^19F0:0EE4
			if ((si & 4) != 0 && door->DestroyablebyFireball() != 0)
				goto _0f9d;
			//^19F0:0EFE
			if ((si & 8) != 0 && door->BashablebyChopping() != 0)
				goto _0f9d;
		}
		//^19F0:0F15
		if ((si & 0x40) != 0)
			goto _0f9d;
		goto _123a;
	}
	//^19F0:0F21
	if (glbAIDef->w20_c_f() < bp08)
		goto _123a;
	//^19F0:0F34
	if ((si & 1) != 0) {
		if (door->Button() != 0 || door->Bit13() != 0)
			goto _0f7f;
	}
	//^19F0:0F59
	if (ww != 0 || (si & 4) == 0)
		goto _123a;
	//^19F0:0F6B
	if (door->DestroyablebyFireball() == 0)
		goto _123a;
	//^19F0:0F7F
_0f7f:
	if (_19f0_0207(xx, yy, di, tt, &SkWinCore::_19f0_00b8) == 0)
		goto _123a;
	//^19F0:0F9D
_0f9d:
	if ((si & 1) != 0) {
		//^19F0:0FA6
		bp10 = xx;
		bp12 = yy;
		bp14 = bp08;
		for (; bp14 >= 0; ) {
			//^19F0:0FBB
			for (bp18 = GET_WALL_TILE_ANYITEM_RECORD(bp10, bp12); bp18 != OBJECT_END_MARKER; bp18 = GET_NEXT_RECORD_LINK(bp18)) {
				//^19F0:0FCB
				Cloud *bp20;
				bp16 = bp18.DBType();
				if (bp16 == dbMissile) {
					//^19F0:0FDC
					Missile *bp1c = GET_ADDRESS_OF_RECORDE(bp18);
					//^19F0:0FEB
					if (bp1c->GetMissileObject() != OBJECT_EFFECT_ZO_2 && bp1c->GetMissileObject() != OBJECT_EFFECT_ZO_SPELL) // != oFF8D && != oFF84
						continue;
					//^19F0:0FFC
					if (glbTimersTable[bp1c->TimerIndex()].Direction() != aa)
						continue;
					goto _104f;
				}
				//^19F0:101F
				else if (bp16 == dbCloud) {
					//^19F0:1025
					bp20 = GET_ADDRESS_OF_RECORDF(bp18);
					if (bp20->CloudType() != 13 && bp20->CloudType() != 4)
						continue;
					//^19F0:104F
_104f:
					bp06 = 2;
					goto _108f;
				}
				//^19F0:1056
			}
			//^19F0:106B
			bp10 += glbXAxisDelta[aa];
			bp12 += glbYAxisDelta[aa];
			bp14--;
			//^19F0:1086
		}
	}
	//^19F0:108F
_108f:
	if (bp06 != 0 && ww == 2)
		goto _123a;
	if (bp0e == 0)
		goto _1235;
	//^19F0:10A7
	if (aa == -1) {
		aa = CALC_VECTOR_DIR(xx, yy, di, tt);
	}
	//^19F0:10C2
	if (bp06 == 1) {
		//^19F0:10C8
		_4976_4ee5 = xactrYes;
		goto _1235;
	}
	//^19F0:10D0
	if (bp06 == 2) {
		//^19F0:10D6
		glbCurrentThinkingCreatureData->Command = ccmNeutral;
		goto _1230;
	}
	//^19F0:10E2
	if (_19f0_0559(aa) != 0)
		goto _1235;
	//^19F0:10F1
	if ((si & 0x20) != 0) {
		si &= 0xffdf;
		if (ww == 0) {
			//^19F0:1101
			door->Bit12(1);
		}
	}
	//^19F0:1109
	if (bp08 > 1)
		si &= 5;
	//^19F0:1113
	if ((si & 0x42) != 0) {
		if ((si & 0xffbd) == 0 || RAND02() == 0) {
			//^19F0:1128
			glbCurrentThinkingCreatureData->Command = ccm0B;
			goto _11d2;
		}
	}
	//^19F0:1134
	U16 bp0c;
	if ((si & 1) != 0) {
		//^19F0:113A
		if ((si & 0xffbc) == 0 || RAND02() == 0) {
			//^19F0:1149
			glbCurrentThinkingCreatureData->Command = (RAND01() != 0) ? ccmCastSpell2 : ccmCastSpell1;
			//^19F0:1160
			// SPX: 8D (unknow zo2?) replaced with 84 (open door zo1)
			glbCurrentThinkingCreatureData->ItemToThrow = (ww == 0) ? 0x8d : 0x84;
			goto _11d2;
		}
	}
	//^19F0:1176
	bp0c = glbAIAttacksSpells;
	if ((si & 8) != 0 && (bp0c & 1) != 0 && ((si & 0xffb4) == 0 || RAND01() != 0)) {
		//^19F0:1198
		glbAIAttacksSpells &= 1;
		goto _11af;
	}
	//^19F0:11A0
	if ((si & 4) == 0)
		goto _123a;
	//^19F0:11A9
	glbAIAttacksSpells &= 0x50;
	//^19F0:11AF
_11af:
	si = _19f0_0891(0x84, xx, yy, di, tt, aa);
	glbAIAttacksSpells = bp0c;
	//^19F0:11CE
	return si;
_11d2:
	glbCurrentThinkingCreatureData->w24.SetX(di);
	glbCurrentThinkingCreatureData->w24.SetY(tt);
	glbCurrentThinkingCreatureData->w24.SetMap(glbCurrentMapIndex);
    glbCurrentThinkingCreatureData->b29 = glbCurrentThinkingCreatureData->b27 = U8(aa);
	glbCurrentThinkingCreatureData->b28 = (U8(RAND01()) + U8(aa)) & 3;
	glbCurrentThinkingCreatureData->b32 = U8(ww);
	//^19F0:1230
_1230:
	_4976_4ee5 = xactrAgain;
	//^19F0:1235
_1235:
	return 1;
_123a:
	if (bp0e != 0)
		_4976_4ee5 = xactrNo;
	return 0;
}

//^0CEE:3275
X16 SkWinCore::_0cee_3275(U8 xx)
{
	//^0CEE:3275
	ENTER(0);
	//^0CEE:3278
	return QUERY_GDAT_ENTRY_DATA_INDEX(0x0e, xx, dtWordValue, 0x0d);
}

//^19F0:000A
U16 SkWinCore::_19f0_000a(i16 xx, i16 yy)
{
	//^19F0:000A
	ENTER(6);
	//^19F0:000F
	U16 bp06 = GET_TILE_VALUE(xx, yy);
	U16 si = bp06 >> 5;
	if (si == ttDoor) {
		Door *bp04 = GET_ADDRESS_OF_TILE_RECORD(U8(xx), U8(yy))->castToDoor();
		if ((bp06 & 7) == 4 && _0cee_3275(GET_GRAPHICS_FOR_DOOR(bp04)) == 0)
			return 1;
		//^19F0:0066
		return 0;
	}
	//^19F0:006A
	if (si != ttWall) {
		if (si != ttTrickWall)
			return 0;
		if ((bp06 & 4) != 0)
			return 0;
	}
	return 1;
}

//^1C9A:1BAE
//SPX: somewhat called when in bat caves
U16 SkWinCore::_1c9a_1bae(i16 xx, i16 yy)
{
	//^1C9A:1BAE
	ENTER(0);
	//^1C9A:1BB1
	if (glbCreatureTimerGetX == xx && glbCreatureTimerGetY == yy)
		return 0;
	//^1C9A:1BC9
	return _19f0_00b8(xx, yy);
	//^1C9A:1BD6
}

//^1C9A:1BD8
U16 SkWinCore::FIND_WALK_PATH(i16 xx, i16 yy, U16 aa, U16 bb, i16 cc, skxxx9 *ss, WalkPath *wp)
{
	// xx: x pos
	// yy: y pos
	// aa = 7
	// bb = 0
	// cc = 1
	// ss: array size is by cc
	// wp: array of size 5

#if DLV_CAI
	SkD((DLV_CAI, "CAI: (e) FIND_WALK_PATH(%2d,%2d,%04X,%04X,%2d,%p,x) \n", (Bitu)xx, (Bitu)yy, (Bitu)aa, (Bitu)bb, (Bitu)cc, ss));
	for (int t=0; t<cc; t++) {
		SkD((DLV_CAI, "       ) #%d (%2d,%2d,%2d) (%2d,%2d,%2d) (%2d,%2d,%2d) %02X %02X %02X %02X \n"
			, t
			, (Bitu)ss[t].w2.GetX(), (Bitu)ss[t].w2.GetY(), (Bitu)ss[t].w2.GetMap()
			, (Bitu)ss[t].w4.GetX(), (Bitu)ss[t].w4.GetY(), (Bitu)ss[t].w4.GetMap()
			, (Bitu)ss[t].w12.GetX(), (Bitu)ss[t].w12.GetY(), (Bitu)ss[t].w12.GetMap()
			, (Bitu)(U8)ss[t].b0
			, (Bitu)(U8)ss[t].b6
			, (Bitu)(U8)ss[t].b7
			, (Bitu)(U8)ss[t].b16
			));
	}
#endif
	//^1C9A:1BD8
	ENTER(132);
	//^1C9A:1BDE
	skxxx9 *bp0c = ss;
	//^1C9A:1BEC
	if (bp0c->b7 == 0) {
		//^1C9A:1BF5
		bp0c->w2.SetX(xx);
		//^1C9A:1C07
		bp0c->w2.SetY(yy);
		//^1C9A:1C1A
		bp0c->w2.SetMap(glbCurrentMapIndex);
		//^1C9A:1C2C
		bp0c->w4 = bp0c->w2;
		//^1C9A:1C34
		bp0c->b6 = 0;
		//^1C9A:1C39
		return 0;
	}
	//^1C9A:1C3E
	U32 bp64 = U32(cc) << 2;
	//^1C9A:1C4F
	i32 allocSizes[6] = {0,0,0,0,0,0};
	skxxxa *bp22 = reinterpret_cast<skxxxa *>(ALLOC_MEMORY_RAM(allocSizes[0] = bp64, afZeroMem, 1024));
	//^1C9A:1C69
	U8 (*bp08)[4] = (U8 (*)[4])ALLOC_MEMORY_RAM(allocSizes[1] = 1024, afDefault, 1024);
	//^1C9A:1C81
	U32 bp6c = sizeof(DistMapTile) * dunHeader->nMaps;
	//^1C9A:1C96
	DistMapTile (**bp1a)[1][32] = reinterpret_cast<DistMapTile (**)[1][32]>(ALLOC_MEMORY_RAM(allocSizes[2] = bp6c, afZeroMem, 1024));
	//^1C9A:1CB0
	U32 bp68;
	bp6c += (bp68 = dunHeader->nMaps << 1);
	//^1C9A:1CCA
	i16 *bp1e = reinterpret_cast<i16 *>(ALLOC_MEMORY_RAM(allocSizes[3] = bp68, afDefault, 1024));
	//^1C9A:1CE3
	U16 bp56 = 0;
	//^1C9A:1CE8
	FILL_U16(bp1e, dunHeader->nMaps, -1, 2);
	//^1C9A:1D05
	bp68 = sizeof(DistMapTile) * (U32(glbCurrentMapWidth) << 5);
	//^1C9A:1D1D
	DistMapTile (*bp04)[1][32] = reinterpret_cast<DistMapTile (*)[1][32]>(ALLOC_MEMORY_RAM(allocSizes[4] = bp68, afDefault, 1024));
	//^1C9A:1D36
	U16 bp48 = glbCurrentMapIndex;
	//^1C9A:1D3C
	bp1a[bp48] = bp04;
	//^1C9A:1D51
	bp6c += bp64 +bp68 +1024;
	//^1C9A:1D6A
	U16 bp52 = 0;
	U16 bp58 = 0;
	U16 si = 0;
	U16 bp34 = 0xffff;
	U8 bp38 = 0;
	U16 bp3e = MIN_EYE_DIST; // eye distance
	//^1C9A:1D84
	skxxxa *bp10 = bp22;
	//^1C9A:1D90
	bp0c = ss;
	//^1C9A:1D9C
	U16 bp0084;
	i16 bp3c;
	U16 bp7e;
	U16 bp80;
	U16 bp0082;
	X16 bp78;
	X16 bp7a;
	X16 bp7c;
	i16 di;
	for (di = 0; di < cc; bp10++, bp0c++, di++) {
		//^1C9A:1DA1
		bp0c->b6 = -1;
		//^1C9A:1DA9
		bp10->setX((i8)bp0c->w12.GetX());
		//^1C9A:1DB6
		bp10->setY((i8)bp0c->w12.GetY());
		//^1C9A:1DCA
		bp10->setMap((i8)bp0c->w12.GetMap());
		//^1C9A:1DDE
		bp38 |= (bp0c->b16 = _4976_3932[RCJ(28,bp0c->b7)]);
		//^1C9A:1DF6
		switch (bp0c->b7) {
			case  3:
				//^1C9A:1E0D
				bp7e = glbCurrentThinkingCreatureData->w12.GetX();
				bp80 = glbCurrentThinkingCreatureData->w12.GetY();
				bp0082 = glbCurrentThinkingCreatureData->w12.GetMap();
				//^1C9A:1E36
				if (true
					&& bp7e == glbCreatureMap
					&& bp80 == glbCreaturePosX
					&& bp0082 == glbCreaturePosY
				) {
					//^1C9A:1E52
					bp0c->b16 ^= 3;
				}
				//^1C9A:1E5A
_1e5a:
				bp52 = 1;
				//^1C9A:1E5F
				break;

			case 12:
				//^1C9A:1E62
				bp10->setDist((bp10->getMap() == glbCurrentMapIndex)
					? max_value(1, CALC_SQUARE_DISTANCE(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), bp10->getX(), bp10->getY()))
					: 100);
				//^1C9A:1EA4
				goto _1e5a;

			case 11:
				//^1C9A:1EA6
				goto _1e5a;

			case  1:
				//^1C9A:1EA8
				bp78 = glbCurrentThinkingCreatureRec->TriggerX();
				//^1C9A:1EB6
				bp7a = glbCurrentThinkingCreatureRec->TriggerY();
				//^1C9A:1EC3
				bp7c = glbCurrentThinkingCreatureRec->TriggerMap();
				//^1C9A:1ED0
				goto _1e5a;

			case  5:
				//^1C9A:1ED2
				bp10->setDist(U8(max_value((glbCurrentMapIndex == glbCreatureMap) ? CALC_SQUARE_DISTANCE(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), glbCreaturePosX, glbCreaturePosY) : 100, bp0c->w8)));
				//^1C9A:1F12
				break;

			case  8:
			case  9:
				//^1C9A:1F14
				bp58 = 1;

				goto _1f19;

			case  6:
			case  7:
			case 10:
				//^1C9A:1F19
_1f19:
				bp0084 = glbAIAttacksSpells;
				//^1C9A:1F20
				break;

			case 23:
				//^1C9A:1F22
				_4976_4eec = 0x0227;
				glbPrecomputedLight = 0;
				glbLightModifier = 0;
				//^1C9A:1F34
				break;

			case 24:
				//^1C9A:1F36
				bp10->setDist(127);
				break;

			case  2:
			case  4:
			case 13:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:

				break;
		}
		//^1C9A:1F3E
		U16 bp70 = 0;
		U16 bp6e = 0;
		do {
			//^1C9A:1F46
			if ((_4976_3932[RCJ(28,bp0c->b7)] & 0x20) != 0) {
				//^1C9A:1F5A
				bp6e = (glbGlobalSpellEffects.Invisibility != 0 && (glbAIDef->w0_a_a() == 0) ? 1 : 0);
				//^1C9A:1F76
				if (bp6e == 0) {
					//^1C9A:1F7A
					bp70 = (glbLightLevel != 0 && glbGlobalSpellEffects.Light < 0 && (glbAIDef->w0_b_b() == 0) ? 1 : 0);
					//^1C9A:1F9D
					if (bp70 == 0) {
						//^1C9A:1FA1
						break;
					}
				}
				//^1C9A:1FA4
				bp3c = (glbSomeMap_4976_4ee7 == glbCreatureMap)
					? CALC_SQUARE_DISTANCE(glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreaturePosX, glbCreaturePosY)
					: CALC_SQUARE_DISTANCE(
						dunMapsHeaders[glbSomeMap_4976_4ee7].MapOffsetX() +glbCreatureTimerGetX,
						dunMapsHeaders[glbSomeMap_4976_4ee7].MapOffsetY() +glbCreatureTimerGetY,
						dunMapsHeaders[glbCreatureMap].MapOffsetX() +glbCreaturePosX,
						dunMapsHeaders[glbCreatureMap].MapOffsetY() +glbCreaturePosY
					);
				//^1C9A:2040
				U16 bp76 = RAND();
				//^1C9A:2048
				if (true
					&& (bp76 & 0x8000) == 0
					&& (false
						|| bp3c == 0 
						||(bp3c == 1 && CALC_VECTOR_DIR(glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreaturePosX, glbCreaturePosY) == glbCurrentThinkingCreatureRec->b15_0_1()))
				) {
					//^1C9A:2088
					break;
				}
				//^1C9A:208A
				if (false
					|| bp3c > 4
					||(bp6e != 0 && ((bp76 & 15) -(4 -bp3c) <= (glbAIDef->w20 & 15) || (bp76 & 0x4000) != 0))
					||(bp70 != 0 && ((glbLightLevel * bp3c) -((bp76 >> 8) & 7) > (glbAIDef->w20 & 15)))
				) {
					//^1C9A:20E3
					if ((bp76 & 0x0070) != 0) {
						//^1C9A:20EA
						bp0c->b0 = -1;
					}
					else {
						//^1C9A:20F3
						bp0c->b0 >>= 3;
					}
				}
			}
		} while (false);

		//^1C9A:20FA
		U16 bp2c = bp0c->b0;
		//^1C9A:2104
		if ((bp0c->b16 & 2) != 0)
			//^1C9A:210B
			bp2c++;
		//^1C9A:210E
		bp3e = max_value(bp3e, bp2c);
		//^1C9A:211E
	}
	//^1C9A:212F
	U16 bp5a = _4976_4eec & 0x2000;
	//^1C9A:2138
	X16 bp5c;
	X16 bp5e;
	if (bp5a != 0) {
		//^1C9A:213C
		bp5a = _4976_4eec & 0x0118;
		//^1C9A:2145
		if (bp5a != 0) {
			//^1C9A:2149
			bp5c = _4976_4eec & 0x0110;
			bp5e = _4976_4eec & 0x0108;
		}
	}
	//^1C9A:215B
	if (bp58 != 0 || bp3e != 0) {
		//^1C9A:2167
		ZERO_MEMORY(bp04, bp68);
	}
	//^1C9A:217B
	U16 bp2a = 0;
	U16 bp28 = 0;
	i16 bp2c = 0;
	//^1C9A:2188
	U16 bp46 = glbCurrentMapIndex;
	i16 bp12;
	i16 bp42;
	bp12 = bp42 = xx;
	i16 bp14;
	i16 bp44;
	bp14 = bp44 = yy;
	//^1C9A:21A0
	i16 bp32 = 1;
	i16 bp30 = -1;
	U8 bp37 = 0;
	U16 bp50 = 0xffff;
	//^1C9A:21B3
	_19f0_045a(bp12, bp14);
	//^1C9A:21C0
	X16 bp4c;
	X16 bp4e;
	if (bp52 != 0) {
		//^1C9A:21C9
		_4976_5225 = GET_TELEPORTER_DETAIL(&_4976_5226, U8(bp12), U8(bp14));
		//^1C9A:21DE
		if (_4976_5225 != 0) {
			//^1C9A:21E5
			bp50 = _4976_5226.b4;
			bp4c = _4976_5226.b2;
			bp4e = _4976_5226.b3;
		}
	}
	X16 bp40 = 0; // defaulting to 0
	i16 bp3a;
	ObjectID bp36;
	U16 bp16;
	DistMapTile bp74;
	// SPX: There is a BIG do-while after, and goto _25f9 jumps directly in the middle of this!...
	goto _25f9;
	//^1C9A:2200
	do {
		bp42 = bp08[bp2a][0];
		bp44 = bp08[bp2a][1];
		bp46 = bp08[bp2a][2];	// current map
		//^1C9A:223B
		bp2a = (bp2a +1) & 255;
		//^1C9A:2245
		if (bp46 != glbCurrentMapIndex) {
			//^1C9A:224E
			_1c9a_0648(bp46);
			//^1C9A:2256
			bp04 = bp1a[bp46];
		}
		//^1C9A:226E
		// SPX: whoa, this would looks like a distance map 2D array!
		bp2c = (*bp04)[bp42][bp44].distance;
		//^1C9A:2289
		if (bp2c > i16(bp3e))
			//^1C9A:228E
			break;
		//^1C9A:2291
		if (bp2c > 6)
			//^1C9A:2297
			aa |= 0x0040;
		//^1C9A:229C
		if ((aa & 0xff1f) == 5 && bp2c > 1) {
			//^1C9A:22AD
			aa = (aa & 0x00e0) | 0x0004;
		}
		//^1C9A:22B9
		bp40 = _4976_3930 & 1;
		//^1C9A:22C2
		if (bp40 == 0)
			//^1C9A:22C6
			bp40--;
		//^1C9A:22C9
		if ((_4976_3930 & 1) != 0) {
			//^1C9A:22D1
			_4976_3930 = (_4976_3930 >> 1) ^ 0xB400;
		}
		else {
			//^1C9A:22DE
			_4976_3930 >>= 1;
		}
		//^1C9A:22E2
		bp30 = _4976_3930 & 3;
		//^1C9A:22EB
		for (bp32 = (bp5a != 0) ? 7 : 5; --bp32 != 0 && ((bp28 +1) & 255) != bp2a; bp30 = (bp30 +bp40) & 3) {
			//^1C9A:2301
			if (bp46 != glbCurrentMapIndex) {
				//^1C9A:230A
				_1c9a_0648(bp46);
				//^1C9A:2312
				bp04 = bp1a[bp46];
			}
			//^1C9A:232A
			if (bp5a != 0 && bp32 <= 2) {
				//^1C9A:2336
				if (bp32 == 2) {
					//^1C9A:233C
					if (bp5e == 0)
						//^1C9A:2342
						continue;
					//^1C9A:2345
					bp30 = 5;
				}
				//^1C9A:234C
				else if (bp5c == 0) {
					//^1C9A:2352
					continue;
				}
				else {
					//^1C9A:2355
					bp30 = 4;
				}
				//^1C9A:235A
				bp12 = bp42;
				bp14 = bp44;
			}
			else {
				//^1C9A:2368
				bp12 = bp42 + glbXAxisDelta[bp30];
				bp14 = bp44 + glbYAxisDelta[bp30];
				//^1C9A:2386
				if (bp12 < 0 || bp12 >= glbCurrentMapWidth || bp14 < 0 || bp14 >= glbCurrentMapHeight) {
					//^1C9A:23AD
					continue;
				}
			}
			//^1C9A:23B0
			_4976_5224 = 0;
			//^1C9A:23B5
			bp37 = (*bp04)[bp12][bp14].distance;
			//^1C9A:23D0
			if (bp37 == 0 || bp30 >= 4) {
				//^1C9A:23DD
				//SkD((DLV_CAI, "CAI: -w- %d,%2d (%2d,%2d) -> (%2d,%2d) \n"
				//	, (Bitu)bp2c, (Bitu)bp28, (Bitu)bp42, (Bitu)bp44, (Bitu)bp12, (Bitu)bp14
				//	));
				if (CREATURE_GO_THERE(aa, bp42, bp44, bp12, bp14, bp30) == 0) {
					//^1C9A:23FB
					bp37 = 0xff;
				}
				else {
					//^1C9A:2402
					bp50 = 0xffff;
					//^1C9A:2407
					if (glbCreatureSomeZMap != glbCurrentMapIndex) {
						//^1C9A:2413
						if (bp1a[glbCreatureSomeZMap] == NULL) {
							//^1C9A:2427
							bp68 = ((dunMapsHeaders[glbCreatureSomeZMap].RawColumn() +1) << 5) << 2;
							//^1C9A:244C
							bp68 += 200;
							//^1C9A:2459
							if (i32(bp68) > glbFreeRAMMemPool) {
								//^1C9A:246D
								bp3a = ALLOC_TEMP_CACHE_INDEX();
								//^1C9A:2475
								ALLOC_CPXHEAP_MEM(bp3a, bp68);
								//^1C9A:2486
								for (bp3c = 0; dunHeader->nMaps > bp3c; bp3c++) {
									//^1C9A:248D
									if (bp1e[bp3c] < 0)
										//^1C9A:249B
										continue;
									//^1C9A:249D
									bp1a[bp3c] = reinterpret_cast<DistMapTile (*)[1][32]>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp1e[bp3c]));
									//^1C9A:24CB
								}
								//^1C9A:24DD
								bp1e[glbCreatureSomeZMap] = bp3a;
								bp56 = 1;
								bp04 = reinterpret_cast<DistMapTile (*)[1][32]>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp3a));
								ZERO_MEMORY(bp04, bp68);
							}
							else {
								//^1C9A:2517
								// SPX: I added this because I hit sometime the ATLASSERT and don't know the reason.
								if (SkCodeParam::bUseFixedMode && allocSizes[5] != 0){
									DEALLOC_UPPER_MEMORY(allocSizes[5]);
									allocSizes[5] = 0;
								}
								ATLASSERT(allocSizes[5] == 0);
								bp04 = reinterpret_cast<DistMapTile (*)[1][32]>(ALLOC_MEMORY_RAM(allocSizes[5] = bp68, afZeroMem, 1024));
								//^1C9A:2531
								bp6c += bp68;
							}
							//^1C9A:253D
							bp1a[glbCreatureSomeZMap] = bp04;
						}
						//^1C9A:2555
						if (bp30 < 4) {
							//^1C9A:255B
							bp50 = glbCurrentMapIndex;
						}
						//^1C9A:2561
						_1c9a_0648(glbCreatureSomeZMap);
						//^1C9A:256A
						bp04 = bp1a[glbCurrentMapIndex];
					}
					else {
						//^1C9A:2584
						if (bp30 < 4) {
							//^1C9A:258A
							if (_4976_5225 != 0) {
								//^1C9A:2591
								bp50 = _4976_5226.b4;
								bp4c = _4976_5226.b2;
								bp4e = _4976_5226.b3;
								
							}
							//^1C9A:25A8
							else if (glbCreatureSomeX != bp12 || glbCreatureSomeY != bp14) {
								//^1C9A:25B8
								bp50 = glbCurrentMapIndex;
							}
						}
					}
					//^1C9A:25BE
					bp4c = bp12;
					//^1C9A:25C7
					bp4e = bp14;
					//^1C9A:25CA
					bp37 = 0;
				}
			}
			//^1C9A:25CE
			if (bp37 != 0) {
				//^1C9A:25D4
				//^1C9A:2ECE
				i8 bp5f;
				if (bp37 == 0xff && bp30 < 4) {
					//^1C9A:2EE0
					bp5f = _4976_5224;
					bp37 = U8(bp2c);
					//^1C9A:2EEF
					if ((bp38 & 2) != 0) {
						//^1C9A:2EFA
						if ((bp38 & 8) != 0)
							//^1C9A:2F00
							_19f0_045a(bp12, bp14);
						//^1C9A:2F0D
						bp0c = ss;
						//^1C9A:2F19
						for (di = 0; di < cc; di++, bp0c++) {
							//^1C9A:2F1E
							if (bp0c->b0 +1 < bp2c || (bp0c->b16 & 2) == 0)
								continue;
							//^1C9A:2F3D
							U16 bp4a;
							X16 bp6e;
							X16 bp70;
							Creature *bp26 ;
							switch (bp0c->b7) {
								case  3:
									//^1C9A:2F58
									si = (glbCurrentMapIndex == glbCreatureMap && bp12 == glbCreaturePosX && bp14 == glbCreaturePosY) ? 1 : 0;
									//^1C9A:2F7C
									break;

								case  2:
									//^1C9A:2F7F
									if (glbCurrentMapIndex != glbCreatureMap || bp12 != glbCreaturePosX || bp14 != glbCreaturePosY)
										//^1C9A:2FA0
										break;
									//^1C9A:2FA3
									switch (bp0c->w8) {
										default:
											//^1C9A:2FB4
											break;

										case 1:
											//^1C9A:2FB7
											if (false
												|| bp0c->w10 == 0
												||(bp0c->w10 & (1 << ((U8(CALC_VECTOR_DIR(glbCreaturePosX, glbCreaturePosY, bp42, bp44)) - glbCreatureDir) & 3))) != 0
											) {
												//^1C9A:2FED
												goto _31c0;
											}
											//^1C9A:2FF0
											bp37 = 0xff;
											//^1C9A:2FF4
											break;

										case 3:
											//^1C9A:2FF7
											bp4a = GET_TILE_VALUE(bp12 + glbXAxisDelta[bp30], bp14 + glbYAxisDelta[bp30]);
											//^1C9A:301D
											if ((bp4a >> 5) == ttPit && (bp4a & 8) != 0 && (bp4a & 1) == 0)
												//^1C9A:3032
												goto _31c0;
											//^1C9A:3035
											bp37 = 0xff;
											//^1C9A:3039
											break;
									}
									break;

								case  8:
									//^1C9A:303C
									if ((_4976_521c >> 5) == 0)
										//^1C9A:3046
										break;

									goto _3049;

								case  9:
									//^1C9A:3049
		_3049:
									glbAIAttacksSpells &= bp0c->w10;
									//^1C9A:3054
									si = _19f0_05e8(bp0c->w8, bp04, &bp0c->w2, bp42, bp44, bp30, (bp0c->b7 == 9) ? 1 : 0);
									//^1C9A:308C
									if (si != 0) {
										//^1C9A:3090
										bp0c->w4.SetX(glbCreatureSomeX);
										//^1C9A:30A2
										bp0c->w4.SetY(glbCreatureSomeY);
										//^1C9A:30B5
										bp0c->w4.SetMap(glbCreatureSomeZMap);
										//^1C9A:30C7
										bp0c->b6 = (*(bp1a[glbCreatureSomeZMap]))[glbCreatureSomeX][glbCreatureSomeY].distance -1;
									}
									//^1C9A:30F1
									glbAIAttacksSpells = bp0084;
									//^1C9A:30F8
									break;

								case 15:
								case 17:
									//^1C9A:30FB
									si = _19f0_2165(0, bp42, bp44, bp12, bp14, bp30, bp0c->w8);
									//^1C9A:311D
									if (si == 0 && _4976_522c != 0)
										//^1C9A:312E
										bp37 = 0xff;
									//^1C9A:3132
									break;

								case 19:
									//^1C9A:3135
									if ((glbCurrentThinkingCreatureRec->b15 & 3) != bp30)
										//^1C9A:3145
										break;

									goto _3148;

								case 18:
									//^1C9A:3148
		_3148:
									if ((bp36 = _19f0_050f()) == OBJECT_END_MARKER)
										//^1C9A:3155
										break;
									//^1C9A:3158
									bp26 = GET_ADDRESS_OF_RECORD4(bp36);
									//^1C9A:3169
									if (bp26->CreatureType() != bp0c->w8)
										//^1C9A:317A
										break;
									//^1C9A:317D
									si = (bp0c->w10 == 1) ? 1 : 0;
									//^1C9A:318D
									if (si != 0)
										//^1C9A:3191
										break;
									//^1C9A:3194
									if (bp0c->w10 == 2) {
										//^1C9A:319E
										for (bp36 = bp26->GetPossessionObject(); bp36 != OBJECT_END_MARKER; bp36 = GET_NEXT_RECORD_LINK(bp36)) {
											//^1C9A:31A7
											if (bp36.DBType() != dbMissile && bp36.Dir() != bp30) {
												//^1C9A:31C0
		_31c0:
												si = 1;
												//^1C9A:31C3
												break;
											}
											//^1C9A:31C6
										}
										//^1C9A:31D8
										break;
									}
									//^1C9A:31DB
									bp6e = bp12 + glbXAxisDelta[bp30];
									//^1C9A:31EA
									bp70 = bp14 + glbYAxisDelta[bp30];
									//^1C9A:31F9
									if (glbCurrentMapIndex != glbCreatureMap || bp6e != glbCreaturePosX || bp70 != glbCreaturePosY) {
										//^1C9A:3214
										bp36 = GET_CREATURE_AT(bp6e, bp70);
										//^1C9A:3223
										si = (bp36 != OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp36) & 1) == 0) ? 1 : 0;
									}
									else {
										//^1C9A:3236
										si = 1;
									}
									//^1C9A:323F
									if (si == 0)
										//^1C9A:3246
										bp37 = 0xff;
									//^1C9A:324A
									break;

								case 20:
									//^1C9A:324D
									bp36 = _19f0_050f();
									//^1C9A:3255
									if (bp36 == OBJECT_END_MARKER)
										//^1C9A:325A
										break;
									//^1C9A:325D
									if (CREATURE_CAN_HANDLE_IT(bp36, bp0c->w8) == 0)
										//^1C9A:3271
										break;
									//^1C9A:3274
									_1c9a_19d4(bp36, bp12, bp14, bp0c->w10);
									//^1C9A:328B
									si = 1;
									//^1C9A:328E
									break;

								case 22:
									//^1C9A:3291
									if ((_4976_521c & 16) == 0)
										//^1C9A:3298
										break;
									//^1C9A:329B
									si = _19f0_2813(bp0c->w10, bp42, bp44, bp12,bp14,bp30,bp0c->w8);
									//^1C9A:32BF
									if (si==0)
										//^1C9A:32C3
										bp37=0xff;
									//^1C9A:32C7
									break;

								case 23:
									//^1C9A:32C9
									if ((_4976_521c & 16)!=0){
										//^1C9A:32D0
										// SPX: bp2c = distance
										ADD_BACKGROUND_LIGHT_FROM_TILE(bp2c,bp30,bp12,bp14,4);
										//^1C9A:32E6
										bp37=0xff;
									}
									//^1C9A:32EA
									break;

								case 26:
									//^1C9A:32EC
									if (bp0c->w8 == 1 && (glbCurrentMapIndex != glbCreatureMap || bp12 != glbCreaturePosX || bp14 != glbCreaturePosY))
										//^1C9A:330F
										break;
									//^1C9A:3311
									if (_19f0_0d10(bp0c->w10,bp42,bp44,bp12,bp14,bp30)!=0)
										//^1C9A:3333
										si=1;

									break;

								case  4:
								case  5:
								case  6:
								case  7:
								case 10:
								case 11:
								case 12:
								case 13:
								case 14:
								case 16:
								case 21:
								case 24:
								case 25:

									break;
							}
							//^1C9A:3336
							if (si != 0)
								break;
							//^1C9A:333A
						}
					}
					//^1C9A:3347
					if (bp5f == 0) {
						//^1C9A:334F
						(*bp04)[bp12][bp14].distance = bp37;
					}
				}
				goto _3368;
			}
			//^1C9A:25D7
			if ((*bp04)[bp12 = glbCreatureSomeX][bp14 = glbCreatureSomeY].distance != 0) {
				//^1C9A:25F6
				continue;
			}
			//^1C9A:25F9
	_25f9:
			bp16 = glbCurrentMapIndex;
			//^1C9A:25FF
			U16 bp54;
			if ((bp38 & 1) != 0) {
				//^1C9A:260D
				bp10 = bp22;
				bp0c = ss;
				//^1C9A:2625
				for (di = 0; di < cc; di++, bp0c++, bp10++) {
					//^1C9A:262A
					if (bp0c->b0 < bp2c || (bp0c->b16 & 1) == 0)
						//^1C9A:2645
						continue;
					//^1C9A:2648
					switch (bp0c->b7) {
						case  0:
							//^1C9A:2661
							si = 1;
							//^1C9A:2664
							break;

						case  2:
							//^1C9A:2667
							switch (bp0c->w8) {
								case 4:
									//^1C9A:2701
									if (bp0c->w10 != CALC_SQUARE_DISTANCE(bp12, bp14, glbCreaturePosX, glbCreaturePosY))
										//^1C9A:2720
										break;
									//^1C9A:2723
									if ((bp12 - glbCreaturePosX == 0 || bp14 - glbCreaturePosY == 0) && _19f0_0207(glbCreaturePosX, glbCreaturePosY, bp12, bp14, &SkWinCore::_1c9a_1bae) != 0)
										//^1C9A:2755
										break;
									//^1C9A:2758
									si = 1;
									//^1C9A:275B
									break;

								case 0:
									//^1C9A:2682
									si = (glbCurrentMapIndex == glbCreatureMap && bp12 == glbCreaturePosX && bp14 == glbCreaturePosY) ? 1 : 0;
									//^1C9A:26A4
									//^1C9A:2D9B
									break;

								case 2:
									//^1C9A:26A7
									if (CALC_VECTOR_DIR(glbCreaturePosX, glbCreaturePosY, bp12, bp14) != glbCreatureDir)
										//^1C9A:26C3
										break;
									//^1C9A:26C6
									bp3c = _19f0_0207(glbCreaturePosX, glbCreaturePosY, bp12, bp14, &SkWinCore::_19f0_000a);
									//^1C9A:26E5
									if (bp3c <= 0)
										//^1C9A:26E9
										break;
									//^1C9A:26EC
									if (bp0c->w10 < bp3c)
										//^1C9A:26F8
										break;
									//^1C9A:26FB
									si = 1;
									//^1C9A:26FE
									break;

								default:
									//^1C9A:267F
									break;
							}
							break;

						case  7:
							//^1C9A:275E
							if (bp16 != glbCreatureMap)
								//^1C9A:2767
								break;
							//^1C9A:276A
							glbAIAttacksSpells &= bp0c->w10;
							//^1C9A:2775
							si = _19f0_0891(0, bp12, bp14, glbCreaturePosX, glbCreaturePosY, -1);
							//^1C9A:2791
							glbAIAttacksSpells = bp0084;
							//^1C9A:2798
							break;

						case  6:
							//^1C9A:279B
							if (bp16 != glbCreatureMap)
								//^1C9A:27A4
								break;
							//^1C9A:27A7
							glbAIAttacksSpells &= bp0c->w10;
							//^1C9A:27B2
							si = _19f0_0891(1, bp12, bp14, glbCreaturePosX, glbCreaturePosY, -1);
							//^1C9A:27CE
							glbAIAttacksSpells = bp0084;
							//^1C9A:27D5
							break;

						case  8:
						case  9:
							//^1C9A:27D8
							if (bp0c->b0 != bp2c)
								//^1C9A:27E4
								break;
							//^1C9A:27E7
							glbAIAttacksSpells &= aa;
							//^1C9A:27EF
							si = _19f0_05e8(bp0c->w8, bp04, &bp0c->w2, bp12, bp14, -1, (bp0c->b7 == 9) ? 1 : 0);
							//^1C9A:2826
							if (si != 0) {
								//^1C9A:282A
								bp0c->w2.SetX(glbCreatureSomeX);
								//^1C9A:283C
								bp0c->w2.SetY(glbCreatureSomeY);
								//^1C9A:284F
								bp0c->w2.SetMap(glbCreatureSomeZMap);
								//^1C9A:2861
								bp0c->b6 = (glbCreatureSomeX == bp12 && glbCreatureSomeY == bp14 && glbCreatureSomeZMap == bp16) 
									? bp2c
									:((*(bp1a[glbCreatureSomeZMap]))[glbCreatureSomeX][glbCreatureSomeY].distance -1);
							}
							//^1C9A:28A8
							glbAIAttacksSpells = bp0084;
							//^1C9A:28AF
							break;

						case 24:
							//^1C9A:28B2
							if ((_4976_521c & 0x10) == 0)
								//^1C9A:28B9
								break;
							//^1C9A:28BC
							bp3c = _1c9a_1b16(bp0c->w8, bp0c->w10);
							//^1C9A:28D0
							if (bp3c == -1)
								//^1C9A:28D5
								break;
							//^1C9A:28D8
							if (bp10->getDist() <= bp3c)
								//^1C9A:28E5
								break;
							//^1C9A:28E8
							if (bp3c == 0 || bp10->getDist() < 127 || bp0c->b0 == 0) {
								//^1C9A:28FE
								si = 1;
								//^1C9A:2901
								bp0c->b16 = bp0c->b16 & 0xfb;
								//^1C9A:290E
								break;
							}
							//^1C9A:2911
							bp10->setDist(i8(bp3c));
							//^1C9A:291B
							break;

						case 25:
							//^1C9A:291E
							if (false
								|| bp30 == -1
								|| (_4976_521c & 0x10) == 0 
								|| (bp3c = _1c9a_1a48(1, _4976_4ef8)) == 0xffff
								|| (bp3c & (1 << ((bp30 +2) & 3))) != 0
							) {
								//^1C9A:295B
								break;
							}
							//^1C9A:295E
							si = 1;
							//^1C9A:2961
							break;

						case 10:
							//^1C9A:2964
							if (bp16 != glbCreatureMap || (_4976_37a6[RCJ(86,_4976_4ee4)] & 3) != 0)
								//^1C9A:2982
								break;
							//^1C9A:2985
							glbAIAttacksSpells &= bp0c->w10;
							//^1C9A:2990
							si = _19f0_0891(0, bp12, bp14, -1, -1, glbCurrentThinkingCreatureRec->b15_0_1());
							//^1C9A:29B2
							glbAIAttacksSpells = bp0084;
							//^1C9A:29B9
							break;

						case  4:
							//^1C9A:29BC
							if (bp16 != glbCreatureMap || (CALC_SQUARE_DISTANCE(bp12, bp14, glbCreaturePosX, glbCreaturePosY) +8) != 2)
								//^1C9A:29E3
								break;
							//^1C9A:29E6
							si = 1;
							//^1C9A:29E9
							break;

						case 15:
						case 16:
							//^1C9A:29EC
							si = _19f0_2165(0, bp12, bp14, bp12, bp14, -1, bp0c->w8);
							//^1C9A:2D99
							//^1C9A:2D9B
							break;

						case  5:
							//^1C9A:2A0E
							if (bp0c->w12.IsValid())
								//^1C9A:2A18
								goto _2b85;
							//^1C9A:2A1B
							if (bp0c->b6 <= 0) {
								//^1C9A:2A25
								bp54 = 1;
							}
							else {
								//^1C9A:2A2C
								if ((_4976_3930 & 1) != 0) {
									//^1C9A:2A34
									_4976_3930 = (_4976_3930 >> 1) ^ 0xB400;
								}
								else {
									//^1C9A:2A41
									_4976_3930 >>= 1;
								}
								//^1C9A:2A45
								bp54 = ((_4976_3930 & 7) == 0) ? 1 : 0;
							}
							//^1C9A:2A57
							if (bp54 == 0)
								//^1C9A:2A5D
								break;
							//^1C9A:2A60
							if (bp16 == glbCreatureMap) {
								//^1C9A:2A69
								bp3c = CALC_SQUARE_DISTANCE(bp12, bp14, glbCreaturePosX, glbCreaturePosY);
							}
							else {
								//^1C9A:2A82
								bp3c = CALC_SQUARE_DISTANCE(
									dunMapsHeaders[bp16].MapOffsetX() +bp12,
									dunMapsHeaders[bp16].MapOffsetY() +bp14,
									dunMapsHeaders[glbCreatureMap].MapOffsetX() + glbCreaturePosX,
									dunMapsHeaders[glbCreatureMap].MapOffsetY() + glbCreaturePosY
									)
									<< ((dunMapsHeaders[bp16].Level() != dunMapsHeaders[glbCreatureMap].Level()) ? 1 : 0);
							}
							//^1C9A:2B20
							if (bp10->getDist() <= bp3c)
								//^1C9A:2B2E
								break;
							//^1C9A:2B31
							if (bp16 == glbCreatureMap && bp3c < 5 && (bp12 - glbCreaturePosX == 0 || bp14 - glbCreaturePosY == 0) && _19f0_0207(glbCreaturePosX, glbCreaturePosY, bp12, bp14, &SkWinCore::_1c9a_1bae) != 0)
								//^1C9A:2B72
								break;
							//^1C9A:2B75
							si = 1;
							//^1C9A:2B78
							bp10->setDist(i8(bp3c));
							//^1C9A:2B82
							break;

						case 11:
							//^1C9A:2B85
	_2b85:
							if (false
								|| (bp10->getMap() == bp16 && bp10->getX() == bp12 && bp10->getY() == bp14)
								|| (bp10->getMap() == bp50 && bp10->getX() == bp4c && bp10->getY() == bp4e)
							) {
								//^1C9A:2BCE
								si = 1;
							}
							//^1C9A:2BD1
							break;

						case 12:
							//^1C9A:2BD4
							if (false
								|| bp10->getMap() != bp16
								||(bp3c = CALC_SQUARE_DISTANCE(bp12, bp14, bp10->getX(), bp10->getY())) >= bp10->getDist()
							) {
								//^1C9A:2C0B
								if (bp10->getMap() != bp50)
									//^1C9A:2C18
									break;
								//^1C9A:2C1B
								bp3c = CALC_SQUARE_DISTANCE(bp4c, bp4e, bp10->getX(), bp10->getY());
								//^1C9A:2C37
								if (bp3c >= bp10->getDist())
									//^1C9A:2C45
									break;
							}
							//^1C9A:2C48
							si = 1;
							//^1C9A:2C4B
							bp10->setDist((i8)bp3c);
							//^1C9A:2C55
							if (bp10->getDist() != 0)
								//^1C9A:2C59
								break;
							//^1C9A:2C5C
							bp0c->b16 = bp0c->b16 & 0xfb;
							//^1C9A:2C69
							break;

						case  3:
							//^1C9A:2C6C
							if (false
								|| (bp16 == bp0082 && bp12 == bp7e && bp14 == bp80)
								|| (bp50 == bp0082 && bp4c == bp7e && bp4e == bp80)
							) {
								//^1C9A:2CA7
								si = 1;
							}
							//^1C9A:2CAA
							break;

						case 13:
							//^1C9A:2CAD
							if (bp0c->w12.IsValid())
								//^1C9A:2CB7
								goto _2b85;
							//^1C9A:2CBA
							if (bp2c <= 0)
								//^1C9A:2CC0
								break;
							//^1C9A:2CC3
							if (bp0c->b6 <= 0) {
								//^1C9A:2CCD
								//^1C9A:2661
								si = 1;
								//^1C9A:2664
								break;
							}
							//^1C9A:2CD0
							if ((_4976_3930 & 1) != 0) {
								//^1C9A:2CD8
								_4976_3930 = (_4976_3930 >> 1) ^ 0xB400;
							}
							else {
								//^1C9A:2CE5
								_4976_3930 >>= 1;
							}
							//^1C9A:2CE9
							if ((_4976_3930 & 7) != 0)
								//^1C9A:2CF1
								break;
							//^1C9A:2CF4
							si = 1;
							//^1C9A:2CF7
							break;

						case  1:
							//^1C9A:2CFA
							if (false
								|| (bp16 == bp7c && bp12 == bp78 && bp14 == bp7a)
								|| (bp50 == bp7c && bp4c == bp78 && bp4e == bp7a)
							) {
								//^1C9A:2D33
								si = 1;
							}
							//^1C9A:2D36
							break;

						case 14:
							//^1C9A:2D39
							bp3c = bp0c->w8;
							//^1C9A:2D43
							if (bp3c < 0) {
								//^1C9A:2D47
								if (RAND16(-bp3c) == 0)
									//^1C9A:2D54
									break;
								//^1C9A:2D57
								si = 1;
								//^1C9A:2D5A
								break;
							}
							//^1C9A:2D5D
							if (bp3c <= 0)
								//^1C9A:2D63
								break;
							//^1C9A:2D66
							if (RAND16(bp3c) != 0)
								//^1C9A:2D73
								break;
							//^1C9A:2D76
							si = 1;
							//^1C9A:2D79
							break;

						case 21:
							//^1C9A:2D7C
							si = CREATURE_GO_THERE(bp0c->w8, bp12, bp14, bp12, bp14, -1);
							//^1C9A:2D9B
							break;

						case 20:
							//^1C9A:2D9D
							if (bp12 == xx && bp14 == yy)
								//^1C9A:2DAB
								break;
							//^1C9A:2DAD
							bp36 = _19f0_050f();
							//^1C9A:2DB5
							if (bp36 == OBJECT_END_MARKER)
								//^1C9A:2DB8
								break;
							//^1C9A:2DBA
							if (CREATURE_CAN_HANDLE_IT(bp36, bp0c->w8) == 0)
								//^1C9A:2DCC
								break;
							//^1C9A:2DCE
							_1c9a_19d4(bp36, bp12, bp14, bp0c->w10);
							//^1C9A:2DE5
							si = 1;
							//^1C9A:2DE8
							break;

						case 23:
							//^1C9A:2DEA
							if ((_4976_521c & 16) == 0)
								//^1C9A:2DEF
								break;
							//^1C9A:2DF1
							ADD_BACKGROUND_LIGHT_FROM_TILE(bp2c, (bp30 == -1) ? glbPlayerDir : bp30, bp12, bp14, 3);

							break;

						case 17:
						case 18:
						case 19:
						case 22:

							break;
					}
					//^1C9A:2E13
					if (si != 0)
						//^1C9A:2E15
						break;
					//^1C9A:2E17
				}
			}
			//^1C9A:2E28
			if (bp2c < bp3e) {
				//^1C9A:2E30
				bp08[bp28][0] = X8(bp12);	// width
				bp08[bp28][1] = X8(bp14);	// 1 ?
				bp08[bp28][2] = X8(bp16);	// map
				bp28 = (bp28 +1) & 255;
			}
			//^1C9A:2E6F
			bp74.distance = bp2c +1;
			//^1C9A:2E77
			bp74.dir = U8(bp30);
			//^1C9A:2E7D
			bp74.w2.SetMap(bp46);
			//^1C9A:2E8D
			bp74.w2.SetX(bp42);
			//^1C9A:2E9A
			bp74.w2.SetY(bp44);
			//^1C9A:2EAB
			(*bp04)[bp12][bp14] = bp74;
			//^1C9A:2ECB
			//^1C9A:3368
		_3368:
			if (si == 0)
				//^1C9A:336C
				continue;
			//^1C9A:336F
			if ((bp0c->b16 & 16) == 0) {
				//^1C9A:3381
				if ((bp0c->b16 & 32) != 0) {
					//^1C9A:3388
					bp0c->w2.SetX(glbCreaturePosX);
					//^1C9A:3397
					bp0c->w2.SetY(glbCreaturePosY);
					//^1C9A:33AA
					bp0c->w2.SetMap(glbCreatureMap);
				}
				else {
					//^1C9A:33AF
					bp0c->w2.SetX(bp12);
					//^1C9A:33C1
					bp0c->w2.SetY(bp14);
					//^1C9A:33D4
					bp0c->w2.SetMap(bp16);
				}
				//^1C9A:33E9
				if (bp37 != 0) {
					//^1C9A:33EF
					bp0c->b6 = i8(bp2c -1);
					//^1C9A:33FB
					bp12 = bp42;
					bp14 = bp44;
					bp16 = bp46;
				}
				else {
					//^1C9A:340F
					bp0c->b6 = i8(bp2c);
				}
				//^1C9A:3419
				SkD((DLV_CAI, "CAI: (e) Go-to (%2d,%2d,%2d),%d _ %02X %02X \n", (Bitu)bp12, (Bitu)bp14, (Bitu)bp16, (Bitu)bp2c, (Bitu)bp37, (Bitu)bp0c->b16));

				bp0c->w4.SetX(bp12);
				//^1C9A:342B
				bp0c->w4.SetY(bp14);
				//^1C9A:343E
				bp0c->w4.SetMap(bp16);
			}
			//^1C9A:3450
			bp34 = di;
			//^1C9A:3455
			if (di == 0 && (((bp0c->b16 & 4) == 0) || bp0c->b0 <= bp2c))
				goto _35ba;
			//^1C9A:3477
			cc = di +1;
			//^1C9A:347D
			while (ss[--di].b1 < 0) {
				//^1C9A:347F
				if (di == 0)
					//^1C9A:3483
					goto _35ba;
			}
			//^1C9A:349A
			if ((bp0c->b16 & 4) == 0) {
				//^1C9A:34A9
				cc = di +1;
			}
			//^1C9A:34AF
			if ((bp0c->b16 & 64) == 0) {
				//^1C9A:34BE
				i16 bp2e = 0;

				do {
					//^1C9A:34C3
					bp12 = ss[di].b1;
					//^1C9A:34D7
					if (bp12 > 0)
						//^1C9A:34DB
						bp2e += bp12;
					//^1C9A:34DE
					if (ss[di].b0 > bp2c +bp2e) {
						//^1C9A:34F8
						ss[di].b0 = i8(bp2c) +i8(bp2e);
					}
					//^1C9A:350D
				} while (--di >= 0);
			}
			//^1C9A:3510
			bp38 = 0;
			bp3e = MIN_EYE_DIST;
			//^1C9A:3519
			for (di = 0; di < cc; di++) {
				//^1C9A:351D
				bp3c = ss[di].b16;
				//^1C9A:3532
				bp38 = bp38 | X8(bp3c);
				//^1C9A:353A
				if (di == 0 || ss[di].b6 < 0) {
					//^1C9A:3551
					X16 bp2e = ss[di].b0;
					//^1C9A:3564
					if ((bp3c & 2) != 0)
						//^1C9A:356B
						bp2e++;
					//^1C9A:356E
					bp3e = max_value(bp2e, bp3e);
				}
				//^1C9A:357E
			}
			//^1C9A:3584
			si = 0;
			//^1C9A:3586
		}
		//^1C9A:35A6
	} while (bp2a != bp28);

	//^1C9A:35B1
	if (bp34 != 0xffff) {
		//^1C9A:35BA
_35ba:
		bp0c = &ss[bp34];
		//^1C9A:35D0
		bp42 = bp0c->w4.GetX();
		//^1C9A:35DD
		bp44 = bp0c->w4.GetY();
		//^1C9A:35EA
		bp46 = bp0c->w4.GetMap();
		//^1C9A:35F7
		for (bp2c = bp0c->b6; --bp2c >= 0; ) {
			// SPX: bp1a is a table of n pos, n being number of maps;
			// but initially, only the pos of current map is initialized.. then we could init if we fall into a nonset map..
			// I am not sure about this fix! and why we want to ask for a map non initialized ? but hope this can prevent the crash
			if (SkCodeParam::bUseFixedMode && bp46 >= dunHeader->nMaps)
				continue;	// In this case I don't know what to do better than nothing!
			if (SkCodeParam::bUseFixedMode && bp1a[bp46] == NULL)
			{
				if (allocSizes[5] != 0)
				{
					DEALLOC_UPPER_MEMORY(allocSizes[5]);
					allocSizes[5] = 0;
				}
				bp04 = reinterpret_cast<DistMapTile (*)[1][32]>(ALLOC_MEMORY_RAM(allocSizes[5] = bp68, afDefault, 1024));
				bp6c += bp68;
				bp1a[bp46] = bp04;
			}
			
			ATLASSERT(bp1a[bp46] != NULL);

			//^1C9A:3602
			// SPX: Spotted a regular CRASH here (from saved game)
			DistMapTile bp74 = (*(bp1a[bp46]))[bp42][bp44];
			//^1C9A:362D
			wp[bp2c].setDir(bp74.dir);
			//^1C9A:3646
			wp[bp2c].setX(bp42);
			//^1C9A:3660
			wp[bp2c].setY(bp44);
			//^1C9A:3679
			if (bp74.w2.GetMap() == bp46) {
				//^1C9A:3687
				wp[bp2c].setMapCross(0);
			}
			else {
				//^1C9A:3698
				// SPX: This bugs me also ... I can get 51 as a map number while there are only 44 ... 
				// thus it would cause a crash because of bp1a[bp46] (and why change bp46 ???)
				bp46 = bp74.w2.GetMap();
				//^1C9A:36A4
				wp[bp2c].setMapCross(1);
			}
			//^1C9A:36B3
			bp42 = bp74.w2.GetX();
			//^1C9A:36BC
			bp44 = bp74.w2.GetY();
			//^1C9A:36C8
		}
	}
	//^1C9A:36D0
	if (bp56 != 0) {
		//^1C9A:36D6
		for (bp12 = 0; dunHeader->nMaps > bp12; bp12++) {
			//^1C9A:36DD
			bp3a = bp1e[bp12];
			//^1C9A:36ED
			if (bp3a >= 0)
				//^1C9A:36F1
				FREE_TEMP_CACHE_INDEX(bp3a);
			//^1C9A:36FA
		}
	}
	//^1C9A:370C

#if DLV_CAI // SPX: Added reinterpret_cast because of VC6 error
	printDistMap(glbCurrentMapIndex, reinterpret_cast<const DistMapTile (*const *)[1][32]>(bp1a));
#endif

#if UseAltic
	if (allocSizes[5] != 0) DEALLOC_UPPER_MEMORY(allocSizes[5]);
	DEALLOC_UPPER_MEMORY(allocSizes[4]);
	DEALLOC_UPPER_MEMORY(allocSizes[3]);
	DEALLOC_UPPER_MEMORY(allocSizes[2]);
	DEALLOC_UPPER_MEMORY(allocSizes[1]);
	DEALLOC_UPPER_MEMORY(allocSizes[0]);
#else
	DEALLOC_UPPER_MEMORY(bp6c);
#endif
	//^1C9A:3719
	_1c9a_0648(bp48);

	SkD((DLV_CAI, "CAI: (!) ss %d \n"
		, (Bitu)bp34));

	//^1C9A:3721
	return bp34;
}

//^1C9A:0648
void SkWinCore::_1c9a_0648(U16 mapno)
{
	//^1C9A:0648
	ENTER(0);
	//^1C9A:064C
	U16 si = mapno;
	if (glbCurrentMapIndex != si) {
		CHANGE_CURRENT_MAP_TO(si);
		if (si == _4976_4c12) {
			//^1C9A:0662
			glbCreatureDir = _4976_4c10;
			glbCreaturePosX = _4976_4c04;
			glbCreaturePosY = _4976_4c1e;
			glbCreatureMap = _4976_4c12;
		}
		else {
			glbCreatureDir = glbPlayerDir;
			glbCreaturePosX = glbPlayerPosX;
			glbCreaturePosY = glbPlayerPosY;
			glbCreatureMap = glbPlayerMap;
		}
	}
	//^1C9A:0691
	return;
}

//^1C9A:02F6
// SPX: _1c9a_02f6 renamed CHECK_RECOMPUTE_LIGHT
void SkWinCore::CHECK_RECOMPUTE_LIGHT(i16 xx, i16 yy)
{
	//^1C9A:02F6
	ENTER(34);
	//^1C9A:02FB
	U16 recomputeLight = 0;	// si
	//^1C9A:02FD
	// SPX: Comparison of these 0x6D (GDAT_GFXSET_AMBIANT_DARKNESS) values ..
	// VOID => 0
	// THICKET => 3
	// CAVE => 8
	// KEEP => 8
	// ROOF => 3
	// MISTY => 3
	// DEBUG => 8
	i16 bp0c = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_AMBIANT_DARKNESS);
	//^1C9A:0312
	if (bp0c == 0) {
		//^1C9A:0318
		glbDoLightCheck = 0;
		//^1C9A:031E
		glbPrecomputedLight = 0;
		glbPreviousPrecompLight = 0;
		glbLightModifier = 0;
		glbPreviousLightModifier = 0;
		//^1C9A:032E
		return;
	}
	//^1C9A:0330
	if (bp0c > 8) {	// Thresholding at 8
		//^1C9A:0336
		bp0c = 8;
	}
	//^1C9A:033B
	skxxx9 bp22;
	bp22.b0 = i8(bp0c);
	bp22.b1 = 0;
	bp22.b7 = 0x17;
	//^1C9A:0349
	WalkPath bp0a[5]; // size=?
	FIND_WALK_PATH(xx, yy, 7, 0, 1, &bp22, bp0a);
	//^1C9A:0367
	if (glbPrecomputedLight != glbPreviousPrecompLight) {
		//^1C9A:0370
		glbPreviousPrecompLight = glbPrecomputedLight;
		recomputeLight = 1;
	}
	//^1C9A:0376
	if (glbLightModifier != glbPreviousLightModifier) {
		//^1C9A:037F
		glbPreviousLightModifier = glbLightModifier;
		recomputeLight = 1;
	}
	//^1C9A:0385
	if (recomputeLight != 0) {
		//^1C9A:0389
		RECALC_LIGHT_LEVEL();
	}
	//^1C9A:038E
	glbDoLightCheck = 0;
	//^1C9A:0394
	return;
}

//^38C8:03AD
// SPX: _38C8_03AD renamed __INIT_GAME_38c8_03ad
void SkWinCore::__INIT_GAME_38c8_03ad()
{
	//^38C8:03AD
	ENTER(0);
	//^38C8:03B1
	glbShowItemStats = 0;
	_4976_4bfe = 0;
	_4976_4c3e = 0;
	_4976_4ddc = 0;
	glbIsPlayerSleeping = 0;
	_4976_5bec = 0;
	//^38C8:03D5
	ZERO_MEMORY(glbChampionMajorSkillsLevel, sizeof(glbChampionMajorSkillsLevel));
	//^38C8:03E5
	ZERO_MEMORY(glbChampionEngagingHandCommand, sizeof(glbChampionEngagingHandCommand));
	//^38C8:03F5
	glbChampionIndex = 0;
	_4976_5dbc = 0;
	//^38C8:0401
	RESET_CAII();
	//^38C8:0406
	_1031_0541(5);
	//^38C8:040E
	LOAD_NEWMAP(U8(glbPlayerMap));
	//^38C8:0418
	_4976_4bd8 = 0;
	//^38C8:041E
	if (glbSpecialScreen == 0) {
		//^38C8:0425
		FIRE_FILL_SCREEN_RECT(2, 0);
		//^38C8:0430
		_0aaf_0067(_0aaf_02f8(6, 0));
		//^38C8:0442
		U16 si = _4976_5d10;
		//^38C8:0447
		if (si != 0) {
			//^38C8:044B
			_4976_5d10 = 1;
			//^38C8:0451
			GRAPHICS_DATA_CLOSE();
		}
		//^38C8:0456
		_2066_03e0(0);
		//^38C8:045E
		if (si != 0) {
			//^38C8:0462
			GRAPHICS_DATA_OPEN();
			//^38C8:0467
			_4976_5d10 = si;
		}
		//^38C8:046B
		WAIT_SCREEN_REFRESH();
	}
	else {
		//^38C8:0472
		WAIT_SCREEN_REFRESH();
		//^38C8:0477
		glbGameHasEnded = 0;
	}
	//^38C8:047D
	FIRE_FILL_SCREEN_RECT(2, 0);
	//^38C8:0488
	_29ee_000f();
	//^38C8:048D
	INIT_CHAMPIONS();
	//^38C8:0492
	_4976_4c02 = 1;
	//^38C8:0498
	CHECK_RECOMPUTE_LIGHT(glbPlayerPosX, glbPlayerPosY);
	//^38C8:04A7
	return;
}

//^101B:0001
//SPX: _101b_0001 renamed END_GAME
void SkWinCore::END_GAME(U16 xx)
{
	//^101B:0001
	ENTER(2);
	//^101B:0005
	FIRE_HIDE_MOUSE_CURSOR();
	//^101B:000A
	if (xx != 0 && _4976_4c26 == 0) {
		//^101B:0017
		U8 bp01 = (glbChampionsCount > 0) ? glbChampionSquad[0].HeroType() : 0xfe;
		//^101B:002A
		// SPX: Sound when dying
		QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, bp01, SOUND_CHAMPION_SCREAM, 0xfe, glbPlayerPosX, glbPlayerPosY, 0, 255, 255);
		//^101B:004E
		SLEEP_SEVERAL_TIME(240);
	}
	//^101B:0057
	_2066_03e0(0);
	//^101B:005F
	glbGameHasEnded = 1;
#if DM2_EXTENDED_MODE == 1
	glbXAmbientSoundActivated = 0;	// reinit that variable to get ambient sound again with a restart
#endif
	//^101B:0065
	if (xx != 0) {
		//^101B:006B
		FIRE_FILL_SCREEN_RECT(2, 0);
		//^101B:0076
		if (_4976_5bf6 != 0) {
			//^101B:007D
			_4976_5bf2 = (_0aaf_0067(_0aaf_02f8(16, 0)) == 0) ? 1 : 0;
			//^101B:009D
			if (_4976_5bf2 != 0) {
				//^101B:00A1
				glbSpecialScreen = 0;
				//^101B:00A7
				if (GAME_LOAD() != -1) {
					//^101B:00B1
					__INIT_GAME_38c8_03ad();
					//^101B:00B6
					_4976_5bf2 = 0;
					//^101B:00BC
					FIRE_SHOW_MOUSE_CURSOR();
					//^101B:00C1
					_1031_098e();
					//^101B:00C6
					return;
				}
			}
		}
	}
	//^101B:00C8
	FIRE_FILL_SCREEN_RECT(2, 0);
	//^101B:00D3
	FIRE_SELECT_PALETTE_SET(0);
	//^101B:00DB
	//DRAW_TRANSPARENT_STATIC_PIC(0x06, 0x00, 0x01, 2, 0xffff);
	DRAW_TRANSPARENT_STATIC_PIC(GDAT_CATEGORY_CREDITS, 0x00, GDAT_IMG_CREDITS_TOMBSTONE, 2, 0xffff);
	//^101B:00ED
	FIRE_SELECT_PALETTE_SET(1);
	//^101B:00F5
	_1031_0541(1);
	//^101B:00FD
	while (MAIN_LOOP(), glbUIEventCode != UI_EVENTCODE_QUIT_CREDITS); // 239
	//^101B:010A
	SK_PREPARE_EXIT();
	//^101B:010F
	return;
}

//^2066:0D09
void SkWinCore::GAME_SAVE_MENU()
{
	//^2066:0D09
	ENTER(132);
	//^2066:0D0F
	U16 bp18 = 0;
	U8 bp21 = 0;
	//^2066:0D18
	DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
	//^2066:0D1D
	UPDATE_RIGHT_PANEL(0);
	//^2066:0D25
	_38c8_0002();
	//^2066:0D2A
	FIRE_HIDE_MOUSE_CURSOR();
	//^2066:0D2F
	REARRANGE_TIMERLIST();
	//^2066:0D34
	if (_4976_49a0 == 0 && _4976_5eb0 != 0)
		//^2066:0D42
		_476d_04e8(2);
	//^2066:0D4A
	_4976_52f4 = 2;

	//^2066:0D50
_0d50:
	_4976_5258 = 0;
	//^2066:0D5C
	_4976_5246 = NULL;
	_4976_5240 = NULL;
	glbMinionsObjectIDTable = NULL;
	//^2066:0D7A
	U8 bp13 = 0;
	U16 bp16 = 0;
	U8 *bp08;
	U8 *bp0c;
	i16 bp0e;
	U8 *bp1c;
	i16 bp1e;
	U16 bp20;

	do {
		//^2066:0D83
		if (_4976_49a0 == 0 && bp13 != 0)
			//^2066:0D90
			_476d_04e8(2);
		//^2066:0D98
		U16 bp0e = _0aaf_0067(_0aaf_02f8((_4976_49a0 != 0) ? 0x12 : 0x0b, bp13));
		//^2066:0DBB
		if (bp0e == 3)
			//^2066:0DC1
			goto _1523;
		//^2066:0DC4
		if (bp0e == 2) {
			//^2066:0DCA
			_2066_046d();
			//^2066:0DCE
			bp13 = 0;
		}
		//^2066:0DD5
		else if (bp0e == 1) {
			//^2066:0DDB
			if (true
				&& _4976_4c1a +100 < glbGameTick 
				&& _4976_523c +100 < glbGameTick
				&& _0aaf_0067(_0aaf_02f8(0x0c, 0x00)) == 3
			) {
				//^2066:0E28
				//^2066:0DCE
				bp13 = 0;
			}
			else {
				//^2066:0E2A
				FIRE_SHOW_MOUSE_CURSOR();
				//^2066:0E2F
				_4976_5bf6 = 0;
				//^2066:0E35
				bp18 = 1;
				//^2066:0E3A
				goto _1523;
			}
		}
		//^2066:0E3D
		else if (bp0e == 0) {
			//^2066:0E43
			if (_4976_49a0 != 0 || _476d_04af(0) == 1) {
				//^2066:0E57
				bp16 = 1;
			}
			else {
				//^2066:0E5E
				bp16 = 0;
				//^2066:0E63
				switch (_4976_5eb8) {
					case 0:
						//^2066:0E73
						bp13 = 0x15;
						//^2066:0E77
						break;

					case 2:
						//^2066:0E79
						bp13 = 0x16;
						//^2066:0E7D
						break;

					case 4:
						//^2066:0E7F
						bp13 = 0x17;
						//^2066:0E83
						break;

					case 3:
						//^2066:0E85
						bp13 = 0x1a;

						break;

					case 1:

						break;
				}
			}
		}
		//^2066:0E89
	} while (bp16 == 0);

	//^2066:0E92
	bp1c = ALLOC_MEMORY_RAM(1024, afDefault, 128);
	//^2066:0EAA
	bp20 = 1;
	bp1e = 3;
	//^2066:0EB4
	goto _100f;
	//^2066:0EB7
_0eb7:
	goto _1045;

	//^2066:100F
_100f:
	if (bp1e >= 0)
		//^2066:1015
		goto _0eb7;
	//^2066:1018
	DEALLOC_UPPER_MEMORY(1024);
	//^2066:1024
	if (bp20 != 0) {
		//^2066:102A
		_0aaf_0067(_0aaf_02f8(0x13, bp21));
        //^2066:103E
		bp21 = 0x14;
		//^2066:1042
		goto _0d50;
	}
	//^2066:1045
_1045:
	bp0e = _2066_33e7();
	//^2066:104D
	if (bp0e < 0)
		//^2066:1051
		goto _0d50;
	//^2066:1054
	_4976_525c = bp0e;
	_4976_52e2 = U8(_4976_525c) +0x30;
	//^2066:1062
	_0aaf_02f8(0x0d, 0x00);
	//^2066:106D
	bp08 = FORMAT_SKSTR(ptrSKSave_dat, NULL);
	//^2066:1087
	bp0c = FORMAT_SKSTR(ptrSKSave_bak, NULL);
	//^2066:10A1
	DELETE_FILE(bp0c);
	//^2066:10AE
	FILE_RENAME(bp08, bp0c);
	//^2066:10C2
	glbDataFileHandle = FILE_CREATE(bp08);
	//^2066:10D2
	i16 bp10;
	if (glbDataFileHandle < 0)
		//^2066:10D6
		goto _14fa;
	//^2066:10D9
	bp10 = FILE_OPEN(bp0c);
	//^2066:10E9
	sksave_header_asc bp4c;
	if (bp10 >= 0) {
		//^2066:10ED
		READ_FILE(bp10, 42, &bp4c);
		//^2066:1101
		CLOSE_FILE(bp10);
	}
	else {
		//^2066:110C
		bp4c.w38 = 0;
	}
	//^2066:1116
	bp4c.w0 = 1;
	//^2066:111B
	SK_STRCPY(bp4c.b2, _4976_5268);
	//^2066:112C
	WRITE_FILE(glbDataFileHandle, 42, &bp4c);
	//^2066:1141
	if (SKSAVE_WRITE(dunHeader, 44) == 0)
		//^2066:1156
		goto _14fa;
	//^2066:1159
	if (SKSAVE_WRITE(dunMapsHeaders, dunHeader->nMaps << 4) == 0)
		//^2066:117A
		goto _14fa;
    //^2066:117D
	if (SKSAVE_WRITE(dunMapTilesObjectIndexPerColumn, _4976_4cb4 << 1) == 0)
		//^2066:1196
		goto _14fa;

	//^2066:1199
	if (SKSAVE_WRITE(dunGroundStacks, dunHeader->cwListSize << 1) == 0)
		goto _14fa;
	//^2066:11BA
	if (SKSAVE_WRITE(dunTextData, dunHeader->cwTextData << 1) == 0)
		goto _14fa;

	//^2066:11DB
	for (bp0e = 0; bp0e < 16; bp0e++) {
		//^2066:11E2
		if (SKSAVE_WRITE(glbDBObjectData[bp0e], dbSize[bp0e] * dunHeader->nRecords[bp0e]) == 0)
			//^2066:1214
			goto _14fa;
		//^2066:1217
	}
	//^2066:1220
	if (SKSAVE_WRITE(dunMapData, dunHeader->cbMapData) == 0)
		//^2066:123B
		goto _14fa;

	//^2066:123E
	_1c9a_3bab();
	//^2066:1243
	COMPACT_TIMERLIST();
	//^2066:1248
	skload_table_60 sGameVar; // bp0084
	ZERO_MEMORY(&sGameVar, 56);
	//^2066:125A
	sGameVar.dwGameTick = glbGameTick;
	sGameVar.dwRandomSeed = glbRandomSeed;
	sGameVar.wChampionsCount = glbChampionsCount;
	sGameVar.wPlayerPosX = glbPlayerPosX;
	sGameVar.wPlayerPosY = glbPlayerPosY;
	sGameVar.wPlayerDir = glbPlayerDir;
	sGameVar.wPlayerMap = glbPlayerMap;
	sGameVar.wChampionLeader = glbChampionLeader;
	sGameVar.wTimersCount = glbTimersCount;
	sGameVar.dw22 = _4976_0090;
	sGameVar.dw26 = _4976_4b80;
	sGameVar.w30 = _4976_4c00;
	sGameVar.wPlayerThrowCounter = glbPlayerThrowCounter;
	sGameVar.w34 = _4976_4c0c;

	sGameVar.wRainFlagSomething = glbRainFlagSomething;
	sGameVar.bRainAmbientLightModifier = glbRainAmbientLightModifier;
	sGameVar.bRainDirection = glbRainDirection;
	sGameVar.bRainStrength = glbRainStrength;
	sGameVar.bRainLevelForSky = glbRainLevelForSky;
	sGameVar.bRainLevelForGround = glbRainLevelForGround;
	sGameVar.bRainMultiplicator = glbRainMultiplicator;
	sGameVar.wRainStormController = glbRainStormController;
	sGameVar.bRainRelated3 = glbRainRelated3;
	sGameVar.bRainRelated2 = glbRainRelated2;
	sGameVar.dwRainSpecialNextTick = glbRainSpecialNextTick;

	s_testSKSave.StartWrite(FILE_TELL(glbDataFileHandle));

	//^2066:1317
	SUPPRESS_INIT();

	DEBUG_HELP_WRITER("Global Game Variables", &sGameVar, 56, 1);
	//^2066:131B
	if (SUPPRESS_WRITER(&sGameVar, _4976_395a, 56, 1) != 0)
		goto _14fa;
	DEBUG_HELP_WRITER("Ingame Global Flags", glbIngameGlobVarFlags, 1, 8);
	//^2066:1339
	if (SUPPRESS_WRITER(glbIngameGlobVarFlags, _4976_3956, 1, 8) != 0)
		goto _14fa;
	DEBUG_HELP_WRITER("Ingame Global Bytes", glbIngameGlobVarBytes, 1, 64);
	//^2066:1355
	if (SUPPRESS_WRITER(glbIngameGlobVarBytes, _4976_3956, 1, 64) != 0)
		goto _14fa;
	DEBUG_HELP_WRITER("Ingame Global Words", glbIngameGlobVarWords, 2, 64);
	//^2066:1371
	if (SUPPRESS_WRITER(glbIngameGlobVarWords, _4976_3956, 2, 64) != 0)
		goto _14fa;
	DEBUG_HELP_WRITER("Champion Squad", glbChampionSquad, 261, glbChampionsCount);
	//^2066:138D
	if (SUPPRESS_WRITER(glbChampionSquad, _4976_3992, 261, glbChampionsCount) != 0)
		goto _14fa;
	DEBUG_HELP_WRITER("Global Spell Effects", &glbGlobalSpellEffects, 6, 1);
	//^2066:13AC
	if (SUPPRESS_WRITER(&glbGlobalSpellEffects, _4976_3a97, 6, 1) != 0)
		goto _14fa;
	DEBUG_HELP_WRITER("Timers Table", glbTimersTable, 10, glbTimersCount);
	//^2066:13C8
	if (SUPPRESS_WRITER(glbTimersTable, _4976_3a9d, 10, glbTimersCount) != 0)
		goto _14fa;
	//^2066:13EA
	_4976_5240 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(dunHeader->nRecords[dbContainer] << 1, afDefault, 1024));
	//^2066:140E
	_4976_5246 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(dunHeader->nRecords[dbCreature] << 1, afDefault, 1024)); // dbCreature or dbMissile ??? (check WRITE_MINION_ASSOC)
	//^2066:1432
	glbMinionsObjectIDTable = reinterpret_cast<ObjectID *>(ALLOC_MEMORY_RAM(200, afDefault, 1024));
	//^2066:144B
	glbMinionsAssocCount = _4976_3952 = _4976_3950 = 0;
	//^2066:1456
	_4976_5258 = 0;
	//^2066:1462
	for (bp0e = 0; bp0e < glbChampionsCount; bp0e++) {
		//^2066:1469
		ObjectID *bp04 = glbChampionSquad[bp0e].inventory;
		//^2066:147A
		for (i16 bp12 = 0; bp12 < 30; bp12++) {
			//^2066:1481
			if (WRITE_RECORD_CHECKCODE(*(bp04++), 0, 0) != 0)
				goto _14fa;
			//^2066:149A
		}
		//^2066:14A3
	}
	DEBUG_HELP_WRITER("Leader Hand Object Ref", &glbLeaderHandPossession.object, 2, 1);
	//^2066:14AF
	if (WRITE_RECORD_CHECKCODE(glbLeaderHandPossession.object, 0, 0) != 0)
		goto _14fa;
	//^2066:14C3
	if (STORE_EXTRA_DUNGEON_DATA() == 0)
		goto _14fa;
	//^2066:14CA
	if (WRITE_MINION_ASSOC() != 0)
		goto _14fa;
	//^2066:14D2
	if (SUPPRESS_FLUSH() != 0)
		goto _14fa;
	//^2066:14DA
	CLOSE_FILE(glbDataFileHandle);
	//^2066:14E4
	_4976_5bf6 = 1;
	//^2066:14EA
	_4976_523c = glbGameTick;
	//^2066:14F8
	goto _1523;

	//^2066:14FA
_14fa:
	CLOSE_FILE(glbDataFileHandle);
	//^2066:1504
	DELETE_FILE(bp08);
	//^2066:1511
	_0aaf_0067(_0aaf_02f8(0x00, 0x1b));

_1523:
	//^2066:1523
	if (glbMinionsObjectIDTable != NULL) {
		//^2066:152C
		DEALLOC_UPPER_MEMORY(200);
	}
	//^2066:1538
	if (_4976_5246 != NULL) {
		//^2066:1541
		DEALLOC_UPPER_MEMORY(U32(dunHeader->nRecords[dbCreature]) << 1);
	}
	//^2066:1558
	if (_4976_5240 != NULL) {
		//^2066:1561
		DEALLOC_UPPER_MEMORY(U32(dunHeader->nRecords[dbContainer] << 1));
	}
	//^2066:1578
	FILL_ORPHAN_CAII();
	//^2066:157D
	if (bp18 != 0) {
		//^2066:1583
		END_GAME(0);
	}
	//^2066:158B
	_2066_03e0(0);
	//^2066:1592
	_38c8_0060();
	//^2066:1597
	FIRE_SHOW_MOUSE_CURSOR();
	//^2066:159C
	return;
}

//^2481:01D8
void SkWinCore::SHOW_CREDITS()
{
	//^2481:01D8
	ENTER(0);
	//^2481:01DC
	X16 si = SCREEN_CREDITS_TIMER;		// SPX: 1800 time before going back to main screen
	FIRE_SELECT_PALETTE_SET(0);
	FIRE_HIDE_MOUSE_CURSOR();
	DRAW_GAMELOAD_DIALOGUE_TO_SCREEN(glbImageCreditScreen, 2, -1, _4976_52b6);
	FIRE_SELECT_PALETTE_SET(1);
	FIRE_SHOW_MOUSE_CURSOR();
	_1031_0541(1);
	do {
		MessageLoop(true); // credits

		//^2481:021D
		MAIN_LOOP();
		if (glbUIEventCode == UI_EVENTCODE_QUIT_CREDITS) // 239
			break;
		//^2481:022A
		SLEEP_SEVERAL_TIME(1);
		//^2481:0232
	} while (--si != 0);
	//^2481:0239
	glbSpecialScreen = 0xDA;	// 218
	_1031_0541(0);
	FIRE_HIDE_MOUSE_CURSOR();
	//^2481:024C
	return;
}

U8 SkWinCore::inportb(U16 port) {
	switch (port) {
		case 0x60: // key in
		{
			CSkKinput *p = skwin.DequeueKinput();
			if (p != NULL)
				return p->raw;
			return 0;
		}
		case 0x64: // keyboard status: 2=still buffered
			return (skwin.cntKeybIn != 0) ? 2 : 0;
	}
	return 0;
}

void SkWinCore::MessageLoop(bool fBalanceWait, bool fShortWait) {
	if (fBalanceWait) {
		if (fShortWait) {
			if (!skwin.ML())
				throw i8();
		}
		else {
			if (tickThen == (U32)-1)
				tickThen = skwin.GetTickCount();
			while (true) {
				if (!skwin.ML())
					throw i8();
				U32 tickDelta = skwin.GetTickCount() -tickThen;
				if (tickDelta >= (fShortWait ? (TICK_TIME_STAY >> 1) : (TICK_TIME_STAY)))
					break;
				skwin.Sleep(1);
			}
			tickThen = skwin.GetTickCount();
		}
	}
	if (_04bf_0e7a != 0) // if block hardware interruption
		return;
	// mouse event notice
	for (int i = 0; i < skwin.cntMiceIn; i++) {
		mice_btn = skwin.xMiceInput[i].btn;
		mice_x = skwin.xMiceInput[i].x;
		mice_y = skwin.xMiceInput[i].y;
		(this->*_int33_mouse_callback)();
	}
	skwin.cntMiceIn = 0;

	// key event notice
	if (skwin.cntKeybIn != 0) {
		(this->*_sys_getvect(0x09))();
	}

	// interval timer notice
	(this->*_sys_getvect(0x08))();
}

//^2C1D:105F
// SPX: The default delay with fresh champions is 4 in original code.
// However, this delay seems to be too much for standard compatibility with DM1 trigger delays; it should rather be 2.
// And there are some curious calculation ...
// For reference
//	1 = maximum speed (given by any aura of speed value)
//	2 = normal speed with no charges
//	3 = medium speed (3/5 of max load)
//	4 = overcharged (exceed max load)
i16 SkWinCore::CALC_PLAYER_WALK_DELAY(U16 player)
{
	//^2C1D:105F
	ENTER(6);
	//^2C1D:1065
	if (glbGlobalSpellEffects.AuraOfSpeed != 0)
		return 1;
	//^2C1D:1072
	Champion *champion = &glbChampionSquad[player];
	U16 maxLoad = MAX_LOAD(champion);			// bp06
	U16 currentLoad = GET_PLAYER_WEIGHT(player);		// di
	U16 walkDelay = 0;		
	U16 walkPenalty = 0; // another usage of di
	if (!SkCodeParam::bUseFixedMode)	// SPX: I rewrote the whole block as I think there are some weird calculations
	{
		//^2C1D:109E
		if (maxLoad > currentLoad) {	// Standard case, current load is < than max load
			walkDelay = 2;
			if ((U32(maxLoad) << 3) > maxLoad * 5U) {	// Wait ... "is 8 > 5 ?" => of course, certainly an error of translation
				//^2C1D:10CC
				walkDelay++;
			}
			//^2C1D:10CD
			walkPenalty = 1;
		}
		else {				// Champion exceeds his max load
			//^2C1D:10D2
			walkDelay = ((currentLoad -maxLoad) << 2) / maxLoad +4;
			walkPenalty = 2;
		}
		//^2C1D:10E7
		if ((champion->bodyFlag & 0x20) != 0)	// Add penalties (what is 0x20 flag? wounded?)
			walkDelay += walkPenalty;
		//^2C1D:10F4
		walkDelay = max_value(1, walkDelay - champion->walkSpeed);	// walkspeed is changed by item giving bonus (positive)
		if (walkDelay > 2) {
			walkDelay = (walkDelay +1) & 0xfffe;
		}
	}
	else if (SkCodeParam::bUseFixedMode)
	{
		// standard si = 2;
		//^2C1D:109E
		if (maxLoad > currentLoad) {	// Standard case, current load is < than max load
			walkDelay = 2;
			if ((U32(currentLoad) << 3) > maxLoad * 5U) {
				//^2C1D:10CC
				walkDelay++;	// medium => si = 3
			}
			//^2C1D:10CD
			walkPenalty = 1;	// penalty
		}
		else {				// Champion exceeds his max load
			//^2C1D:10D2
			walkDelay = ((currentLoad - maxLoad) << 2) / maxLoad + 4;
			walkPenalty = 2;
		}
		//^2C1D:10E7
		if ((champion->bodyFlag & 0x20) != 0)	// Add penalties (what is 0x20 flag? wounded?)
			walkDelay += walkPenalty;
		//^2C1D:10F4
		walkDelay = max_value(1, walkDelay - champion->walkSpeed);	// walkspeed is changed by item giving bonus (positive)
		//if (si > 2) {	// This is for rounding up to next even number. Why not try without this?
		//	si = (si +1) & 0xfffe;
		//}
	}
	return walkDelay;
}

//^2FCF:0C7D
X16 SkWinCore::IS_TILE_BLOCKED(U8 tile)
{
	// return 0 if you can enter
	// return 1 if you cannot enter

	//^2FCF:0C7D
	ENTER(0);
	//^2FCF:0C80
	U8 dl = tile;
	switch (dl >> 5) {
		case ttWall://^0C9A
		case ttMapExit://^0C9A
			return 1;
		case ttDoor://^0C9F
			dl = dl & 7;
			if (dl != 0 && dl != 1 && dl != 5)
				return 1;
			break;
		case ttTrickWall://^0CB5
			if ((dl & 4) == 0 && (dl & 1) == 0)
				return 1;
			break;
		case ttFloor://^0CCB
		case ttPit://^0CCB
		case ttStairs://^0CCB
		case ttTeleporter://^0CCB
			break;
	}
	return 0;
}
//^12B4:0953
X16 SkWinCore::_12b4_0953(Creature *rec, U16 ww)
{
	//^12B4:0953
	ENTER(0);
	//^12B4:0958
	U16 si = (rec->b15_0_1() +ww) & 3;
	if (si == 1 || si == 3) {
		i16 di = QUERY_CREATURE_5x5_POS(rec, si);
		if (((di / 5) -2) != 0)
			return 1;
	}
	//^12B4:0998
	return 0;
}

//^12B4:0881
X16 SkWinCore::_12b4_0881(X16 aa, U16 oldTile, U16 newTile, i16 xx, i16 yy, ObjectID *rl)
{
	//^12B4:0881
	ENTER(0);
	//^12B4:0886
	*rl = OBJECT_NULL;
	X16 di = ((oldTile >> 5) == ttStairs) ? 1 : 0;
	//^12B4:08A1
	if (di != 0 && aa == 2)
		return 1;
	//^12B4:08B1
	if ((newTile >> 5) == ttStairs) {
		return 2;
	}
	//^12B4:08C1
	if (IS_TILE_BLOCKED(U8(newTile)) != 0) {
		return 3;
	}
    //^12B4:08D4
	*rl = GET_CREATURE_AT(xx, yy);
	if (*rl != OBJECT_NULL) {
		//^12B4:08EC
		if ((QUERY_CREATURE_AI_SPEC_FLAGS(*rl) & 0x8000) == 0) {
			if (_12b4_0953(GET_ADDRESS_OF_RECORD4(*rl), glbPlayerDir) != 0)
				return 5;
			return 4;
		}
	}
	//^12B4:091F
	ObjectID si = _1c9a_03cf(&xx, &yy, 255);
	if (si != OBJECT_NULL) {
		if ((QUERY_CREATURE_AI_SPEC_FLAGS(si) & 0x8000) == 0)
			return 5;
	}
	return 6;
}
//^12B4:023F
// SPX: Walk into a wall ?
U16 SkWinCore::_12b4_023f(i16 xx, i16 yy, i16 *ss, i16 *tt, i16 ww, X16 vv)
{
	//^12B4:023F
	ENTER(6);
	//^12B4:0245
	vv += ww +2;
	i16 bp06[2];
	bp06[0]= _2c1d_028c(xx, yy, vv & 3);
	//^12B4:0265
	*ss = bp06[0];
	//^12B4:026B
	bp06[1] = _2c1d_028c(xx, yy, (vv +1) & 3);
	//^12B4:0284
	*tt = bp06[1];
	//^12B4:028A
	if (bp06[0] == bp06[1])
		bp06[1] = -1;
	//^12B4:0297
	U16 di;
	for (i16 si = 0; si < 2; si++) {
		//^12B4:029D
		i16 bp02 = bp06[si];
		if (bp02 >= 0) {
			//^12B4:02B0
			if (WOUND_PLAYER(bp02, 1, 0x18, 2) != 0) {
				//^12B4:02C5
				di = 1;
				QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, glbChampionSquad[bp02].HeroType(), SOUND_CHAMPION_BUMP, 0xfe, xx, yy, 1, 0x64, 0xc8);
			}
		}
		//^12B4:02F4
	}
	//^12B4:02FA
	return di;
}
//^12B4:0BF1
X16 SkWinCore::IS_CREATURE_MOVABLE_THERE(i16 xx, i16 yy, i16 dir, ObjectID *prlWhatsLying)
{
	// test if creature at (xx,yy) can move one step by dir.

	// return 0 if cannot
	// ... because no creature's lying there.
	// ... because block is there.
	// ... because he couldn't be alive there.

	// return 1 if can

	//^12B4:0BF1
	ENTER(12);
	//^12B4:0BF7
	i16 di = xx;
	i16 si = yy;
	ObjectID bp02 = GET_CREATURE_AT(di, si);
	if (bp02 == OBJECT_NULL || GET_CREATURE_WEIGHT(bp02) == 0xff)
		return 0;
	//^12B4:0C22
	TELE_inf bp0c;
	U8 bp03;
	if (GET_TELEPORTER_DETAIL(&bp0c, U8(di), U8(si)) != 0) {
		//^12B4:0C38
		if (((bp0c.b0 +2) & 3) == dir) {
			if (IS_CREATURE_ALLOWED_ON_LEVEL(bp02, bp0c.b4) == 0)
				return 0;
			//^12B4:0C61
			i16 bp06 = glbCurrentMapIndex;
			CHANGE_CURRENT_MAP_TO(bp0c.b4);
			bp03 = (IS_TILE_BLOCKED(GET_TILE_VALUE(bp0c.b2, bp0c.b3)) != 0 || (prlWhatsLying != NULL && GET_CREATURE_AT(bp0c.b2 + glbXAxisDelta[bp0c.b1], bp0c.b3 + glbYAxisDelta[bp0c.b1]) != OBJECT_NULL));
			//^12B4:0CD5
			CHANGE_CURRENT_MAP_TO(bp06);
			if (bp03 != 0) {
				return 0;
			}
		}
	}
	//^12B4:0CE7
	di += glbXAxisDelta[dir];
	si += glbYAxisDelta[dir];
	bp03 = GET_TILE_VALUE(di, si);
	if (IS_TILE_BLOCKED(bp03) != 0)
		return 0;
	if ((bp03 >> 5) == ttStairs)
		return 0;
	if (prlWhatsLying != NULL) {
		if (GET_CREATURE_AT(di, si) != OBJECT_NULL)
			return 0;
	}
	//^12B4:0D32
	if (GET_TELEPORTER_DETAIL(&bp0c, U8(di), U8(si)) != 0) {
		if (IS_CREATURE_ALLOWED_ON_LEVEL(bp02, bp0c.b4) == 0)
			return 0;
	}
	//^12B4:0D59
	if (prlWhatsLying != NULL) {
		*prlWhatsLying = bp02;
	}
	//^12B4:0D6A
	return 1;
}
//^12B4:099E
X16 SkWinCore::_12b4_099e(ObjectID rl)
{
	//^12B4:099E
	ENTER(8);
	//^12B4:09A4
	i16 bp06 = GET_CREATURE_WEIGHT(rl);
	if (bp06 == 0xff)
		return 0;
	X16 bp08 = 0;
	U16 si;
	for (si = 0; si < glbChampionsCount; si++) {
		//^12B4:09C3
		Champion *bp04 = &glbChampionSquad[si];
		if (bp04->curHP() != 0) {
			i16 di = GET_PLAYER_ABILITY(bp04, abStr, 0);
			if (si == glbChampionLeader) {
				di += di >> 3;
			}
			//^12B4:09FC
			if (bp06 <= 0x2d) {
				di += di >> 2;
			}
			//^12B4:0A09
			di = STAMINA_ADJUSTED_ATTR(bp04, di);
			if (di < bp06) {
				if (RAND16(((bp06 -di) >> 1) +1) != 0)
					continue;
			}
			//^12B4:0A32
			bp08 = 1;
			break;
		}
		//^12B4:0A39
	}
	//^12B4:0A40
	for (si = 0; si < glbChampionsCount; si++) {
		//^12B4:0A44
		if (glbChampionSquad[si].curHP() != 0) {
			//^12B4:0A54
			if (glbChampionSquad[si].curStamina() > glbChampionSquad[si].maxStamina()) {
				ADJUST_STAMINA(
					si,
					(bp08 != 0) ? max_value(5, bp06 >> 2) : 5
					);
			}
		}
		//^12B4:0A97
	}
	//^12B4:0A9E
	return bp08;
}


//^12B4:0300
// SPX: _12b4_0300 renamed PERFORM_MOVE
U16 SkWinCore::PERFORM_MOVE(X16 xx)
{
	// Moves:
	//	xx = 3	forward
	//	xx = 4	move right
	//	xx = 5	backward
	//	xx = 6	move left
	//^12B4:0300
	ENTER(38);
	//^12B4:0306
	ObjectID bp14;
	U16 bp06 = GET_TILE_VALUE(glbSomePosX_4c2e, glbSomePosY_4c30);
	X16 bp08 = ((bp06 >> 5) == ttStairs) ? 1 : 0;
	i16 bp26 = 1;
	Champion *champion = glbChampionSquad;
	//^12B4:0338
	U16 si;
	SkD((DLV_MOVE, "------------------------------------------------\n"));
	for (si = 0; si < glbChampionsCount; champion++, si++) {
		//^12B4:033C
		if (champion->curHP() != 0) {
			bp26 = max_value(bp26, CALC_PLAYER_WALK_DELAY(si));
			SkD((DLV_MOVE, "Move: champion %d sets walk delay to %d\n", si, bp26));
		}
		//^12B4:035B
	}
	//^12B4:0367
	U16 bp0a;
	i16 bp0e;
	i16 bp1a;
	i16 bp1c;
	X16 di;
	SkD((DLV_MOVE, "Move: delay:%d, glbIsPlayerMoving:%d, move:%d, DSM:%d, _4976_4c08:%d, bp08:%d\n"
		, bp26
		, glbIsPlayerMoving
		, xx
		, skwin.enableDoubleStepMove
		, _4976_4c08
		, bp08));

#if UseAltic
	if (bp26 > 1 && glbIsPlayerMoving == 0 &&
			((xx == 3 && skwin.enableDoubleStepMove) 
			|| ((xx == 5 && skwin.enableDoubleStepMove) && _4976_4c08 == 0 && bp08 == 0)
			|| glbTableToMove != OBJECT_NULL)
		) {
#else
	if (bp26 > 1 && glbIsPlayerMoving == 0 && (xx == 3 || (xx == 5 && _4976_4c08 == 0 && bp08 == 0) || glbTableToMove != OBJECT_NULL)) {
#endif
		//^12B4:0394
		glbIsPlayerMoving = bp26 >> 1;
		_4976_4c32 = glbPlayerPosX;
		_4976_4c34 = glbPlayerPosY;
		_4976_4c40 = glbPlayerDir;
		glbPlayerLastMove = xx;
		if (xx != 3) {
			CALC_VECTOR_W_DIR(glbPlayerDir, -1, 0, &_4976_4c32, &_4976_4c34);
		}
		if (SkCodeParam::bUsePlayerWalkSound)	// Use ROCKY walk sound
			//QUEUE_NOISE_GEN1(GDAT_CATEGORY_CREATURES, 0x0C, 0x00, 0x46, 0x80, glbPlayerPosX, glbPlayerPosY, 1);
			QUEUE_NOISE_GEN1(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, SOUND_CHAMPION_FOOTSTEP, 0x46, 0x80, glbPlayerPosX, glbPlayerPosY, 1);
		goto _0768;
	}
	//^12B4:03D8
	U16 bp10;
	if (glbTableToMove != OBJECT_NULL) {
		//^12B4:03E2
		if (true
			&& glbPlayerDir == _4976_4c40 && glbPlayerMap == glbMap_4976_4eaa && glbPlayerPosX == glbPosX_4976_4eae && glbPlayerPosY == glbPosY_4976_4eb0
			&& GET_CREATURE_AT(glbTargetPosXTest, glbTargetPosYTest) == glbTableToMove
		) {
			//^12B4:0427
			glbTableToMove = OBJECT_NULL;
			bp10 = glbPlayerMap;
			if (xx == 3) {
				//^12B4:0439
				_12b4_0d75(glbTargetPosXTest, glbTargetPosYTest, _4976_4eac, 0xfe);
			}
			//^12B4:0450
			if (PERFORM_MOVE(xx) != 0) {
				//^12B4:045C
				PERFORM_TURN_SQUAD(_4976_4eb2);
				if (xx != 3) {
					//^12B4:046B
					CHANGE_CURRENT_MAP_TO(bp10);
					_12b4_0d75(glbTargetPosXTest, glbTargetPosYTest, _4976_4eac, 0xfe);
				}
			}
			//^12B4:048B
			CHANGE_CURRENT_MAP_TO(glbPlayerMap);
		}
		//^12B4:0495
		glbTableToMove = OBJECT_NULL;
		if (_4976_4ddc == 0)
			glbTargetTypeMoveObject = 6;
		//^12B4:04A8
		return 1;
	}
	//^12B4:04AE
	bp10 = glbCurrentMapIndex;
	di = xx -3;
	//^12B4:04BC
	if (_4976_4c08 != 0 && di == 2) {
		CHANGE_CURRENT_MAP_TO(_4976_4c12);
	}
	//^12B4:04D2
	bp1a = glbSomePosX_4c2e;
	bp1c = glbSomePosY_4c30;
	bp0e = _4976_4c2c;
	//^12B4:04E4
	CALC_VECTOR_W_DIR(bp0e, _4976_19b2[RCJ(4,di)], _4976_19b6[RCJ(4,di)], &bp1a, &bp1c);
	//^12B4:0505
	bp0a = GET_TILE_VALUE(bp1a, bp1c);
	_4976_4e5c = 1;
	champion = glbChampionSquad;
	//^12B4:0525
	for (si = 0; si < glbChampionsCount; champion++, si++) {
		//^12B4:0529
		if (champion->curHP() != 0) {
			//^12B4:0533
			ADJUST_STAMINA(si, ((GET_PLAYER_WEIGHT(si) * 3) / MAX_LOAD(champion)) +1);
		}
		//^12B4:055E
	}
	//^12B4:056A
	RESET_SQUAD_DIR();
	//^12B4:056E
	X16 bp12;
	X16 bp24;
	i16 bp16;
	i16 bp18;
	U16 bp0c;
	switch (_12b4_0881(di, bp06, bp0a, bp1a, bp1c, &bp14)) {
	case 2://^059A
		//^12B4:059A
		MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, -1, 0);
		glbPlayerPosX = bp1a;
		glbPlayerPosY = bp1c;
		bp06 = bp0a;
		goto _05c2;
	case 1://^05C2
		//^12B4:05C2
_05c2:
		_12b4_00af(bp06 & 4);
		break;
	case 4://^05D0
		//^12B4:05D0
		if (glbChampionsCount == 0)
			break;
		//^12B4:05DA
		bp12 = QUERY_CREATURE_AI_SPEC_FLAGS(bp14) & 1;
		if (bp12 != 0 || GET_CREATURE_WEIGHT(bp14) == 0xff) {
			//^12B4:05FB
			_12b4_023f(bp1a, bp1c, &bp16, &bp18, bp0e, di);
		}
		//^12B4:0616
		bp24 = ((bp0e +xx) -3) & 3;
		if (IS_CREATURE_MOVABLE_THERE(bp1a, bp1c, bp24, &bp14) != 0 && _12b4_099e(bp14) != 0) {
			//^12B4:064C
			_12b4_0d75(bp1a, bp1c, bp24, 0xfe);
			goto _0685;
		}
		//^12B4:0662
		if (bp12 != 0)
			break;	
		//^12B4:066B
		ATTACK_CREATURE(OBJECT_NULL, bp1a, bp1c, 0x4005, 5, 0);
		break;
	case 6://^0685
		//^12B4:0685
_0685:
		if (_4976_4c08 != 0 && di == 2) {
			//^12B4:0691
			CHANGE_CURRENT_MAP_TO(bp10);
			bp1a = glbSomePosX_4c2e;
			bp1c = glbSomePosY_4c30;
			CALC_VECTOR_W_DIR(bp0e = _4976_4c2c, -1, 0, &bp1a, &bp1c);
		}
		//^12B4:06C3
		if (bp08 != 0) {
			MOVE_RECORD_TO(OBJECT_NULL, -1, 0, bp1a, bp1c);
			goto _0768;
		}
		//^12B4:06D6
		TELE_inf bp22;
		if (GET_TELEPORTER_DETAIL(&bp22, U8(bp1a), U8(bp1c)) != 0) {
			if (((bp22.b1 +2) & 3) != bp0e) {
				//^12B4:06FC
				CHANGE_CURRENT_MAP_TO(glbPlayerMap);
				MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, -1, 0);
				LOAD_NEWMAP(bp22.b4);
				MOVE_RECORD_TO(OBJECT_NULL, -1, 0, bp22.b2, bp22.b3);
				ROTATE_SQUAD(bp22.b1);
				goto _0768;
			}
		}
		//^12B4:0750
		MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, bp1a, bp1c);
		//^12B4:0768
_0768:
		_4976_4c00 = bp26;
		glbPlayerThrowCounter = 0;
		//^12B4:0776
		return 1;
	case 3://^0779
		//^12B4:0779
		if (glbChampionsCount == 0)
			break;
		_12b4_023f(bp1a, bp1c, &bp16, &bp18, bp0e, di);
		//^12B4:079E
		if ((bp0a >> 5) != ttDoor || (bp0a & 7) != 4)
			break;
		//^12B4:07B7
		bp0c = 0;
		if (bp16 != 0xffff) {
			//^12B4:07C2
			champion = &glbChampionSquad[bp16];
			bp0c += STAMINA_ADJUSTED_ATTR(champion, GET_PLAYER_ABILITY(champion, abStr, 0) + (RAND() & 15));
		}
		//^12B4:0803
		if (bp18 != bp16 && bp18 != 0xffff) {
			//^12B4:0811
			champion = &glbChampionSquad[bp18];
			bp0c += STAMINA_ADJUSTED_ATTR(champion, GET_PLAYER_ABILITY(champion, abStr, 0) + (RAND() & 15));
		}
		//^12B4:084F
		ATTACK_DOOR(bp1a, bp1c, bp0c, 0, 0);
		break;
	case 5://^0864
		break;
	}
	//^12B4:0864
	_1031_098e();
	_4976_4e5c = 0;
	return 0;
}

//^1031:1951
Bit16u SkWinCore::HANDLE_UI_EVENT(MousePosition *ref)
{
	// CSBwinSimilarity: TAG01a7b2,_HandleMouseEvents

	// process user input event such as mouse click and keyboard pressure.

	//^1031:1951
	ENTER(46);
	//^1031:1957
	Bit16u si = ref->event;
	Bit16u bp04 = ref->XPos;
	Bit16u bp06 = ref->YPos;
	//^1031:196B
	//if (si >= 0x03 && si <= 0x06) {
	if (si >= UI_EVENTCODE_MOVE_FIRST && si <= UI_EVENTCODE_MOVE_LAST) {
		//^1031:1975
		if (_4976_4c00 != 0)
			//^1031:197A
			goto _19b1;
		//^1031:197C
		if (glbPlayerThrowCounter != 0 && ((glbPlayerDir +si -3) & 3) == _4976_4c0c)
			//^1031:197A
			goto _19b1;
	}
	//^1031:1994
	if (glbIsPlayerMoving != 0) {
		//^1031:199B
		//if (si == 0x01 || si == 0x02 || si == 0x03)
		if (si == UI_EVENTCODE_TURN_LEFT || si == UI_EVENTCODE_TURN_RIGHT || si == UI_EVENTCODE_MOVE_FORWARD)
			//^1031:19A8
			goto _19b1;
	}
	//^1031:19AA
	Bit16u di;
	if (_4976_4dfe != 0) {
		//^1031:19B1
_19b1:
		_4976_4e5c = 1;
		//^1031:19B7
        di = 0;
		//^1031:19B9
		//^1031:1E64
		return di;
	}
	//^1031:19BC
	di = 1;
	//^1031:19BF
	_4976_4e5c = 0;
	//^1031:19C5
	i16 bp02;
	if (si == UI_EVENTCODE_RELEASE_MOUSE_BUTTON) {	// 0xE3
		//^1031:19CB
		_1031_050c();
	}
	//^1031:19D2
	//else if (si == 0xe1) {
	else if (si == UI_EVENTCODE_MOVE_OBJECT) {	// 0xE1
		//^1031:19D8
		_1031_04f5();
	}
	//^1031:19DF
	else if (si == UI_EVENTCODE_TURN_RIGHT || si == UI_EVENTCODE_TURN_LEFT) {
		//^1031:19E9
		PERFORM_TURN_SQUAD(si);  // 1="TURN LEFT", 2="TURN RIGHT" at arrow panel
	}
	//^1031:19F2
	else if (si >= UI_EVENTCODE_MOVE_FIRST && si <= UI_EVENTCODE_MOVE_LAST) {
		//^1031:19FC
		PERFORM_MOVE(si);  // 3="MOVE FORWARD", 4="MOVE RIGHT", 5="MOVE BACK", 6="MOVE LEFT"
	}
	//^1031:1A05
	// SPX: Covers all item clickable slots : champions hands, inventory, container. x42-x14 = d46
	//else if (si >= 0x14 && si <= 0x42) {
	else if (si >= UI_EVENTCODE_ITEM_SLOT_FIRST && si <= UI_EVENTCODE_ITEM_SLOT_LAST) {
		//^1031:1A0F
		CLICK_ITEM_SLOT(si - UI_EVENTCODE_ITEM_SLOT_FIRST);
	}
	//^1031:1A1D
	// SPX: When dropping item on stats bar
	//else if (si >= 0xea && si <= 0xed) {
	else if (si >= UI_EVENTCODE_CLICK_STATS_BAR_1 && si <= UI_EVENTCODE_CLICK_STATS_BAR_4) {
		//^1031:1A29
		PUT_ITEM_TO_PLAYER(si - UI_EVENTCODE_CLICK_STATS_BAR_1);
		// SPX: extended mode : clicking on stats bar will give player main stats :)
		if (SkCodeParam::bUseDM2ExtendedMode && glbLeaderHandPossession.object == OBJECT_NULL)
		{
			U8 message[64];
			U8 player = si - UI_EVENTCODE_CLICK_STATS_BAR_1;
			sprintf((char*)message, "HP %d / %d | STA %d / %d | MANA %d / %d\n",
				glbChampionSquad[player].curHP(), glbChampionSquad[player].maxHP(),
				glbChampionSquad[player].curStamina()/10, glbChampionSquad[player].maxStamina()/10,
				glbChampionSquad[player].curMP(), glbChampionSquad[player].maxMP());
			DISPLAY_HINT_TEXT(glbChampionColor[player], message);
		}
	}
	//^1031:1A37
	//else if (si >= 0x7d && si <= 0x81) {
	else if (si >= UI_EVENTCODE_TAKE_CHAMPION_TOP_LEFT && si <= UI_EVENTCODE_UPDATE_CHAMPION_POSITION) {
		//^1031:1A42
		if (si == UI_EVENTCODE_UPDATE_CHAMPION_POSITION) {
			//^1031:1A48
			CHAMPION_SQUAD_RECOMPUTE_POSITION();
		}
		else {
			//^1031:1A4F
			CHANGE_PLAYER_POS(si - UI_EVENTCODE_TAKE_CHAMPION_TOP_LEFT);
		}
		//^1031:1A5B
		_1031_0667();
		//^1031:1A5F
		goto _1ab8;
	}
	//^1031:1A61
	// SPX: One for each moneybox part?
	else if (si >= UI_EVENTCODE_MONEYBOX_1 && si <= UI_EVENTCODE_MONEYBOX_6) {	// (si >= 0xe4 && si <= 0xe9)
		//^1031:1A6D
		CLICK_MONEYBOX(si - UI_EVENTCODE_MONEYBOX_1);	// -0xE4
	}
	//^1031:1A7B
	else if (si == UI_EVENTCODE_CHAMPION_TURN_LEFT || si == UI_EVENTCODE_CHAMPION_TURN_RIGHT) {	// (si == 0x5d || si == 0x5e)
		//^1031:1A85
		bp02 = (si == UI_EVENTCODE_CHAMPION_TURN_LEFT) ? -1 : 1;
		//^1031:1A95
		glbChampionTable[glbChampionIndex].playerDir((glbChampionTable[glbChampionIndex].playerDir() +bp02) & 3);
		//^1031:1AB8
_1ab8:
		UPDATE_RIGHT_PANEL(0);
	}
	//^1031:1AC2
	else if (si >= UI_EVENTCODE_010 && si <= UI_EVENTCODE_013) {	// (si >= 0x10 && si <= 0x13)
		//^1031:1ACC
		SELECT_CHAMPION_LEADER(GET_PLAYER_AT_POSITION((si -UI_EVENTCODE_010 + glbPlayerDir) & 3));
		//^1031:1AE5
		_2e62_0cfa(0);
	}
	//^1031:1AEF
	//else if (si >= 0x07 && si <= 0x0b) {
	else if (si >= UI_EVENTCODE_VIEW_CHAMPION_1 && si <= UI_EVENTCODE_RETURN_VIEWPORT) {
		//^1031:1AF9
		if (glbNextChampionNumber != 0 && si <= UI_EVENTCODE_RETURN_VIEWPORT) {
			//^1031:1B05
			//^1031:1DDE
			_2f3f_04ea_CHAMPION(glbPlayerPosX, glbPlayerPosY, glbPlayerDir, glbPlayerMap, 0xa1);
		}
		else {
			//^1031:1B0B
			Bit16u bp02 = si -UI_EVENTCODE_VIEW_CHAMPION_1;
			//^1031:1B13
			if (bp02 == 4 || bp02 < glbChampionsCount) {
				//^1031:1B21
				if (glbNextChampionNumber == 0) {
					//^1031:1B2B
					INTERFACE_CHAMPION(bp02);
					// SPX TODO: This is switch viewport/champion view?
				}
			}
		}
	}
	//^1031:1B37
	//else if (si == 0x52) {
	else if (si == UI_EVENTCODE_VIEW_LEADER) {
		//^1031:1B3C
		if (glbChampionLeader != 0xffff) {
			//^1031:1B46
			INTERFACE_CHAMPION(glbChampionLeader);
		}
	}
	//^1031:1B53
	else if (si == UI_EVENTCODE_VALIDATE_SPELL) {
		//^1031:1B58
		_4976_4e5c = TRY_CAST_SPELL();
		//^1031:1B5D
		//^1031:1BA9
	}
	//^1031:1B5F
	else if (si == UI_EVENTCODE_REMOVE_RUNE) {
		//^1031:1B64
		REMOVE_RUNE_FROM_TAIL();
	}
	//^1031:1B6C
	else if (si >= UI_EVENTCODE_ADD_RUNE_1 && si <= UI_EVENTCODE_ADD_RUNE_6) {
		//^1031:1B76
		ADD_RUNE_TO_TAIL(si - UI_EVENTCODE_ADD_RUNE_1);
	}
	//^1031:1B84
	//else if (si == 0x70) {
	else if (si == UI_EVENTCODE_HAND_RUNE_QUIT) {
		//^1031:1B89
		PROCEED_COMMAND_SLOT(-1);
	}
	//^1031:1B93
	//else if (si >= 0x71 && si <= 0x73) {
	else if (si >= UI_EVENTCODE_HAND_ACTION_1 && si <= UI_EVENTCODE_HAND_ACTION_3) {
		//^1031:1B9D
		_4976_4e5c = PROCEED_COMMAND_SLOT(si -UI_EVENTCODE_HAND_ACTION_1);
	}
	//^1031:1BAF
	//else if (si >= 0x74 && si <= 0x7b) {
	else if (si >= UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT && si <= UI_EVENTCODE_CHAMPION4_ACTION_HAND_LEFT) {
		//^1031:1BB9
		si -= UI_EVENTCODE_CHAMPION1_ACTION_HAND_RIGHT;
		//^1031:1BBC
		ACTIVATE_ACTION_HAND(si >> 1, ((si & 1) != 0) ? 1 : 0);
	}
	//^1031:1BD6
	//else if (si >= 0x5f && si <= 0x62) {
	else if (si >= UI_EVENTCODE_SPELL_OR_LEADER_1 && si <= UI_EVENTCODE_SPELL_OR_LEADER_4) {
		//^1031:1BE0
		i16 bp02 = GET_PLAYER_AT_POSITION((si -UI_EVENTCODE_SPELL_OR_LEADER_1 + glbPlayerDir) & 3);
		//^1031:1BF6
		if (bp02 >= 0) {
			//^1031:1BFD
			SET_SPELLING_CHAMPION(bp02);
		}
	}
	//^1031:1C09
	//else if (si == 0x46) {
	else if (si == UI_EVENTCODE_MOUTH) {
		//^1031:1C0E
		PLAYER_CONSUME_OBJECT(0xffff, OBJECT_NULL, -1);
	}
	//^1031:1C1B
	//else if (si == 0x47) {
	else if (si == UI_EVENTCODE_EYE) {
		//^1031:1C20
		CLICK_INVENTORY_EYE();
	}
	//^1031:1C28
	//else if (si == 0x50) {
	else if (si == UI_EVENTCODE_CLICK_VIEWPORT) {
		//^1031:1C2D
		CLICK_VWPT(bp04, bp06);
	}
	//^1031:1C3D
	//else if (si == 0x96) {
	else if (si == UI_EVENTCODE_MAGIC_MAP) {
		//^1031:1C43
		CLICK_MAGICAL_MAP_AT(si, bp04, bp06);
	}
	//^1031:1C54
	// SPX: Clicking runes on magical maps (runes = KU, ROS, DAIN, NETA)
	//else if (si >= 0x97 && si <= 0x9a) {
	else if (si >= UI_EVENTCODE_MAGIC_MAP_RUNE_1 && si <= UI_EVENTCODE_MAGIC_MAP_RUNE_4) {
		//^1031:1C60
		CLICK_MAGICAL_MAP_RUNE(si -UI_EVENTCODE_MAGIC_MAP_RUNE_1);
	}
	//^1031:1C6F
	//else if (si == 0x93) {
	else if (si == UI_EVENTCODE_PAUSE) {
		//^1031:1C75
		_4976_4c02 = 0;
		//^1031:1C7B
		_38c8_0002();
		//^1031:1C80
		FILL_ENTIRE_PICT(_4976_4c16, glbPaletteT16[COLOR_BLACK]);
		//^1031:1C9A
		Bit8u bp2e[40];
		// SPX: text = GAME PAUSED
		DRAW_VP_RC_STR(
			6,
			glbPaletteT16[COLOR_CYAN],
			QUERY_GDAT_TEXT(0x01, 0x00, 0x12, bp2e)
			);
		//^1031:1CC4
		CHANGE_VIEWPORT_TO_INVENTORY(0);
		//^1031:1CCC
		_1031_0675(3);
		//^1031:1CD3
		_1031_098e();
	}
	//^1031:1CDA
	//else if (si == 0x94) {
	else if (si == UI_EVENTCODE_END_PAUSE) {
		//^1031:1CE0
		if (_4976_4c02 == 0) {
			//^1031:1CEA
			_4976_4c02 = 1;
			//^1031:1CF0
			_38c8_0060();
			//^1031:1CF5
			_1031_06a5();
			//^1031:1CF9
			_1031_098e();
		}
	}
	//^1031:1D00
	else if (true
		&& glbShowItemStats == 0 
		&& _4976_4bfe == 0 
		&& _4976_4c3e == 0
		&& _4976_4ddc == 0
	) {
		//^1031:1D28
		//if (si == 0x91) {
		if (si == UI_EVENTCODE_SLEEP) {
			//^1031:1D2E
			if (glbNextChampionNumber == 0) {
				//^1031:1D38
				_4976_3d59 = 0;
				//^1031:1D3E
				if (glbChampionInventory != 0) {
					//^1031:1D45
					INTERFACE_CHAMPION(4);
				}
				//^1031:1D4D
				_4976_3d59 = 1;
				//^1031:1D53
				DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
				//^1031:1D58
				_38c8_0002();
				//^1031:1D5D
				glbIsPlayerSleeping = 1;
				//^1031:1D63
				if (glbIsPlayerMoving != 0) {
					//^1031:1D6A
					PERFORM_MOVE(glbPlayerLastMove);
					//^1031:1D74
					glbIsPlayerMoving = 0;
				}
				//^1031:1D7A
				DRAW_WAKE_UP_TEXT();
				//^1031:1D7E
				CHANGE_VIEWPORT_TO_INVENTORY(0);
				//^1031:1D86
				glbTickSpeed = 1;
				//^1031:1D8C
                _1031_0541(2);
				//^1031:1D93
				_1031_098e();
			}
		}
		//^1031:1D9A
		//else if (si == 0x92) {
		else if (si == UI_EVENTCODE_WAKE) {
			//^1031:1DA0
			RESUME_FROM_WAKE();
		}
		//^1031:1DA8
		//else if (si == 0x8c) {
		else if (si == UI_EVENTCODE_DISK_OP) {
			//^1031:1DAE
			if (glbChampionsCount > 0 && glbNextChampionNumber == 0) {
				//^1031:1DC2
				_4976_4e62--;
				//^1031:1DC6
				GAME_SAVE_MENU();
				//^1031:1DCB
                _4976_4e62++;
			}
		}
		//^1031:1DD1
		//else if (si == 0xa0 || si == 0xa1) {
		else if (si == UI_EVENTCODE_REVIVE_CHAMPION || si == UI_EVENTCODE_EXIT_CRYOCELL) {
			//^1031:1DDD
            _2f3f_04ea_CHAMPION(glbPlayerPosX, glbPlayerPosY, glbPlayerDir, glbPlayerMap, si);
		}
		//^1031:1DF8
		//else if (si == 0xd7) {
		else if (si == UI_EVENTCODE_START_NEW_GAME) {
			//^1031:1DFE

			// "NEW" at main menu
			glbSpecialScreen = 1;
		}
		//^1031:1E06
		//else if (si == 0xd8) {
		else if (si == UI_EVENTCODE_0D8) {
			//^1031:1E0C
			glbSpecialScreen = 1;
			_4976_5bea = 1;
		}
		//^1031:1E1A
		//else if (si == 0xd9) {
		else if (si == UI_EVENTCODE_RESUME_GAME) {
			//^1031:1E20
			// "RESUME" at main menu
			glbSpecialScreen = 0;
		}
		//^1031:1E28
		//else if (si == 0xda) {
		else if (si == UI_EVENTCODE_SHOW_CREDITS) {
			//^1031:1E2E
			SHOW_CREDITS();
		}
		//^1031:1E35
		//else if (si == 0xdf) {
		else if (si == UI_EVENTCODE_0DF) {
			//^1031:1E3B
			_4976_5bf2 = 1;
		}
		//^1031:1E43
		//else if (si == 0xe0) {
		else if (si == UI_EVENTCODE_QUIT_GAME) {
			//^1031:1E49
			SK_PREPARE_EXIT();
		}
	}
	//^1031:1E4E
	//if (glbUIEventCode >= 0xa5 && glbUIEventCode <= 0xc6)
	if (glbUIEventCode >= UI_EVENTCODE_0A5 && glbUIEventCode <= UI_EVENTCODE_0C6)
		//^1031:1E5E
		_4976_4e5c = 1;
	//^1031:1E66
	return di;
}

//^1031:1E6A
// SPX: _1031_1e6a renamed MAIN_LOOP
void SkWinCore::MAIN_LOOP() //#DS=4976
{
	//^1031:1E6A
	ENTER(0);
	//^1031:1E6E
	if (_4976_4dfe != 0)
		//^1031:1E75
		_4976_4dfe--;
	//^1031:1E79
	_4976_4e48 = 0;

	do {
		MessageLoop(true); // main menu

		//^1031:1E7F
		IBMIO_USER_INPUT_CHECK();
		//^1031:1E83
		if (_4976_4e60 == _4976_4e5e)
			//^1031:1E8A
			break;
		//^1031:1E8C
		Bit16u si = _4976_4e60++;
		//^1031:1E94
		if (_4976_4e60 > 2)
			//^1031:1E9C
			_4976_4e60 = 0;
		//^1031:1EA2
		if (HANDLE_UI_EVENT(&_4976_4e6c[si]) != 0) {
			//^1031:1EB8
			if (_4976_4e62 != 0)
				//^1031:1EBF
				_4976_4e62--;
		}
		else {
			//^1031:1EC5
			_4976_4e60 = si;
		}
		//^1031:1EC9
	} while (_4976_4e5c == 0);
	//^1031:1ED0
	return;
}

//^476D:04ED
Bit16u SkWinCore::_476d_04ed(Bit16u xx)
{
	//^476D:04ED
	ENTER(0);
	//^476D:04F0
	return 0;
}

//^1031:06B3
sk0d9e *SkWinCore::_1031_06b3(sk1891 *ref, X16 xx)
{
	//^1031:06B3
	ENTER(12);
	//^1031:06B8
	U8 *bp0c = _1031_023b(ref);
	//^1031:06CC
	do {
		sk1891 *bp08 = &_4976_1574[*bp0c & 0xff7f];
		if ((this->*_4976_0cba[ref->b0_0_6()])(bp08) != 0) {
			//^1031:0702
			if (bp08->b0_7_7() == 1) {
				//^1031:070E
				sk0d9e *bp04 = _1031_06b3(bp08, xx);
				if (bp04 != 0)
					return bp04;
			}
			else {
				//^1031:0734
				sk0d9e *bp04 = _1031_024c(bp08);
				if (bp08 != NULL) {
					X16 si;
					for (; (si = (0x7ff & bp04->w0)) != 0; bp04++) {
						//^1031:074C
						if (xx != si)
							return bp04;
						//^1031:0753
					}
				}
			}
		}
		//^1031:0766
	} while ((*(++bp0c) & 0x80) == 0);
	//^1031:077A
	return NULL;
}

//^1031:0781
void SkWinCore::_1031_0781(Bit16u xx) 
{
	//^1031:0781
	ENTER(12);
	//^1031:0785
	sk0d9e *bp04 = _1031_06b3(&_4976_1891[_4976_19ad], xx);
	SRECT bp0c;
	if (bp04 != NULL && _1031_01d5(bp04->w2, &bp0c) != 0) {
		//^1031:07BB
		FIRE_QUEUE_MOUSE_EVENT(bp0c.x, bp0c.y, 255 & bp04->w4);
	}
	//^1031:07D4
	return;
}

//^4726:0383
void SkWinCore::_4726_0383()
{
	//^4726:0383
	ENTER(0);
	//^4726:0386
	LOADDS(0x0433);
	glbAbsoluteTickCounter += glbTickStepValue;
	glbIntermediateTickCounter += glbTickStepValue;
	if (i16(glbIntermediateTickCounter) >= i16(glbTickSpeed))
		glbTickStepReached = 1;

	if (glbTickStepReached)
	{
		SkD((DLV_DBG_TICK, "GameTick:%06d, TStep:%02d, TAbsolute:%03d, TCurrent:%03d, TSpeed:%03d, Reached:%d\n"
			, glbGameTick
			, glbTickStepValue
			, glbAbsoluteTickCounter
			, glbIntermediateTickCounter
			, glbTickSpeed
			, glbTickStepReached
			));
		SkD((DLV_DBG_TICK, "==================================================================\n"));
	}
	//^4726:03B0
	return;
}

//^01B0:051A
Bit16u SkWinCore::_01b0_051a() //#DS=04BF
{
	//^01B0:051A
	ENTER(0);
	//^01B0:051E
	LOADDS(0x3083);
	//^01B0:0524
	if (glbDMode != 0 && _04bf_0284 != 0) {
		//^01B0:0532
		_4726_0383() INDIRECT_CALL;
	}
	//^01B0:0536
	return (_04bf_1886 != 0) ? 1 : 0;
}

//^476D:05A9
Bit16u SkWinCore::_476d_05a9()
{
	//^476D:05A9
	ENTER(0);
	//^476D:05AC
	return _01b0_051a() CALL_IBMIO;
}

//^476D:04E8
Bit8u SkWinCore::_476d_04e8(Bit16u xx) { // TODO: Unr
	Unr(); return 0;
}

//^476D:04AF
Bit16u SkWinCore::_476d_04af(Bit16u xx) { // TODO: Unr
	Unr(); return 0;
}

//^01B0:04E4
X16 SkWinCore::_01b0_04e4() //#DS=04BF
{
	//^01B0:04E4
	ENTER(0);
	//^01B0:04E8
	LOADDS(0x3083);
	while (_04bf_1886 == 0);
	//^01B0:04F5
	X16 si = _04bf_188e[_04bf_1864];
	_04bf_1864 = (_04bf_1864 +1) % 10;
	_04bf_1886--;
	return si;
}

//^476D:050E
Bit16u SkWinCore::_476d_050e()
{
	//^476D:050E
	ENTER(0);
	//^476D:0513
	X16 si = _01b0_04e4() CALL_IBMIO;
	X16 di = si;
	switch (di) {
	case 0x1048://^0534
		si = 0x4c; break;
	case 0x1050://^0539
		si = 0x50; break;
	case 0x104B://^053E
		si = 0x4b; break;
	case 0x104D://^0543
		si = 0x4d; break;
	case 0x124B://^0548
		si = 0x4f; break;
	case 0x124D://^054D
		si = 0x51; break;
	}
	//^476D:0550
	return si;
}
//^1031:06A5
void SkWinCore::_1031_06a5()
{
	//^1031:06A5
	ENTER(0);
	//^1031:06A8
	_1031_0541(_4976_4ea8);
	//^1031:06B1
	return;
}

//^2066:2CA8
Bit16u SkWinCore::LOAD_NEW_DUNGEON() 
{
	//^2066:2CA8
	ENTER(6);
	//^2066:2CAD
	X8 bp05 = 0;
	U8 *bp04 = ALLOC_MEMORY_RAM(0x400, afDefault, 0x80);

	Bit8u* sDungeonFilename = NULL;

	if (false) {
		//^2066:2CCB

		//^2066:2D0C
	}
	DEALLOC_UPPER_MEMORY(0x400);
	if (_4976_5bea == 0 || (glbDataFileHandle = OPEN_FILE(FORMAT_SKSTR(ptrDungenB, NULL))) < 0)
	{
		// Default is the DUNGEON.DAT filename
		sDungeonFilename = (Bit8u*) ptrDungeonFilename;

		if (skwin.sCustomDungeonDatFilename != NULL)
			sDungeonFilename = (Bit8u*) skwin.sCustomDungeonDatFilename;
		
		glbDataFileHandle = OPEN_FILE(FORMAT_SKSTR(sDungeonFilename, NULL));
	}
	if (glbDataFileHandle < 0) 
	{
		//^2066:2D6C
		RAISE_SYSERR(SYSTEM_ERROR__MISSING_DUNGEON);
	}
	//^2066:2D74
	_4976_5bf6 = 0;
	glbChampionsCount = 0;
	glbLeaderHandPossession.object = OBJECT_NULL;
	_4976_524a = 0;
	return READ_DUNGEON_STRUCTURE(1);
}

//^2066:2CA8
// SPX: original LOAD_NEW_DUNGEON
Bit16u SkWinCore::ORIGINAL__LOAD_NEW_DUNGEON() 
{
	//^2066:2CA8
	ENTER(6);
	//^2066:2CAD
	X8 bp05 = 0;
	U8 *bp04 = ALLOC_MEMORY_RAM(0x400, afDefault, 0x80);
	if (false) {
		//^2066:2CCB

		//^2066:2D0C
	}
	DEALLOC_UPPER_MEMORY(0x400);
	if (_4976_5bea == 0 || (glbDataFileHandle = OPEN_FILE(FORMAT_SKSTR(ptrDungenB, NULL))) < 0) {
		//^2066:2D45
		glbDataFileHandle = OPEN_FILE(FORMAT_SKSTR(ptrDungeonFilename, NULL));
	}
	if (glbDataFileHandle < 0) {
		//^2066:2D6C
		RAISE_SYSERR(SYSTEM_ERROR__MISSING_DUNGEON);
	}
	//^2066:2D74
	_4976_5bf6 = 0;
	glbChampionsCount = 0;
	glbLeaderHandPossession.object = OBJECT_NULL;
	_4976_524a = 0;
	return READ_DUNGEON_STRUCTURE(1);
}

//^2066:32BB
i16 SkWinCore::SELECT_LOAD_GAME()
{
	//^2066:32BB
	ENTER(14);
	//^2066:32C1
	if (_4976_5bf2 != 0)
		return _4976_525c;
	__OPEN_DIALOG_PANEL(0x80, 5);
	_2066_398a(-1);
	_0aaf_002f();
	FIRE_FADE_SCREEN(0);
	U16 bp06 = 0;
	i16 si = -1;
	_4976_4dfc = 255;
	do {
		MessageLoop(true); // game load

		//^2066:32FD
		while (_476d_05a9() != 0) {
			_1031_0d36(0x20, _476d_050e());
		}
		//^2066:3317
		MAIN_LOOP();
		SRECT bp0e;
		i16 bp02;
		i16 bp04;
		U16 di;
		switch (_4976_4dfc) {
			case 1://^_3330
				//^2066:3330
				si = -1;
				goto _3333;
			case 2://^_3333
				//^2066:3333
_3333:
				bp06 = 1;
				break;
			case 3://^_333a
				//^2066:333A
				QUERY_EXPANDED_RECT(_4976_4df8, &bp0e);
				QUERY_TOPLEFT_OF_RECT(_4976_4e44, &bp02, &bp04);
				di = _4976_4e68;
				di -= bp0e.y +bp04;
				si = min_value(di / glbPanelStatsYDelta, 10);
				//^2066:3380
				if (_4976_5250[si].w40 == 0xDEAD && _4976_5250[si].w38 == 0xBEEF)
					si = -1;
				_2066_398a(si);
				_0aaf_002f();
			default://^_33aa
				break;
		}
		//^2066:33AA
		_4976_4dfc = 0xffff;
		//^2066:33B0
	} while (bp06 == 0);
	//^2066:33B9
	_2066_37f2();
	return si;
}

//^2FCF:0B8B
void SkWinCore::_2fcf_0b8b(Bit16u xx, Bit16u yy, Bit16u zz)
{
	//^2FCF:0B8B
	ENTER(6);
	//^2FCF:0B91
	_4976_4c12 = 0xffff;
	//^2FCF:0B97
	TELE_inf bp06;
	_4976_4c08 = GET_TELEPORTER_DETAIL(&bp06, Bit8u(xx), Bit8u(yy));
	//^2FCF:0BAD
	if (_4976_4c08 != 0) {
		//^2FCF:0BB1
		_4976_4c12 = bp06.target_z();
		_4976_4c04 = bp06.target_x_pos();
		_4976_4c1e = bp06.target_y_pos();
		_4976_4c10 = (glbPlayerDir + (bp06.cross_scene_test_of_teleporter_target() - bp06.cross_scene_test())) & 3;
	}
	else {
		//^2FCF:0BE6
		for (Bit16u si = 0; si < 4; si++) {
			//^2FCF:0BEA
			if (GET_TELEPORTER_DETAIL(&bp06, xx + glbXAxisDelta[si], yy + glbYAxisDelta[si]) != 0) {
				//^2FCF:0C13
				_4976_4c12 = bp06.target_z();
				//^2FCF:0C1B
				Bit16u di = bp06.cross_scene_test_of_teleporter_target() +6 -bp06.cross_scene_test();
				//^2FCF:0C2C
				si = (si +di +2) & 3;
				//^2FCF:0C37
				_4976_4c04 = bp06.target_x_pos() + glbXAxisDelta[si];
				//^2FCF:0C47
				_4976_4c1e = bp06.target_y_pos() + glbYAxisDelta[si];
				//^2FCF:0C57
				_4976_4c10 = (glbPlayerDir + di) & 3;
				//^2FCF:0C62
				break;
			}
			//^2FCF:0C64
		}
	}
	//^2FCF:0C6A
	glbCurrentMapIndex = -1;
	//^2FCF:0C70
	CHANGE_CURRENT_MAP_TO(zz);
	//^2FCF:0C79
	return;
}

//^443C:06AF
void SkWinCore::_443c_06af(sk0cea *ref)
{
	//^443C:06AF
	ENTER(0);
	//^443C:06B2
	return;
}

//^1031:096A
void SkWinCore::_1031_096a()
{
	//^1031:096A
	ENTER(0);
	//^1031:096E
	for (i16 si = 0; si < 18; si++) {
		//^1031:0972
		_443c_06af(&_4976_0ce0[1 +si]);
		//^1031:0985
	}
	//^1031:098B
	return;
}

//^482B:015C
// SPX: looks like searching next available index in the _4976_49d4 table ?
Bit16u SkWinCore::_482b_015c(Bit16u xx)
{
	//^482B:015C
	ENTER(0);
	//^482B:0160
	for (Bit16u si = 0; si < _4976_49d4[0][0]; si++) {
		//^482B:0164
		if (_4976_5f06[si].w5 == xx) {
			//^482B:017A
			return si +1;
		}
		//^482B:017F
	}
	//^482B:0186
	return 0;
}

//^01B0:18D3
void SkWinCore::_01b0_18d3(Bit16u xx) //#DS=4976
{
	//^01B0:18D3
	ENTER(2);
	//^01B0:18D8
	Bit8u bp02 = _4976_04ee;
	//^01B0:18E9
	LOADDS(0x3083);	//#DS=04BF
	//^01B0:18EF
	if (sndSoundInBuffer != 0) {
		//^01B0:18F6
		if (sndLockSoundBuffer != 0) {
			//^01B0:18FE
			sndLockSoundBuffer = 1;	
			//^01B0:1908
			while (sndLockSoundBuffer != 0);
			//^01B0:1910
			for (Bit16u si = 0; si < sndSoundBufferSize; si++) {
				//^01B0:1914
				sndSoundBuffer[si] = 0;
				//^01B0:192C
			}
		}
		//^01B0:1933
	}
	else {
		//^01B0:1935
		IBMIO_BLEND_TO_SNDBUFF(&bp02, 1, 1, 6000);
	}
	//^01B0:1949
	return;
}

//^47EB:02C3
void SkWinCore::_47eb_02c3(sk5f0a *ref)
{
	//^47EB:02C3
	ENTER(0);
	//^47EB:02C6
	_01b0_18d3(0) CALL_IBMIO;
	//^47EB:02D1
	return;
}

//^47EB:00D9
void SkWinCore::_47eb_00d9(sk5f0a *ref)
{
	//^47EB:00D9
	ENTER(4);
	//^47EB:00DD
	_47eb_02c3(ref);
	//^47EB:00EA
	sk5f0a **bp04 = &_4976_5efa;
	//^47EB:00F2
	while ((*bp04) != NULL && (*bp04) != ref) {
		//^47EB:00F4
		bp04 = &(*bp04)->pv8;
		//^47EB:0107
	}
	//^47EB:0124
	if ((*bp04) == ref) {
		//^47EB:0138
		(*bp04) = ref->pv8;
	}
	//^47EB:014D
	return;
}

//^482B:07C2
void SkWinCore::_482b_07c2(Bit16u xx)
{
	//^482B:07C2
	ENTER(0);
	//^482B:07C7
	Bit16u si;
	for (si = 0; _4976_49d4[0][0]-- > si; ) {
		//^482B:07CB
		Bit16u di = _4976_5f06[_4976_49d4[0][0]].w5;
		//^482B:07DF
		if (di != 0xffff) {
			//^482B:07E4
			if (_482b_015c(di) == 0) {
				//^482B:07EE
				_47eb_00d9(&_4976_5f0a[_4976_5f06[_4976_49d4[0][0]].w0]);
				//^482B:0814
				_4976_49d4[0][1]--;
			}
		}
		//^482B:0818
	}
	//^482B:0823
	_4976_49d4[0][0] = si;
	_4976_49d0 = 0;
	//^482B:082D
	return;
}

//^4726:00F3
void SkWinCore::EMS_FREE()
{
#if UseAltic
	;
#else
//		//^4726:00F3
//		ENTER(0);
//		//^4726:00F6
//		if (_4976_5ea4 != 0) {
//			//^4726:00FD
//			__asm mov dx,[_4976_5ea4]
//			__asm mov ah,0x45
//			__asm int 0x67
//		}
//		//^4726:0105
//		return;
#endif
}

//^069A:05DE
void SkWinCore::_farfree(void *ref) {
	ATLASSERT(false);
}

//^069A:014A
void SkWinCore::__restorezero() {
}

//^069A:00EA
void __declspec(noreturn) SkWinCore::__terminate(Bit8u errorLevel)
{
	ATLASSERT(false);
//		//^069A:00EA
//		//^069A:00EF
//		__restorezero();
//		//^069A:00F4
//		__asm mov bp,sp
//		__asm mov ah,0x4c
//		__asm mov al,[bp+04]
//		__asm int 0x21h
}

//^4726:0448
void SkWinCore::SK_EXIT()
{
	//^4726:0448
	ENTER(0);
	//^4726:044B
	EMS_FREE();
	//^4726:044F
	_farfree(_4976_5e94);
	//^4726:045E
	__terminate((_4976_4c26 != 0) ? 1 : 0);
	//^4726:0473
	return;
}

//^069A:043C
void SkWinCore::_sk_longjmp(jmp_buf xx, Bit16u yy)
{
	ATLASSERT(false);
	longjmp(xx, yy);
}

//^101B:0111
void SkWinCore::SK_PREPARE_EXIT()
{
	//^101B:0111
	ENTER(0);
	//^101B:0114
	_1031_096a();
	//^101B:0119
	while (glbMouseVisibility <= 0)
		//^101B:011B
		FIRE_HIDE_MOUSE_CURSOR();
	//^101B:0127
	GRAPHICS_DATA_CLOSE();
	//^101B:012C
	GRAPHICS_DATA_CLOSE();
	//^101B:0131
	_482b_07c2(1);
	//^101B:0139
	if (_4976_4c26 != 0) {
		//^101B:0140
		FIRE_FILL_SCREEN_RECT(2, 0);
	}
#if UseAltic
	throw i8(0);
#else
	//^101B:014B
	SK_EXIT();
	//^101B:0150
	_sk_longjmp(_4976_4de0, 1);
#endif
	//^101B:015B
	return;

}

//^3A15:3331
void SkWinCore::ACTIVATE_TICK_GENERATOR(Actuator *ref, ObjectID recordLink)
{
	//^3A15:3331
    //^3A15:3337
	Bit16u di = ref->ActuatorType();
	//^3A15:3343
	Bit16u si;
	switch (di) {
		case ACTUATOR_TYPE_TICK_GENERATOR: // 0x001e -> Activator, tick generator
			//^3A15:3358
			si = 1; break;
		case ACTUATOR_TYPE_X33_V008: // 0x0033 -> -
			//^3A15:335D
			si = 8; break;
		case ACTUATOR_TYPE_X34_V016: // 0x0034 -> -
			//^3A15:3362
			si = 16; break;
		case ACTUATOR_TYPE_X35_V032: // 0x0035 -> -
			//^3A15:3367
			si = 32; break;
		case ACTUATOR_TYPE_X36_V064: // 0x0036 -> -
			//^3A15:336C
			si = 64; break;
		case ACTUATOR_TYPE_X37_V128: // 0x0037 -> -
			//^3A15:3371
			si = 128; break;
	}
	//^3A15:3374
	if (ref->ActuatorData() != 0) {
		//^3A15:3385
		Timer bp0a;
		bp0a.SetMap(glbCurrentMapIndex);
		bp0a.SetTick(glbGameTick + (glbGameTick % (Bit32u(ref->ActuatorData()) * Bit32u(si))));
		bp0a.TimerType(ttyTickGenerator);
		bp0a.actor = 0x00;
		bp0a.value = recordLink;
		bp0a.Value2(Bit8u(si & 0xff));
		bp0a.ActionType(0);
		//^3A15:33ED
		QUEUE_TIMER(&bp0a);
	}
	//^3A15:3400
	return;
}

//^0B36:1647
void SkWinCore::DRAW_DIALOGUE_PARTS_PICT(Bit8u *buffsrc, SRECT *rc, __int16 colorkey, Bit8u *localpal)
{
	// the back buffer is an off-screen buffer of the dungeon viewport (224x136x8bpp)

	// what you draw:
	// a) dialogue window
	// b) dialogue button
	// c) 18x18 bevelled icon frame

	//^0B36:1647
	//^0B36:164A
	FIRE_BLIT_PICTURE(
		buffsrc,
		_4976_4c16,
		rc,
		0,
		0,
		READ_UI16(buffsrc,-4),
		_4976_00f6,
		colorkey,
		0,
		READ_UI16(buffsrc,-6),
		8,
		localpal
		);
	//^0B36:1686
	return;
}

//^3E74:0AE3
void SkWinCore::FREE_PICT_ENTRY(Bit8u *buff)
{
	//^3E74:0AE3
	//^3E74:0AE7
	if (_4976_5d76 == 0) {
		//^3E74:0AF1
		sk5cfc_image *bp04 = reinterpret_cast<sk5cfc_image *>(&_4976_5cfc);
		//^3E74:0AF9
		for (; (void *)PTR_PADD(buff,-int(sizeof(sk5cfc_image))) != (void *)bp04->pv0; ) {
			//^3E74:0AFB
			bp04 = bp04->pv0;
		}
		//^3E74:0B31
		bp04->pv0 = bp04->pv0->pv0;
		//^3E74:0B48
		Bit32u bp08 = CALC_IMAGE_BYTE_LENGTH(buff) +0x1e;
		//^3E74:0B60
		if (reinterpret_cast<SkImage *>(PTR_PADD(buff,-int(sizeof(sk5cfc_image))))->AllocLower() == 0) {
			//^3E74:0B7C
			DEALLOC_UPPER_MEMORY(bp08);
		}
		else {
			//^3E74:0B88
			DEALLOC_LOWER_MEMORY(bp08);
		}
	}
	//^3E74:0B94
	return;
}

//^3929:0BD7
void SkWinCore::DRAW_VP_RC_STR(Bit16u rectno, Bit16u clr1, const U8 *str)
{
	// draw string to viewport, within specified rectangle.

	// like dialog ver: "V1.0"
	// like buttons: "SAVE", "QUIT", "RESULT", ...
	// like item name: "SCOUT MAP", ...

	//^3929:0BD7
	//^3929:0BDB
	__int16 bp02;
	__int16 bp04;
	if (QUERY_STR_METRICS(str, &bp02, &bp04) != 0) {
		//^3929:0BF6
		SRECT bp0c;
		if (QUERY_BLIT_RECT(NULL, &bp0c, rectno, &bp02, &bp04, -1) != 0) {
			//^3929:0C1A
			DRAW_VP_STR(bp0c.x, bp0c.y + bp0c.cy -1, clr1, str);
		}
	}
	//^3929:0C35
	return;
}

//^3929:000F
Bit16u SkWinCore::QUERY_MBCS_PRESENCE(const Bit8u *str)
{
	//^3929:000F
	Bit8u dl;
	while ((dl = *str++) != 0) {
		//^3929:0014
		if ((dl & 0x80) != 0)
			return 1;
		//^3929:001E
		if (dl == 2) {
			//^3929:0023
			if (*str++ != 0x20)
				return 1;
			return 0;
		}
        //^3929:0031
	}
	//^3929:0040
	return 0;
}

//^3929:0044
skxxxf *SkWinCore::QUERY_CHAR_METRICS(U8 cls2, U8 yy, U8 chr, U8 *tableIdxOut)
{
	//^3929:0044
	ENTER(6);
	//^3929:0048
	skxxxf *bp04 = _4976_5bfa[cls2];
	U8 bp05 = _4976_5bf8[cls2];
	bp05--;
	//^3929:0071
	U8 cl;
	for (cl = 0; cl <= bp05; bp04++, cl++) {
		//^3929:0075
		if (true
			&& bp04->b0 == yy 
			&& bp04->b1 <= chr 
			&& bp04->w2 * bp04->w4 +bp04->b1 >= chr
		) {
			//^3929:00A2
			if (cl == bp05 || bp04[1].b0 != yy || bp04[1].b1 > chr) {
				//^3929:00BB
				if (tableIdxOut != NULL)
					*tableIdxOut = cl;
				return bp04;
			}
		}
		//^3929:00D3
	}
	//^3929:00E0
	return NULL;
}

//^3929:03DC
Bit16u SkWinCore::QUERY_STR_METRICS(const Bit8u *buff, __int16 *xx, __int16 *yy)
{
	//^3929:03DC
	//^3929:03E2
	if (buff == NULL) {
		//^3929:03EA
		return 0;
	}
	//^3929:03EF
	__int16 si;
	Bit16u di;
	if (QUERY_MBCS_PRESENCE(buff) != 0) {
		//^3929:0402
		si = - _4976_0132;
		Bit8u bp05 = 1;
		di = 0;
		//^3929:040F
		Bit8u bp07;
		for (; *buff != 0; ) {
			//^3929:0412
			Bit8u bp06 = *(buff++);
			//^3929:041E
			if (bp06 >= 0xf0) {
				//^3929:0422
				bp07 = *buff; buff++;
			}
			//^3929:0430
			else if (bp06 < 32) {
				//^3929:0436
				if (bp06 == 2) {
					//^3929:043C
					bp05 = *buff + 0xe0;
				}
				//^3929:044A
				continue;
			}
			else {
				//^3929:044C
				bp07 = bp06;
				bp06 = 0;
			}
			//^3929:0456
			Bit8u bp08;
			skxxxf *bp04 = QUERY_CHAR_METRICS(bp05, bp06, bp07, &bp08);
			//^3929:0474
			if (bp04 != NULL) {
				//^3929:0478
				si += bp04->w6 + _4976_0132;
				//^3929:0485
				di = max_value(di, bp04->w8 - _4976_0136);
			}
			//^3929:0498
		}
		//^3929:04A4
	}
	else {
		//^3929:04A6
		si = - _4976_0120;
		di = _4976_011e - _4976_0124;
		//^3929:04B6
		while (*(buff++) != 0) {
			//^3929:04B8
			si += _4976_0126;
		}
	}
	//^3929:04C8
	if (si <= 0) {
		//^3929:04CC
		//^3929:03EA
		return 0;
	}
	//^3929:04CF
	*xx = si;
	*yy = di;
	//^3929:04DB
	return 1;
}

//^
inline Bit16u SkWinCore::QUERY_STR_METRICS(Bit8u *buff, Bit16u *xx, Bit16u *yy)
{
	return QUERY_STR_METRICS(buff, reinterpret_cast<__int16 *>(xx), reinterpret_cast<__int16 *>(yy));
}

//^3929:04E2
Bit16u SkWinCore::_3929_04e2(const Bit8u *strIn, Bit8u *strOut, Bit16u *textPos, __int16 maxWidth)
{
	//^3929:04E2
	//^3929:04E8
	Bit16u si = *textPos;
	__int16 bp02 = 0;
	Bit16u di = 0;
	Bit16u bp04 = 0xffff;
    Bit16u bp06 = 0;
	Bit16u bp08 = 0;
	//^3929:0504
	Bit8u bp0d;
	skxxxf *bp0c;
	if (QUERY_MBCS_PRESENCE(strIn) != 0 || _4976_475e != 0xff) {
		//^3929:051E
		if (_4976_475e == 0xff) {
			//^3929:0525
			_4976_475e = 1;
		}
		else {
			//^3929:052C
			strOut[di] = 2; di++;
			//^3929:0534
			strOut[di] = 0x20 + _4976_475e;
			//^3929:053C
            di++;
		}

		while (true) {
			//^3929:053D
			strOut[di] = 0;
			//^3929:0544
			if (strIn[si] == vbLf || strIn[si] == 0) {
				//^3929:0553
				if (strIn[si] == 0) {
					_4976_475e = 0xff;
				}
				//^3929:0564
				break;
			}
			//^3929:0567
			bp0d = strIn[si];
			//^3929:0570
			Bit8u bp0e;
			if (bp0d >= 0xf0) {
				//^3929:0574
				bp0e = strIn[si +1];
			}
			else {
				//^3929:057D
				if (bp0d < 0x20) {
					//^3929:0583
					strOut[di] = strIn[si]; si++; di++;
					//^3929:0591
					if (bp0d == 2) {
						//^3929:0597
						_4976_475e = (strOut[di] = strIn[si]) + 0xe0; si++; di++;
					}
					//^3929:05AA
					continue;
				}
				//^3929:05AC
				bp0e = bp0d;
				bp0d = 0;
				//^3929:05B6
				if (strIn[si] == 0x20) {
					//^3929:05BF
					bp04 = si;
					bp06 = di;
					bp08 = bp02;
				}
			}
			//^3929:05CB
			Bit8u bp0f;
			bp0c = QUERY_CHAR_METRICS(_4976_475e, bp0d, bp0e, &bp0f);
			//^3929:05E9
			if (bp0c == NULL) {
				//^3929:05ED
				si++;
				if (bp0d != 0) {
					//^3929:05F7
					si++;
				}
				//^3929:05F8
				continue;
			}
			//^3929:05FB
			if (__int16(bp0c->w6) + _4976_0132 + bp02 <= maxWidth) {
				//^3929:060E
				if (bp02 == 0) {
					//^3929:0614
					bp02 = - _4976_0132;
				}
				//^3929:061C
				bp02 += bp0c->w6 + _4976_0132;
				//^3929:062A
				if (bp0d != 0) {
					//^3929:0630
					strOut[di] = strIn[si]; si++; di++;
				}
				//^3929:063E
				strOut[di] = strIn[si]; si++;
				//^3929:064B
				di++; continue;
			}
			//^3929:064E
			if (bp04 != 0xffff) {
				//^3929:0654
_0654:
				*textPos = bp04 +1;
				//^3929:065E
				strOut[bp06] = 0;
				//^3929:0668
				return bp08;
			}
			//^3929:066D
			break;
		}
	}
	else {
		while (true) {
			//^3929:066F
			strOut[di] = 0;
			//^3929:0676
			if (strIn[si] == vbLf || strIn[si] == 0)
				//^3929:0685
				break;
			//^3929:0687
			if (strIn[si] == 0x20) {
				//^3929:0690
				bp04 = si;
				bp06 = di;
				bp08 = bp02;
			}
			//^3929:069C
			if (bp02 + _4976_0126 <= maxWidth) {
				//^3929:06A8
				if (bp02 == 0) {
					//^3929:06AE
					bp02 = - _4976_0120;
				}
				//^3929:06B6
				bp02 += _4976_0126;
				//^3929:06BC
				strOut[di] = strIn[si]; si++; di++;
				//^3929:06CA
				continue;
			}
			//^3929:06CC
			if (bp04 == 0xffff) {
				//^3929:06D0
				break;
			}
			goto _0654;
		}
	}
	//^3929:06D4
	*textPos = si;
	//^3929:06DA
	return bp02;
}

//^3929:00E6
const Bit8u *SkWinCore::DRAW_MBCS_STR(
	const Bit8u *str, 
	Bit8u *dst, 
	__int16 zz, 
	Bit8u *ww, 
	Bit16u clr1, 
	Bit16u clr2, 
	Bit16u *xx, 
	Bit16u *yy, 
	Bit16u dstpitch, 
	Bit16u dstbpp
) {
	//^3929:00E6
	Bit8u bp0b = *str++;
	//^3929:00F8
	Bit8u bp0c;
	if (bp0b >= 0xF0) {
		//^3929:00FC
		bp0c = *str;
		str++;
	}
	else {
		//^3929:010A
		if (bp0b < 0x20) {
			//^3929:0110
			if (bp0b != 0x02)
				return str;
			//^3929:0119
			*ww = *str + 0xE0;
			str++;
			return str;
		}
		//^3929:012D
		bp0c = bp0b;
		bp0b = 0;
	}
	//^3929:0137
	Bit8u bp0d;
	skxxxf *bp04 = QUERY_CHAR_METRICS(*ww, bp0b, bp0c, &bp0d);
	if (bp04 == NULL)
		return str;
	//^3929:015F
	Bit16u bp18 = _4976_5ca8;
	_4976_5ca8 = -_4976_5d76;
	//^3929:0170
	Bit8u *bp08 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x001c, *ww, bp0d);
	//^3929:018B
	Bit8u bp2a[16]; // 2a-1b
	Bit16u bp0a;
	if (dstbpp != 4) {
		//^3929:0191
		bp2a[ 0] = (Bit8u)clr2;
		bp2a[15] = (Bit8u)clr1;
		//^3929:019D
		bp0a = ((clr2 & 0x4000) != 0) ? 0 : -1;
		//^3929:01A6
	}
	else {
		//^3929:01B1
		if ((clr2 & 0x4000) != 0) {
			//^3929:01B8
			bp0a = clr2 = (clr1 == 0) ? 1 : 0;
		}
		else {
			//^3929:01CD
			bp0a = -1;
		}
		//^3929:01D2
		Bit8u *bp12;
		Bit16u di;
		Bit16u si;
		Bit32u bp16;
		if ((clr1 == 0 && clr2 == 0) || _4976_5d76 == 0) {
			//^3929:01E5
			bp08 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x001c, *ww, bp0d);
			//^3929:0200
			if (clr1 != 0 || clr2 != 15) {
				//^3929:020F
				Bit8u *bp12 = bp08;
				Bit16u di = ((Bit16u *)bp08)[-2];
				Bit16u si = ((Bit16u *)bp08)[-1];
				//^3929:0226
				//^3929:02E5
				goto _02e5;
			}
		}
		else {
			//^3929:0229
			bp16 = (QUERY_GDAT_ENTRY_DATA_INDEX(0x1c, *ww, 1, bp0d) & 0x1fff) 
				| 0x4000 
				| ((clr2 & 0x000f) << 4) 
				| ((clr1 & 0x000f)     );
			//^3929:026D
			Bit16u bp1a;
			if (ADD_CACHE_HASH(bp16, &bp1a) != 0) {
				//^3929:0284
				bp08 = QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp1a);
				//^3929:0293
			}
			else {
				//^3929:0295
				di = (bp04->w2 * bp04->w6);
				si = (bp04->w4 * bp04->w8);
				ALLOC_NEW_PICT(bp1a, di, si, 4);
				//^3929:02BB
				bp12 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x1c, *ww, bp0d);
				//^3929:02D6
				bp08 = QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp1a);
				//^3929:02E5
_02e5:
				Bit8u bp3a[16]; // 3a-2b
				bp3a[ 0] = (Bit8u)clr2;
				bp3a[15] = (Bit8u)clr1;
				//^3929:02F1
				FIRE_STRETCH_BLIT_TO_MEMORY_4TO4BPP(bp12, bp08, di, si, di, si, bp3a);
			}
			//^3929:030E
			if (_4976_5d76 != 0) {
				//^3929:0315
				_3e74_585a(bp1a, 0);
			}
		}
	}
	//^3929:0321
	if (zz >= 0) {
		//^3929:0327
		dst = QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(zz);
	}
	//^3929:0336
	bp0c -= bp04->b1;
	//^3929:0340
	FIRE_BLIT_PICTURE(
		bp08,
		dst,
		ALLOC_TEMP_RECT(
			*xx,
			*yy,
			bp04->w6,
			bp04->w8
			),
		(bp0c % bp04->w2) * bp04->w6,
		(bp0c / bp04->w2) * bp04->w8,
		READ_UI16(bp08,-4),
		dstpitch,
		bp0a,
		0,
		4,
		dstbpp,
		bp2a
		);
	//^3929:03AE
	*xx += bp04->w6 + _4976_0132;
	//^3929:03BF
	FREE_PICT_ENTRY(bp08);
	//^3929:03CC
	_4976_5ca8 = bp18;
	//^3929:03D2
	return str;
}

//^470A:0008
Bit8u *SkWinCore::QUERY_FONT(i8 input, Bit8u fore, Bit8u back)
{
	//^470A:0008
	Bit8u bp02 = fore << 4;
	Bit8u bp03 = back << 4;
	Bit16u si = 0;
	Bit16u di = 0;
	for (; di < 6; di++) {
		//^470A:0026
		U8 bp01 = _4976_5c0e[(di << 7) + input];
		i8 bp06;
		for (bp06 = 0; bp06 < 3; bp06++) {
			//^470A:0046
			_4976_5e72[si++] = (((bp01 & 0x10) != 0) ? bp02 : bp03) | (((bp01 & 0x08) != 0) ? fore : back);
			bp01 <<= 2;
			//^470A:0071
		}
		//^470A:007A
	}
	//^470A:0080
	return _4976_5e72;
}

//^470A:0089
void SkWinCore::DRAW_STRING(
	Bit8u *dst, 
	Bit16u ss, 
	Bit16u dstpitch, 
	Bit16u dstx, 
	Bit16u dsty, 
	Bit16u clr1, 
	Bit16u clr2, 
	const Bit8u *str, 
	Bit16u dstbpp
) {
	//^470A:0089
	Bit16u di = dstbpp;
	//^470A:0089
	if (*str == 0)
		return;
	//^470A:00A0
	Bit16u si;
	if ((clr2 & 0x4000) != 0) {
		//^470A:00A7
		clr2 &= 0xBFFF;
		si = clr2;
	}
	else {
		//^470A:00B4
		si = -1;
	}
	//^470A:00B7
	SRECT bp08;
	bp08.x = dstx;
	//^470A:00BD
	if (QUERY_MBCS_PRESENCE(str) != 0) {
		//^470A:00CE
		Bit8u bp09 = 1;
		dsty -= 14;
		//^470A:00D6
		if (si != 0xFFFF) {
			//^470A:00DB
            clr2 |= 0x4000;
		}
		do {
			//^470A:00E4
			str = DRAW_MBCS_STR(str, dst, ss, &bp09, clr1, clr2, &dstx, &dsty, dstpitch, di);
			//^470A:011E
		} while (*str != 0);
	}
	else {
		//^470A:0127
		Bit8u bp1a[16];
		if (di != 4) {
			//^470A:012C
			bp1a[0] = (Bit8u)clr1;
			bp1a[1] = (Bit8u)clr2;
			clr1 = 0;
			clr2 = 1;
			//^470A:0142
			if (si != 0xFFFF) {
				si = 1;
			}
		}
		//^470A:014A
		if (str[0] == 0x02 && str[1] == 0x20) {
			str += 2;
		}
		//^470A:015E
		// bp08 = bp08.x
		// bp06 = bp08.y
		// bp04 = bp08.dstcx
		// bp02 = bp08.dstcy
		bp08.cy = _4976_011e;
		bp08.y = (dsty + _4976_0124) - (bp08.cy - 1);
		bp08.cx = _4976_0126;
		do {
			//^470A:017A
			FIRE_BLIT_PICTURE(QUERY_FONT(*str, (Bit8u)clr1, (Bit8u)clr2), dst, &bp08, 0, 0, 5, dstpitch, si, 0, 4, di, bp1a);
			//^470A:01B7
			bp08.x += _4976_0126;
			str++;
			//^470A:01C0
		} while (*str != 0);
	}
	//^470A:01C9
}

//^3929:0B6C
void SkWinCore::DRAW_VP_STR(Bit16u dstx, Bit16u dsty, Bit16u clr1, const Bit8u *str)
{
	// draw text to dungeon/inventory viewport.
	// draw dialogue text such as.
	// a) version: "V1.0"
	// b) button text: "A6 86 97 A8" [[gJ] (=load), "8B 84 A7 92 A5" [LZ] (=cancel)
	// c) savegame name: "0 GAMEE", "GAME 1 STRONG", "2 UNUSED", "3 UNUSED", ...

	//^3929:0B6C
	//^3929:0B6F
	DRAW_STRING(
		_4976_4c16,
		-1,
		_4976_00f6,
		dstx,
		dsty,
		clr1,
		glbPaletteT16[COLOR_DARKEST_GRAY] | 0x4000,
		str,
		8
		);
	//^3929:0BA4
	return;
}

//^3A15:020F
void SkWinCore::_3a15_020f()
{
	//^3A15:020F
	ENTER(4);
	//^3A15:0215
	Bit16u timerCnt = glbTimersCount;	// di
	//^3A15:021A
	if (timerCnt == 0)
		//^3A15:021C
		return;
	//^3A15:0220
	Bit16u si;
	for (si = 0; si < MAX_CHAMPIONS; si++) {
		//^3A15:0222
		glbChampionSquad[si].timerIndex = TIMER_NONE;
		//^3A15:0231
	}
	//^3A15:0237
	si = 0;
	//^3A15:0239
	Timer *timer = glbTimersTable;	//*bp04
	//^3A15:0246
	for (; si < timerCnt; si++, timer++) {
		//^3A15:0248
		switch (timer->TimerType()) {
			case tty0C:
				//^3A15:0262
				glbChampionSquad[timer->actor].timerIndex = si;
				break;
			case tty1D:
			case tty1E:
				//^3A15:0278
				GET_ADDRESS_OF_RECORDE(timer->value)->TimerIndex(si);
				break;
		}
		//^3A15:028D
	}
	//^3A15:0296
	return;
}

//^3A15:029A
void SkWinCore::COMPACT_TIMERLIST()
{
	//^3A15:029A
	//^3A15:02A0
	Bit16u si = 0;
	Bit16u di = glbTimersCount;
	//^3A15:02A7
	if (di != 0) {
		//^3A15:02AB
		Timer *bp04 = glbTimersTable;

		do {
			//^3A15:02B8
			if (bp04->TimerType() == tty00) {
				//^3A15:02C2
				Timer *bp08 = &bp04[1];
				//^3A15:02D1
				for (; bp08->TimerType() == tty00; bp08++);
				//^3A15:02E1
				*bp04 = *bp08;
				//^3A15:02F5
				bp08->TimerType(tty00);
			}
			//^3A15:02FD
			bp04++;
			si++;
			//^3A15:0302
		} while (si != di);
		//^3A15:0308
		__SORT_TIMERS();
		_3a15_020f();
	}
	//^3A15:0310
	return;
}

U16 SkWinCore::RAND16(U16 maxcnt) {
	U16 r = _RAND16(maxcnt);
	SkD((DLV_DBG_RAND, "DBG: RAND16(%d) = %d\n", (Bitu)maxcnt, (Bitu)r));
	return r;
}
U16 SkWinCore::RAND01() {
	U16 r = _RAND01();
	SkD((DLV_DBG_RAND, "DBG: RAND01() = %d\n", (Bitu)r));
	return r;
}
U16 SkWinCore::RAND() {
	U16 r = _RAND();
	SkD((DLV_DBG_RAND, "DBG: RAND() = %d\n", (Bitu)r));
	return r;
}
U16 SkWinCore::RAND02() {
	U16 r = _RAND02();
	SkD((DLV_DBG_RAND, "DBG: RAND02() = %d\n", (Bitu)r));
	return r;
}

//^0CD5:0147
//SPX: Random int on 2 bits => range = 0 to 3
Bit16u SkWinCore::_RAND02()
{
	// CSBwinSimilarity: TAG001074,STRandom0_3

	//^0CD5:0147
	//^0CD5:014A
	glbRandomSeed = glbRandomSeed * 0xbb40e62d + 11;
	//^0CD5:016A
	return (glbRandomSeed >> 8) & 3;
	//^0CD5:0175
}

//^098D:02D2
Bit16u SkWinCore::CALC_SIZE_OF_COMPRESSED_RECT(Bit16u xx)
{
	//^098D:02D2
	Bit16u di = xx;
	Bit16u si = 8;
	//^098D:02DD
	if ((di & 4) != 0) {
		//^098D:02E3
		//^098D:02F7
		si = si -2;
	}
	else {
		//^098D:02E5
		if ((di & 2) != 0) {
			//^098D:02EB
			si = si -2;
		}
		//^098D:02F1
		if ((di & 1) != 0) {
			//^098D:02F7
			si = si -2;
		}
	}
	//^098D:02FD
	if ((di & 24) != 0) {
		//^098D:0303
		si = si -2;
	}
	//^098D:0309
	return si;
}

//^098D:1208
void SkWinCore::_098d_1208() //#DS=4976?
{
	// TODO: {Y
	//^098D:1208
	//^098D:120B
	LOAD_RECTS_AND_COMPRESS(1, 0, 0);
	//^098D:1218
	_4976_4ba4 = 1;
	//^098D:121E
	return;
}

//^3E74:0A51
void SkWinCore::DEALLOC_LOWER_MEMORY(Bit32u size) //#DS=4976?
{
	// TODO: {Y
	//^3E74:0A51
	//^3E74:0A54
	if ((size & 1) != 0) {
		//^3E74:0A5F
		size++;
	}
	//^3E74:0A67
	glbFreeRAMMemPool += size;
	//^3E74:0A75
	SkD((DLV_MEM, "MEM: DEALLOC_LOWER_MEMORY(%10d)\n", (Bitu)size));
#if defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
	ATLVERIFY(vecLowerAlloc.size() != 0);
	ATLVERIFY(vecLowerAlloc.top() == size);
	vecLowerAlloc.pop();
#endif // defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
	return;
}

//^3E74:5AB7
Bit16u SkWinCore::QUERY_GDAT_ENTRY_DATA_LENGTH(Bit8u cls1, Bit8u cls2, Bit8u cls3, Bit8u cls4)
{
LOGX(("%40s: C%02d=I%02X=E%02X=T%03d = %08X (%06d)", "QUERY_GDAT_ENTRY_DATA_LENGTH of ", cls1, cls2, cls4, cls3, QUERY_GDAT_RAW_DATA_LENGTH(QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4)), QUERY_GDAT_RAW_DATA_LENGTH(QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4)) ));

	//^3E74:5AB7
	return QUERY_GDAT_RAW_DATA_LENGTH(
		QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4)
		);
}

//^098D:1185
void SkWinCore::LOAD_RECTS_AND_COMPRESS(Bit8u cls1, Bit8u cls2, Bit8u cls4) //#DS=4976?
{
	// TODO: {Y
	//^098D:1185
	//^098D:1189
	Bit32u bp08 = QUERY_GDAT_ENTRY_DATA_LENGTH(cls1, cls2, dt04, cls4);
	//^098D:11A2
	Bit8u *bp04 = ALLOC_MEMORY_RAM(bp08, afUseLower, 1024);
	//^098D:11C0
	LOAD_GDAT_ENTRY_DATA_TO(cls1, cls2, dt04, cls4, bp04);
	//^098D:11DC
	COMPRESS_RECTS((__int16 *)bp04, bp08, &glbRectNoTable, &SkWinCore::ALLOC_UPPER_MEMORY);
	//^098D:11F9
	DEALLOC_LOWER_MEMORY(bp08);
}

//^3E74:51E4
void SkWinCore::LOAD_GDAT_ENTRY_DATA_TO(Bit8u cls1, Bit8u cls2, Bit8u cls3, Bit8u cls4, Bit8u *where) //#DS=4976?
{
//LOGX(("%40s: C%02d=I%02X=E%02X=T%03d to %08X", "LOAD_GDAT_ENTRY_DATA_TO of ", cls1, cls2, cls4, cls3, where ));
	// TODO: {Y
	//^3E74:51E4
	Bit16u si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4);
	//^3E74:5201
//LOGX(("LOAD_GDAT_RAW_DATA call from LOAD_GDAT_ENTRY_DATA_TO"));
	LOAD_GDAT_RAW_DATA(si, CONVERT_PHYS_TO_SHELF_FORM(where));

	SkD((DLV_GLD, "GLD: Dyn1-load Raw#%4d at RAM(%p)\n", (Bitu)si, where));
}

//^098D:116D
Bit8u *SkWinCore::ALLOC_UPPER_MEMORY(Bit32u size)
{
	// TODO: {Y
	//^098D:116D
	//^098D:1170
	return ALLOC_MEMORY_RAM(size, afUseUpper, 1024);
}

//^098D:0E78
void SkWinCore::COMPRESS_RECTS(__int16 *data, Bit32u size, RectTable *zz, Bit8u *(SkWinCore::*allocFunc)(Bit32u size))
{
#define	PTR_ADVANCE(PTR,DELTA) *((Bit8u **)&(PTR)) += (DELTA);
#define	WRITE_BYTE(PTR,VAL) **(Bit8u **)&(PTR) = (VAL);
#define	WRITE_WORD(PTR,VAL) **(Bit16u **)&(PTR) = (VAL);

	// TODO: {Y
	//^098D:0E78
	//^098D:0E7E
	if (*(data++) != (__int16)0xfc0d)
		return;
	//^098D:0E8F
	__int16 bp0e = *(data++);
	//^098D:0E9C
	__int16 *bp08 = data;
	//^098D:0EA8
	data += bp0e << 1;
	//^098D:0EB2
	while (zz->pb0 != NULL) {
		//^098D:0EB4
		zz = zz->pb0;
	}
	//^098D:0ED0
	for (; --bp0e >= 0; ) {
		//^098D:0ED3
		Bit16u bp0a = *bp08; bp08++;
		//^098D:0EE0
		Bit16u bp0c = *bp08; bp08++;
		//^098D:0EED
		__int16 si = bp0c - bp0a +1;
		//^098D:0EF3
		__int16 *bp16 = data;
		//^098D:0EFF
		Bit8u bp17 = 0x1f;
		//^098D:0F03
		Bit16u bp1a = data[0];
		//^098D:0F0C
		Bit16u bp1c = data[1];

		do {
			//^098D:0F13
			if (*(data++) != (__int16)bp1a) {
				//^098D:0F22
				bp17 &= ~2;
			}
			//^098D:0F2A
			if (*(data) != (__int16)bp1c) {
				//^098D:0F35
				bp17 &= ~1;
			}
			//^098D:0F3D
			if (*(data++) > 255) {
				//^098D:0F4B
				bp17 &= ~4;
			}
			//^098D:0F53
			Bit16u bp1e = 2;

			do {
				//^098D:0F58
				__int16 di = *(data++);
				//^098D:0F64
				if (di < 0 || di > 255) {
					//^098D:0F6E
					bp17 &= ~16;
				}
				//^098D:0F76
				if (di < -128 || di > 127) {
					//^098D:0F80
					bp17 &= ~8;
				}
				//^098D:0F88
			} while (--bp1e != 0);

			//^098D:0F8D
		} while (--si > 0);

		//^098D:0F90
		if ((bp17 & 3) != 0) {
			//^098D:0F96
			bp17 &= ~4;
		}
		//^098D:0F9E
		si = bp0c - bp0a +1;
		//^098D:0FA7
		Bit32u bp12 = CALC_SIZE_OF_COMPRESSED_RECT(bp17) * si + 10;
		//^098D:0FC3
		if ((bp17 & 1) != 0) {
			//^098D:0FC9
			bp12 += 2;
		}
		//^098D:0FD1
		RectTable *bp04 = reinterpret_cast<RectTable *>((this->*allocFunc)(bp12));
		//^098D:0FE2
		zz = (zz->pb0 = bp04);
		//^098D:0FF8
		bp04->pb0 = NULL;
		//^098D:1006
		bp04->w4 = bp0a;
		//^098D:100D
		bp04->w6 = bp0c;
		//^098D:1014
		bp04->b8 = (Bit8u)bp17;
		//^098D:101B
		bp04->b9 = (Bit8u)bp1a;
		SkD((DLV_RCT, "RCT: COMPRESS_RECTS (%p,(%d,%d,%d,%d))\n"
			, (Bitu)bp04->pb0, (Bitu)bp04->w4, (Bitu)bp04->w6, (Bitu)bp04->b8, (Bitu)bp04->b9));
		//^098D:1022
		bp04++;
		//^098D:1026
		if ((bp17 & 1) != 0) {
			//^098D:102C
			WRITE_WORD(bp04,bp1c);
			//^098D:1035
			PTR_ADVANCE(bp04,+2);
		}
		//^098D:1043
		data = bp16;

		do {
			//^098D:104F
			if ((bp17 & 4) != 0) {
				//^098D:1055
				WRITE_BYTE(bp04,(Bit8u)*data); data++;
				//^098D:1065
				PTR_ADVANCE(bp04,+1);
				//^098D:1072
				WRITE_BYTE(bp04,(Bit8u)*data); data++;
				//^098D:1082
				PTR_ADVANCE(bp04,+1);
			}
			else {
				//^098D:1091
				if ((bp17 & 2) == 0) {
					//^098D:109C
					WRITE_WORD(bp04,*data);
					//^098D:10A8
					PTR_ADVANCE(bp04,+2);
				}
				//^098D:10B6
				data++;
				//^098D:10BA
				if ((bp17 & 1) == 0) {
					//^098D:10C5
					WRITE_WORD(bp04,*data);
					//^098D:10D1
					PTR_ADVANCE(bp04,+2);
				}
				//^098D:10DF
				data++;
			}
			//^098D:10E3
			if ((bp17 & 24) != 0) {
				//^098D:10E9
				WRITE_BYTE(bp04,(Bit8u)*data); data++;
				//^098D:10F9
				PTR_ADVANCE(bp04,+1);
				//^098D:1106
				WRITE_BYTE(bp04,(Bit8u)*data); data++;
				//^098D:1116
				PTR_ADVANCE(bp04,+1);
			}
			else {
				//^098D:111F
				WRITE_WORD(bp04,*data); data++;
				//^098D:112F
				PTR_ADVANCE(bp04,+2);
				//^098D:113D
				WRITE_WORD(bp04,*data); data++;
				//^098D:114D
				PTR_ADVANCE(bp04,+2);
			}

			//^098D:115B
		} while (--si > 0);

		//^098D:1161
	}
	//^098D:1169
	return;

#undef	PTR_ADVANCE
#undef	WRITE_BYTE
#undef	WRITE_WORD
}

//^098D:030F
SRECT *SkWinCore::QUERY_RECT(RectTable *entry, Bit16u rectno) //#DS=4976?
{
#define	PTR_ADVANCE(PTR,DELTA) *((Bit8u **)&(PTR)) += (DELTA);
#define	READ_BYTE(PTR) **((Bit8u **)&(PTR))
#define	READ_SBYTE(PTR) **((__int8 **)&(PTR))
#define	READ_WORD(PTR) **((Bit16u **)&(PTR))

	// TODO: PmF 13:59 2006/05/07
	//^098D:030F
	//^098D:0315
	Bit16u iRequestedRectNo = rectno;	// Bit16u si
	//^098D:0318
	if (iRequestedRectNo == 0)
		return NULL;
	//^098D:031F
	for (; entry != NULL; entry = entry->pb0) {
		//^098D:0322
		if (entry->w4 > iRequestedRectNo || entry->w6 < iRequestedRectNo)
			continue;
		//^098D:0337
		iRequestedRectNo -= entry->w4;
		//^098D:033B
		_4976_0198++;
		//^098D:033F
		if (_4976_0198 >= 4) {
			//^098D:
			_4976_0198 = 0;
		}
		//^098D:034D
		sk4b84 *bp04 = &_4976_4b84[_4976_0198];
		//^098D:035C
		Bit8u bp05 = entry->b8;

		// bp05 combinations:
		// 0x00		@prefix @entry (x=RW, y=RW)
		// 0x01		@prefix (y=w10) @entry

		//^098D:0366
		if ((bp05 & 2) != 0) {
			//^098D:036A
			bp04->w0 = entry->b9;
		}
		//^098D:0376
		entry++;
		//^098D:037A
		if ((bp05 & 1) != 0) {
			//^098D:0380
			bp04->w2 = READ_WORD(entry);
			//^098D:038F
			PTR_ADVANCE(entry,+2);
		}
		//^098D:039D
		PTR_ADVANCE(entry,+(CALC_SIZE_OF_COMPRESSED_RECT(bp05) * iRequestedRectNo));
		//^098D:03B8
		if ((bp05 & 4) != 0) {
			//^098D:03BE
			bp04->w0 = READ_BYTE(entry);
			//^098D:03CC
			PTR_ADVANCE(entry,+1);
			//^098D:03D9
			bp04->w2 = READ_BYTE(entry);
			//^098D:03E7
			PTR_ADVANCE(entry,+1);
			//^098D:03EE
		}
		else {
			//^098D:03F0
			if ((bp05 & 2) == 0) {
				//^098D:03FB
				bp04->w0 = READ_WORD(entry);
				//^098D:0407
				PTR_ADVANCE(entry,+2);
			}
			//^098D:0415
			if ((bp05 & 1) == 0) {
				//^098D:0420
				bp04->w2 = READ_WORD(entry);
				//^098D:042F
				PTR_ADVANCE(entry,+2);
			}
		}
		//^098D:043D
		if ((bp05 & 8) != 0) {
			//^098D:0443
			bp04->w4 = READ_SBYTE(entry); PTR_ADVANCE(entry,+1);
			//^098D:0453
			bp04->w6 = READ_SBYTE(entry);
			//^098D:045B
		}
		//^098D:045D
		else if ((bp05 & 16) != 0) {
			//^098D:0463
			bp04->w4 = READ_BYTE(entry); PTR_ADVANCE(entry,+1);
			//^098D:0474
			bp04->w6 = READ_BYTE(entry);
			//^098D:047D
		}
		else {
			//^098D:047F
			bp04->w4 = READ_WORD(entry); PTR_ADVANCE(entry,+2);
			//^098D:048E
			bp04->w6 = READ_WORD(entry);
		}

		SkD((DLV_RCT, "RCT: QUERY_RECT(%4d,(%3d,%3d,%3d,%3d))\n", (Bitu)rectno, (Bitu)bp04->w0, (Bitu)bp04->w2, (Bitu)bp04->w4, (Bitu)bp04->w6));

		//^098D:0495
		return (SRECT *)bp04;

		//^098D:04A4
	}
	//^098D:04BF
	return NULL;

#undef	PTR_ADVANCE
#undef	READ_BYTE
#undef	READ_SBYTE
#undef	READ_WORD
}

//^098D:0048
SRECT *SkWinCore::SET_SRECT(SRECT *prc, Bit16u x, Bit16u y, Bit16u cx, Bit16u cy)
{
	//^098D:0048
	//^098D:004B
	prc->x = x;
	prc->y = y;
	prc->cx = cx;
	prc->cy = cy;
	//^098D:0069
	return prc;
}

//^098D:0126
SRECT *SkWinCore::UNION_RECT(SRECT *rc1, const SRECT *rc2, __int16 *offx, __int16 *offy)
{
	// it modifies rc1 to represent union area.
	// returns non-null if 2 rects have union area.

	// it is to clip the rc1 within rc2.
	// you are to draw picture at top-left of rc1.

	// rc1
	// +------+
	// |      |
	// |    +------+ rc2
	// |    |*|    |
	// +----|-+    |
	//      |      |
	//      +------+
	// 
	// in this case, (offx,offy) is at (5, 2).

	// rc2
	// +------+
	// |      |
	// |    +------+ rc1
	// |    |*|    |
	// +----|-+    |
	//      |      |
	//      +------+
	// 
	// in this case, (offx,offy) is at (0, 0).

	//^098D:0126
	__int16 si = rc2->x - rc1->x;
	//^098D:0139
	if (si > 0) {
		//^098D:013D
		*offx = si;
		//^098D:0143
		rc1->x += si;
		rc1->cx -= si;
	}
	else {
		//^098D:014F
		*offx = 0;
	}
	//^098D:0157
	si = rc2->y - rc1->y;
	//^098D:0167
	if (si > 0) {
		//^098D:016B
		*offy = si;
		//^098D:0171
		rc1->y += si;
		rc1->cy -= si;
	}
	else {
		//^098D:017E
		*offy = 0;
	}
	//^098D:0186
	si = (rc1->x +rc1->cx -1) - (rc2->x +rc2->cx -1);
	//^098D:01AC
	if (si > 0) {
		//^098D:01B2
		rc1->cx -= si;
	}
	//^098D:01B9
	si = (rc1->y +rc1->cy -1) - (rc2->y +rc2->cy -1);
	//^098D:01D5
	if (si > 0) {
		//^098D:01D9
		rc1->cy -= si;
	}
	//^098D:01E0
	if (rc1->cx > 0 && rc1->cy > 0) {
		//^098D:01F1
		return rc1;
	}
	//^098D:01F9
	return NULL;
}

//^098D:0599 
// SPX: ww is the method to know how to start drawing image from ref point (can be ornate position)
// 0 => centered
// 1 => point is corner left/upper (0,0)
// 2 => point is corner right/upper (x,0)
// 3 => point is corner right/bottom (x,y)
// 4 => point is corner left/bottom (0,y)
// 5 => centered from top (image is then moved to lower)
// 6 => centered from right (image is then moved to left)
// 7 => centered from bottom (image is then moved to upper)
// 8 => centered from left (image is then moved to right)
SRECT *SkWinCore::QUERY_BLIT_RECT(Bit8u *buff, SRECT *rect, Bit16u rectno, __int16 *yourcx, __int16 *yourcy, __int16 ww) //#DS=4976?
{
	SkD((DLV_RCT, "RCT: -> QUERY_BLIT_RECT(%p,%p(     x,     x,     x,     x),%4d,%3d,%3d,%3d)\n"
		, buff, rect, (Bitu)(rectno & 0x7fff), (Bitu)*yourcx, (Bitu)*yourcy, (Bitu)ww));

	//^098D:0599
	//^098D:059F
	__int16 di;

	Bit16u bp24 = 0;
	SRECT bp1a;
	Bit16u bp12;
	Bit16u bp10;
	i16 bp0c;
	i16 bp0a;
	SRECT *bp08;
	SRECT *bp04;

	//^098D:05A4
	if (rectno == 0xffff) {
		//^098D:05AA
		return NULL;
	}
	//^098D:05B1
	Bit16u si = rectno & 0x8000;
	//^098D:05B9
	if (si != 0) {
		//^098D:05BD
		rectno &= 0x7fff;
	}
	//^098D:05C6
	bp04 = QUERY_RECT(glbRectNoTable.pb0, rectno);
	//^098D:05DE
	if (bp04 == NULL) {
		//^098D:05AA
		return NULL;
	}
	//^098D:05E4
	SET_SRECT(&bp1a, -10000, -10000, 20000, 20000);
	//^098D:05FC
	SRECT bp22;
	Bit16u bp0e;
	if (ww == -1) {
		//^098D:0602
		bp0e = bp04->x;
	}
	else {
		//^098D:060D
		COPY_MEMORY(bp04, &bp22, sizeof(SRECT));
		//^098D:0624
		bp22.x = bp0e = ww;
		//^098D:062D
		bp04 = &bp22;
	}
	//^098D:0636
	if (bp0e <= 8) {
		//^098D:063C
		bp0a = bp04->cx;
		bp0c = bp04->cy;
	}
	else {
		//^098D:064F
		if (bp0e == 9) {
			//^098D:05AA
			return NULL;
		}
		//^098D:0658
		bp0e -= 10;
		bp0a = 0;
		bp0c = 0;
	}
	//^098D:0666
	if (si != 0) {
		//^098D:066A
		bp0a += *yourcx;
		bp0c += *yourcy;
		*yourcx = 0;
		*yourcy = 0;
	}
	//^098D:068C
	if (buff == NULL && (*yourcx <= 0 || *yourcy <= 0)) {
		//^098D:06A6
		//^098D:05AA
		return NULL;
	}
	//^098D:06A9
	bp10 = 0;
	//^098D:06AE
	for (; bp04->y != 0; ) {
		//^098D:06B1
		if (bp04->x >= 10 && bp04->x <= 18) {
			//^098D:06C6
			bp08 = QUERY_RECT(glbRectNoTable.pb0, bp04->y);
			//^098D:06DF
			if (bp08 == NULL)
				break;
			//^098D:06E6
			si = bp08->cx;
			di = bp08->cy;
			bp12 = bp08->x;
			bp24 = bp08->y;
			//^098D:06FE
			bp08 = QUERY_RECT(glbRectNoTable.pb0, bp08->y);
			//^098D:0717
			if (bp08 == NULL)
				break;
			//^098D:071E
			switch (bp12) {
				default:
					//^098D:072D
					//^098D:05AA
					return NULL;

				case 0:
					//^098D:0730
					di -= (bp08->cy +1) >> 1;
					//^098D:073C
					si -= (bp08->cx +1) >> 1;
					//^098D:0748
					break;

				case 5:
					//^098D:073C
					si -= (bp08->cx +1) >> 1;
					//^098D:0748
					break;

				case 3:
					//^098D:074A
					di -= bp08->cy -1;
					//^098D:0754
					si -= bp08->cx -1;
					//^098D:075C
					//^098D:0746
					break;

				case 2:
					//^098D:0754
					si -= bp08->cx -1;
					//^098D:075C
					//^098D:0746
					break;

				case 6:
					//^098D:075E
					si -= bp08->cx -1;
					//^098D:0768
					di -= (bp08->cy +1) >> 1;
					//^098D:0772
					break;

				case 8:
					//^098D:0768
					di -= (bp08->cy +1) >> 1;
					//^098D:0772
					break;

				case 7:
					//^098D:0774
					si -= (bp08->cx +1) >> 1;
					//^098D:0780
					di -= bp08->cy -1;
					//^098D:0788
					break;

				case 4:
					//^098D:0780
					di -= bp08->cy -1;
					//^098D:0788
					break;

				case 1:
					//^098D:078A
					break;
			}

			//^098D:078A
			bp1a.x += si;
			//^098D:078D
			if (bp1a.x < si) {
				//^098D:0794
				bp1a.x = si;
			}
			//^098D:0797
			if (bp08->cx + si <= bp1a.x + bp1a.cx -1) {
				//^098D:07AB
				bp1a.cx = bp08->cx - bp1a.x + si;
			}
			//^098D:07B7
			bp1a.y += di;
			//^098D:07BA
			if (bp1a.y < di) {
				//^098D:07C1
				bp1a.y = di;
			}
			//^098D:07C4
			if (bp08->cy + di <= bp1a.y + bp1a.cy -1) {
				//^098D:07D8
				bp1a.cy = bp08->cy - bp1a.y + di;
			}
			//^098D:07E4
			switch (bp04->x) {
				default:
					//^098D:07F9
					//^098D:05AA
					return NULL;

				case 10:
					//^098D:07FC
					di += (bp08->cy +1) >> 1;
					//^098D:0808
					si += (bp08->cx +1) >> 1;
					//^098D:0814
					break;

				case 15:
					//^098D:0808
					si += (bp08->cx +1) >> 1;
					//^098D:0814
					break;

				case 13:
					//^098D:0816
					di += bp08->cy -1;
					//^098D:0820
					si += bp08->cx -1;
					//^098D:0814
					break;

				case 12:
					//^098D:0820
					si += bp08->cx -1;
					//^098D:0814
					break;

				case 16:
					//^098D:082A
					si += bp08->cx -1;
					//^098D:0834
					di += (bp08->cy +1) >> 1;
					//^098D:083E
					break;

				case 18:
					//^098D:0834
					di += (bp08->cy +1) >> 1;
					//^098D:083E
					break;

				case 17:
					//^098D:0840
					si += (bp08->cx +1) >> 1;
					//^098D:084C
					di += bp08->cy -1;

					break;

				case 14:
					//^098D:084C
					di += bp08->cy -1;

					break;

				case 11:
					//^098D:0856
					break;
			}
			//^098D:0856
			bp0a += si + bp04->cx;
			//^098D:0862
			bp0c += di + bp04->cy;
			//^098D:086B
		}
		else {
			//^098D:086E
			bp08 = QUERY_RECT(glbRectNoTable.pb0, bp04->y);
			//^098D:088A
			if (bp08 == NULL)
				break;
			//^098D:0891
			bp24 = bp04->y;
			si = bp08->cx;
			di = bp08->cy;
			//^098D:08A6
			if (bp08->x == 1) {
				//^098D:08AC
				bp0a += si;
				bp0c += di;
				bp1a.x += si;
				bp1a.y += di;
			}
			//^098D:08BB
			else if (bp08->x == 9) {
				//^098D:08C7
				switch (bp04->x) {
					case 0:
						//^098D:08DC
						si = bp04->cx - ((si +1) >> 1);
						//^098D:08EC
						//^098D:0960
						di = bp04->cy - ((di +1) >> 1);
						break;

					case 1:
						//^098D:08EE
						si = bp04->cx;
						//^098D:08F5
						di = bp04->cy;
						break;

					case 2:
						//^098D:08FE
						si = bp04->cx - (si -1);
						//^098D:0908
						//^098D:0939
						//^098D:08F5
						di = bp04->cy;
						break;

					case 3:
						//^098D:090A
						si = bp04->cx - (si -1);
						//^098D:0918
						di = bp04->cy - (di -1);
						//^098D:0922
						//^098D:096C
						break;

					case 4:
						//^098D:0924
						si = bp04->cx;
						//^098D:092B
						//^098D:0918
						di = bp04->cy - (di -1);
						//^098D:0922
						//^098D:096C
						break;

					case 5:
						//^098D:092D
						si = bp04->cx - ((si +1) >> 1);
						//^098D:0939
						//^098D:093D
						//^098D:08F5
						di = bp04->cy;
						break;

					case 6:
						//^098D:093F
						si = bp04->cx - (si -1);
						//^098D:0949
						//^098D:08E8
						break;

					case 7:
						//^098D:094B
						si = bp04->cx - ((si +1) >> 1);
						//^098D:0957
						//^098D:0914
						//^098D:0918
						di = bp04->cy - (di -1);
						//^098D:0922
						//^098D:096C
						break;

					case 8:
						//^098D:0959
						si = bp04->cx;
						//^098D:0960
						di = bp04->cy - ((di +1) >> 1);
						break;
				}
				//^098D:0970
				if (bp10 != 0) {
					//^098D:0976
					bp10 = 0;
					bp0a += si;
					bp0c += di;
					bp1a.x += si;
					bp1a.y += di;
				}
				//^098D:0987
				if (bp1a.x < si) {
					//^098D:098C
					bp1a.x = si;
				}
				//^098D:098F
				if (bp08->cx + si <= bp1a.x + bp1a.cx -1) {
					//^098D:09A3
					bp1a.cx = bp08->cx - bp1a.x + si;
				}
				//^098D:09AF
				if (bp1a.y < di) {
					//^098D:09B4
					bp1a.y = di;
				}
				//^098D:09B7
				if (bp08->cy + di <= bp1a.y + bp1a.cy -1) {
					//^098D:09CB
					bp1a.cy = bp08->cy - bp1a.y + di;
				}
			}
			else {
				//^098D:09D9
				if (bp08->x <= 8) {
					//^098D:09E2
					bp10 = 1;
				}
			}
		}
		//^098D:09E7
		bp04 = bp08;
		//^098D:09F3
	}
	//^098D:0A00
	si = *yourcx;
	//^098D:0A08
	if (si == 0) {
		//^098D:0A0C
		si = READ_UI16(buff,-4);
	}
	//^098D:0A13
	di = *yourcy;
	//^098D:0A1B
	if (di == 0) {
		//^098D:0A1F
		di = READ_UI16(buff,-2);
	}
	//^098D:0A26
	switch (bp0e) {
		default:
			//^098D:0A35
			//^098D:05AA
			return NULL;

		case 0:
			//^098D:0A38
			rect->x = bp0a -((si +1) >> 1);
			//^098D:0A48
			//^098D:0AB1
			rect->y = bp0c -((di +1) >> 1);
			break;

		case 1:
			//^098D:0A4A
			rect->x = bp0a;
			//^098D:0A53
			rect->y = bp0c;
			break;

		case 2:
			//^098D:0A5F
			rect->x = bp0a - (si -1);
			//^098D:0A53
			rect->y = bp0c;
			break;

		case 3:
			//^098D:0A64
			rect->x = bp0a - (si -1);
			//^098D:0A72
			rect->y = bp0c - (di -1);
			//^098D:0A7D
			//^098D:0ABE
			break;

		case 4:
			//^098D:0A7F
			rect->x = bp0a;
			//^098D:0A88
			//^098D:0A72
			rect->y = bp0c - (di -1);
			//^098D:0A7D
			//^098D:0ABE
			break;

		case 5:
			//^098D:0A8A
			rect->x = bp0a - ((si +1) >> 1);
			//^098D:0A9A
			//^098D:0A53
			rect->y = bp0c;
			break;

		case 6:
			//^098D:0A9C
			rect->x = bp0a - (si -1);
			//^098D:0A9F
			//^098D:0A3D
			//^098D:0A48
			//^098D:0AB1
			rect->y = bp0c - ((di +1) >> 1);
			break;

		case 7:
			//^098D:0AA1
			rect->x = bp0a - ((si +1) >> 1);
			//^098D:0A72
			rect->y = bp0c - (di -1);
			//^098D:0A7D
			//^098D:0ABE
			break;

		case 8:
			//^098D:0AA8
			rect->x = bp0a;
			//^098D:0AB1
			rect->y = bp0c - ((di +1) >> 1);
			break;
	}
	//^098D:0AC2
	if (_4976_4bca.cx != 0) {
		//^098D:0AC9
		COPY_MEMORY(&_4976_4bca, &bp1a, sizeof(SRECT));
	}
	//^098D:0ADE
	if (_4976_4bc8 != 0 && glbIsPlayerMoving != 0 && bp24 == 3) {
		//^098D:0AF2
		if (UNION_RECT(&bp1a, &_4976_00fe, yourcx, yourcy) == NULL) {
			//^098D:05AA
			return NULL;
		}
	}
	//^098D:0B15
	bp0a = bp1a.x - rect->x;
	//^098D:0B21
	if (bp0a <= 0) {
		//^098D:0B25
		*yourcx = 0;
		//^098D:0B33
		rect->cx = min_value(si, bp1a.cx + bp0a);
	}
	else {
		//^098D:0B37
		*yourcx = bp0a;
		//^098D:0B40
		rect->x = bp1a.x;
		//^098D:0B49
		rect->cx = min_value(si - bp0a, bp1a.cx);
	}
	//^098D:0B60
	bp0c = bp1a.y - rect->y;
	//^098D:0B6D
	if (bp0c <= 0) {
		//^098D:0B71
		*yourcy = 0;
		//^098D:0B79
		rect->cy = min_value(di, bp1a.cy + bp0c);
	}
	else {
		//^098D:0B83
		*yourcy = bp0c;
		//^098D:0B8C
		rect->y = bp1a.y;
		//^098D:0B96
		rect->cy = min_value(di - bp0c, bp1a.cy);
	}
	//^098D:0BAD
	if (rect->cx <= 0 || rect->cy <= 0)
		return NULL;
	//^098D:0BC1

	SkD((DLV_RCT, "RCT: <- QUERY_BLIT_RECT(%p,%p(%6d,%6d,%6d,%6d),%4d,%3d,%3d,%3d)\n"
		, buff, rect, (Bitu)rect->x, (Bitu)rect->y, (Bitu)rect->cx, (Bitu)rect->cy
		, (Bitu)rectno, (Bitu)*yourcx, (Bitu)*yourcy, (Bitu)ww));

	return rect;
}

//^0B36:16E4
void SkWinCore::DRAW_GAMELOAD_DIALOGUE_TO_SCREEN(Bit8u *buffsrc, Bit16u rectno, __int16 colorkey, Bit8u localpal[16])
{
	//^0B36:16E4
	//^0B36:16E8
	__int16 bp02 = 0;
	__int16 bp04 = 0;
	SRECT bp0c;
	//^0B36:16F2
	if (QUERY_BLIT_RECT(buffsrc, &bp0c, rectno, &bp02, &bp04, -1) != NULL) {
		//^0B36:1718
		FIRE_BLIT_PICTURE(
			buffsrc,
			_4976_4964,
			&bp0c,
			bp02,
			bp04,
			*(Bit16u *)&buffsrc[-4],
			glbScreenWidth,
			colorkey,
			0,
			*(Bit16u *)&buffsrc[-6],
			8,
			localpal
			);
	}
	//^0B36:1755
	return;
}

//^01B0:0D39
void SkWinCore::_01b0_0d39(__int16 *xx, __int16 *yy, __int16 *zz, Bit16u ww) //#DS=04BF
{
	//^01B0:0D39
	ENTER(0);
	//^01B0:0D3C
	LOADDS(0x3083);
	//^01B0:0D42
	if (ww != 0) {
		//^01B0:0D4A
		*xx = _04bf_185e;
		//^01B0:0D53
		*yy = _04bf_1860;
		//^01B0:0D5C
		*zz = _04bf_1936;
	}
	else {
		//^01B0:0D64
		*xx = glbMouseXPos;
		//^01B0:0D6D
		*yy = glbMouseYPos;
		//^01B0:0D76
		*zz = glbMouseButtonState;
	}
	//^01B0:0D7F
	//^01B0:0D81
	return;
}

//^01B0:0008
void SkWinCore::MOVE_MEMORY(const void *buffSrc, void *buffDst, Bit16u size)
{
	memmove(buffDst, buffSrc, size);
}

//^00EB:01EB
void SkWinCore::MOVE_MEMORY_WITH_DELTA(Bit16u offSrc, Bit16u offDst, Bit16u size) //#DS=04BF
{
	//^00EB:01EB
	//^00EB:01EE
	MOVE_MEMORY(
		_04bf_0cf0 +offSrc,
		_04bf_0e34 +offDst,
		size
		);
	//^00EB:021F
	return;
}

//^00EB:0221
void SkWinCore::COPY_MEMORY_WITH_DELTA_AND_TRANSPARENT(Bit16u offSrc, Bit16u offDst, Bit16u size, Bit8u colorkey) //#DS=04BF
{
	//^00EB:0221
	//^00EB:0224
	Bit8u dh = colorkey;
	Bit8u *di = _04bf_0e34 + offDst;
	Bit16u cx = size;
	Bit8u *si = _04bf_0cf0 + offSrc;

	do {
		//^00EB:0242
		Bit8u al = *(si++);
		//^00EB:0243
		if (al != colorkey) {
			//^00EB:0247;
			*(di++) = al;
		}
		else {
			//^00EB:024C
			di++;
		}
		//^00EB:024D
	} while (--cx != 0);
	//^00EB:024F
	return;
}

//^00EB:0812
void SkWinCore::MOVE_MEMORY_STRETCH_13TO16(Bit16u offSrc, Bit16u offDst)
{
	// compose 0.5 stepping viewport. (123% larger)

	//^00EB:0812
	//^00EB:0817
	Bit8u *di = _04bf_0e34 +offDst;
	Bit8u *si = _04bf_0cf0 +offSrc;
	Bit16u cx = 14;

	// DS:SI	E000:871B -> E000:8728 (+13)
	// ES:DI	A000:3340 -> A000:3350 (+16)

	// [DS:SI] in  E000:8728  A4 A7 A2 A7 AB AB A6 A9 A9 A9 A9 A9 A8
	// [ES:DI] out A000:3350  A4 A7 A2 A2 A7 AB AB A6 A9 A9 A9 A9 A9 A9 A9 A8

	// [DS:SI] in  E000:87FB  00 01 02 03 04 05 06 07 08 09 0A 0B 0C
	// [ES:DI] out A000:3480  00 01 02 02 03 04 05 06 07 07 08 09 0A 0B 0B 0C

	do {
		//^00EB:082C
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; 
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; 
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; si++;
		*di = *si; di++; 
		*di = *si; di++; si++;
		//^00EB:083E
	} while (--cx != 0);
	//^00EB:0840
	return;
}

//^00EB:0845
void SkWinCore::_00eb_0845(Bit8u *buff, SRECT *rc, Bit16u ww) //#DS=04BF
{
	//^00EB:0845
	//^00EB:084B
	LOADDS(0x0c48);
	//^00EB:0851
	Bit16u bp12 = ((ww & 0x8000) != 0) ? 1 : 0;
	//^00EB:0862
	LOCK_MOUSE_EVENT();
	//^00EB:0867
	if (true
		&& glbMouseCursorVisible != 0
		&&                           rc->y <= _04bf_09e0.y + _04bf_09e0.cy -1
		&&               rc->y + rc->cy -1 >= _04bf_09e0.y
		&&               rc->x + rc->cx -1 >= _04bf_09e0.x
		&& _04bf_09e0.x + _04bf_09e0.cx -1 >= rc->x
	) {
		//^00EB:08B0
		//^00EB:092C
		SRECT bp10;
		bp10.y = max(rc->y, _04bf_09e0.y);
		//^00EB:0948
		bp10.x = max(rc->x, _04bf_09e0.x);
		//^00EB:0962
		bp10.cx = min(rc->x + rc->cx -1, _04bf_09e0.x + _04bf_09e0.cx -1) -bp10.x +1;
		//^00EB:099D
		bp10.cy = min(rc->y + rc->cy -1, _04bf_09e0.y + _04bf_09e0.cy -1) -bp10.y +1;
		//^00EB:09D2
		__int16 bp06 = bp10.x - rc->x;
		__int16 bp08 = bp10.y - rc->y;
		//^00EB:09E8
		bp10.y -= _04bf_09e0.y;
		bp10.x -= _04bf_09e0.x;
		//^00EB:09F4
		if (bp12 != 0) {
			//^00EB:09FA
			IBMIO_BLIT_TO_SCREEN_8TO8BPP(
				buff,
				_04bf_079e,
				&bp10,
				bp06,
				bp08,
				rc->cx,
				24,
				-1
				);
		}
		//^00EB:0A1E
		Bit16u si = rc->y * 320 + rc->x;
		Bit16u bp02 = 0;
		Bit16u di = 0;
		Bit16u bp04 = rc->y;
		//^00EB:0A3D
		for (; rc->y + rc->cy -1 >= bp04; di += 103, bp02 += rc->cx, si += 320, bp04++) {
			//^00EB:0A40
			if (bp04 >= _04bf_09e0.y && _04bf_09e0.y + _04bf_09e0.cy -1 >= bp04) {
				//^00EB:0A5C
				_04bf_0cf0 = buff;
				_04bf_0e34 = _04bf_0cf4;
				//^00EB:0A73
				if (bp12 != 0) {
					//^00EB:0A79
					MOVE_MEMORY_STRETCH_13TO16(
						(((di >> 7) +8) *224) +21,
						0
						);
				}
				else {
					//^00EB:0A94
					MOVE_MEMORY_WITH_DELTA(bp02, 0, rc->cx);
				}
				//^00EB:0AA7
				_04bf_0cf0 = _04bf_0cf4;
				_04bf_0e34 = _04bf_079e;
				//^00EB:0ABB
				MOVE_MEMORY_WITH_DELTA(_04bf_09e0.x, ((bp04 - _04bf_09e0.y) * 24) +bp10.x, bp10.cx);
				//^00EB:0AD9
				_04bf_0cf0 = _04bf_0e80[_04bf_1938].b6;
				_04bf_0e34 = _04bf_0cf4;
				//^00EB:0AF5
				COPY_MEMORY_WITH_DELTA_AND_TRANSPARENT(
					(bp04 - _04bf_09e0.y) * (_04bf_0e80[_04bf_1938].b2) + bp10.x,
					bp06,
					bp10.cx,
					(Bit8u)_04bf_079c
					);
				//^00EB:0B25
				_04bf_0cf0 = _04bf_0cf4;
				_04bf_0e34 = pbVram;
				//^00EB:0B3B
				//^00EB:0B8B
				MOVE_MEMORY_WITH_DELTA(0, si, rc->cx);
			}
			else {
				//^00EB:0B47
				_04bf_0cf0 = buff;
				_04bf_0e34 = pbVram;
				//^00EB:0B60
				if (bp12 != 0) {
					//^00EB:0B66
					MOVE_MEMORY_STRETCH_13TO16((((di >> 7) + 8) * 224) + 21, si);
				}
				else {
					//^00EB:0B80
					MOVE_MEMORY_WITH_DELTA(bp02, si, rc->cx);
				}
			}
			//^00EB:0B92
		}
	}
	else {
		//^00EB:08B3
		if (bp12 != 0) {
			//^00EB:08B9
			_04bf_0e34 = (Bit8u *)__vram;
			_04bf_0cf0 = buff;
			//^00EB:08D2
			Bit16u di = 0;
			Bit16u si = 320*40;
			//^00EB:08D7
			for (; si < 320*176; di += 103, si += 320) {
				//^00EB:08D9
				MOVE_MEMORY_STRETCH_13TO16(
					((di >> 7) +8) *224 +21,
					si
					);
				//^00EB:08F1
			}
		}
		else {
			//^00EB:0901
			IBMIO_BLIT_TO_SCREEN_8TO8BPP(
				buff,
				__vram,
				rc,
				0,
				0,
				rc->cx,
				320,
				-1
				);
		}
	}
#if UseAltic
	skwin.UpdateRect(0, 40, 224, 136);
#endif

	//^00EB:0BBA
	UNLOCK_MOUSE_EVENT();
	//^00EB:0BBF
	return;
}

//^098D:0D3F
SRECT *SkWinCore::SCALE_RECT(Bit16u rectno, SRECT *rc, Bit16u horzResolution, Bit16u vertResolution)
{
	// horzResolution, vertResolution: 10,000 is fair. 5,000 is half. 20,000 is double.

	//^098D:0D3F
	//^098D:0D45
	Bit16u di = horzResolution;
	Bit16u si = vertResolution;
	//^098D:0D4B
	SRECT *bp04 = QUERY_RECT(&glbRectNoTable, rectno);
	//^098D:0D63
	if (bp04 != NULL) {
		//^098D:0D6A
		if (bp04->y != 0) {
			//^098D:0D77
			bp04 = QUERY_RECT(&glbRectNoTable, bp04->y);
			//^098D:0D93
			if (bp04 != NULL) {
				//^098D:0D9A
				if (bp04->x == 9) {
					//^098D:0DA6
					__int16 bp06 = (di == 10000) ? (bp04->cx) : (__int16)((__int32(bp04->cx) * di) / 10000);
					//^098D:0DD6
					__int16 bp08 = (si == 10000) ? (bp04->cy) : (__int16)((__int32(bp04->cy) * si) / 10000);
					//^098D:0E09
					if (bp06 == 0 && di != 0) {
						//^098D:0E13
						bp06 = 1;
					}
					//^098D:0E18
					if (bp08 == 0 && si != 0) {
						//^098D:0E22
						bp08 = 1;
					}
					//^098D:0E27
					if (bp06 > 0 && bp08 > 0) {
						//^098D:0E33
						return QUERY_BLIT_RECT(NULL, rc, rectno, &bp06, &bp08, -1);
					}
				}
			}
		}
	}
	//^098D:0E55
	return NULL;
}

//^098D:0E5D
SRECT *SkWinCore::QUERY_EXPANDED_RECT(Bit16u rectno, SRECT *rc)
{
	//^098D:0E5D
	//^098D:0E60
	return SCALE_RECT(rectno, rc, 10000, 10000);
}

//^44C8:1BE8
// SPX: _44c8_1be8 renamed CHANGE_VIEWPORT_TO_INVENTORY
void SkWinCore::CHANGE_VIEWPORT_TO_INVENTORY(Bit16u xx) //#DS=4976
{
	//^44C8:1BE8
	//^44C8:1BEE
	Bit16u di = glbIsPlayerMoving;
	glbIsPlayerMoving = 0;
	//^44C8:1BF8
	SRECT bp0e;
	QUERY_EXPANDED_RECT(7, &bp0e);
	//^44C8:1C07
	glbIsPlayerMoving = di;
	//^44C8:1C0B
	Bit16u si;
	if (glbPaletteIRGBLoaded == 0) {
		//^44C8:1C12
		__int16 bp02, bp04, bp06;
		//_01b0_0d39(&bp02, &bp04, &bp06, 1) CALL_IBMIO;
		//^44C8:1C2E
		if (bp0e.x +bp0e.cx -1 < bp02 || bp0e.y +bp0e.cy -1 < bp04 || bp04 +bp06 < bp0e.y) {
			//^44C8:1C51
			si = 0;
		}
		else {
			//^44C8:1C55
			FIRE_HIDE_MOUSE_CURSOR();
			si = 1;
		}
	}
	//^44C8:1C5D
	_00eb_0845(_4976_4c16, &bp0e, (glbIsPlayerMoving != 0) ? 0x8008 : 0x0008) CALL_IBMIO;
	//^44C8:1C85
	if (glbPaletteIRGBLoaded == 0 && si != 0) {
		//^44C8:1C90
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^44C8:1C95
	return;
}

//^0AAF:002F
void SkWinCore::_0aaf_002f()
{
	//^0AAF:002F
	//^0AAF:0032
	if (glbGameHasEnded != 0) {
		//^0AAF:0039
		FIRE_HIDE_MOUSE_CURSOR();
		//^0AAF:003E
		DRAW_GAMELOAD_DIALOGUE_TO_SCREEN(_4976_4c16, 5, -1, NULL);
		//^0AAF:0056
		FIRE_SHOW_MOUSE_CURSOR();
	}
	else {
		//^0AAF:005D
		CHANGE_VIEWPORT_TO_INVENTORY(0);
	}
}

//^0CD5:00A0
Bit16u SkWinCore::max_value(__int16 v1, __int16 v2) {
	//^0CD5:00A0
	//^0CD5:00A3
	if (v1 > v2)
		return v1;
	return v2;
}

//^0CD5:008E
Bit16u SkWinCore::min_value(__int16 v1, __int16 v2) {
	//^0CD5:008E
	//^0CD5:0091
	if (v1 < v2)
		return v1;
	return v2;
}

//^44C8:1BA2
void SkWinCore::FIRE_WAIT_VSYNC()
{
	//^44C8:1BA2
	//^44C8:1BA5
	IBMIO_WAIT_VSYNC() CALL_IBMIO;
}

//^0CD5:000E
void SkWinCore::WAIT_SCREEN_REFRESH()
{
	//^0CD5:000E
	FIRE_WAIT_VSYNC();
}

//^3E74:178C
//RawEntry *SkWinCore::QUERY_GDAT_ENTRYPTR(Bit8u cls1, Bit16u cls2, Bit8u cls3, Bit16u cls4)
RawEntry *SkWinCore::QUERY_GDAT_ENTRYPTR(Bit8u iCategory, Bit16u iItem, Bit8u iType, Bit16u iEntry)
{
	// cls1 - main category	-> iCategory
	// cls2 - sub category	-> iItem
	// cls3 - type			-> iType
	// cls4 - name			-> iEntry

	//^3E74:178C
	// If requested category is above max category
	if (iCategory > U8(glbGDatEntries.w12)) {
		//^3E74:179D
		return NULL;
	}
	Bit16u si = glbGDatEntries.pw0[iCategory];
	if (glbGDatEntries.pw0[iCategory +1] - si < iType) {
		//^3E74:17D2
		return NULL;
	}
	//^3E74:17D2
	si += iType;
	Bit16u di = glbGDatEntries.pw4[si];
//		3E74:17E6  8BF8                 mov  di,ax
//		3E74:17E8  33D2                 xor  dx,dx							DX:AX=0000:1399
//		3E74:17EA  05FFFF               add  ax,FFFF
//		3E74:17ED  83D2FF               adc  dx,FFFF						DX:AX=0000:1398
//		3E74:17F0  B102                 mov  cl,02
//		3E74:17F2  9A85099A06           call 069A:0985		call SHL32		DX:AX=0000:4E60
//		3E74:17F7  50                   push ax
//		3E74:17F8  52                   push dx
//		3E74:17F9  8B16C05C             mov  dx,[5CC0]
//		3E74:17FD  A1BE5C               mov  ax,[5CBE]						DX:AX=9283:0006
//		3E74:1800  59                   pop  cx
//		3E74:1801  5B                   pop  bx								CX:BX=0000:4E60
//		3E74:1802  9A6F0A9A06           call 069A:0A6F		call ADD_TO_FAR_PTR
//		3E74:1807  8946F8               mov  [bp-08],ax						DX:AX=9769:0006
//		3E74:180A  8956FA               mov  [bp-06],dx

//9283:0006 + 00703C -> 99872
//9987:0002 + 000030 -> 998A2

	RawEntry *bp08 = &glbGDatEntries.pv8[di -1];
	//^3E74:180D
	di = glbGDatEntries.pw4[si +1] -di +1;
	//^3E74:1820
	si = 0;
	while (true) {
		//^3E74:1822
		Bit16u bp0a = (si +di) / 2;
		//^3E74:182B
		if (!(bp0a != si))
			return NULL;
		//^3E74:1833
		RawEntry *bp04 = &bp08[bp0a];
		__int16 bp0c = bp04->cls2 - iItem;
		//^3E74:1866
		if (!(bp0c != 0)) {
			//^3E74:186A
			bp0c = bp04->cls4 - iEntry;
			if (!(bp0c != 0)) {
				//^3E74:187E
				return bp04;
			}
		}
		//^3E74:1887
		if (!(bp0c <= 0)) {
			//^3E74:188D
			di = bp0a;
		}
		else {
			//^3E74:1892
			si = bp0a;
		}
	}
}

//^3E74:1CF3
//Bit16u SkWinCore::QUERY_GDAT_ENTRY_IF_LOADABLE(Bit8u cls1, Bit8u cls2, Bit8u cls3, Bit8u cls4)
Bit16u SkWinCore::QUERY_GDAT_ENTRY_IF_LOADABLE(Bit8u iCategory, Bit8u iItemIndex, Bit8u iDataType, Bit8u iEntryNumber)
{
LOGX(("%40s: C%02d=I%02X=E%02X=T%03d to %08X", "QUERY_GDAT_ENTRY_IF_LOADABLE", iCategory, iItemIndex, iEntryNumber, iDataType ));
	//^3E74:1CF3
	//^3E74:1CF7
	RawEntry *bp04 = QUERY_GDAT_ENTRYPTR(iCategory, iItemIndex, iDataType, iEntryNumber);
	//^3E74:1D14
	if (bp04 != NULL) {
		//^3E74:1D18
		if (false
			|| (iDataType == dtWordValue)
			|| (iEntryNumber == dtImageOffset)
			|| (glbShelfMemoryTable[bp04->data & 0x7fff].Present())
			|| (IS_CLS1_CRITICAL_FOR_LOAD(iCategory) != 0)
		) {
			//^3E74:1D56
			return 1;
		}
	}
	//^3E74:1D5B
	return 0;
}

//^0B36:000A
Bit16u SkWinCore::CALC_IMAGE_BYTE_LENGTH(Bit8u *buff)
{
	//^0B36:000A
	//^0B36:000D
	return ((READ_UI16(buff,-6) == 4) ? (((READ_UI16(buff,-4) +1) & 0xfffe) >> 1) : READ_UI16(buff,-4) & 0xffff) * READ_UI16(buff,-2);
}

//^00EB:03D5
void SkWinCore::IBMIO_WAIT_VSYNC()
{
#if UseAltic
	skwin.Sleep(1000 / 50);
#else
	//^00EB:03D5
	//^00EB:03D8
	while ((inportb(0x03da) & 0x08) != 0);
	//^00EB:03E0
	while ((inportb(0x03da) & 0x08) == 0);
#endif
}

//^00EB:045D
void SkWinCore::IBMIO_UPDATE_PALETTE_SET()
{
	//^00EB:045D
	//^00EB:0463
	IBMIO_WAIT_VSYNC();
	//^00EB:0466
	outportb(0x03c8, 0);
	Bit16u si = 0;
	//^00EB:0470
	for (; si < 256; si++) {
		//^00EB:0472
		Bit8u bp01 = glbPaletteRGB[si][0];
		Bit8u bp02 = glbPaletteRGB[si][1];
		Bit8u bp03 = glbPaletteRGB[si][2];
		//^00EB:04A2
		outportb(0x03c9, bp01);
		outportb(0x03c9, bp02);
		outportb(0x03c9, bp03);
		//^00EB:04B1
	}
	//^00EB:04B8
	//^00EB:04B9
	return;
}

//^00EB:0654
void SkWinCore::IBMIO_SELECT_PALETTE_SET(Bit8u number) //#DS=04BF
{
	//^00EB:0654
	//^00EB:0659
	LOADDS(0x0c48);
	//^00EB:065E
	if (number == 0) {
		//^00EB:0664
		IBMIO_WAIT_VSYNC();
		//^00EB:0668
		outportb(0x03c8, 0);
		Bit16u si = 0;
		for (; si < 256; si++) {
			//^00EB:0674
			outportb(0x03c9, 0);
			outportb(0x03c9, 0);
			outportb(0x03c9, 0);
			//^00EB:067C
		}
		//^00EB:0683
	}
	//^00EB:0686
	else if (number == 1) {
		//^00EB:068C
		IBMIO_UPDATE_PALETTE_SET();
	}
	//^00EB:0690
	glbUpdatePalette = number;
	//^00EB:0696
	return;
}

//^44C8:1BD4
void SkWinCore::FIRE_SELECT_PALETTE_SET(Bit8u number)
{
	//^44C8:1BD4
	IBMIO_SELECT_PALETTE_SET(number) CALL_IBMIO;
}

//^00EB:0353
void SkWinCore::IBMIO_FILL_SCREEN_LINE(Bit16u offDst, Bit16u fill, Bit16u size) //#DS=04BF?
{
	//^00EB:0353
	//^00EB:0357

	// TODO: Alt impl
	memset(_04bf_0e34 + offDst, fill, size);
}

//^00EB:0383
void SkWinCore::IBMIO_FILL_RECT_SCREEN(SRECT *rc, Bit16u fill) //#DS=04BF
{
	//^00EB:0383
	//^00EB:0389
	LOADDS(0x0c48);
	//^00EB:038E
	_04bf_0e34 = pbVram;
	//^00EB:039A
	Bit16u di = rc->y * 320 + rc->x;
	Bit16u si = 0;
    //^00EB:03AD
	for (; rc->cy > si; di += 320, si++) {
		//^00EB:03AF
		IBMIO_FILL_SCREEN_LINE(di, fill, rc->cx);
		//^00EB:03C2
	}
	//^00EB:03D0
#if UseAltic
	skwin.UpdateRect(rc->x, rc->y, rc->cx, rc->cy);
	MessageLoop(false);
#endif
	return;
}

//^44C8:1233
void SkWinCore::FIRE_FILL_4BPP_PICT_LINE(Bit16u offDst, Bit16u fill, Bit16u size)
{
	ATLASSERT(size != 0);

	//^44C8:1233
	//^44C8:1237
	Bit8u *di = _4976_5e6a;
	Bit16u bx = offDst;
	Bit16u cx = size;
	U8 ah = Bit8u(fill);
	U8 al;
	//^44C8:1245
	bool carry = (bx & 1) ? true : false;
	bx >>= 1;
	di += bx;
	//^44C8:124B
	if (carry) {
		//^44C8:124D
		al = *di;
		al &= 0xf0;
		al |= ah;
		stosb(di, al);
		//^44C8:1255
		cx--;
		if (cx == 0)
			//^44C8:1256
			return;
	}
	//^44C8:1258
	al = ah;
	al <<= 4;
	al |= ah;
	ah = al;
	{
		bool carry = (cx & 1) ? true : false;
		cx >>= 1;
		{
			bool carry = (cx & 1) ? true : false;
			cx >>= 1;
			if (carry) {
				//^44C8:1268
				stosb(di, al);
			}
			while (cx != 0) {
				//^44C8:1269
				stosb(di, al);
				stosb(di, ah);
				cx--;
			}
		}
		if (carry) {
			al = *di;
			al &= 0x0f;
			ah &= 0xf0;
			al |= ah;
			stosb(di, al);
		}
	}
	//^44C8:127B
	return;
}

//^44C8:1A1E
void SkWinCore::FIRE_FILL_RECT_4BPP_PICT(Bit8u *buff, SRECT *rc, Bit16u fill, Bit16u width)
{
	//^44C8:1A1E
	//^44C8:1A23
	_4976_5e6a = buff;
	//^44C8:1A30
	width = (width + 1) & 0xfffe;
	//^44C8:1A3A
	Bit16u di = rc->y * width + rc->x;
	Bit16u si = 0;
	//^44C8:1A4B
	for (; rc->cy > si; di += width, si++) {
		//^44C8:1A4D
		FIRE_FILL_4BPP_PICT_LINE(di, fill, rc->cx);
		//^44C8:1A60
	}
	//^44C8:1A6D
	return;
}

//^44C8:127E
void SkWinCore::FIRE_FILL_8BPP_PICT_LINE(Bit16u offDst, Bit16u fill, Bit16u size)
{
	//^44C8:127E
	//^44C8:1282
	Bit8u *di = _4976_5e6a + offDst;
	Bit16u cx = size;
	Bit8u al = Bit8u(fill);
	//^44C8:1292
	U16 dx = cx;
	dx &= 1;
	if (dx != 0) {
		//^44C8:1299
		stosb(di, al);
		cx--;
	}
	//^44C8:129B
	dx = cx;
	cx >>= 1;
	if (cx != 0) {
		//^44C8:12A1
		U16 ax = al | (al << 8);
		while (cx != 0) {
			stosw(di, ax);
			cx--;
		}
	}
	//^44C8:12A5
	dx &= 1;
	if (dx != 0) {
		//^44C8:12AA
		stosb(di, al);
	}
	//^44C8:12AB
	return;
}

//^44C8:19D5
void SkWinCore::FIRE_FILL_RECT_8BPP_PICT(Bit8u *buff, SRECT *rc, Bit16u fill, Bit16u width)
{
	//^44C8:19D5
	//^44C8:19DA
	_4976_5e6a = buff;
	//^44C8:19E7
	Bit16u di = rc->y * width + rc->x;
	Bit16u si = 0;
	//^44C8:19F8
	for (; rc->cy > si; di += width, si++) {
		//^44C8:19FA
		FIRE_FILL_8BPP_PICT_LINE(di, fill, rc->cx);
		//^44C8:1A0D
	}
	//^44C8:1A1A
	return;
}

//^44C8:1A71
void SkWinCore::FIRE_FILL_RECT_ANY(Bit8u *buff, SRECT *rc, Bit16u fill, Bit16u width, Bit16u bpp)
{
	//^44C8:1A71
	//^44C8:1A75
	Bit16u si = fill;
	//^44C8:1A78
	if (buff == NULL) {
		//^44C8:1A80
		IBMIO_FILL_RECT_SCREEN(rc, si) CALL_IBMIO;
	}
	//^44C8:1A94
	else if (bpp == 4) {
		//^44C8:1A9A
		FIRE_FILL_RECT_4BPP_PICT(buff, rc, si, width);
	}
	else {
		//^44C8:1AB0
		FIRE_FILL_RECT_8BPP_PICT(buff, rc, si, width);
	}
	//^44C8:1AC7
	return;
}

//^44C8:1DAF
void SkWinCore::FIRE_FILL_SCREEN_RECT(Bit16u rectno, Bit8u fill)
{
	//^44C8:1DAF
	//^44C8:1DB3
	SRECT bp08;
	SRECT *prc = QUERY_EXPANDED_RECT(rectno, &bp08);
	FIRE_FILL_RECT_ANY(NULL, prc, fill, bp08.cx, 8);
}

//^0AAF:0000
void SkWinCore::FIRE_FADE_SCREEN(Bit16u fadeOutIfTrue) //#DS=4976
{
	//^0AAF:0000
	//^0AAF:0003
	if (glbGameHasEnded != 0) {
		//^0AAF:000A
		if (fadeOutIfTrue != 0) {
			//^0AAF:0010
			FIRE_SELECT_PALETTE_SET(0);
			//^0AAF:0018
			FIRE_FILL_SCREEN_RECT(2, 0);
		}
		else {
			//^0AAF:0025
			FIRE_SELECT_PALETTE_SET(1);
		}
	}
	//^0AAF:002D
	return;
}

//^44C8:1D8C
void SkWinCore::FIRE_FILL_BACKBUFF_RECT(SRECT *rc, Bit8u fill)
{
	//^44C8:1D8C
	//^44C8:1D8F
    FIRE_FILL_RECT_ANY(
		_4976_4c16,
		rc,
		fill,
		_4976_00f6,
		8
		);
	//^44C8:1DAD
	return;
}

//^098D:0071
SRECT *SkWinCore::SET_ORIGIN_RECT(SRECT *rc, __int16 width, __int16 height)
{
	//^098D:0071
	//^098D:0074
	rc->x = 0;
	rc->y = 0;
	rc->cx = width;
	rc->cy = height;
	//^098D:0090
	return rc;
}

//^098D:00F9
SRECT *SkWinCore::INFLATE_RECT(SRECT *rc, __int16 halfWidth, __int16 halfHeight)
{
	//^098D:00F9
	//^098D:00FC
	rc->x -= halfWidth;
	rc->y -= halfHeight;
	rc->cx += halfWidth << 1;
	rc->cy += halfHeight << 1;
	//^098D:011E
	return rc;
}

//^098D:0201
SRECT *SkWinCore::CALC_CENTERED_RECT_IN_RECT(SRECT *rcNew, const SRECT *rcBBox, Bit16u newWidth, Bit16u newHeight)
{
	//^098D:0201
	//^098D:0204
	rcNew->cx = newWidth;
	//^098D:020E
	rcNew->x = rcBBox->x + ((rcBBox->cx - rcNew->cx + 1) >> 1);
	//^098D:022D
	rcNew->cy = newHeight;
	//^098D:0234
	rcNew->y = rcBBox->y + ((rcBBox->cy - rcNew->cy + 1) >> 1);
	//^098D:0255
	return rcNew;
}

//^098D:0CFE
void SkWinCore::QUERY_TOPLEFT_OF_RECT(Bit16u rectno, __int16 *xpos, __int16 *ypos)
{
	//^098D:0CFE
	//^098D:0D02
	__int16 bp02 = 1;
	__int16 bp04 = 1;
	//^098D:0D0C
	SRECT bp0c;
	ATLVERIFY(QUERY_BLIT_RECT(NULL, &bp0c, rectno, &bp02, &bp04, -1) != NULL);
	//^098D:0D2B
	*xpos = bp0c.x;
	*ypos = bp0c.y;
	//^098D:0D3D
	return;
}

//^0CD5:0063
void SkWinCore::SLEEP_SEVERAL_TIME(Bit16u count)
{
	//^0CD5:0063
	//^0CD5:0066
	while (count-- != 0) {
		//^0CD5:0068
		WAIT_SCREEN_REFRESH();
		//^0CD5:006C

		MessageLoop(true, true);
	}
}

//^0AAF:01DB
void SkWinCore::_0aaf_01db(Bit16u rectno, Bit16u yy)
{
	//^0AAF:01DB
	//^0AAF:01E0
	if (_4976_5cb0 != 0) {
		//^0AAF:01EA
		if (yy == 0)
			//^0AAF:01F0
			return;
		//^0AAF:01F3
		Bit8u *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(_4976_4bd5, _4976_4bd6, _4976_4bd4);
		//^0AAF:020D
		SRECT bp10;
		CALC_CENTERED_RECT_IN_RECT(&bp10, &_4976_4e9e, READ_UI16(bp04,-4), READ_UI16(bp04,-2));
		//^0AAF:0229
		if (_4976_4e44 != 0xffff) {
			//^0AAF:0230
			__int16 bp12;
			__int16 bp14;
			QUERY_TOPLEFT_OF_RECT(_4976_4e44, &bp12, &bp14);
			//^0AAF:0246
			bp10.x -= bp12;
			bp10.y -= bp14;
		}
		//^0AAF:0252
		Bit8u *bp08;
		if (_4976_5d76 != 0) {
			//^0AAF:0259
			bp08 = QUERY_GDAT_IMAGE_LOCALPAL(_4976_4bd5, _4976_4bd6, _4976_4bd4);
		}
		else {
			//^0AAF:0272
			bp08 = bp04 + CALC_IMAGE_BYTE_LENGTH(bp04);
		}
		//^0AAF:028D
		DRAW_DIALOGUE_PARTS_PICT(bp04, &bp10, 7, bp08);
		//^0AAF:02A8
		FREE_PICT_ENTRY(bp04);
	}
	else {
		//^0AAF:02B7
		Bit8u si = (yy != 0) ? (glbPaletteT16[COLOR_BLACK]) : (glbPaletteT16[COLOR_DARK_GRAY]);
		//^0AAF:02D2
		SRECT bp10;
		FIRE_FILL_BACKBUFF_RECT(QUERY_EXPANDED_RECT(rectno, &bp10), si);
	}
	//^0AAF:02ED
	SLEEP_SEVERAL_TIME(20);
	//^0AAF:02F5
	return;
}

//^0AAF:02F8
Bit8u SkWinCore::_0aaf_02f8(Bit8u xx, Bit8u yy) //#DS=4976
{
	Bit16u si;
	skxxx1 bp04e4[2];
	Bit8u bp04d4[128];
	Bit8u bp0454[128];
	Bit8u bp03d4[0x14][40];
	Bit8u *bp00b4[0x14];
	Bit8u bp64[60];
	Bit16u bp28[2];
	skxxx1 *bp24;
	SRECT bp20;
	Bit8u bp17;
	Bit16u bp16;
	Bit16u bp14;
	Bit16u bp12;
	Bit16u bp10;
	Bit16u bp0e;
	Bit16u bp0c;
	Bit16u bp0a;
	Bit8u *bp08;
	Bit8u *bp04;

	//^0AAF:02F8
	//^0AAF:02FE
	if (xx == 0x07 || xx == 0x13) {
		//^0AAF:030A
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(0x001a, 0x0059, 0x0001, 0x0000) != 0) {
			//^0AAF:031E
			xx = 0x59;
		}
	}
	//^0AAF:0322
	bp28[0] = glbPaletteT16[COLOR_YELLOW];
	bp28[1] = glbPaletteT16[COLOR_ORANGE];
	//^0AAF:0338
	if (yy != 0 && xx != 0) {
		//^0AAF:0344
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(0x001a, 0x0000, 0x0001, 0x0000) != 0) {
			//^0AAF:0358
			_0aaf_0067(_0aaf_02f8(0, yy));
			//^0AAF:036A
			yy = 0x00;
		}
	}
	//^0AAF:036E
	bp0c = 0;
	//^0AAF:0377
	for (bp17=0; bp17 < 0x14; bp17++) {
		//^0AAF:0379
		bp00b4[bp0c] = QUERY_GDAT_TEXT(0x1a, xx, bp17, bp03d4[bp0c]);
		//^0AAF:03B6
		if (bp00b4[bp0c][0] != 0) {
			//^0AAF:03C0
			bp0c++;
		}
		//^0AAF:03C3
	}
	//^0AAF:03CC
	if ((_4976_5cb0 != 0) && ((_4976_5d76 != 0) || (_4976_00f4 +8 <= glbFreeRAMMemPool))) {
		//^0AAF:03F9
		bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x1a, xx, 0x00);
		//^0AAF:040F
		if (_4976_5d76 != 0) {
			//^0AAF:0416
			bp08 = QUERY_GDAT_IMAGE_LOCALPAL(0x1a, xx, 0);
		}
		else {
			//^0AAF:042B
			bp08 = bp04 + CALC_IMAGE_BYTE_LENGTH(bp04);
		}
		//^0AAF:0443
		DRAW_DIALOGUE_PARTS_PICT(bp04, QUERY_EXPANDED_RECT(4, &bp20), -1, bp08);
		//^0AAF:046D
		FREE_PICT_ENTRY(bp04);
		//^0AAF:047A
	}
	else {
		//^0AAF:047D
		FIRE_FILL_BACKBUFF_RECT(SET_ORIGIN_RECT(&bp20, _4976_00f6, _4976_00f8), glbPaletteT16[COLOR_DARK_GRAY]);
		//^0AAF:04A7
		FIRE_FILL_BACKBUFF_RECT(INFLATE_RECT(&bp20, -10, -10), glbPaletteT16[COLOR_BROWN]);
		//^0AAF:04CD
		if (bp0c == 0x0003) {
			bp10 = 1;
		}
		else if (bp0c == 0x0004) {
			bp10 = 4;
		}
		else {
			bp10 = 0;
		}
		//^0AAF:04EF
		for (Bit16u si=0; si < bp0c; si++) {
			//^0AAF:04F3
			_0aaf_01db(_4976_01bc[0][RCJ(8,si + bp10)], 0);
			//^0AAF:0506
		}
	}
	//^0AAF:050C
	// SPX: Draw string version on dialog box
	DRAW_VP_RC_STR(0x1c2, glbPaletteT16[COLOR_GRAY], strVersionNumber);
	//^0AAF:0526
	FIRE_FADE_SCREEN(1);
	//^0AAF:052D
	if (bp0c < 2) {
		//^0AAF:0533
		bp0e = 0x01d5;
	}
	else {
		//^0AAF:053A
		bp0e = 0x01d7;
	}
	//^0AAF:053F
	switch (bp0c) {
		case 2:
			//^0AAF:0553
			bp10 = 1;
			break;
		case 3:
			//^0AAF:055A
			bp10 = 3;
			break;
		case 4:
			//^0AAF:0561
			bp10 = 6;
			break;
		default:
			//^0AAF:0568
			bp10 = 0;
			break;
	}
	//^0AAF:056D
	for (si=0; si < bp0c; si++) {
		//^0AAF:0571
		DRAW_VP_RC_STR(_4976_01bc[1][RCJ(8,si + bp10)], glbPaletteT16[COLOR_ORANGE], bp00b4[si]);
		//^0AAF:05A1
	}
	//^0AAF:05A7
	QUERY_EXPANDED_RECT(bp0e, &bp20);
	//^0AAF:05B7
	bp12 = bp20.cx;
	bp14 = bp20.cy;
	//^0AAF:05C3
	if (yy != 0 && xx == 0) {
		//^0AAF:05CF
		bp04e4[0].pb0 = QUERY_GDAT_TEXT(0x1a, xx, yy, bp0454);
	}
	else {
		//^0AAF:05F1
		bp04e4[0].pb0 = QUERY_GDAT_TEXT(0x1a, xx, 0x14, bp0454);
		//^0AAF:060F
		if (yy != 0) {
			//^0AAF:0615
			bp04e4[1].pb0 = QUERY_GDAT_TEXT(0x1a, 0, yy, bp04d4);
			//^0AAF:0633
			goto _0641;
		}
	}
	//^0AAF:0635
	bp04e4[1].pb0 = NULL;
	//^0AAF:0641
_0641:
	Bit16u di = 0;
	si = 0;
	//^0AAF:0647
	bp24 = &bp04e4[0];
	//^0AAF:0651
	for (bp16=0; bp16 < 2; bp16++, bp24++) {
		//^0AAF:0659
		if (bp24->pb0 != 0) {
			//^0AAF:0668
			QUERY_STR_METRICS(bp24->pb0, &bp24->w4, &bp24->w6);
			//^0AAF:068B
			if (bp24->w4 > bp12 - (bp12 >> 3)) {
				//^0AAF:069F
				if (bp24->w4 < bp12 + (bp12 >> 2)) {
					//^0AAF:06B0
					bp24->w4 -= bp24->w4 >> 2;
				}
				else {
					//^0AAF:06BD
					bp24->w4 = bp12;
				}
			}
			//^0AAF:06C7
			for (bp0e=0; bp24->pb0[bp0e] != 0; ) {
				//^0AAF:06CE
				_3929_04e2(bp24->pb0, bp64, &bp0e, bp24->w4);
				//^0AAF:06EE
				di += bp24->w6 + (_4976_0134 << 1) - (_4976_0136) + 1;
				//^0AAF:0704
				if (bp24->pb0[bp0e] == vbLf) {
					//^0AAF:0710
					bp0e++;
				}
				//^0AAF:0713
			}
		}
		//^0AAF:0722
	}
	//^0AAF:0732
	if (di != 0) {
		//^0AAF:0739
		di = max_value(0, ((bp14 - di - (_4976_0134 << 1)) >> 1) + _4976_0130 - 1);
		//^0AAF:075A
		di += bp20.y;
		//^0AAF:075D
		bp24 = bp04e4;
		//^0AAF:0767
		for (bp16=0; bp16 < 2; bp24++, bp16++) {
			//^0AAF:076F
			if (bp24->pb0 != NULL) {
				//^0AAF:077B
				for (bp0e=0; bp24->pb0[bp0e] != 0; ) {
					//^0AAF:0782
					bp0a = _3929_04e2(bp24->pb0, bp64, &bp0e, bp24->w4);
					//^0AAF:07A5
					DRAW_VP_STR((_4976_00f6 -bp0a) >> 1, di, bp28[bp16], bp64);
					//^0AAF:07C9
					di += _4976_013a + _4976_0134;
					//^0AAF:07D2
					if (bp24->pb0[bp0e] == vbLf) {
						//^0AAF:07E1
						bp0e++;
					}
					//^0AAF:07E4
				}
			}
			//^0AAF:07F3
		}
	}
	//^0AAF:0803
	_0aaf_002f();
	FIRE_FADE_SCREEN(0);
	//^0AAF:080E
	_4976_022c = 1;
	//^0AAF:0814
	return xx;
}

//^3E74:2614
void SkWinCore::GRAPHICS_DATA_CLOSE()
{
	//^3E74:2614
	if ((_4976_5d10--) == 0) {
		//^3E74:261D
		FILE_CLOSE(glbFileHandleGraphics1);
		//^3E74:2627
		if (_4976_5c9c != 0 && _4976_5ca8 == 0) {
			//^3E74:2635
			FILE_CLOSE(glbFileHandleGraphics2);
		}
	}
	//^3E74:263F
	return;
}

//^3A15:3511
void SkWinCore::PROCESS_ACTUATOR_TICK_GENERATOR() //#DS=4976?
{
	//^3A15:3511
	for (Bit16u di=0; dunHeader->nMaps > di; di++) {
		//^3A15:351C
		Bit16u bp14 = dunMapsHeaders[di].RawColumn();
		//^3A15:3534
		Bit16u bp16 = dunMapsHeaders[di].RawRow();
		//^3A15:354C
		Bit8u *bp04 = *glbMapTileValue[di];
		//^3A15:3567
		Bit16u *bp0c = &dunGroundStacks[dunMapTilesObjectIndexPerColumn[dunMapColumnsSumArray[di]]];
		//^3A15:3591
		for (Bit16u bp10=0; bp10 <= bp14; bp10++) {
			//^3A15:3599
			for (Bit16u bp12=0; bp12 <= bp16; bp12++) {
				//^3A15:35A1
				if ((*(bp04++) & 0x10) != 0) {
					//^3A15:35B0
					ObjectID bp0e = *bp0c;
					bp0c++;
					//^3A15:35BD
					while (bp0e.DBType() <= dbActuator) {
						//^3A15:35C0
						if (bp0e.DBType() == dbActuator) {
							//^3A15:35D1
							Actuator *bp08 = GET_ADDRESS_OF_RECORD(bp0e)->castToActuator();
							//^3A15:35E0
							Bit16u bp1c = bp08->ActuatorType();
							//^3A15:35ED
							switch (bp1c) {
								case ACTUATOR_TYPE_TICK_GENERATOR: // 0x001e -> 'Activator, tick generator'
								case ACTUATOR_TYPE_X33_V008: // 0x0033 -> ?
								case ACTUATOR_TYPE_X34_V016: // 0x0034 -> ?
								case ACTUATOR_TYPE_X35_V032: // 0x0035 -> ?
								case ACTUATOR_TYPE_X36_V064: // 0x0036 -> ?
								case ACTUATOR_TYPE_X37_V128: // 0x0037 -> ?
									{
										//^3A15:3606
										if (glbSpecialScreen != 0) {
											//^3A15:360D
											if (bp08->OnceOnlyActuator() != 0) {
												//^3A15:361E
												CHANGE_CURRENT_MAP_TO(di);
												//^3A15:3625
												ACTIVATE_TICK_GENERATOR(bp08, bp0e);
												//^3A15:3635
												break;
											}
											//^3A15:3638
											bp08->w4 &= 0xfffe;
											//^3A15:3640
											break;
										}
										//^3A15:3643
										Bit16u si;
										for (si=0; si < glbTimersMaximumCount; ) {
											//^3A15:3647
											Timer *bp1a = &glbTimersTable[si];
											si++;
											//^3A15:365F
											if (bp1a->TimerType() == ttyTickGenerator && bp1a->value == bp0e) {
												//^3A15:3672
												bp1a->SetMap(di);
												break;
											}
											//^3A15:36A1
										}
										//^3A15:36A7
										for (; si < glbTimersMaximumCount; si++) {
											//^3A15:36A9
											Timer *bp1a = &glbTimersTable[si];
											//^3A15:36C3
											if (bp1a->TimerType() == ttyTickGenerator) {
												//^3A15:36CA
												if (bp1a->value == bp0e) {
													//^3A15:36D3
													DELETE_TIMER(si);
												}
											}
											//^3A15:36D9
										}
										break;
									}
							}
						}
						//^3A15:36E0
						bp0e = GET_NEXT_RECORD_LINK(bp0e);
						//^3A15:36EC
					}
				}
				//^3A15:36FD
			}
			//^3A15:370B
		}
		//^3A15:3719
	}
	//^3A15:372B
	COMPACT_TIMERLIST();
	//^3A15:372F
	return;
}

//^0CD5:00D2
Bit16u SkWinCore::_RAND() //#DS=4976
{
	// CSBwinSimilarity: TAG001030,STRandom

	//^0CD5:00D2
	glbRandomSeed = glbRandomSeed * 0xbb40e62d + 11;
	//^0CD5:00F5
	return glbRandomSeed >> 8;
	//^0CD5:00FD
}

//^4937:00CC
// SPX: This function uses creature animation/sequence information related to command
// _4937_00cc renamed GET_CREATURE_ANIMATION_FRAME
Bit16u SkWinCore::GET_CREATURE_ANIMATION_FRAME(Bit8u ct, Bit16u command, Bit16u *pw08, Bit16u *pw0a, CreatureAnimationFrame **animframe, Bit16u vv)
{
	//^4937:00CC
	SkD((DLV_DBG_SED2, "DBG: GET_CREATURE_ANIMATION_FRAME %02X ccm:%04X %04X %04X %04X \n", (Bitu)ct, (Bitu)command, (Bitu)*pw08, (Bitu)*pw0a, (Bitu)vv));
	CreatureCommandAnimation *bp04 = &tlbCreaturesActionsGroupSets[tlbCreaturesActionsGroupOffsets[QUERY_GDAT_CREATURE_WORD_VALUE(ct, 0)]];
	//^4937:00FD
	while (bp04->ccmReference != 0xffff && bp04->ccmReference != command) {
		bp04++;
	}
	//^4937:0114
	Bit16u di = bp04->animSeqOffset;
	*pw08 = di;	// Is the base anim offset
	//^4937:0123
	if (QUERY_CREATURE_AI_SPEC_FROM_TYPE(ct)->IsStaticObject() != 0) {
		//^4937:0138
		Bit16u si = 0;
		CreatureAnimationFrame *bp08 = &tlbCreaturesAnimationSequences[di];
		//^4937:0151
		do {
			si++;
		} while((bp08++)->w2_0_3() != 0);
		//^4937:0161
		if (vv != 0) {
			//^4937:0167
			si |= 0x8000 | ((vv & 0x003f) << 6);
		}
		else {
			//^4937:0179
			si |= 0x9000;
		}
		//^4937:017D
		*pw0a = si;	// would be the number of frames within animation
		return 1;
	}
	//^4937:0188
	*pw0a = 0xffff;
	//^4937:0190
	return _4937_01a9(di, pw0a, animframe);
}

//^1C9A:09DB
void SkWinCore::_1c9a_09db(ObjectID recordLink)
{
	//^1C9A:09DB
	CreatureAnimationFrame bp0e;
	CreatureAnimationFrame *bp12 = &bp0e;
	//^1C9A:09E8
	Creature *bp04 = GET_ADDRESS_OF_RECORD(recordLink)->castToCreature();
	//^1C9A:09F7
	sk1c9a02c3 *bp08 = _1c9a_02c3(bp04, QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType()));
	//^1C9A:0A1A
	GET_CREATURE_ANIMATION_FRAME(
		bp04->CreatureType(),
		0x11,
		&bp08->w0,
		&bp08->w2,
		&bp12,
		bp04->w12
		);
}

//^2066:1FAB
void SkWinCore::ARRANGE_DUNGEON()
{
	//^2066:1FAB
	//^2066:1FB1
	for (Bit16u si=0; dunHeader->nMaps > si; si++) {
		//^2066:1FB6
		Bit16u bp2e = dunMapsHeaders[si].RawColumn();
		Bit16u bp30 = dunMapsHeaders[si].RawRow();
		//^2066:1FE6
		Bit8u *bp04 = *glbMapTileValue[si];
		//^2066:2001
		Bit16u *bp1c = &dunGroundStacks[dunMapTilesObjectIndexPerColumn[dunMapColumnsSumArray[si]]];
		//^2066:202B
		for (Bit16u bp2a=0; bp2a <= bp2e; bp2a++) {
			//^2066:2033
			for (Bit16u bp2c=0; bp2c <= bp30; bp2c++) {
				//^2066:203B
				Bit8u bp35 = *(bp04++);
				//^2066:2047
				if ((bp35 & 0x10) != 0) {
					//^2066:204E
					ObjectID di = *bp1c;
					bp1c++;
					//^2066:2058
					do {
						switch (di.DBType()) {
							case dbTeleporter:
								{
									//^2066:22D0
									Teleporter *bp0c = (Teleporter *)GET_ADDRESS_OF_RECORD(di);
									//^2066:22DD
									CHANGE_CURRENT_MAP_TO(bp0c->DestinationMap());
									//^2066:22EE
									ObjectID bp26 = GET_TILE_RECORD_LINK(bp0c->DestinationX(), bp0c->DestinationY());
									//^2066:230E
									if (bp26 == OBJECT_END_MARKER)
										break;
									//^2066:2316
									if (bp26.DBType() != dbTeleporter)
										break;
									//^2066:2327
									Teleporter *bp10 = GET_ADDRESS_OF_RECORD1(bp26);
									//^2066:2336
									if (bp10->DestinationX() != bp2a)
										break;
									//^2066:2348
									if (bp10->DestinationY() != bp2c)
										break;
									//^2066:2357
									if (bp10->DestinationMap() != si)
										break;
									//^2066:2362
									Bit16u bp3c = 0;
									//^2066:2367
									Bit16u bp32 = _2066_1f37(bp26, bp0c->DestinationMap(), &bp3c);
									//^2066:2384
									bp32 |= _2066_1f37(di, si, &bp3c);
									//^2066:2395
									if (bp3c == 2) {
										//^2066:239B
										bp10->w0 = bp0c->w0 = _2066_1ec9(GET_NEXT_RECORD_LINK(di), GET_NEXT_RECORD_LINK(bp26));
										break;
									}
									//^2066:23C1
									if (bp3c == 0 && bp32 != 0)
										goto _23de;
									break;
								}
							case dbText:
								{
									//^2066:2071
									Text *bp20 = GET_ADDRESS_OF_RECORD(di)->castToText();
									//^2066:207E
									if (bp20->TextMode() != 1)
										break;
									//^2066:2092
									switch (bp20->SimpleTextExtUsage()) {
										case 0x06: // Ladder enabled
										case 0x07: // Ladder disabled
											{
												//^2066:20B4
												Bit16u bp34 = di.Dir();
												//^2066:20BC
												SET_TILE_ATTRIBUTE_02(bp2a + glbXAxisDelta[bp34], bp2c + glbYAxisDelta[bp34], si);
												break;
											}
										case 0x08: // Recharge
											{
												//^2066:20E1
												bp20->TextVisibility(1);
												break;
											}
									}
									break;
								}
							case dbActuator:
								{
									//^2066:20EB
									Actuator *bp08 = GET_ADDRESS_OF_RECORD(di)->castToActuator();
									//^2066:20F8
									Bit16u bp3e = bp08->ActuatorType();
									//^2066:2105
									switch (bp3e) {
										case ACTUATOR_TYPE_SIMPLE_LADDER: // 0x1C unused in retail ver.
										case ACTUATOR_TYPE_SHOP_PANEL: // 0x3F Shop panel
											//^2066:213E
											bp08->ActiveStatus(0);
											bp08->OnceOnlyActuator(1);
											break;
										case ACTUATOR_FLOOR_TYPE__CROSS_SCENE: // 0x27 Cross scene
										case ACTUATOR_FLOOR_TYPE__INFINITE_ORNATE_ANIMATOR: // 0x2C Continuous ornate animator
											//^2066:211E
											if (bp08->OnceOnlyActuator() != 1)
												break;
											//^2066:2133
											bp08->ActiveStatus(1);
											break;
										case ACTUATOR_TYPE_PUSH_BUTTON_WALL_SWITCH: // 0x46 Activator, seal-able push button wall switch
											//^2066:214E
											CHANGE_CURRENT_MAP_TO(si);
											//^2066:2155
											if ((GET_TILE_VALUE(bp08->Xcoord(), bp08->Ycoord()) >> 5) != ttDoor)
												break;
											//^2066:2181
											//^2066:2192
											GET_ADDRESS_OF_TILE_RECORD(bp08->Xcoord(), bp08->Ycoord())->castToDoor()->Bit13B(bp08->OnceOnlyActuator() & 1);
											break;
									}
									break;
								}
							case dbCreature:
								{
									//^2066:21C3
									Creature *bp14 = GET_ADDRESS_OF_RECORD(di)->castToCreature();
									//^2066:21D0
									AIDefinition *bp18 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp14->CreatureType());
									//^2066:21E4
									bp14->HP1(bp18->BaseHP);
									//^2066:21F2
									if (bp18->IsStaticObject() == 0) {
										//^2066:21FC
										bp14->HP3(0);
										//^2066:2205
										bp14->SetTriggerXPos(bp2a);
										//^2066:2214
										bp14->SetTriggerYPos(bp2c);
										//^2066:2227
										bp14->SetTriggerMap(si);
										break;
									}
									//^2066:223B
									bp14->w8 = bp14->w10 = 0;
									//^2066:2248
									_1c9a_09db(di);
									//^2066:224F
									if (bp14->b14_7_7() != 0)
										break;
									//^2066:2263
									Bit16u bp28 = bp14->possession;
									//^2066:226A
									if (bp28 == 0xfffe)
										break;
									//^2066:2272
									bp14->possession = (bp28 & 0x3fff) | (RAND02() << 14);
									//^2066:228A
									while (bp28 != 0xfffe) {
										//^2066:228C
										GenericRecord *bp24 = GET_ADDRESS_OF_RECORD(bp28);
										//^2066:229B
										if (bp24->w0 != 0xfffe) {
											//^2066:22A4
											bp24->w0.Dir(RAND02());
										}
										//^2066:22BB
										bp28 = GET_NEXT_RECORD_LINK(bp28);
										//^2066:22C7
									}
									break;
								}
						}
						//^2066:23CD
						di = GET_NEXT_RECORD_LINK(di);
					} while(di != OBJECT_END_MARKER);
				}
				//^2066:23DE
_23de:
				if ((bp35 >> 5) == ttPit) {
					//^2066:23EA
					// SPX: The item 0x6A is 1 only for VOID. It does not exist for other tilesets.
					// Beware! if this is not set to a map expecting it, it will crash the map loading!
					if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, dunMapsHeaders[si].MapGraphicsStyle(), dtWordValue, GDAT_GFXSET_VOID_RANDOM_FALL) == 0) {	// 0x6A
						//^2066:2412
						i16 xx = bp2a; //__int16 bp38 = bp2a;
						i16 yy = bp2c; //__int16 bp3a = bp2c;
						Bit16u map = LOCATE_OTHER_LEVEL(si, 1, &xx, &yy, NULL); // bp34 = ...
						//SPX: locate_other_level can return -1 (65535) and it will crash the next function
						if (SkCodeParam::bUseFixedMode && map != 65535) // Use fixed mode to prevent crash
							//^2066:243A
							//SET_TILE_ATTRIBUTE_02(bp38, bp3a, bp34);
							SET_TILE_ATTRIBUTE_02(xx, yy, map);
					}
				}
				//^2066:244A
			}
			//^2066:2458
		}
		//^2066:2466
	}
}

//^476D:007A
i16 SkWinCore::FILE_OPEN(const U8 *filename) {
	return fset.fileOpen(reinterpret_cast<const char *>(filename));
}

//^476D:00D2
U16 SkWinCore::FILE_READ(Bit16u handle, Bit32u buffSize, void *buff) {
	return fset.fileRead(handle, buffSize, buff);
}

//^476D:00A5
void SkWinCore::FILE_CLOSE(Bit16u handle) {
	fset.fileClose(handle);
}

//^476D:00BF
void SkWinCore::FILE_RENAME(const U8 *curf, const U8 *newf)
{
	fset.fileMove(reinterpret_cast<const char *>(curf), reinterpret_cast<const char *>(newf));
}

//^00EB:02EB
void SkWinCore::IBMIO_BLIT_TO_SCREEN_xTO8BPP(
	const void *src,
	SRECT *rc,
	__int16 srcx,
	__int16 srcy,
	__int16 srcPitch,
	__int16 colorkey,
	const void *localPal,
	__int16 srcBpp
	)
{
#if UseAltic
	SkD((DLV_GUI, "GUI: xToScr (%p,(%3d,%3d,%3d,%3d),%3d,%3d,%3d,%2d,%p,%d)\n"
		, src
		, (Bitu)rc->x, (Bitu)rc->y, (Bitu)rc->cx, (Bitu)rc->cy
		, (Bitu)srcx, (Bitu)srcy, (Bitu)srcPitch, (Bitu)colorkey, localPal, (Bitu)srcBpp));

	Pic8 dp;
	dp.buff = (U8 *)vram; dp.ox = rc->x; dp.oy = rc->y; dp.pitch = 320; dp.cy = 200; dp.dx = 1; dp.dy = 1;

	if (srcBpp == 8) {
		Pic8 sp;
		sp.buff = (U8 *)src; sp.ox = srcx; sp.oy = srcy; sp.pitch = srcPitch; sp.cy = 0; sp.dx = 1; sp.dy = 1;
		BlitSvc(sp, dp, rc->cx, rc->cy, colorkey);
	}
	else {
		Pic4 sp;
		sp.buff = (U8 *)src; sp.ox = srcx; sp.oy = srcy; sp.cx = srcPitch; sp.pitch = (srcPitch +1) / 2; sp.cy = 0; sp.dx = 1; sp.dy = 1; sp.pal = (U8 *)localPal;
		BlitSvc(sp, dp, rc->cx, rc->cy, colorkey);
	}

	skwin.UpdateRect(rc->x, rc->y, rc->cx, rc->cy);
	MessageLoop(false);
#else
	Unr();
#endif
}
//^44C8:05AE
void SkWinCore::FIRE_BLIT_TO_MEMORY_4TO4BPP(
	const void *src,
	void *dst,
	SRECT *rc,
	__int16 srcx,
	__int16 srcy,
	__int16 srcPitch,
	__int16 dstPitch,
	__int16 colorkey,
	__int16 mirrorFlip
	)
{
#if UseAltic
	SkD((DLV_GUI, "GUI: 4To4 (%p,%p,(%3d,%3d,%3d,%3d),%3d,%3d,%3d,%3d,%2d,%d)\n"
		, src, dst
		, (Bitu)rc->x, (Bitu)rc->y, (Bitu)rc->cx, (Bitu)rc->cy, (Bitu)srcx, (Bitu)srcy
		, (Bitu)srcPitch, (Bitu)dstPitch, (Bitu)colorkey, (Bitu)mirrorFlip));

	static const U8 thru[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};

	Pic4 sp;
	sp.buff = (U8 *)src; sp.ox = srcx; sp.oy = srcy; sp.cx = srcPitch; sp.pitch = (srcPitch +1) / 2; sp.cy = 0; sp.dx = 1; sp.dy = 1; sp.pal = thru;
	sp.Apply(mirrorFlip & 1, mirrorFlip & 2);
	Pic4 dp;
	dp.buff = (U8 *)dst; dp.ox = rc->x; dp.oy = rc->y; dp.pitch = (dstPitch +1) / 2; dp.cy = 0; dp.dx = 1; dp.dy = 1; dp.pal = thru;
	BlitSvc(sp, dp, rc->cx, rc->cy, colorkey);
#else
	Unr();
#endif
}

//^44C8:09D7
void SkWinCore::FIRE_BLIT_TO_MEMORY_4TO8BPP(
	const void *src,
	void *dst,
	SRECT *rc,
	__int16 srcx,
	__int16 srcy,
	__int16 srcPitch,
	__int16 dstPitch,
	__int16 colorkey,
	__int16 mirrorFlip,
	const U8 *localPal
	)
{
#if UseAltic
	SkD((DLV_GUI, "GUI: 4To8 (%p,%p,(%3d,%3d,%3d,%3d),%3d,%3d,%3d,%3d,%2d,%d,%p)\n"
		, src, dst
		, (Bitu)rc->x, (Bitu)rc->y, (Bitu)rc->cx, (Bitu)rc->cy, (Bitu)srcx, (Bitu)srcy
		, (Bitu)srcPitch, (Bitu)dstPitch, (Bitu)colorkey, (Bitu)mirrorFlip, localPal));

	ATLASSERT(localPal != NULL);
	FIRE_UPDATE_BLIT_PALETTE(localPal);

	Pic4 sp;
	sp.buff = (U8 *)src; sp.ox = srcx; sp.oy = srcy; sp.cx = rc->cx; sp.pitch = (srcPitch +1) / 2; sp.cy = rc->cy; sp.dx = 1; sp.dy = 1; sp.pal = (U8 *)localPal;
	sp.Apply(mirrorFlip&1, mirrorFlip&2);
	Pic8 dp;
	dp.buff = (U8 *)dst; dp.ox = rc->x; dp.oy = rc->y; dp.pitch = dstPitch; dp.cy = 0; dp.dx = 1; dp.dy = 1;
	BlitSvc(sp, dp, rc->cx, rc->cy, colorkey);
#else
	Unr();
#endif
}

//^44C8:0B8D
void SkWinCore::_44c8_0b8d(U16 src, U16 dst, U16 pitch)
{
	//^44C8:0B8D
	ENTER(0);
	//^44C8:0B92
	U8 *esdi = _4976_5e6a;
	esdi += dst;
	U16 cx = pitch;
	const U8 *dssi = _4976_5e64;
	dssi += src;
	//^44C8:0BA9
	if ((U8(dssi) & 1) != 0) {
		movsb(esdi, dssi);
		cx--;
	}
	//^44C8:0BB2
	U16 dx = cx;
	bool carry = (cx & 1) != 0;
	cx >>= 1;
	if (cx != 0)
		for (; cx != 0; cx--) movsw(esdi, dssi);
	dx &= 1;
	if (dx != 0)
		movsb(esdi, dssi);
	//^44C8:0BC1
	return;
}
void SkWinCore::_44c8_0bc5(U16 src, U16 dst, U16 pitch, U8 ck) { // TODO: Unr
	Unr();
}
void SkWinCore::_44c8_0bf8(U16 src, U16 dst, U16 pitch) { // TODO: Unr
	Unr();
}
void SkWinCore::_44c8_0c3c(U16 src, U16 dst, U16 pitch, U8 ck) { // TODO: Unr
	Unr();
}

//^44C8:0C74
void SkWinCore::FIRE_BLIT_TO_MEMORY_8TO8BPP(
	const void *src,
	void *dst,
	SRECT *rc,
	__int16 srcx,
	__int16 srcy,
	__int16 srcPitch,
	__int16 dstPitch,
	__int16 colorkey,
	__int16 mirrorFlip
	)
{
#if UseAltic
	SkD((DLV_GUI, "GUI: 8To8 (%p,%p,(%3d,%3d,%3d,%3d),%3d,%3d,%3d,%3d,%2d,%d)\n"
		, src, dst
		, (Bitu)rc->x, (Bitu)rc->y, (Bitu)rc->cx, (Bitu)rc->cy, (Bitu)srcx, (Bitu)srcy
		, (Bitu)srcPitch, (Bitu)dstPitch, (Bitu)colorkey, (Bitu)mirrorFlip));

	Pic8 sp;
	sp.buff = (U8 *)src; sp.ox = srcx; sp.oy = srcy; sp.pitch = srcPitch; sp.cy = 0; sp.dx = 1; sp.dy = 1;
	Pic8 dp;
	dp.buff = (U8 *)dst; dp.ox = rc->x; dp.oy = rc->y; dp.pitch = dstPitch; dp.cy = 0; dp.dx = 1; dp.dy = 1;
	BlitSvc(sp, dp, rc->cx, rc->cy, colorkey);
#else
	//^44C8:0C74
	ENTER(6);
	//^44C8:0C7A
	_4976_5e64 = reinterpret_cast<U8 *>(const_cast<void *>(src));
	_4976_5e6a = reinterpret_cast<U8 *>(dst);
	U16 bp04 = rc->cx;
	U16 bp02 = rc->cy;
	if (bp04 <= 0 && bp02 <= 0)
		return;
	//^44C8:0CB7
	U16 di = rc->y * dstPitch +rc->x;
	U16 si;
	U16 bp06;
	switch (mirrorFlip) {
		case 3://^_0cde
			//^44C8:0CDE
			//^44C8:0CE0
			si = srcy * srcPitch;
			for (bp06 = 0; bp06 < bp02; si += srcPitch, di += dstPitch, bp06++) {
				//^44C8:0CF2
				if (colorkey < 0) {
					//^44C8:0CF8
					_44c8_0b8d(si, di, bp04);
				}
				else {
					//^44C8:0D06
					_44c8_0bc5(si, di, bp04, U8(colorkey));
				}
				//^44C8:0D16
			}
			//^44C8:0D27
			break;
		case 2://^_0d2a
			//^44C8:0D2A
			si = (srcy +bp02 -1) * srcPitch +srcx;
			for (bp06 = 0; bp06 < bp02; si -= srcPitch, di += dstPitch, bp06++) {
				//^44C8:0D42
				if (colorkey < 0) {
					//^44C8:0D48
					_44c8_0b8d(si, di, bp04);
				}
				else {
					//^44C8:0D56
					_44c8_0bc5(si, di, bp04, U8(colorkey));
				}
				//^44C8:0D66
			}
			//^44C8:0D77
			break;
		case 1://^_0d7a
			//^44C8:0D7A
			si = srcy * srcPitch +srcx;
			for (bp06 = 0; bp06 < bp02; si += srcPitch, di += dstPitch, bp06++) {
				//^44C8:0D8C
				if (colorkey < 0) {
					//^44C8:0D92
					_44c8_0bf8(si, di, bp04);
				}
				else {
					//^44C8:0DA0
					_44c8_0c3c(si, di, bp04, U8(colorkey));
				}
				//^44C8:0DB0
			}
			//^44C8:0DC1
			break;
		default: //^_0dc3
			//^44C8:0DC3
			si = (srcy +bp02 -1) * srcPitch +srcx;
			for (bp06 = 0; bp06 < bp02; si -= srcPitch, di += dstPitch, bp06++) {
				//^44C8:0DDB
				if (colorkey < 0) {
					//^44C8:0DE1
					_44c8_0bf8(si, di, bp04);
				}
				else {
					//^44C8:0DEF
					_44c8_0c3c(si, di, bp04, U8(colorkey));
				}
				//^44C8:0DFF
			}
			break;
	}
	//^44C8:0E10
	return;
#endif
}

//^44C8:0F29
void SkWinCore::_44c8_0f29(	// TODO: Unr
	const void *src,
	void *dst,
	SRECT *rc,
	__int16 srcx,
	__int16 srcy,
	__int16 srcPitch,
	__int16 dstPitch,
	__int16 colorkey,
	__int16 mirrorFlip,
	const void *localPal
	)
{
#if UseAltic
	SkD((DLV_GUI, "GUI: 8To8wPal (%p,%p,(%3d,%3d,%3d,%3d),%3d,%3d,%3d,%3d,%2d,%d)\n"
		, src, dst
		, (Bitu)rc->x, (Bitu)rc->y, (Bitu)rc->cx, (Bitu)rc->cy, (Bitu)srcx, (Bitu)srcy
		, (Bitu)srcPitch, (Bitu)dstPitch, (Bitu)colorkey, (Bitu)mirrorFlip));

	Pic8wPal sp;
	sp.buff = (U8 *)src; sp.ox = srcx; sp.oy = srcy; sp.cx = srcPitch; sp.cy = 0; sp.dx = 1; sp.dy = 1; sp.pal = reinterpret_cast<const U8 *>(localPal); sp.cx2 = rc->cx; sp.cy2 = rc->cy;
	sp.Apply(mirrorFlip & 1, mirrorFlip & 2);
	Pic8 dp;
	dp.buff = (U8 *)dst; dp.ox = rc->x; dp.oy = rc->y; dp.pitch = dstPitch; dp.cy = 0; dp.dx = 1; dp.dy = 1;
	BlitSvc(sp, dp, rc->cx, rc->cy, colorkey);
#else
	Unr();
#endif
}

//^44C8:1101
void SkWinCore::FIRE_BLIT_PICTURE(
	const void *src,
	void *dst,
	SRECT *rc,
	U16 srcx,
	U16 srcy,
	U16 srcPitch,
	U16 dstPitch,
	__int16 colorkey,
	U16 mirrorFlip,
	U16 srcBpp,
	U16 dstBpp,
	const U8 *localPal
	)
{
	SkD((DLV_GUI, "GUI: xTox (%p,%p,(%3d,%3d,%3d,%3d),%3d,%3d,%3d,%3d,%2d,%d,%d,%d,%p)\n", src, dst
		, (Bitu)rc->x, (Bitu)rc->y, (Bitu)rc->cx, (Bitu)rc->cy, (Bitu)srcx, (Bitu)srcy
		, (Bitu)srcPitch, (Bitu)dstPitch, (Bitu)colorkey, (Bitu)mirrorFlip, (Bitu)srcBpp, (Bitu)dstBpp, localPal));
#if UseAltic
	ATLASSERT((srcBpp == 4 || srcBpp == 8) && (dstBpp == 4 || dstBpp == 8));
	ATLASSERT(colorkey == -1 || (0 <= colorkey && colorkey <= 255));
	U16 dstibpp = 8, dsticx = 320, dsticy = 200;
	if (dst != NULL) {
		dstibpp = READ_I16(dst,-6);
		dsticx = READ_I16(dst,-4);
		dsticy = READ_I16(dst,-2);
	}
	ATLASSERT(dstBpp == dstibpp);
	ATLASSERT((dstBpp == 4) ? RUp2(dstPitch) == RUp2(dsticx) : true);
	ATLASSERT((dstBpp == 8) ? (dstPitch == dsticx) : true);
	ATLASSERT(rc->x >= 0);
	ATLASSERT(rc->y >= 0);
	ATLASSERT(rc->cx >= 0);
	ATLASSERT(rc->cy >= 0);
	ATLASSERT((0 +rc->x +RUp2(dsticx) * (rc->y +rc->cy -1) +rc->cx) <= (RUp2(dsticx) * dsticy));

#endif

	//^44C8:1101
	ENTER(0);
	//^44C8:1106
	Bit16u di = srcPitch;
	Bit16u si = colorkey;
	//^44C8:110C
	if (dst == NULL) {
		//^44C8:1114
		IBMIO_BLIT_TO_SCREEN_xTO8BPP(src, rc, srcx, srcy, di, si, localPal, srcBpp) CALL_IBMIO;
		//^44C8:113C
	}
	else {
		//^44C8:113F
		if (srcBpp == 4) {
			//^44C8:1145
			if (dstBpp == 4) {
				//^44C8:114B
				FIRE_BLIT_TO_MEMORY_4TO4BPP(src, dst, rc, srcx, srcy, srcPitch, dstPitch, colorkey, mirrorFlip);
			}
			else {
				//^44C8:1171
				FIRE_BLIT_TO_MEMORY_4TO8BPP(src, dst, rc, srcx, srcy, srcPitch, dstPitch, colorkey, mirrorFlip, localPal);
			}
		}
		else {
			//^44C8:11A0
			if (localPal == NULL) {
				//^44C8:11A8
				FIRE_BLIT_TO_MEMORY_8TO8BPP(src, dst, rc, srcx, srcy, srcPitch, dstPitch, colorkey, mirrorFlip);
			}
			else {
				//^44C8:11D1
				_44c8_0f29(src, dst, rc, srcx, srcy, di, dstPitch, si, mirrorFlip, localPal);
			}
		}
	}
	//^44C8:11FE
	return;
}

//^00EB:0254
void SkWinCore::IBMIO_BLIT_TO_SCREEN_8TO8BPP(
	void *src,
	void *dst,
	SRECT *prc,
	__int16 srcx,
	__int16 srcy,
	__int16 srcpitch,
	__int16 dstpitch,
	__int16 colorkey
	) //#DS=04BF
{
	ATLASSERT(srcx >= 0 && srcy >= 0 && srcpitch >= 0 && dstpitch >= 0 && srcpitch <= 320 && dstpitch <= 320);
	ATLASSERT(prc->x >= 0 && prc->y >= 0 && prc->cx < 320 && prc->cy < 200);

	//^00EB:0254
	ENTER(6);
	//^00EB:025A
	_04bf_0cf0 = reinterpret_cast<U8 *>(src);
	_04bf_0e34 = reinterpret_cast<U8 *>(dst);
	X16 bp04 = prc->cx;
	X16 bp02 = prc->cy;
	if (bp04 <= 0 || bp02 <= 0)
		return;
	//^00EB:0291
	X16 di = prc->y *dstpitch +prc->x;
	X16 si = srcy *srcpitch +srcx;
	X16 bp06 = 0;
	for (; bp06 < bp02; si += srcpitch, di += dstpitch, bp06++) {
		//^00EB:02B2
		if (colorkey < 0) {
			//^00EB:02B8
			MOVE_MEMORY_WITH_DELTA(si, di, bp04);
		}
		else {
			//^00EB:02C6
			COPY_MEMORY_WITH_DELTA_AND_TRANSPARENT(si, di, bp04, U8(colorkey));
		}
		//^00EB:02D6
	}
	//^00EB:02E7

#if UseAltic
	if (dst == vram) {
		if (skwin.IsAvail() != NULL) skwin.UpdateRect(prc->x, prc->y, prc->cx, prc->cy);
		//MessageLoop();
	}
#endif
}

//^476D:030A
Bit16u SkWinCore::_476d_030a(Bit16u xx) { // TODO: Unr
	Unr(); return 0;
}

//^2C1D:0250
__int16 SkWinCore::GET_PLAYER_AT_POSITION(Bit16u position)
{
	//^2C1D:0250
	Champion *bp04 = glbChampionSquad;
	//^2C1D:025D
	for (Bit16u si=0; si<glbChampionsCount; si++, bp04++) {
		//^2C1D:0261
		if (bp04->playerPos() == position && bp04->curHP() != 0) {
			//^2C1D:0276
			return si;
		}
		//^2C1D:027A
	}
	//^2C1D:0286
	return -1;
}

//^4726:0107
void SkWinCore::EMS_MAP_BANK_TO_MEMORY() { // TODO: Unr
#if UseAltic
	;
#else
	Unr();
#endif
}

//^4726:0107
Bit8u *SkWinCore::EMS_MAP_BANK_TO_MEMORY(shelf_memory info, Bit16u physPage0to3) { // TODO: Unr
#if UseAltic
	return REALIZE_GRAPHICS_DATA_MEMORY(info);
#else
	return Unr(), NULL;
#endif
}

//^3E74:0683
Bit8u *SkWinCore::FIND_FREE_POOL(i32 size, Bit16u poolno)
{
	//^3E74:0683
	Bit16u si = poolno;
	//^3E74:068B
	EMS_MAP_BANK_TO_MEMORY();
	//^3E74:0699
	sk5d00 *bp04 = _4976_5d00;
	//^3E74:06A6
	Bit8u *bp08 = 0;
	i32 bp10 = 0x7fffffff;
	//^3E74:06BA
	while (bp04 != NULL) {
		//^3E74:06BC
		__int32 bp0c;
		if (true
			&& (bp04->w18 == 0)
			&& (bp04->w16 & si) == si 
			&& (bp04->w16 & 0x0800) == (si & 0x0800) 
			&& (bp0c = bp04->dw12 -size) >= 0
			&& (bp0c < bp10)
		) {
			//^3E74:0711
			bp10 = bp0c;
			bp08 = (Bit8u *)bp04;
		}
		//^3E74:0729
		bp04 = bp04->pv0;
		//^3E74:0739
	}
	//^3E74:074D
	return bp08;
}

U8 *SkWinCore::ALLOC_MEMORY_RAM(i32 size, Bit16u flags, Bit16u poolno) {
	ATLASSERT((poolno & 0x800) == 0);
	U8 *pb = t2ptr(ALLOC_MEMORY_(size, flags, poolno));
	SkD((DLV_MEM, "MEM: ALLOC_MEMORY_RAM(%10d,%04X,%04X) = %08X  (free:%7u)\n", (Bitu)size, (Bitu)flags, (Bitu)poolno, pb, (Bitu)glbFreeRAMMemPool));
	return pb;
}
shelf_memory SkWinCore::ALLOC_MEMORY_EMS(i32 size, Bit16u flags, Bit16u poolno) {
	ATLASSERT((poolno & 0x800) != 0);
	shelf_memory ps = t2s(ALLOC_MEMORY_(size, flags, poolno));
	SkD((DLV_MEM, "MEM: ALLOC_MEMORY_EMS(%10d,%04X,%04X) = %08X  (free:%7u)\n", (Bitu)size, (Bitu)flags, (Bitu)poolno, (Bitu)ps.val, (Bitu)glbFreeEMSMemPool));
	return ps;
}

//^3E74:088E
tiamat SkWinCore::ALLOC_MEMORY_(i32 size, Bit16u flags, Bit16u poolno)
{
	// if (flags & 0x7FFF)==1, try to allocate memory from upper free area (for temporary use?)
	// if (flags & 0x7FFF)==2, try to allocate memory from lower free area (for permanent use?)
	// if (flags & 0x8000)!=0, clear memory with 0

	// if (poolno & 0x0c00)==0x0c00, it forces engine to allocate ibmio free memory. if no avail, SYSTEM ERROR 39
	// if (poolno & 0x0800)!=0x0000, it forces engine to allocate external free memory. if no avail, SYSTEM ERROR 39

	// if out of memory, always SYSTEM ERROR 40

	//ATLASSERT(0x200000 <= U32(_4976_5d5a) && U32(_4976_5d5a) <= 0x200000 +sizeof(cems));
	ATLASSERT(cram <= _4976_5cf4 && _4976_5cf4 <= cram +sizeof(cram));
	ATLASSERT(0 <= glbFreeRAMMemPool);

	//^3E74:088E
	Bit16u si = flags;
	Bit16u di = poolno;
	Bit16u bp0a = si & 0x8000;
	tiamat bp04;
	si &= 0x7fff;
	//^3E74:08A6
	if ((size & 1) != 0)
		size++;
	//^3E74:08B9
	if (si == 1) {
		//^3E74:08BE
		Bit8u *bp08 = FIND_FREE_POOL(size, di);
		//^3E74:08D2
		if (bp08 != NULL) {
			//^3E74:08DD
			bp04 = _3e74_0756(bp08, size);

			//^3E74:09F7
			goto _09f7;
		}
	}
	//^3E74:08F9
	if (si == 1) { // alloc upper mem
		//^3E74:0901
		if ((di & _4976_5d6e) == di) {
			//^3E74:090B
			if (size <= glbFreeEMSMemPool) {
				//^3E74:091F
				if ((_4976_5d6e & 0x0800) == (di & 0x0800)) {
					//^3E74:092F
					glbFreeEMSMemPool -= size;
					//^3E74:093D
					if ((_4976_5d6e & 0x0800) != 0) {
						//^3E74:0945
						_4976_5d5a -= size;
						bp04 = _4976_5d5a;
						//^3E74:09F7
						goto _09f7;
					}
					else {
						//^3E74:0962
						_4976_5d5a -= size;
						//^3E74:0972
						bp04 = _4976_5d5a;
						//^3E74:09F7
						goto _09f7;
					}
				}
			}
		}
	}

	/*
	if (SkCodeParam::bUseIngameDebug && glbTickSpeed > 0)
	{
		U8 message[32];
		sprintf((char*)message, "FREE MEM = %06d , ALLOC SIZE = %05d \n", glbFreeRAMMemPool, size);
		DISPLAY_HINT_TEXT(COLOR_YELLOW, message);
	}
	*/


	//^3E74:0981
	if ((di & 0x0800) != 0) { // syserr39 if run out of EMS memory!
		//^3E74:0987
		RAISE_SYSERR(SYSTEM_ERROR__OUT_OF_EMS_MEM);
	}
	//^3E74:098F
	if (size > glbFreeRAMMemPool) { // syserr40 if run out of main memory!
		//^3E74:09A3
		RAISE_SYSERR(SYSTEM_ERROR__OUT_OF_MAIN_MEM);
	}
	//^3E74:09AB
	if (si == 2) { // from lower pool
		//^3E74:09B0
		bp04 = ptr2t(_4976_5cf4 - glbFreeRAMMemPool);

#if defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
		vecLowerAlloc.push(size);
#endif // defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
	}
	else { // from upper pool
		//^3E74:09CC
		_4976_5cf4 -= size;
		bp04 = ptr2t(_4976_5cf4);

#if defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
		vecUpperAlloc.push(size);
#endif // defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
	}
	//^3E74:09E9
	glbFreeRAMMemPool -= size;
	//^3E74:09F7
_09f7:
#if UseAltic
	if ((poolno & 0x800) == 0) {
		memset(t2ptr(bp04), 0xcc, size); // for DEBUG purpose
	}
#endif
	if (bp0a != 0) {
		ATLASSERT((poolno & 0x800) == 0); // clear cannot be ran if you request shelf_memory address!
		ZERO_MEMORY(t2ptr(bp04), size);
	}
	return bp04;
}

//^3E74:0B96
Bit8u *SkWinCore::ALLOC_PICT_BUFF(Bit16u srccx, Bit16u srccy, Bit16u flags, Bit16u bpp)
{
	//^3E74:0B96
	Bit16u si = srccx;
	//^3E74:SkWinCore::0B9E
	Bit8u *bp04 = ALLOC_MEMORY_RAM((((bpp == 4) ? (((si +1) & 0xfffe) >> 1) : (si & 0xffff)) * srccy) +6, flags, 8) +6;
	//^3E74:0BD2
	bp04 = bp04;
	//^3E74:0BE1
	WRITE_UI16(bp04,-6,bpp);	// bpp
	//^3E74:0BFF
	WRITE_UI16(bp04,-4,si);		// image width
	//^3E74:0C06
	WRITE_UI16(bp04,-2,srccy);	// image height
	//^3E74:0C0D
	return bp04;
}

//^47E1:0008
void SkWinCore::COPY_MEMORY(const void *buffSrc, void *buffDst, Bit32u buffSize) {
	memcpy(buffDst, buffSrc, buffSize);
}

//^3E74:189B
//U16 SkWinCore::QUERY_GDAT_ENTRY_DATA_INDEX(U8 cls1, U16 cls2, U8 cls3, U16 cls4)
U16 SkWinCore::QUERY_GDAT_ENTRY_DATA_INDEX(U8 iCategory, U16 iItem, U8 iType, U16 iEntry)
{
//LOGX(("%40s: C%02d=I%02X=E%02X=T%03d to %08X", "QUERY_GDAT_ENTRY_DATA_INDEX from ", iCategory, iItem, iEntry, iType ));
	//^3E74:189B
	RawEntry *bp04 = QUERY_GDAT_ENTRYPTR(iCategory, iItem, iType, iEntry);
	if (bp04 == NULL) {
		//^3E74:18C4
		switch (iType) {
			case fmtWordVal: //0x0B:
			case fmtPicOff://0x0C:	// word
				//^3E74:18D5
				return 0;
		}
		//^3E74:18D0
		return -1;
	}
	else {
		//^3E74:18D9
		switch (iType) {
			case fmtWordVal://0x0B:
			case fmtPicOff://0x0C:
                //^3E74:18F1
				return bp04->data;
		}
		//^3E74:18E5
		return bp04->data & 0x7FFF;
	}
}

//^3E74:01A5
Bit8u *SkWinCore::REALIZE_GRAPHICS_DATA_MEMORY(shelf_memory info) {
	//U32 iMemVal = info.val & 0x00FFFFFF;	// SPX: replaced info.val by this iMemVal with mask. ==> NOTE This does not work. Need to understand more this
	U32 iMemVal = info.val;
	// Original code would just take full value, which can be 0x80****** and break the limit.
	// the 0x80 part must be some flag info then not to be taken for memory check.
	// Note: it happens when loading original BETA GDAT.

#if UseAltic
	if (iMemVal >= 0x200000 +sizeof(cems)) {
		ATLASSERT(false);
		return NULL;
	}
	if (iMemVal >= 0x00200000) {
		return &cems[iMemVal -0x00200000];
	}
	else if (iMemVal >= sizeof(cram)) {
		ATLASSERT(false);
		return NULL;
	}
	else {
		return &cram[iMemVal];
	}
#else
	ATLASSERT(false);
	return Unr(), NULL;
#endif
}

//^3E74:0422
Bit16u SkWinCore::QUERY_GDAT_RAW_DATA_LENGTH(Bit16u index)
{
	//^3E74:0422
	ENTER(4);
	//^3E74:0426
    //shelf_memory bp04 = glbShelfMemoryTable[index];
	// SPX : rewritten block; I encountered the case where index is > to glbGDatNumberOfData
	// which is not correct ... => added assert.
	shelf_memory bp04;
	if (index > glbGDatNumberOfData && SkCodeParam::bUsePowerDebug)
	{
	//	ATLASSERT(index < glbGDatNumberOfData);
		return 0;
	}
	
	bp04 = glbShelfMemoryTable[index];
	//--- SPX END

	if (bp04.Present()) {
		//^3E74:044A
		return READ_UI16(REALIZE_GRAPHICS_DATA_MEMORY(bp04),-2);
	}
	//^3E74:046A
	return bp04.SizeIfAbsent();
}

//^3E74:1586
Bit16u SkWinCore::IS_CLS1_CRITICAL_FOR_LOAD(Bit8u cls1)
{
	//^3E74:1586
	switch (cls1) {
		case 0x1B: // ?
		case GDAT_CATEGORY_CREDITS: // 0x06: // Credits
		case GDAT_CATEGORY_JAPANESE_FONT: // 0x1C: // Kanji table
		case GDAT_CATEGORY_TITLE: // 0x05: // Main Menu and Credits
			//^3E74:15A0
			return 1;
	}
	//^3E74:15A5
	return 0;
}

//^3E74:0472
i32 SkWinCore::QUERY_GDAT_RAW_DATA_FILE_POS(Bit16u index)
{
	//^3E74:0472
	Bit16u di = index;
	Bit32u bp04 = _4976_5d6a;
	Bit16u si = 0;
	//^3E74:048A
	if (di >= _4976_4839) {
		//^3E74:0490
		si = _4976_4839;
		bp04 += _4976_483b;
	}
	//^3E74:04A1
	while (si < di) {
		//^3E74:04A3
		bp04 += QUERY_GDAT_RAW_DATA_LENGTH(si);
		si++;
		//^3E74:04B1
	}
	//^3E74:04B5
	_4976_4839 = di;
	//^3E74:04B9
	_4976_483b = bp04 - _4976_5d6a;
	//^3E74:04CE
	return bp04;
}

//^476D:0005
U16 SkWinCore::FILE_SEEK(Bit16u handle, Bit32u pos) {
	if (fset.fileSeekTo(handle, pos) == pos)
		return 1;
	return 0;
}

U32 SkWinCore::FILE_TELL(Bit16u handle) {
	return fset.fileTell(handle);
}

//^476D:05E3
void SkWinCore::_476d_05e3(U8 *str) { // TODO: Unr
	Unr();
}

//^0CCD:000A
void __declspec(noreturn) SkWinCore::RAISE_SYSERR(Bit16u syserr)
{
	// 30 = invalid header in graphics.dat
	// 31 = no graphic2.dat
	// 32 = corrupted graphic2.dat
	// 41 = no graphics.dat
	// 45 = too many timer entries, you can add no more!
	// 46 = corrupted graphics.dat
	// 50 = no dungeon dat
	// 70 = invalid status on game timer
	// 71 = creature assoc record is full, you cannot add one

	// kkdf2: 1001 = no player startup data in graphics.dat

	// SYSTEM ERROR .Z000.
	static const Bit8u * const strSystemError = (const Bit8u *) 
		"\x53\x59\x53\x54\x45\x4D\x20\x45\x52\x52\x4F\x52\x20\x2E\x5A\x30\x30\x30\x00";
	// SYSTEM ERROR .Z000.
	static const Bit8u * const strSystemErrorF = (const Bit8u *) 
		"\x53\x59\x53\x54\x45\x4D\x20\x45\x52\x52\x4F\x52\x20\x2E\x5A\x30\x30\x30\x00";
	// SYSTEM ERROR .Z000.
	static const Bit8u * const strSystemErrorG = (const Bit8u *) 
		"\x53\x59\x53\x54\x45\x4D\x20\x45\x52\x52\x4F\x52\x20\x2E\x5A\x30\x30\x30\x00";
	
	// 4976:01E6  F2 01 76 49 05 02 76 49 18 02 76 49

	// SPX : _4976_01e6	renamed strSystemErrorTable
	static const Bit8u *strSystemErrorTable[] = {
		strSystemError,
		strSystemErrorF,
		strSystemErrorG,
	};

	//^0CCD:000A
	_4976_4be6 = syserr;
	//^0CCD:0014
	if (_4976_474c != 0) {
		//^0CCD:001B
		FIRE_SELECT_PALETTE_SET(1);
	}
	//^0CCD:0023
	Bit8u bp80[128];
	ATLASSERT(glbLangageLetterIndex < 3U);
	FORMAT_SKSTR(strSystemErrorTable[glbLangageLetterIndex], bp80);


#if UseAltic
	skwin.ShowMessage(reinterpret_cast<const char *>(bp80));
	_exit(1);
#else
	//^0CCD:003F
	if (_4976_4750 != 0) {
		//^0CCD:0046
		if (_4976_4ba4 != 0) {
			//^0CCD:004D
			PRINT_SYSERR_TEXT(0, 16, 15, 0, bp80);
		}
		else {
			//^0CCD:0064
			_476d_05e3(bp80);
		}
		//^0CCD:0070
		if (_4976_474a != 0) {
			//^0CCD:0077
			_476d_050e();
		}
		else {
			//^0CCD:007E
			SLEEP_SEVERAL_TIME(0x012c);
		}
		//^0CCD:0087
		SK_PREPARE_EXIT();
	}
#endif
}

//^3E74:0EA2
void SkWinCore::GRAPHICS_DATA_READ(Bit32u location, Bit32u size, Bit8u *buff)
{
	//^3E74:0EA2
	Bit16u bp14[2] = {glbFileHandleGraphics1};
	Bit32u bp08[2] = {location, 0};
	__int32 bp10[2] = {size, 0};
	//^3E74:0ECF
	if (_4976_5c9c != 0) {
		//^3E74:0ED6
		bp14[1] = glbFileHandleGraphics2;
		bp08[1] = location - _4976_5cea;
		//^3E74:0EF0
		if (bp08[1] >= 0) {
			//^3E74:0EFA
			bp10[1] = size;
		}
		else {
			//^3E74:0F08
			bp10[1] = bp08[1] + size;
			//^3E74:0F1A
			if (bp10[1] > 0) {
				//^3E74:0F24
				bp08[1] = 0;
			}
			else {
				//^3E74:0F30
				bp10[1] = 0;
			}
		}
		//^3E74:0F3A
		bp10[0] -= bp10[1];
	}
	//^3E74:0F46
	// spx: si = part file of graphics.dat.
	for (Bit16u si=0; si < 2; si++) {
		//^3E74:0F4B
		if (bp10[si] != 0) {	// check size
			do {
				//^3E74:0F61
				if (FILE_SEEK(bp14[si], bp08[si]) != 0) {
					//^3E74:0F8A
					if (FILE_READ(bp14[si], bp10[si], buff) != 0)
						break;
				}
				//^3E74:0FB9
				GRAPHICS_DATA_CLOSE();
				//^3E74:0FBE
				RAISE_SYSERR((si == 0) ? SYSTEM_ERROR__CORRUPTED_GRAPHICS : SYSTEM_ERROR__CORRUPTED_GRAPHICS_2);
				//^3E74:0FD1
			} while (false);

			buff += bp10[si];
		}
		//^3E74:0FEC
	}
	//^3E74:0FF5
}

//^3E74:0FF8
void SkWinCore::LOAD_GDAT_RAW_DATA(Bit16u index, shelf_memory ps)
{
//LOGX((" + LOAD_GDAT_RAW_DATA loads GDAT item %04d to ptr %08x", index, &ps ));
	//^3E74:0FF8
	Bit16u di = index;
	GRAPHICS_DATA_OPEN();
	//^3E74:1006
	i32 bp04; // file len
	Bit32u bp0c; // file pos
	if (di == 0) {
		//^3E74:100A
		bp04 = _4976_5d7a;
		bp0c = _4976_5d6a - bp04;
	}
	else{
		//^3E74:102C
		bp0c = QUERY_GDAT_RAW_DATA_FILE_POS(di);
		bp04 = QUERY_GDAT_RAW_DATA_LENGTH(di);
	}
	//^3E74:1046
	Bit16u si = bp0c / TEMP_BUFF_SIZE;
	//^3E74:1058
	Bit32u bp08 = ((Bit32u)si) * TEMP_BUFF_SIZE;
	//^3E74:1066
	while (bp04 > 0) {
		//^3E74:1069
		if (si != _4976_480d || _4976_5d34 != 0) {
			//^3E74:1076
			_4976_480d = si;
			//^3E74:107A
			Bit32u bp18 = _4976_5caa - bp08;
			//^3E74:108D
			if (bp18 > TEMP_BUFF_SIZE) {
				bp18 = TEMP_BUFF_SIZE;
			}
			//^3E74:10A3
			GRAPHICS_DATA_READ(bp08, bp18, _4976_5d04);
			//^3E74:10BE
			_4976_5d34 = 0;
		}
		//^3E74:10C4
		__int32 bp14 = bp0c - bp08;
		//^3E74:10D6
		Bit32u bp10 = (TEMP_BUFF_SIZE - bp14 > bp04) ? (bp04) : (TEMP_BUFF_SIZE - bp14);
		//^3E74:1106
		COPY_MEMORY(&_4976_5d04[bp14], REALIZE_GRAPHICS_DATA_MEMORY(ps), bp10);
		//^3E74:1136
		bp04 -= bp10;
		bp0c += bp10;
		ps += (bp10);
		//^3E74:114E
		si++;
		bp08 += TEMP_BUFF_SIZE;
		//^3E74:1158
	}
	//^3E74:116C
	GRAPHICS_DATA_CLOSE();
}

//^3E74:0213
shelf_memory SkWinCore::CONVERT_PHYS_TO_SHELF_FORM(Bit8u *buff)
{
	U32ptr p1 = buff -cram;
	if (p1 < sizeof(cram)) {
		shelf_memory ps;
		ps.val = U32(p1);
		return ps;
	}
	U32ptr p2 = buff -cems;
	if (p2 < sizeof(cems)) {
		shelf_memory ps;
		ps.val = 0x00200000U +U32(p2);
		return ps;
	}
	ATLASSERT(false);
	throw int();

//		//^3E74:0213
//		Bit8u *bp04 = buff;
//
//		DOSIMPL(); // TODO: WRONG conversion. Fix me
//
//#pragma warning( push )
//#pragma warning( disable : 4311 4312 )
//		return (Bit8u *)((((Bit32u)bp04 & 0xffff0000) >> 12) + ((Bit16u)bp04 & 0xffff));
//#pragma warning( pop )
}

//^3E74:15A9
Bit8u *SkWinCore::QUERY_GDAT_DYN_BUFF(Bit16u index, Bit16u *yy, Bit16u allocUpper)
{
	//^3E74:15A9
	Bit16u si = index;
	Bit16u di = allocUpper;
	//^3E74:15B5
	if (_4976_5d76 == 0) {
		//^3E74:15BF
		__int32 bp08;
		Bit8u *bp04 = ALLOC_MEMORY_RAM(
			bp08 = (QUERY_GDAT_RAW_DATA_LENGTH(si) +6),
			(di != 0) ? afDefault : afUseLower,
			1024
			) + 6;
		//^3E74:15F8
//LOGX(("LOAD_GDAT_RAW_DATA call from QUERY_GDAT_DYN_BUFF (1)"));
		LOAD_GDAT_RAW_DATA(
			si,
			CONVERT_PHYS_TO_SHELF_FORM(bp04)
			);
		SkD((DLV_GLD, "GLD: Dyn2-load Raw#%4d at RAM(%p)\n", (Bitu)si, bp04));
		//^3E74:160E
		WRITE_UI16(bp04,-6 +4,(di != 0) ? afDefault : afUseLower);
		//^3E74:1634
		WRITE_UI32(bp04,-6 +0,bp08);
		//^3E74:1658
		//^3E74:16E3
		return bp04;
	}
	else {
		//^3E74:165B
		Bit8u *bp04;
		if (ADD_CACHE_HASH(si + 0xfffe0000, yy) != 0) {
			//^3E74:1679
			bp04 = reinterpret_cast<Bit8u *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(*yy));
			//^3E74:168B
			if (di == 0)
				return bp04;
			//^3E74:168F
			_3e74_583a(*yy);
		}
		else {
			//^3E74:169D
			bp04 = ALLOC_CPXHEAP_MEM(
				*yy,
				QUERY_GDAT_RAW_DATA_LENGTH(si)
				);
			//^3E74:16BA
//LOGX(("LOAD_GDAT_RAW_DATA call from QUERY_GDAT_DYN_BUFF (2)"));
			LOAD_GDAT_RAW_DATA(
				si,
				CONVERT_PHYS_TO_SHELF_FORM(bp04)
				);
			SkD((DLV_GLD, "GLD: Dyn3-load Raw#%4d at RAM(%p)\n", (Bitu)si, bp04));
			//^3E74:16D0
			if (di == 0) {
				//^3E74:16D4
				_3e74_585a(*yy, 0);
			}
		}
		//^3E74:16E3
		return bp04;
	}
}

//^3E74:521A
Bit8u *SkWinCore::QUERY_GDAT_IMAGE_LOCALPAL(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	//^3E74:521A
	Bit16u si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtImage, cls4);
	//^3E74:5236
	if (si != 0xffff) {
		//^3E74:523B
		IMG3 *bp04;
		if (glbShelfMemoryTable[si].Absent() != 0) {
			//^3E74:5258
			if (IS_CLS1_CRITICAL_FOR_LOAD(cls1) == 0)
				goto _5276;
			//^3E74:5265
			Bit16u bp06;
			bp04 = reinterpret_cast<IMG3 *>(QUERY_GDAT_DYN_BUFF(si, &bp06, 0));
		}
		else {
			//^3E74:5287
			bp04 = reinterpret_cast<IMG3 *>(REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]));
		}
		//^3E74:529F
		//^3E74:52A5
#if DM2_EXTENDED_MODE == 1
		if (bp04->GetBitsCount() != 4) {
			return NULL;
		}
#else
		if (bp04->OffsetY() == -32 && bp04->w4 != 4) {
			//^3E74:52CE
			return NULL;
		}
#endif
		//^3E74:52D4
		PTR_PADA(bp04, QUERY_GDAT_RAW_DATA_LENGTH(si) - 16);
		//^3E74:52EB
		return reinterpret_cast<Bit8u *>(bp04);
	}
_5276:
	//^3E74:5276
	// SPX: Go fetch from the Yukman face (in MISC 0xFE entry) but .. if it does not exist we can get into an infinite loop, fix this!
	if (SkCodeParam::bUseFixedMode && cls1 == GDAT_CATEGORY_MISCELLANEOUS && cls2 == GDAT_ITEM_DEFAULT_INDEX && cls4 == GDAT_ITEM_DEFAULT_INDEX)
		return NULL;
	return QUERY_GDAT_IMAGE_LOCALPAL(GDAT_CATEGORY_MISCELLANEOUS, GDAT_ITEM_DEFAULT_INDEX, GDAT_ITEM_DEFAULT_INDEX);
	// return QUERY_GDAT_IMAGE_LOCALPAL(0x0015, 0x00fe, 0x00fe);
}

//^3E74:0245
U8 *SkWinCore::_3e74_0245(X16 xx, X16 yy)
{
	//^3E74:0245
	ENTER(20);
	//^3E74:024B
	X16 si = xx;
	shelf_memory bp0c = glbShelfMemoryTable[si];
	U8 *bp04 = REALIZE_GRAPHICS_DATA_MEMORY(bp0c);
	i32 bp10 = CONVERT_PHYS_TO_SHELF_FORM(bp04).val - _4976_5d20.val;
	bp04 += 4;
	if (bp10 >= 0 && bp10 <= 65535) {
		//^3E74:02C5
		i32 bp14 = QUERY_GDAT_RAW_DATA_LENGTH(si);
		if (yy != 0)
			_4976_4807 = si;
		//^3E74:02DE
		if (bp14 +(bp10 & 0x7fff) > 0x7fff) {
			//^3E74:0301
			bp14 -= 4;
			bp0c += (4);
			if (_4976_4809 != 0xffff)
				FREE_INDEXED_MEMENT(_4976_4809);
			//^3E74:0322
			_4976_4809 = si;
			mement *bp08 = ALLOC_LOWER_CPXHEAP(bp14 +16);
			X16 di = FIND_FREE_MEMENTI();
			_4976_5c82[si] = di;
			ATLASSERT(tlbMementsPointers[di] == NULL);
			tlbMementsPointers[di] = bp08;
			TEST_MEMENT(bp08);
			bp08->w10(si);
			PTR_PADA(bp08,+12);
			bp04 = reinterpret_cast<U8 *>(bp08);
			//^3E74:038F
			do {
				COPY_MEMORY(REALIZE_GRAPHICS_DATA_MEMORY(bp0c), bp08, (bp14 > 0x4000) ? 0x4000 : bp14);
				bp14 -= 0x4000;
				if (bp14 <= 0)
					break;
				//^3E74:03E2
				PTR_PADA(bp08,+0x4000);
				bp0c += (0x4000);
			} while (true);
			//^3E74:03FC
			if (yy == 0) {
				RECYCLE_MEMENTI(di, 0);
			}
		}
	}
	//^3E74:040C
	return &bp04[6];
}

//^44C8:12F1
X8 SkWinCore::READ_IMG3_NIBBLE()
{
	//^44C8:12F1
	ENTER(0);
	//^44C8:12F4
	return ((_4976_5dc2 & 1) != 0) 
		? (_4976_5e64[(_4976_5dc2++) >> 1] & 15) 
		: (_4976_5e64[(_4976_5dc2++) >> 1] >> 4);
}

//^44C8:132B
U16 SkWinCore::READ_IMG3_DURATION()
{
	//^44C8:132B
	ENTER(0);
	//^44C8:132F
	X16 si = READ_IMG3_NIBBLE();
	if (si == 0xf) {
		//^44C8:133C
		si = READ_IMG3_NIBBLE() << 4;
		si|= READ_IMG3_NIBBLE();
		if (si == 0xff) {
			//^44C8:1358
			si = READ_IMG3_NIBBLE() << 12;
			si|= READ_IMG3_NIBBLE() << 8;
			si|= READ_IMG3_NIBBLE() << 4;
			si|= READ_IMG3_NIBBLE();
			return si;
		}
		si += 0x11;
		return si;
	}
	si += 2;
	return si;
}

//^44C8:12AE
void SkWinCore::SPILL_IMG3_PIXELS(X16 offDst, X16 offSrc, X16 size)
{
	//^44C8:12AE
	ENTER(0);
	//^44C8:12B3
	U8 *di = _4976_5e6a;
	U8 *si = di;
	X16 bx = offDst;
	X16 dx = offSrc;
	X16 cx = size;
	dx >>= 1;
	{
		bool carry = (bx & 1) ? true : false;
		bx >>= 1;
		di += bx;
		si += dx;
		if (carry) {
			//^44C8:12CF
			X8 dl = *di;
			X8 al = lodsb(si);
			dl &= 0xf0;
			al &= 0x0f;
			al |= dl;
			stosb(di, al);
			cx--;
			if (cx == 0)
				return;
		}
		//^44C8:12DF
		cx++;
		cx >>= 1;
		{
			bool carry = (cx & 1) ? true : false;
			cx >>= 1;
			if (carry)
				//^44C8:12E6
				movsb(di, si);
			//^44C8:12E8
			if (cx != 0)
				//^44C8:12EA
				for (; cx != 0; cx--) movsw(di, si);
		}
	}
	//^44C8:12ED
	return;
}

//^44C8:1649
void SkWinCore::TRANSPARENT_IMG3_PIXELS(X16 offSrcDst, X16 size)
{
	//^44C8:1649
	ENTER(0);
	//^44C8:164E
	U8 *di = _4976_5e6a;	// dst
	U8 *si = _4976_5e6e;	// underlay
	X16 bx = offSrcDst;
	X16 cx = size;
	{
		bool carry = (bx & 1) ? true : false;
		bx >>= 1;
		di += bx;
		si += bx;
		if (carry) {
			U8 dl = *di;
			U8 al = lodsb(si);
			dl &= 0xf0;
			al &= 0x0f;
			al |= dl;
			stosb(di, al);
			cx--;
			if (cx == 0)
				return;
		}
		//^44C8:1677
		cx++;
		cx >>= 1;
		{
			bool carry = (cx & 1) ? true : false;
			cx >>= 1;
			if (carry) {
				//^44C8:167E
				movsb(di, si);
				if (cx == 0)
					return;
			}
			//^44C8:1681
			for (; cx != 0; cx--) movsw(di, si);
		}
	}
	//^44C8:1684
	return;
}

//^44C8:1202
void SkWinCore::_44c8_1202(X16 offDst, X8 pixel)
{
	//^44C8:1202
	ENTER(0);
	//^44C8:1206
	U8 *di = _4976_5e6a;
	X16 bx = offDst;
	{
		bool carry = (bx & 1) ? true : false;
		bx >>= 1;
		if (carry) {
			//^44C8:1212
			di += bx;
			U8 al = *di;
			al &= 0xf0;
			al |= pixel;
			stosb(di, al);
		}
		else {
			//^44C8:121F
			di += bx;
			U8 al = (pixel << 4)|(*di & 0x0f);
			stosb(di, al);
		}
	}
	//^44C8:1230
	return;
}

//^44C8:1688
void SkWinCore::DECODE_IMG3_OVERLAY(U8 *blitUnderlay, IMG3 *blitSrc, U8 *blitDst)
{
	// TODO: SUSPECTED;

	//^44C8:1688
	ENTER(24);
	//^44C8:168E
	_4976_5e64 = reinterpret_cast<U8 *>(blitSrc);
	_4976_5e6a = blitDst;
	_4976_5e6e = blitUnderlay;
	X16 bp02 = blitSrc->Width();
	X16 bp04 = blitSrc->Height();
	X16 bp06 = (bp02 +1)&0xfffe;
	X16 bp08 = bp06 * bp04;
	_4976_5dc2 = 8;
	i16 bp0e = 0;
	U8 bp16[5];

	// SPX: on custom GDAT2, it happens images have w = 0 and h = 0; in that case, might be better to do nothing here
	if (SkCodeParam::bUsePowerDebug)
	{
		if (bp02 == 0 || bp04 == 0)
			return;
	}

	for (; bp0e < 5; bp0e++) {
		//^44C8:16E9
		bp16[bp0e] = READ_IMG3_NIBBLE();
		//^44C8:16F8
	}
	//^44C8:1701
	if (bp02 != bp06) {
		//^44C8:170C
		X16 bp0c = bp06 -bp02;
		X16 di = 0;
		X16 bp0a = bp02;
		//^44C8:171D
		do {
			X8 bp0f = ((_4976_5dc2 & 1) != 0)
				? _4976_5e64[_4976_5dc2 >> 1] & 0xf
				: _4976_5e64[_4976_5dc2 >> 1] >> 4;
			_4976_5dc2++;
			X8 bp10 = bp0f & 7;
			U16 si;
			if (bp10 == 6) {
				//^44C8:175F
				si = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
				ATLASSERT(di +U32(si) < bp08); // fill range must be inside picture
				//^44C8:1772
				while (si >= bp0a) {
					//^44C8:1772
					SPILL_IMG3_PIXELS(di, di -bp06, bp0a);
					di += bp0a +bp0c;
					si -= bp0a;
					bp0a = bp02;
					//^44C8:1794
				}
				//^44C8:1799
				if (si > 0) {
					//^44C8:17A0
#if UseAltic
					SPILL_IMG3_PIXELS(di, di -bp06, si);
#else
					SPILL_IMG3_PIXELS(di, di -bp06, bp0a);
#endif
					di += si;
					bp0a -= si;
				}
				continue;
			}
			//^44C8:17B9
			if (bp10 == 5) {
				//^44C8:17BF
				si = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
				ATLASSERT(di +U32(si) < bp08); // fill range must be inside picture
				//^44C8:17D0
				while (si >= bp0a) {
					//^44C8:17D2
					TRANSPARENT_IMG3_PIXELS(di, bp0a);
					di += bp0a +bp0c;
					si -= bp0a;
					bp0a = bp02;
					//^44C8:17ED
				}
				//^44C8:17F2
				if (si > 0) {
					//^44C8:17F9
#if UseAltic
					TRANSPARENT_IMG3_PIXELS(di, si);
#else
					TRANSPARENT_IMG3_PIXELS(di, bp0a);
#endif
					di += si;
					bp0a -= si;
				}
				continue;
			}
			//^44C8:180B
			X8 bp17;
			if (bp10 < 5) {
				//^44C8:1811
				bp17 = bp16[bp10];
			}
			else {
				bp17 = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 0xf) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
				_4976_5dc2++;
			}
			//^44C8:1859
			si = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
			ATLASSERT(di +U32(si) < bp08); // fill range must be inside picture
			//^44C8:186A
			while (si >= bp0a) {
				//^44C8:186C
				FIRE_FILL_4BPP_PICT_LINE(di, bp17, bp0a);
				di += bp0a +bp0c;
				si -= bp0a;
				bp0a = bp02;
				//^44C8:188C
			}
			//^44C8:1891
			if (si > 0) {
				FIRE_FILL_4BPP_PICT_LINE(di, bp17, si);
				di += si;
				bp0a -= si;
			}
			//^44C8:18A7
		} while (di < bp08);
		ATLASSERT(di <= bp08); // if error, memory broken!
		//^44C8:18AF
		return;
	}
	else {
		//^44C8:18B2
		X16 di = 0;
		do {
			//^44C8:18B4
			X8 bp0f = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 15) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
			_4976_5dc2++;
			X8 bp10 = bp0f & 7;
			X8 bp17;
			X16 si;
			//^44C8:18F0
			if (bp10 == 6) {
				si = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
				SPILL_IMG3_PIXELS(di, di -bp06, si);
				di += si;
				continue;
			}
			//^44C8:191B
			else if (bp10 == 5) {
				si = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
				TRANSPARENT_IMG3_PIXELS(di, si);
				di += si;
				continue;
			}
			//^44C8:193C
			else if (bp10 < 5) {
				bp17 = bp16[bp10];
			}
			else {
				//^44C8:1956
				bp17 = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 15) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
				_4976_5dc2++;
			}
			//^44C8:198A
			if ((bp0f & 8) != 0) {
				//^44C8:1990
				si = READ_IMG3_DURATION();
				FIRE_FILL_4BPP_PICT_LINE(di, bp17, si);
				di += si;
			}
			else {
				//^44C8:19A3
				_44c8_1202(di++, bp17);
			}
			//^44C8:19B1
		} while (di < bp08);
		ATLASSERT(di <= bp08); // if error, memory broken!
	}
	//^44C8:19B9
	return;
}

void SkWinCore::DECODE_IMG9(IMG3 *xx, U8 *pOut) {
	const U32 cx = xx->Width();
	const U32 cy = xx->Height();

	U32 iPix = 0;
	const U32 nPix = cx * cy;

	// a kind of LZSS?
	const U8 typex = reinterpret_cast<U8 *>(xx)[6];

	const U8 *pIn = reinterpret_cast<U8 *>(xx) + 8;

	while (iPix < nPix) {
		U8 command = *pIn;
		pIn++;
		for (int t = 0; t < 8 && iPix < nPix; t++, command >>= 1) {
			if (0 != (command & 1)) {
				// pixel
				pOut[iPix] = *pIn;
				iPix++;
				pIn++;
			}
			else {
				// get back
				int A = pIn[0];
				int B = pIn[1];
				pIn += 2;
				int negative_offset, copy_length;
				if (typex == 2) {
					int Y = A & 0xF;
					int X = A >> 4;
					negative_offset = X + 16 * B;
					copy_length = Y + 3;
				}
				else { // typex == 3
					int Y = A & 0x1F;
					int X = A >> 5;
					negative_offset = X + 8 * B;
					copy_length = Y + 3;
				}
				for (int w = 0; w < copy_length; w++, iPix++) {
					pOut[iPix] = pOut[iPix -negative_offset];
				}
			}
		}
	}
	ATLASSERT(iPix == nPix);
}

//^44C8:1395
void SkWinCore::DECODE_IMG3_UNDERLAY(IMG3 *xx, U8 *yy)
{
	//^44C8:1395
	ENTER(24);
	//^44C8:139B
	_4976_5e64 = reinterpret_cast<U8 *>(xx);
	_4976_5e6a = yy;
	X16 bp02 = xx->Width();
	X16 bp04 = xx->Height();
	X16 bp06 = (bp02 +1)&0xfffe;
	X16 bp08 = bp06 * bp04;
	_4976_5dc2 = 8;
	X16 bp0e = 0;
	X8 bp16[6];

	// SPX: on custom GDAT2, it happens images have w = 0 and h = 0; in that case, might be better to do nothing here
	if (SkCodeParam::bUsePowerDebug)
	{
		if (bp02 == 0 || bp04 == 0)
			return;
	}

	while (bp0e < 6) {
		//^44C8:13E9
		bp16[bp0e] = READ_IMG3_NIBBLE();
		bp0e++;
		//^44C8:13FB
	}
	//^44C8:1401
	X16 si = 0;	// SPX: added init to zero
	U16 di = 0; // SPX: added init to zero
	if (bp02 != bp06) {
		//^44C8:140C
		X16 bp0c = bp06 -bp02;
		si = 0;
		X16 bp0a = bp02;
		do {
			//^44C8:141D
			X8 bp0f = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 15) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
			_4976_5dc2++;
			X8 bp10 = bp0f & 7;
			if (bp10 == 6) {
				//^44C8:145F
				di = ((bp0f & 8) != 0) ? (READ_IMG3_DURATION()) : 1;
				//^44C8:1470
				while (di >= bp0a) {
					//^44C8:1472
					SPILL_IMG3_PIXELS(si, si -bp06, bp0a);
					si += bp0a +bp0c;
					di -= bp0a;
					bp0a = bp02;
					//^44C8:1494
				}
				//^44C8:1499
				if (di > 0) {
					//^44C8:14A0
					SPILL_IMG3_PIXELS(si, si -bp06, bp0a);
					si += di;
					bp0a -= di;
				}
			}
			else {
				//^44C8:14B9
				X8 bp17;
				if (bp10 < 6) {
					//^44C8:14BF
					bp17 = bp16[bp10];
				}
				else {
					//^44C8:14D3
					bp17 = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 15) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
					_4976_5dc2++;
				}
				//^44C8:1507
				di = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
				//^44C8:1518
				while (di >= bp0a) {
					//^44C8:151A
					FIRE_FILL_4BPP_PICT_LINE(si, bp17, bp0a);
					si += bp0a +bp0c;
					di -= bp0a;
					bp0a = bp02;
					//^44C8:153A
				}
				//^44C8:153F
				if (di > 0) {
					FIRE_FILL_4BPP_PICT_LINE(si, bp17, di);
					si += di;
					bp0a -= di;
				}
			}
			//^44C8:1555
		} while (si < bp08);
		if (SkCodeParam::bDebugNoImageDecodingAssert == false)
			ATLASSERT(si <= bp08); // if error, memory broken!
		//^44C8:155D
	}
	else {
		//^44C8:1560
		si = 0;
		do {
			//^44C8:1562
			// SPX: _4976_5e64 would be an image and _4976_5dc2 the cursor ?
			X8 bp0f = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 0xf) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
			_4976_5dc2++;
			X8 bp10 = bp0f & 7;
			X8 bp17;
			if (bp10 == 6) {
				//^44C8:15A4
				di = ((bp0f & 8) != 0) ? READ_IMG3_DURATION() : 1;
				SPILL_IMG3_PIXELS(si, si -bp06, di);
				//^44C8:15C1
				si += di;
				continue;
			}
			else if (bp10 < 6) {
				//^44C8:15CF
				bp17 = bp16[bp10];
			}
			else {
				bp17 = ((_4976_5dc2 & 1) != 0) ? (_4976_5e64[_4976_5dc2 >> 1] & 15) : (_4976_5e64[_4976_5dc2 >> 1] >> 4);
				_4976_5dc2++;
			}
			//^44C8:1617
			if ((bp0f & 8) != 0) {
				di = READ_IMG3_DURATION();
				FIRE_FILL_4BPP_PICT_LINE(si, bp17, di);
				si += di;
			}
			else {
				//^44C8:162F
				_44c8_1202(si++, bp17);
			}
			//^44C8:163D
		} while (si < bp08);
		if (SkCodeParam::bDebugNoImageDecodingAssert == false)
			ATLASSERT(si <= bp08); // if error, memory broken!
	}

	//^44C8:1645
	return;
}

//^44C8:19BD
void SkWinCore::DECODE_IMG3_UNDERLAY_LOCAL(IMG3 *xx, U8 *yy)
{
	//^44C8:19BD
	ENTER(0);
	//^44C8:19C0
	DECODE_IMG3_UNDERLAY(xx, yy);
	//^44C8:19D3
	return;
}

//^3E74:4B48
Bit8u *SkWinCore::EXTRACT_GDAT_IMAGE(Bit16u index, i16 allocUpper)
{
	SkD((DLV_DBG_GETPIC,"DBG: EXTRACT_GDAT_IMAGE(%4u,%u)\n", (Bitu)index, (Bitu)allocUpper));

	//^3E74:4B48
	Bit16u di = index;
	i16 bp16 = -1;
	//^3E74:4B56
	if (_4976_5d76 != 0) {
		//^3E74:4B5D
		Bit16u si = QUERY_MEMENTI_FROM(di);
		//^3E74:4B65
		if (si != 0xffff) {
			mement *bp04;
			//^3E74:4B6D
			if (allocUpper != 0) {
				//^3E74:4B73
				_3e74_4549(si);
				//^3E74:4B79
				bp04 = tlbMementsPointers[si];
			}
			else {
				//^3E74:4B93
				bp04 = _3e74_48c9(si);
			}
			//^3E74:4B9F
			return reinterpret_cast<U8 *>(&bp04[1]); // +18 bytes
		}
	}
	else {
		//^3E74:4BB4
		sk5cfc_image *bp04 = _4976_5cfc.pv0;
		while (bp04 != NULL) {
			//^3E74:4BBD
			if (bp04->w4 == di) {
				//^3E74:4BD6
				return (Bit8u *)&bp04[1]; // +14 bytes
			}
			//^3E74:4BEB
			bp04 = bp04->pv0;
			//^3E74:4BF5
		}
	}
	//^3E74:4C0C
	Bit16u bp1e = 0;
	Bit8u *bp1a;
	Bit16u bp1c;
	if (_4976_5d78 != 0) {
		//^3E74:4C18
		bp1c = TRACK_UNDERLAY(di);
		SkD((DLV_DBG_GETPIC,"DBG: Ulay %4d -> %4d\n", (Bitu)i16(bp1c), (Bitu)i16(di)));
		//^3E74:4C21
		if (bp1c != 0xffff) {
			//^3E74:4C26
			bp1e = 1;
			//^3E74:4C2B
			bp1a = EXTRACT_GDAT_IMAGE(bp1c, (_4976_5d76 != 0) ? 1 : (!allocUpper));
		}
	}
	//^3E74:4C4F
	shelf_memory bp10 = glbShelfMemoryTable[di];
	IMG3 *bp08;
	//^3E74:4C67
	if (bp10.Absent()) {
		//^3E74:4C72
		bp08 = reinterpret_cast<IMG3 *>(QUERY_GDAT_DYN_BUFF(di, reinterpret_cast<U16 *>(&bp16), (_4976_5d76 != 0) ? 1 : (!allocUpper)));
	}
	else {
		//^3E74:4C96
		bp08 = reinterpret_cast<IMG3 *>(REALIZE_GRAPHICS_DATA_MEMORY(bp10));
	}
	//^3E74:4CA2
	//^3E74:4CA8
	if (bp08->OffsetY() == -32) { // uncompressed 4bpp/8bpp. but 8bpp is untested!
		//^3E74:4CB7
		if (bp16 < 0) {
			//^3E74:4CBD
			//^3E74:4CC7
			Bit8u *bp04 = _3e74_0245(di, allocUpper);
			//^3E74:4FB4
			return bp04;
		}
		else {
			//^3E74:4CD0
			//^3E74:4CC7
			Bit8u *bp04 = PTR_PADD(bp08,+10);
			//^3E74:4FB4
			return bp04;
		}
	}
	//^3E74:4CE4
	U16 bp12 = bp08->Width();
	U16 bp14 = bp08->Height();
#if DM2_EXTENDED_MODE == 1
	i32 bp0c = bp08->GetImageSize();
#else
	i32 bp0c = (((bp12 +1) & 0xFFFE) >> 1) * bp14;
#endif
	//^3E74:4D0B
	if (_4976_5d76 == 0) {
		//^3E74:4D12
		bp0c += 16;
	}
	//^3E74:4D1A
	Bit16u si;
	U8 *_bp04;
	if (_4976_5d76 != 0) {
		//^3E74:4D24
		if ((bp0c & 1) != 0) {
			//^3E74:4D2F
			bp0c++;
		}
		//^3E74:4D37
		bp0c += sizeof(mement) + sizeof(i32);
		//^3E74:4D3F
		mement *bp04 = ALLOC_LOWER_CPXHEAP(bp0c);
		//^3E74:4D51
		if (bp16 >= 0) {
			//^3E74:4D57
			bp08 = reinterpret_cast<IMG3 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp16));
		}
		//^3E74:4D66
		si = FIND_FREE_MEMENTI();
		//^3E74:4D6C
		_4976_5c82[di] = si;
		//^3E74:4D79
		ATLASSERT(tlbMementsPointers[si] == NULL);
		tlbMementsPointers[si] = bp04;
		//^3E74:4D91
		bp04->w10(di);
		//^3E74:4D98
#if DM2_EXTENDED_MODE == 1
		bp04->w12(bp08->GetBitsCount());
#else
		bp04->w12(4);
#endif
		//^3E74:4D9E
		bp04->w14(bp12);
		//^3E74:4DA5
		bp04->w16(bp14);
		//^3E74:4DAC
		bp04++; // +18 bytes
		_bp04 = reinterpret_cast<U8 *>(bp04);

		// SkD((DLV_DBG_GETPIC,"DBG: CPX Alloc #%02d (Raw #%04d)\n", si, di));
	}
	else {
		//^3E74:4DC7
		sk5cfc_image *bp04 = reinterpret_cast<sk5cfc_image *>(ALLOC_MEMORY_RAM(bp0c +sizeof(sk5cfc_image), (allocUpper != 0) ? afDefault : afUseLower, 8));
		//^3E74:4DF2
		bp04->pv0 = _4976_5cfc.pv0;
		//^3E74:4E03
		_4976_5cfc.pv0 = bp04;
		//^3E74:4E10
		bp04++;
		//^3E74:4E28
		bp04[-1].w6 = (allocUpper != 0) ? 0 : 2;
		//^3E74:4E50
		bp04[-1].w4 = di;
		//^3E74:4E69
#if DM2_EXTENDED_MODE == 1
		bp04[-1].w8 = bp08->GetBitsCount();
#else
		bp04[-1].w8 = 4;
#endif
		//^3E74:4E83
		bp04[-1].width = bp12;
		bp04[-1].height = bp14;
		//^3E74:4E94
		COPY_MEMORY(
			PTR_PADD(bp08,+QUERY_GDAT_RAW_DATA_LENGTH(di) -16),
			PTR_PADD(bp04,+bp0c -16),
			16
			);
		_bp04 = reinterpret_cast<U8 *>(bp04);
	}
	//^3E74:4EE0
	Bit16u bp20;
	if (bp1e != 0) {
		//^3E74:4EE6
		if (_4976_5d76 != 0) {
			//^3E74:4EED
			bp20 = QUERY_MEMENTI_FROM(bp1c);
			//^3E74:4EF8
			bp1a = reinterpret_cast<U8 *>(&tlbMementsPointers[bp20][1]); // +18 bytes
		}
		//^3E74:4F1A
		DECODE_IMG3_OVERLAY(bp1a, bp08, _bp04);
	}
	else {
#if DM2_EXTENDED_MODE == 1
		switch (bp08->Getpf()) {
			case pfC8:
				DECODE_IMG9(bp08, _bp04);
				break;
			case pfC4:
				DECODE_IMG3_UNDERLAY_LOCAL(bp08, _bp04);
				break;
		}
#else
		//^3E74:4F36
		DECODE_IMG3_UNDERLAY_LOCAL(bp08, _bp04);
#endif
	}
	//^3E74:4F4A
	if (_4976_5d76 != 0) {
		//^3E74:4F51
		if (allocUpper == 0) {
			//^3E74:4F57
			RECYCLE_MEMENTI(si, 0);
		}
		//^3E74:4F60
		if (bp16 >= 0) {
			//^3E74:4F66
			_3e74_585a(bp16, 0);
		}
		//^3E74:4F72
		if (bp1e == 0)
			return _bp04;
		//^3E74:4F78
		RECYCLE_MEMENTI(bp20, 0);
		//^3E74:4F83
		return _bp04;
	}
	//^3E74:4F85
	if (bp10.Absent()) {
		//^3E74:4F96
		_3e74_0a77(reinterpret_cast<U8 *>(bp08));
	}
	//^3E74:4FA2
	if (bp1e != 0) {
		//^3E74:4FA8
		FREE_PICT_ENTRY(bp1a);
	}
	//^3E74:4FB4
	return _bp04;
}

void SkWinCore::DUMP_5CA4() {
#if DLV_DBG_EXTRACT
	SkD((DLV_DBG_EXTRACT,
		"=====\n"
		"_4976_5c8c=%p\n"
		"_4976_5cb2=%p\n"
		"_4976_5ce6=%p\n"
		"_4976_5d5e=%p\n"
		"_4976_5d70=%p\n"
		"_4976_5d90=%p\n"
		"_4976_5d94=%p\n"
		, _4976_5c8c
		, _4976_5cb2
		, _4976_5ce6
		, _4976_5d5e
		, _4976_5d70
		, _4976_5d90
		, _4976_5d94
		));
	for (int x=0; x<glbNumberOfMements; x++) {
		if (tlbMementsPointers[x] == NULL) continue;
		SkD((DLV_DBG_EXTRACT,
			"#%02d %p (%6d,%04X,%04X,%04X,%04X,%04X,%04X,%04X)\n"
			, x, tlbMementsPointers[x]
			, tlbMementsPointers[x]->_dw0
			, tlbMementsPointers[x]->_w4
			, tlbMementsPointers[x]->_w6
			, tlbMementsPointers[x]->_w8
			, tlbMementsPointers[x]->_w10
			, tlbMementsPointers[x]->_w12
			, tlbMementsPointers[x]->_w14
			, tlbMementsPointers[x]->_w16
			));
	}
	SkD((DLV_DBG_EXTRACT,
		"=====\n"));
#endif
}

//^3E74:4FBE
Bit8u *SkWinCore::QUERY_GDAT_IMAGE_ENTRY_BUFF(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	SkD((DLV_DBG_GETPIC,"DBG: QUERY_GDAT_IMAGE_ENTRY_BUFF(%02X,%02X,%02X)\n", (Bitu)cls1, (Bitu)cls2, (Bitu)cls4));
	DUMP_5CA4();
	// ATLASSERT(!(cls1 == 1 && cls2 == 2 && cls4 == 0));
	// ATLASSERT(!(cls1 == 7 && cls2 == 0 && cls4 == 0));
	// ATLASSERT(!(cls1 == 10 && cls2 == 0x37 && cls4 == 2));

	//^3E74:4FBE
	Bit16u di = 0;
	if (glbGameTick != _4976_5d2a) {
		//^3E74:4FD9
		_3e74_44ad();
	}
	//^3E74:4FDD
	RawEntry *bp08 = QUERY_GDAT_ENTRYPTR(cls1, cls2, 1, cls4);
	Bit16u si;
	if (bp08 == NULL) {
		//^3E74:5000
		si = 0xffff;
	}
	else {
		//^3E74:5005
		di |= IS_CLS1_CRITICAL_FOR_LOAD(cls1);
		//^3E74:500E
		si = bp08->data & 0x7fff;
	}
	//^3E74:501C
	if (si != 0xffff) {
		if (glbShelfMemoryTable[si].Present() || (di != 0)) {
			//^3E74:5055
			Bit8u *bp04 = EXTRACT_GDAT_IMAGE(si, 0);
			//^3E74:5064
			return bp04;
		}
	}
	SkD((DLV_BUGHERE,"BUG? Image (%02X,%02X,%02X) not found. We just supply a \":P\" icon\n"
		, (Bitu)cls1, (Bitu)cls2, (Bitu)cls4));
	//^3E74:5042
	// SPX: the default image (yukman) is located as default image from MISC ITEM category
	// If that default image is not here, it is very likely to crash thereafter (anytime the default is required)
	si = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_MISCELLANEOUS, GDAT_ITEM_DEFAULT_INDEX, 0x01, 0xfe); // (0x15, 0xfe, 0x01, 0xfe) // the Yukman :P icon
	//^3E74:5055
	Bit8u *bp04 = EXTRACT_GDAT_IMAGE(si, 0);
	//^3E74:5064
	return bp04;
}

//^0B36:1599
void SkWinCore::DRAW_DIALOGUE_PICT(Bit8u *srcImage, Bit8u *dstImage, SRECT *rect, Bit16u srcx, Bit16u srcy, Bit16u colorkey, Bit8u localpal[16])
{
	// draw the:
	// a) pre rendered dialogue to screen

	//^0B36:1599
	FIRE_BLIT_PICTURE(
		srcImage,
		dstImage,
		rect,
		srcx,
		srcy,
		((Bit16u *)srcImage)[-2], // src-pitch
		((Bit16u *)dstImage)[-2], // dst-pitch
		colorkey,
		0,
		((Bit16u *)srcImage)[-3], // src-bpp
		((Bit16u *)dstImage)[-3], // dst-bpp
		localpal
		);
}

//^2E62:0004
Bit8u *SkWinCore::QUERY_GDAT_SQUAD_ICON(Bit8u *dstImage, Bit8u colorno, Bit8u localpal[16])
{
	//^2E62:0004
	Bit16u si = (((glbChampionSquad[colorno].playerDir() + 4 - glbPlayerDir) & 3) + ((glbGlobalSpellEffects.Invisibility != 0) ? 4 : 0)) * _4976_0118;
	//^2E62:003C
	COPY_MEMORY(
		QUERY_GDAT_IMAGE_LOCALPAL(1, 6, colorno),
		localpal,
		16
		);
	//^2E62:0060
	DRAW_DIALOGUE_PICT(
		QUERY_GDAT_IMAGE_ENTRY_BUFF(1, 6, colorno),
		dstImage,
		ALLOC_TEMP_ORIGIN_RECT(_4976_0118, _4976_011a),
		si,
		0,
		2,
		NULL
		);
	//^2E62:009A
	return dstImage;
}

//^3E74:0A1B
void SkWinCore::DEALLOC_UPPER_MEMORY(Bit32u size)
{
	//^3E74:0A1B
	if ((size & 1) != 0) {
		//^3E74:0A29
		size++;
	}
	//^3E74:0A31
	glbFreeRAMMemPool += size;
	//^3E74:0A3F
	_4976_5cf4 += size;

	SkD((DLV_MEM, "MEM: DEALLOC_UPPER_MEMORY(%10d)\n", (Bitu)size));
#if defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
	i32 cbExpected;
	ATLVERIFY(vecUpperAlloc.size() != 0);
	ATLVERIFY((cbExpected = vecUpperAlloc.top()) == size);
	vecUpperAlloc.pop();
#endif // defined(_USE_MFC80) || defined(_USE_MFC60) || defined(_USE_SDL)
}

//^3E74:0C16
void SkWinCore::FREE_PICT_BUFF(Bit8u *buff)
{
	// READ_UI16(buff,-6) -> bpp(4 or 8)
	// READ_UI16(buff,-4) -> width
	// READ_UI16(buff,-2) -> height

	//^3E74:0C16
	DEALLOC_UPPER_MEMORY(
		(	(READ_UI16(buff,-6) == 4) 
			? (((READ_UI16(buff,-4) +1) & 0xfffe) >> 1)	// if 4 bpp, round up width to byte align.
			:   (READ_UI16(buff,-4)     & 0xffff)		// if 8 bpp, already byte aligned.
		) * READ_UI16(buff,-2) +6
	);
}

//^01B0:07F8
void SkWinCore::LOCK_MOUSE_EVENT() //#DS=04BF
{
	//^01B0:07F8
	LOADDS(0x3083)
	//^01B0:0803
	_04bf_0e7a++;
}

//^443C:00F8
X16 SkWinCore::_443c_00f8(X16 xx, X16 yy)
{
	//^443C:00F8
	ENTER(14);
	//^443C:00FE
	if (glbMouseVisibility > 0)
		return 0xffff;
	if (_4976_5dae.rc4.cx != 0 || xx < _4976_5da8 || xx > _4976_5dae.rc4.x || yy < _4976_5daa || yy > _4976_5dae.rc4.y) {
		//^443C:0133
		_4976_5dae.rc4.cx = 0;
		_4976_4952 = 0;
		sk0cea *bp04 = _4976_5dae.pv0;
		X16 di = 0;
		X16 bp0a = 0;
		X16 bp0c = glbScreenWidth;
		X16 si = glbScreenHeight;
		for (; bp04 != NULL; ) {
			//^443C:0160
			SRECT *bp08 = &bp04->pv6()->rc4;
			X16 bp0e = 0;
			if (bp08->x > xx) {
				//^443C:0184
				bp0c = min_value(bp0c, bp08->x);
			}
			//^443C:0189
			else if (bp08->x +bp08->cx -1 < xx) {
				//^443C:019D
				bp0a = max_value(bp0a, bp08->x +bp08->cx -1);
			}
			else {
				//^443C:01BC
				bp0e = 1;
				bp0a = max_value(bp0a, bp08->x);
				bp0c = min_value(bp0c, bp08->x +bp08->cx -1);
			}
			//^443C:01F1
			if (bp08->y > yy) {
				//^443C:01FD
				si = min_value(si, bp08->y);
			}
			else if (bp08->y +bp08->cy -1 < yy) {
				//^443C:021F
				di = max_value(di, bp08->y +bp08->cy -1);
			}
			else {
				//^443C:0235
				di = max_value(di, bp08->y);
				si = min_value(si, bp08->y +bp08->cy -1);
				if (bp0e != 0) {
					//^443C:0263
					_4976_4952 = bp04->b2();
					if (bp04 != _4976_5da4 && bp04->b4() != 0)
						//^443C:028B
						FIRE_QUEUE_MOUSE_EVENT(xx, yy, bp04->b0());
					break;
				}
			}
			//^443C:02A2
			bp04 = bp04->pv6()->pv0;
			//^443C:02B6
		}
		//^443C:02C1
		if (_4976_5da4 != NULL && bp04 != _4976_5da4 && _4976_5da4->b5() != 0) {
			//^443C:02E7
			FIRE_QUEUE_MOUSE_EVENT(xx, yy, _4976_5da4->b5());
		}
		//^443C:02FC
		_443c_00a9(bp04, bp0a, bp0c, di, si);
	}
	//^443C:0311
	if (_4976_4952 == 2)
		return 3;
	//^443C:031D
	if (_4976_4952 == 1 && glbChampionLeader >= 0) {
		//^443C:032B
		return (_4976_5dac != 0) ? 2 : 1;
	}
	//^443C:033C
	return 0;
}

//^443C:0342
Bit16u SkWinCore::FIRE_MOUSE_EVENT_RECEIVER(Bit16u xx, Bit16u yy, i16 button) //#DS=4976
{
	//^443C:0342
	ENTER(2);
	//^443C:0346
	LOADDS(0x038B) //#DS=4976
	//^443C:034D
	X16 bp02;
	if (button < 0x20) {
		//^443C:0353
		FIRE_QUEUE_MOUSE_EVENT(xx, yy, button);
		bp02 = 0xffff;
	}
	else {
		//^443C:036B
		bp02 = _443c_00f8(xx, yy);
	}
	//^443C:037A
	return bp02;
}

//^00EB:0777
void SkWinCore::IBMIO_BLIT_MOUSE_CURSOR(Bit8u *buff, SRECT *rc, Bit16u srcx, Bit16u srcy, Bit16u srcpitch, __int16 colorkey) //#DS=04BF
{
	//^00EB:0777
	LOADDS(0x0c48)
	//^00EB:0780
	if (glbMouseCursorVisible != 0)
		return;
	//^00EB:078A
	_04bf_09e0.x = rc->x;
	_04bf_09e0.y = rc->y;
	_04bf_09e8.x = _04bf_09e8.y = 0;
	//^00EB:07A6
	_04bf_09e0.cx = _04bf_09e8.cx = rc->cx;
	//^00EB:07B0
	_04bf_09e0.cy = _04bf_09e8.cy = rc->cy;
	//^00EB:07BA
	ATLASSERT(_04bf_09e8.cx <= 18 && _04bf_09e8.cy <= 18);
	IBMIO_BLIT_TO_SCREEN_8TO8BPP(
		__vram,
		_04bf_079e,
		&_04bf_09e8,
		rc->x,
		rc->y,
		320,
		24,
		-1
		);
	//^00EB:07DC
	IBMIO_BLIT_TO_SCREEN_8TO8BPP(
		buff,
		__vram,
		rc,
		srcx,
		srcy,
		srcpitch,
		320,
		colorkey
		);
	//^00EB:0803
	_04bf_079c = colorkey;
	glbMouseCursorVisible = 1;
}

//^01B0:05AE
void SkWinCore::_01b0_05ae() //#DS=04BF
{
	//^01B0:05AE
	if ((true
		&& _04bf_1850 != 0
		&& _04bf_03c6 != 0
	) && (
		false
		|| glbMouseXPos < _04bf_1852.x 
		|| _04bf_1852.x + _04bf_1852.cx - 1 < glbMouseXPos 
		|| glbMouseYPos < _04bf_1852.y 
		|| _04bf_1852.y + _04bf_1852.cy - 1 < glbMouseYPos
	)
	) {
		//^01B0:05EE
		_04bf_1850 = 0;

		//^01B0:05F4
		_04bf_0e7c = FIRE_MOUSE_EVENT_RECEIVER(glbMouseXPos, glbMouseYPos, _04bf_17e8) INDIRECT_CALL;
		//^01B0:060A
		if (_04bf_0e7c >= 0) {
			//^01B0:060E
			_04bf_1938 = _04bf_0e7c;
		}
	}
	//^01B0:0611
	sk0e80 *bp04 = &_04bf_0e80[_04bf_1938];
	//^01B0:0622
	_04bf_185e = glbMouseXPos - bp04->b0;
	//^01B0:0634
	_04bf_1860 = glbMouseYPos - bp04->b1;
	//^01B0:0644
	_04bf_0e38 = bp04->b2;
	_04bf_1936 = bp04->b3;
	_04bf_18aa = 0;
	_04bf_18ac = 0;
	//^01B0:0662
	if (_04bf_185e < 0) {
		//^01B0:0669
		_04bf_18aa = 0 - _04bf_185e;
		_04bf_185e = 0;
	}
	//^01B0:0678
	if (_04bf_1860 < 0) {
		//^01B0:067F
		_04bf_18ac = 0 - _04bf_1860;
		_04bf_1860 = 0;
	}
	//^01B0:068E
	if (_04bf_185e >= 320)
		return;
	//^01B0:069B
	if (_04bf_1860 >= 200)
		return;
	//^01B0:06A8
	if (_04bf_17a8 != 0)
		return;
	_04bf_17a8++;
	//^01B0:06BB
	SRECT bp0c;
	bp0c.x = _04bf_185e;
	bp0c.cx = _04bf_0e38 - _04bf_18aa;
	//^01B0:06CB
	if (bp0c.x + bp0c.cx - 1 > 319) {
		//^01B0:06D7
		bp0c.cx -= bp0c.x + bp0c.cx - 320;
	}
	//^01B0:06E3
	bp0c.y = _04bf_1860;
	bp0c.cy = _04bf_1936 - _04bf_18ac;
	//^01B0:06F3
	if (bp0c.y + bp0c.cy - 1 > 199) {
		//^01B0:06FF
		bp0c.cy -= bp0c.y + bp0c.cy - 200;
	}
	//^01B0:070B
	IBMIO_BLIT_MOUSE_CURSOR(bp04->b6, &bp0c, _04bf_18aa, _04bf_18ac, _04bf_0e38, bp04->b4);
	//^01B0:0738
	return;
}

//^00EB:073F
void SkWinCore::IBMIO_HIDE_MOUSE_CURSOR() //#DS=04BF
{
	//^00EB:073F
	LOADDS(0x0c48);
	//^00EB:0748
	if (glbMouseCursorVisible != 0) {
		//^00EB:074F
		IBMIO_BLIT_TO_SCREEN_8TO8BPP(
			_04bf_079e,
			__vram,
			&_04bf_09e0,
			0,
			0,
			24,
			320,
			-1
			);
		//^00EB:076E
		glbMouseCursorVisible = 0;
	}
	//^00EB:0774
	return;
}

//^01B0:073D
void SkWinCore::_01b0_073d() //#DS=04BF
{
	//^01B0:073D
	//^01B0:0740
	if (_04bf_17a8 != 0) {
		//^01B0:0747
		IBMIO_HIDE_MOUSE_CURSOR();
		//^01B0:074C
		_04bf_17a8--;
	}
	//^01B0:0750
	return;
}

//^01B0:0752
void SkWinCore::IBMIO_MOUSE_EVENT_RECEIVER(Bit16u cursorx, Bit16u cursory, Bit16u buttons) //#DS=04BF
{
	//^01B0:0752
	Bit16u di = cursorx;
	Bit16u si = cursory;
	glbMouseXPos = di;
	glbMouseYPos = si;
	//^01B0:0765
	if ((di != glbMousePreviousXPos || si != glbMousePreviousYPos) && _04bf_17a2 <= 0) {
		//^01B0:0778
		_01b0_073d();
		_01b0_05ae();
		glbMousePreviousXPos = di;
		glbMousePreviousYPos = si;
	}
	//^01B0:0788
	glbMouseButtonState = ((buttons >> 1) & 1) | ((buttons << 1) & 2);
	//^01B0:079D
	_04bf_0e7c = buttons ^ _04bf_1934;
	//^01B0:07A7
	if (_04bf_0e7c != 0 && _04bf_03c6 != 0) {
		//^01B0:07B2
		if ((_04bf_0e7c & 1) != 0) {
			//^01B0:07BA
			(this->*_04bf_179e)(di, si, ((buttons & 1) != 0) ? 2 : 4) INDIRECT_CALL;
		}
		//^01B0:07D0
		if ((_04bf_0e7c & 2) != 0) {
			//^01B0:07D8
			(this->*_04bf_179e)(di, si, ((buttons & 2) != 0) ? 1 : 8) INDIRECT_CALL;
		}
		//^01B0:07EE
		_04bf_1934 = buttons;
	}
	//^01B0:07F4
	return;
}

//^01B0:080B
void SkWinCore::UNLOCK_MOUSE_EVENT() //#DS=04BF
{
	//^01B0:080B
	LOADDS(0x3083)
	//^01B0:0819
	while (_04bf_17a4 > 0) {
		//^01B0:081B
		_04bf_17a4--;
		_04bf_179c = (_04bf_179c +1) % 10;
		//^01B0:082D
		Bit16u si = _04bf_17ac[_04bf_179c].w0;
		//^01B0:083B
		Bit16u bp02 = _04bf_17ac[_04bf_179c].w2;
		//^01B0:084C
		Bit16u di = _04bf_17ac[_04bf_179c].w4;
		//^01B0:085B
		IBMIO_MOUSE_EVENT_RECEIVER(bp02, di, si);
		//^01B0:0867
	}
	//^01B0:0870
	_04bf_0e7a--;
}

//^01B0:0AA8
void SkWinCore::_01b0_0aa8() //#DS=04BF
{
	//^01B0:0AA8
	LOADDS(0x3083);
	//^01B0:0AB3
	if ((_04bf_17a2--) == 1) {
		//^01B0:0ABF
		LOCK_MOUSE_EVENT();
		_01b0_05ae();
		//^01B0:0AC7
		glbMousePreviousXPos = glbMouseXPos;
		glbMousePreviousYPos = glbMouseYPos;
		//^01B0:0AD3
		UNLOCK_MOUSE_EVENT();
	}
	//^01B0:0AD7
}

//^443C:086B
void SkWinCore::FIRE_SHOW_MOUSE_CURSOR()
{
	//^443C:086B
	glbMouseVisibility--;
	//^443C:0872
	_01b0_0aa8() CALL_IBMIO;
}

//^443C:04B6
void SkWinCore::CHANGE_PLAYER_POS(Bit16u squadPos)
{
	//^443C:04B6
	Bit16u di = 1;
	//^443C:04BF
	if ((squadPos & 0x8000) != 0) {
		//^443C:04C6
		di = 0;
		squadPos &= 3;
	}
	//^443C:04CC
	__int16 si = GET_PLAYER_AT_POSITION((squadPos + glbPlayerDir) & 3);
	//^443C:04DF
	if (_4976_5dbc == 0) {
		//^443C:04E9
		if (si < 0)
			return;
		//^443C:04F0
		_4976_495c.cx = _4976_0118;
		_4976_495c.cy = _4976_011a;
		//^443C:04FC
		Bit8u *bp08 = ALLOC_PICT_BUFF(_4976_0118, _4976_011a, afDefault, 4);
		Bit8u *bp0c = ALLOC_PICT_BUFF(_4976_0118, _4976_011a, afDefault, 8);
		//^443C:0530
		Bit8u bp1c[16];
		QUERY_GDAT_SQUAD_ICON(bp08, (Bit8u)si, bp1c);
		//^443C:0544
		FILL_ENTIRE_PICT(bp0c, 0x000c);
		//^443C:0554
		FIRE_BLIT_PICTURE(
			bp08,
			bp0c,
			&_4976_495c,
			0,
			0,
			_4976_0118,
			_4976_0118,
			4,
			0,
			4,
			8,
			bp1c
			);
		//^443C:0585
		FIRE_HIDE_MOUSE_CURSOR();
		//^443C:058A
		IBMIO_SET_CURSOR_PATTERN(3, bp0c, 8, 6, _4976_0118, _4976_011a, 8, NULL, bp1c[12]) CALL_IBMIO;
		//^443C:05B5
		_01b0_0c70(3) CALL_IBMIO;
		//^443C:05C0
		FREE_PICT_BUFF(bp0c);
		//^443C:05CD
		FREE_PICT_BUFF(bp08);
		//^443C:05DA
		_4976_5dba = squadPos;
		_4976_5dbc = squadPos +1;
		//^443C:05E7
		FIRE_SHOW_MOUSE_CURSOR();
	}
	else {
		//^443C:05EE
		Bit16u bp02 = _4976_5dbc -1;
		_4976_5dbc = 0;
		//^443C:05FB
		Bit16u bp04 = GET_PLAYER_AT_POSITION((bp02 + glbPlayerDir) & 0x0003);
		//^443C:060C
		if (di != 0) {
			//^443C:0610
			glbChampionSquad[bp04].playerDir((Bit8u)glbPlayerDir);
		}
		//^443C:061F
		if (bp02 != squadPos) {
			//^443C:0627
			if (si >= 0) {
				//^443C:062B
				glbChampionSquad[si].playerPos((Bit8u)bp02);
			}
			//^443C:0642
			glbChampionSquad[bp04].playerPos((Bit8u)(squadPos + glbPlayerDir));
		}
	}
	//^443C:065A
	_443c_040e();
}

//^443C:0662
// SPX: _443c_0662 renamed CHAMPION_SQUAD_RECOMPUTE_POSITION
void SkWinCore::CHAMPION_SQUAD_RECOMPUTE_POSITION()
{
	//^443C:0662
	if (_4976_5dbc != 0) {
		//^443C:066C
		CHANGE_PLAYER_POS(_4976_5dba | 0x8000);
	}
	//^443C:0678
}

//^38C8:0002
void SkWinCore::_38c8_0002()
{
	//^38C8:0002
	//^38C8:0005
	if (_4976_5bec == 0 && glbGameHasEnded == 0) {
		//^38C8:0013
		_4976_5bec = 1;
		if (_4976_5dbc != 0) {
			//^38C8:0020
			CHAMPION_SQUAD_RECOMPUTE_POSITION();
			UPDATE_RIGHT_PANEL(0);
		}
		//^38C8:002D
		_1031_04f5();
		FIRE_HIDE_MOUSE_CURSOR();
		_12b4_0092();
		//^38C8:003C
		if (glbChampionInventory == 0) {
			//^38C8:0043
			FIRE_FILL_HALFTONE_RECTI(0x09, 0);
		}
		//^38C8:004E
		FIRE_FILL_HALFTONE_RECTI(0x0B, 0);
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^38C8:005E
	return;
}

//^2636:02F8
Bit8u *SkWinCore::QUERY_GDAT_TEXT(Bit8u cls1, Bit8u cls2, Bit8u cls4, Bit8u *buff)
{
	//^2636:02F8
	*buff = 0;
	Bit16u di = 0;
	Bit16u si = 0;
	//^2636:030B
	Bit8u *bp0e = QUERY_GDAT_ENTRY_DATA_BUFF(cls1, cls2, dtText, cls4);
	//^2636:0327
	if (bp0e != NULL) {
		//^2636:0348
		Bit8u *bp0a = ALLOC_MEMORY_RAM(
			di = si = QUERY_GDAT_ENTRY_DATA_LENGTH(cls1, cls2, dtText, cls4),
			0,
			1024
			);
		//^2636:0358
		COPY_MEMORY(bp0e, bp0a, si);
		//^2636:0377
		if (glbTextEntryEncoded != 0) {
			//^2636:037E
			Bit8u *bp04 = bp0a;
			Bit8u bp05 = 0;
			//^2636:038E
			while (di-- != 0) {
				//^2636:0390
				*bp04 = (*bp04 ^ 0xFF) - bp05;
				//^2636:039E
				bp05++;
				bp04++;
				//^2636:03A4
			}
		}
		//^2636:03AB
		FORMAT_SKSTR(bp0a, buff);
		//^2636:03BE
		DEALLOC_UPPER_MEMORY(si);
	}
	//^2636:03CA
	return buff;
}

//^0AAF:0067
Bit8u SkWinCore::_0aaf_0067(Bit8u cls2)
{
	//^0AAF:0067
	Bit16u di = 0;
	Bit16u si = 0xffff;
	Bit16u bp08 = 0;
	//^0AAF:0077
	Bit16u bp38[21];
	ZERO_MEMORY(&bp38[1], 2*20);
	//^0AAF:0088
	Bit8u bp5e[38];
	for (Bit8u bp0d = 0; bp0d < 0x14; bp0d++) {
		//^0AAF:008F
		if (*QUERY_GDAT_TEXT(0x1a, cls2, bp0d, (Bit8u *)bp5e) != 0) {
			//^0AAF:00B0
			Bit16u bp0a = QUERY_GDAT_ENTRY_DATA_INDEX(0x1a, cls2, dtWordValue, bp0d);
			//^0AAF:00C7
			Bit8u *bp04 = (Bit8u *)&bp38[1 + di];
			*bp04 = (Bit8u)bp0a;
			//^0AAF:00E2
			if (*bp04 == 0) {
				//^0AAF:00E6
				*bp04 = bp0d;
			}
			//^0AAF:00EF
			bp04[1] = (Bit8u)(bp0a >> 8);
			//^0AAF:00FC
			if (bp04[1] != 0) {
				//^0AAF:0100
				si = bp04[1];
				bp08 = bp04[0];
			}
			//^0AAF:0110
			di++;
		}
		//^0AAF:0111
	}
	//^0AAF:011D
	_4976_4bd2 = di;
	//^0AAF:0121
	if (si == 0xffff && di == 1) {
		//^0AAF:012B
		si = 1;
	}
	//^0AAF:012E
	_1031_0675(4);
	//^0AAF:0136
	Bit16u bp06;
	for (bp06 = 0; glbMouseVisibility > 0; bp06++) {
		//^0AAF:013D
		FIRE_SHOW_MOUSE_CURSOR();
		//^0AAF:0142
	}
	//^0AAF:014C
	_4976_4dfc = 0x00ff;

	do {
		MessageLoop(false);

		//^0AAF:0152
		MAIN_LOOP();
		WAIT_SCREEN_REFRESH();
		//^0AAF:015C
		if (si != 0xffff) {
			//^0AAF:0161
			if (_476d_04ed(si) != 0) {
				//^0AAF:016C
				_1031_0781(bp08 + 0x00db);
			}
		}
		//^0AAF:0179
		if (_4976_4dfc == 0x00ff && _476d_05a9() != 0 && _476d_050e() == 0x001c) {
			//^0AAF:0194
			_1031_0781(0x00db);
		}
		//^0AAF:019D
	} while (_4976_4dfc == 0x00ff);

	//^0AAF:01A5
	Bit8u bp0c = (Bit8u)bp38[_4976_4dfc];
	//^0AAF:01B8
	while ((bp06--) != 0) {
		//^0AAF:01BA
		FIRE_HIDE_MOUSE_CURSOR();
		//^0AAF:01BF
	}
	//^0AAF:01C9
	_4976_022c = 1;
	//^0AAF:01CF
	_1031_06a5();
	//^0AAF:01D4
	return bp0c;
}

//^2066:03E0
Bit16u SkWinCore::_2066_03e0(Bit16u xx)
{
	//^2066:03E0
	Bit16u di = xx;
	Bit8u bp01 = 0;
	//^2066:03ED
	if (_4976_499e != 0) {
		//^2066:03F4
		return 1;
	}
	//^2066:03F9
	Bit16u si = 1;
	//^2066:03FC
	if (_476d_030a(1) == 0) {
		//^2066:0408
		if (di != 2)
			return si;
	}
	//^2066:040D
	_4976_52f4 = 1;
	//^2066:0413
	while (di != 0 || _476d_030a(1) != 0) {
		//^2066:0415
		_38c8_0002();
		//^2066:041A
		di = si = 0;
		//^2066:0420
		_0aaf_0067(_0aaf_02f8((_4976_5c9c != 0) ? ((_4976_5ca8 != 0) ? (0x13) : (0x14)) : (0x07), bp01 = _476d_04e8(1)));
		//^2066:0453
		bp01 = 0x14;
		//^2066:0457
	}
	//^2066:0467
	return si;
}

//^2066:0002
void SkWinCore::SUPPRESS_INIT()
{
	//^2066:0002
	_4976_524e = _4976_5254 = 0;
}

//^3A15:0314
void SkWinCore::REARRANGE_TIMERLIST()
{
	// chain an unused timer entry to next unused timer entry.

	//^3A15:0314
	//^3A15:0319
	glbTimersActiveCount = 0;
	glbTimerIndexNextAvailable = 0xffff;
	//^3A15:0325
	Bit16u di;
	for (Bit16u si=0; si < glbTimersMaximumCount; si++) {
		//^3A15:0329
		if (glbTimersTable[si].TimerType() == tty00) {
			//^3A15:033D
			if (glbTimerIndexNextAvailable == TIMER_NONE) {	// 0xFFFF
				//^3A15:0344
				glbTimerIndexNextAvailable = si;
			}
			else {
				//^3A15:034A
				glbTimersTable[di].w0_0_f(si);
			}
			//^3A15:035A
			glbTimersTable[si].w0_0_f(0xffff);
			//^3A15:036C
			di = si;
		}
		else {
			//^3A15:0370
			glbTimersActiveCount = si+1;
		}
		//^3A15:0376
	}
	//^3A15:037D
	return;
}

//^3A15:008E
// SPX: _3a15_008e renamed __SORT_TIMERS
void SkWinCore::__SORT_TIMERS()
{
	//^3A15:008E
	//^3A15:0094
	Bit16u bp12 = glbTimersCount;
	//^3A15:009A
	if (bp12 != 0) {
		//^3A15:00A1
		for (Bit16u di = 0; di < bp12; di++) {
			//^3A15:00A5
			glbTimerNextEntries[di] = di;
			//^3A15:00B2
		}
		//^3A15:00B8
		if (bp12 != 1) {
			//^3A15:00C1
			for (__int16 bp0e = (bp12 -2) >> 1; bp0e >= 0; bp0e--) {
				//^3A15:00CE
				Bit16u di = bp0e;
				Timer *bp04 = &glbTimersTable[glbTimerNextEntries[di]];
				while (true) {
					//^3A15:00F3
					Bit16u si = (di << 1) + 1;
					//^3A15:00FA
					if (si >= bp12)
						break;
					//^3A15:0102
					Timer *bp08 = &glbTimersTable[glbTimerNextEntries[si]];
					//^3A15:0124
					if (si+1 < bp12) {
						//^3A15:012C
						Timer *bp0c = &glbTimersTable[glbTimerNextEntries[si+1]];
						//^3A15:014F
						if (_3a15_0381(bp04, bp08) != 0) {
							//^3A15:0167
							if (_3a15_0381(bp04, bp0c) != 0)
								//^3A15:017D
								break;
							//^3A15:017F
							si++;
						}
						else {
							//^3A15:0182
							if (_3a15_0381(bp0c, bp08) != 0)
								//^3A15:019A
								si++;
						}
					}
					else {
						//^3A15:019D
						if (_3a15_0381(bp04, bp08) != 0)
							//^3A15:01B3
							break;
					}
					//^3A15:01B5
					// SPX: This is a swap typical in sort algo
					Bit16u bp10 = glbTimerNextEntries[di];
					//^3A15:01C5
					glbTimerNextEntries[di] = glbTimerNextEntries[si];
					//^3A15:01DF
					glbTimerNextEntries[si] = bp10;
					//^3A15:01EF
					di = si;
				}
				//^3A15:01F4
			}
		}
	}
	//^3A15:0200
	_4976_4762 = -1;
	//^3A15:0206
	REARRANGE_TIMERLIST();
	//^3A15:020B
	return;
}

//^2636:000C
//SPX: This serves for Z000 variable replacement
Bit8u *SkWinCore::FORMAT_SKSTR(const Bit8u *format, Bit8u *output)
{
	//^2636:000C
	Bit8u *bp04;
	Bit8u *bp08;
	if (output != NULL) {
		//^2636:001A
		bp04 = bp08 = output;
	}
	else {
		//^2636:002F
		bp04 = bp08 = _4976_52ea[_4976_52f8];
		//^2636:004A
		_4976_52f8++;
		//^2636:004E
		if (_4976_52f8 >= 2) {
			//^2636:0059
			_4976_52f8 = 0;
		}
		//^2636:005F
	}
	Bit8u bp11;
	while ((bp11 = *format) != 0) {
		//^2636:0062
		Bit8u bp0116[128];
		if ((bp11 == '.' && format[1] == 'Z') || bp11 == 0x01) {
			__int16 si;
			//^2636:007B
			if (bp11 == 0x01) {
				//^2636:0081
				format++;
				si = *format - 32;
				format++;
			}
			else {
				//^2636:0095
				format += 2;
				si = 0;
				Bit16u di = 0;
				//^2636:009D
				while (di < 3) {
					//^2636:009F
					si = si * 10 + (*format) - '0';
					format++;
					di++;
					//^2636:00BA
				}
			}
			//^2636:00BF
			*bp04 = 0;
			Bit8u bp0096[128];
			Bit8u *bp0c = bp0096;
			Bit8u bp12 = 1;
			switch (si) {
				case 0x0000:	// .Z000
					{
						//^2636:00E5
						Bit32u bp10 = _4976_4be6;
						//^2636:0132
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x0001:	// .Z001
					{
						//^2636:00F2
						//^2636:012C
						Bit32u bp10 = ((-_4976_4742) + 1023) >> 10;
						//^2636:0132
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x0002:	// .Z002
					{
						//^2636:0149
						Bit8u bp13 = 0xFE;
						Bit8u bp14 = 0x00;
						//^2636:0161
						// SPX: would be 01/FE/00 = SKULLKEEP ?
						QUERY_GDAT_TEXT(bp12, bp13, bp14, bp0c);
						break;
					}
				case 0x0003:	// .Z003
					{
						//^2636:01AF
						//^2636:0244
						const Bit8u *bp0c = _4976_498e;
						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x0004:	// .Z004
					{
						//^B9 01
						//^2636:0244
						const Bit8u *bp0c = _4976_4992;
						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x0005:
					break;
				case 0x0006:
					break;
				case 0x0007:	// .Z007
					{
						//^2636:017E
						if (glbChampionBonesIndex == 0xFFFF)
							break;
						//^2636:0188
						bp0c = (Bit8u *)&glbChampionSquad[glbChampionBonesIndex];
						break;
					}
				case 0x0008:	// .Z008
					{
						//^2636:01C3
						//^2636:0244
						const Bit8u *bp0c = ptrDirLetter;
						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x0009:	// .Z009	Directory letter
					{
						//^2636:01CC
						//^2636:0244
						const Bit8u *bp0c = ptrDirLetter2;
						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x000a:	// .Z010
					{
						//^14 01
						Bit32u bp10 = glbItemWeightKg;
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x000b:	// .Z011
					{
						//^19 01
						Bit32u bp10 = glbItemWeightDg;
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x000c:	// .Z012
					{
						//^1E 01
						Bit32u bp10 = _4976_52e0;
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x000d:	// .Z013
					{
						//^23 01
						Bit32u bp10 = _4976_52fa;
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x000e:	// .Z014
					{
						//^28 01
						Bit32u bp10 = _4976_52f6;
						SK_LTOA10(bp10, bp0c);
						break;
					}
				case 0x000f:	// .Z015
					//^2636:019C
					{
						if (_4976_52f4 == 1) {
							//^2636:01AF
							//^2636:0244
							const Bit8u *bp0c = _4976_498e;
							//^2636:024A
							FORMAT_SKSTR(bp0c, bp0116);
							//^2636:025D
							SK_STRCAT(bp08, bp0116);
							//^2636:0271
							bp04 = bp08 +SK_STRLEN(bp08);
							continue;
						}
						if (_4976_52f4 == 2) {
							//^2636:01AD
							//^2636:01B9
							//^2636:0244
							const Bit8u *bp0c = _4976_4992;
							//^2636:024A
							FORMAT_SKSTR(bp0c, bp0116);
							//^2636:025D
							SK_STRCAT(bp08, bp0116);
							//^2636:0271
							bp04 = bp08 +SK_STRLEN(bp08);
							continue;
						}
						break;
					}
				case 0x0010:
					break;
				case 0x0011:	// .Z017
					{
						//^2636:0153
						bp12 = 7;
						Bit8u bp13 = 0;
						Bit8u bp14 = U8(_4976_52e4);
						//^2636:0161
						QUERY_GDAT_TEXT(bp12, bp13, bp14, bp0c);
						break;
					}
				case 0x0012:
					break;
				case 0x0013:
					break;
				case 0x0014:	// .Z020 : Data dir (E:DATA\)
					{
						//^DC 01
						//^2636:0244
						const Bit8u *bp0c = strZxxxTable[3];	// ".Z008DATA\"
						
						
						// SPX: the game folder (which is DATA by default) is changed from dungeon menu (need a restart)
						switch(skwin.dung)
						{
							case _OPTION_DUNGEON_DM1_KID_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM1_KID\\"; break;
							case _OPTION_DUNGEON_DM1_DM_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM1_DM\\"; break;
							case _OPTION_DUNGEON_DM1_CSB_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM1_CSB\\"; break;
							case _OPTION_DUNGEON_DM1_TQ_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM1_TQ\\"; break;
							case _OPTION_DUNGEON_DM2_DM_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM2_DM\\"; break;
							case _OPTION_DUNGEON_DM2_CSB_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM2_CSB\\"; break;
							case _OPTION_DUNGEON_DM2_TQ_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM2_TQ\\"; break;
							case _OPTION_DUNGEON_DM2_BETA_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM2_BETA\\"; break;
							case _OPTION_DUNGEON_DM2_DEMO_:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM2_DEMO\\"; break;
							case _OPTION_DUNGEON_DM2_SK:
								bp0c = (const unsigned __int8*) ".Z008DATA_DM2_SK\\"; break;
							case _OPTION_DUNGEON_NO_SPECIFIC_:
							default:
								bp0c = (const unsigned __int8*) ".Z008DATA\\"; break;
						} // END of specific block
						

						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x0015:
					break;
				case 0x0016:	// .Z022 : Data dir (E:DATA\) used for savegames (pc)
					{
						//^2636:01F9
						if (_4976_49a0 == 0) {
							//^2636:0209
							//^2636:0244
							const Bit8u *bp0c = strZxxxTable[6];
							//^2636:024A
							FORMAT_SKSTR(bp0c, bp0116);
							//^2636:025D
							SK_STRCAT(bp08, bp0116);
							//^2636:0271
							bp04 = bp08 +SK_STRLEN(bp08);
							continue;
						}
						else {
							//^2636:0200
							//^2636:0244
							const Bit8u *bp0c = strZxxxTable[5];
							// SPX: the game folder (which is DATA by default) is changed from dungeon menu (need a restart)
							switch(skwin.dung)
							{
								case _OPTION_DUNGEON_DM1_KID_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM1_KID\\"; break;
								case _OPTION_DUNGEON_DM1_DM_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM1_DM\\"; break;
								case _OPTION_DUNGEON_DM1_CSB_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM1_CSB\\"; break;
								case _OPTION_DUNGEON_DM1_TQ_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM1_TQ\\"; break;
								case _OPTION_DUNGEON_DM2_DM_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM2_DM\\"; break;
								case _OPTION_DUNGEON_DM2_CSB_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM2_CSB\\"; break;
								case _OPTION_DUNGEON_DM2_TQ_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM2_TQ\\"; break;
								case _OPTION_DUNGEON_DM2_BETA_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM2_BETA\\"; break;
								case _OPTION_DUNGEON_DM2_DEMO_:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM2_DEMO\\"; break;
								case _OPTION_DUNGEON_DM2_SK:
									bp0c = (const unsigned __int8*) ".Z008DATA_DM2_SK\\"; break;
								case _OPTION_DUNGEON_NO_SPECIFIC_:
								default:
									bp0c = (const unsigned __int8*) ".Z008DATA\\"; break;
							} // END of specific block
							//^2636:024A
							FORMAT_SKSTR(bp0c, bp0116);
							//^2636:025D
							SK_STRCAT(bp08, bp0116);
							//^2636:0271
							bp04 = bp08 +SK_STRLEN(bp08);
							continue;
						}
					}
				case 0x0017:	// .Z023 : Savegame number
					{
						//^2636:0218
						Bit8u bp16[] = {_4976_52e2, 0};
						//^2636:0222
						SK_STRCPY(bp0096, bp16);
						break;
					}
				case 0x0018:	// .Z024 : Dungeon letter (default nothing, or G (german) or F (french)
					{
						//^2636:0235
						//^2636:0244
						ATLASSERT(glbLangageLetterIndex < 8U);
						const Bit8u *bp0c = strZxxxTable[glbLangageLetterIndex];
						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x0019:	// .Z025
					{
						//^2636:010F
						Bit32u bp10 = _4976_4746;
						SK_LTOA10(bp10, bp0c);
					}
				case 0x001C:	// .Z028
					{
						//^2636:01D5
						if (_4976_5c9c != 0) {
							//^2636:01E5
							//^2636:0244
							const Bit8u *bp0c = strZxxxTable[7];	// ".Z009DATA\"
							//^2636:024A
							FORMAT_SKSTR(bp0c, bp0116);
							//^2636:025D
							SK_STRCAT(bp08, bp0116);
							//^2636:0271
							bp04 = bp08 +SK_STRLEN(bp08);
							continue;
						}
						else {
							//^2636:01DC
							//^2636:0244
							const Bit8u *bp0c = strZxxxTable[3];	// ".Z008DATA\"
							//^2636:024A
							FORMAT_SKSTR(bp0c, bp0116);
							//^2636:025D
							SK_STRCAT(bp08, bp0116);
							//^2636:0271
							bp04 = bp08 +SK_STRLEN(bp08);
							continue;
						}
					}
				case 0x001A:	// .Z026 : Dir used for graphics2
					{
						//^2636:01E5
						//^2636:0244
						const Bit8u *bp0c = strZxxxTable[7];	// ".Z009DATA\"
						//^2636:024A
						FORMAT_SKSTR(bp0c, bp0116);
						//^2636:025D
						SK_STRCAT(bp08, bp0116);
						//^2636:0271
						bp04 = bp08 +SK_STRLEN(bp08);
						continue;
					}
				case 0x001B:	// .Z027
					{
						//^2636:01EE
						Bit8u bp13 = 0xFE;
						Bit8u bp14 = 0x06;
						//^2636:0161
						QUERY_GDAT_TEXT(bp12, bp13, bp14, bp0c);
						break;
					}
#if DM2_EXTENDED_MODE == 1
				// SPX : Addition to handle PC9821
				case 0x0050:	// .Z080 : GDAT Platform version
					{
						const Bit8u *bp0c = (const Bit8u *) "_PC9821";
						if (skwin.gdat_vers != 0)
						{
							FORMAT_SKSTR(bp0c, bp0116);
							SK_STRCAT(bp08, bp0116);
							bp04 = bp08 +SK_STRLEN(bp08);
						}
						continue;
					}
				case 0x0051:	// .Z081 : GDAT Version number
					{
						
						if (skwin.gdat_vers == 3)	// ID_VERSION_V3 CLASSIC
						{
							const Bit8u *bpxx = (const Bit8u *) "_V3";
							FORMAT_SKSTR(bpxx, bp0116);
							SK_STRCAT(bp08, bp0116);
							bp04 = bp08 +SK_STRLEN(bp08);
						}
						if (skwin.gdat_vers == 4)	// ID_VERSION_V4 CLASSIC
						{
							const Bit8u *bpxx = (const Bit8u *) "_V4";
							FORMAT_SKSTR(bpxx, bp0116);
							SK_STRCAT(bp08, bp0116);
							bp04 = bp08 +SK_STRLEN(bp08);
						}
						if (skwin.gdat_vers == 6)	// ID_VERSION_V5_CARTOON
						{
							const Bit8u *bpxx = (const Bit8u *) "_V5";
							FORMAT_SKSTR(bpxx, bp0116);
							SK_STRCAT(bp08, bp0116);
							bp04 = bp08 +SK_STRLEN(bp08);
						}
						continue;
					}
				case 0x0052:	// .Z082 : GDAT Style
					{
						if (skwin.gdat_vers != 0 && skwin.gdat_vers < 5)
						{
							const Bit8u *bp0c = (const Bit8u *) "_CLASSIC";
							FORMAT_SKSTR(bp0c, bp0116);
							SK_STRCAT(bp08, bp0116);
							bp04 = bp08 +SK_STRLEN(bp08);
						}
						if (skwin.gdat_vers == 6)		// ID_VERSION_V5_CARTOON
						{
							const Bit8u *bp0c = (const Bit8u *) "_CARTOON";
							FORMAT_SKSTR(bp0c, bp0116);
							SK_STRCAT(bp08, bp0116);
							bp04 = bp08 +SK_STRLEN(bp08);
						}
						continue;
					}
#endif // DM2_EXTENDED_MODE
			}
			//^2636:024A
			FORMAT_SKSTR(bp0c, bp0116);
			//^2636:025D
			SK_STRCAT(bp08, bp0116);
			//^2636:0271
			bp04 = bp08 +SK_STRLEN(bp08);
			//^2636:028C
			continue;
		}
		//^2636:028E
		*bp04 = bp11;
		bp04++;
		format++;
		//^2636:029D
	}
	//^2636:02AD
	bp04[0] = 0;
	return bp08;
}

//^2066:033C
U16 SkWinCore::_2066_033c(void *buff, int size)
{
	//^2066:033C
	Bit32u bp04 = size;
	if (bp04 == 0)
		return 1;
	//^2066:0354
	return FILE_READ(glbDataFileHandle, bp04, buff);
}

//^2066:03A0
int SkWinCore::SKLOAD_READ(void *buff, int size)
{
	//^2066:03A0
	if (_2066_033c(buff, size) == 0)
		return 0;
	//^2066:03BB
	return 1;
}

//^3A15:0002
void SkWinCore::_3a15_0002()
{
	//^3A15:0002
	ENTER(4);
	//^3A15:0007
	glbTimersTable = reinterpret_cast<Timer *>(ALLOC_MEMORY_RAM(glbTimersMaximumCount * 10, afUseUpper, 0x400));
	glbTimerNextEntries = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(glbTimersMaximumCount << 1, afUseUpper, 0x400));
	if (glbSpecialScreen != 0) {
		Timer *bp04 = glbTimersTable;
		U16 si = 0;
		for (; si < glbTimersMaximumCount; bp04++) {
			//^3A15:005A
			bp04->TimerType(tty00);
			bp04->w0_0_f(++si);
			//^3A15:006A
		}
		//^3A15:0070
		glbTimersActiveCount = 0;
		bp04[-1].w0_0_f(0xffff);
		glbTimersCount = 0;
		glbTimerIndexNextAvailable = 0;
	}
	//^3A15:008B
	return;
}

//^2066:2498
void SkWinCore::DECIDE_DEFAULT_DUNGEON_MAP_CHIP_SET()
{
	//^2066:2498
	ENTER(208);
	//^2066:249E
	U8 bp00d0[MAXDEPTH1];
	U8 *bp04 = bp00d0;
	FILL_STR(bp04, MAXDEPTH1, '1', 1);
	X16 bp06 = 0;
	i16 si = 0;
	for (; dunHeader->nMaps > si; si++) {
		//^2066:24C5
		bp06 = max_value(dunMapsHeaders[si].Level(), bp06);
		//^2066:24E6
	}
	//^2066:24F4
	_4976_4c5c = ALLOC_MEMORY_RAM(bp06 +1, afUseUpper, 0x400);
	CHANGE_CURRENT_MAP_TO(0);
	ObjectID di = GET_TILE_RECORD_LINK(dunHeader->StartPartyPosX(), dunHeader->StartPartyPosY());
	for (; di != OBJECT_END_MARKER && di.DBType() != dbText; di = GET_NEXT_RECORD_LINK(di));
	//^2066:2552
	if (di != OBJECT_END_MARKER && GET_ADDRESS_OF_RECORD2(di)->TextMode() == 0) {
		//^2066:256F
		QUERY_MESSAGE_TEXT(bp04, di, 0x8002);
	}
	for (si = 0; si <= bp06; si++) {
		//^2066:2585
_2585:
		i8 bp07 = *(bp04++);
		switch (bp07) {
			case 0: //^_2585 // nul
			case 10: //^_2585 // line feed
			case 32: //^_2585 // spc
				goto _2585;
		}
		//^2066:25A2
		_4976_4c5c[si] = bp07 - '0';
		//^2066:25AE
	}
	//^2066:25B4
	return;
}

//^2066:25B8
int SkWinCore::READ_DUNGEON_STRUCTURE(X16 isNewGame)
{
	// Visit http://dmweb.free.fr/?q=node/217 for file format

	//^2066:25B8
	Bit16u bp04 = 0;
	Bit16u si = 0;
	__int16 di;
	Bit8u bp01 = 0;

	//SPX: Read the first 8 bytes of the dungeon.dat
	Bit8u bp26[8];
	if (FILE_READ(glbDataFileHandle, 8, bp26) == 0)
		return 0;
	//^2066:25DA
	//SPX: ? a magical number to make "the game is damaged" while reading it. What was the purpose? ...
	if (*(Bit16u *)bp26 == 0x8104)
		return 0;

	//SPX: Add control of DM1 gfx seed
	if (*(Bit16u *)bp26 == 0x0063) // DM1
		SkCodeParam::bDM1Mode = true;
	else if (*(Bit16u *)bp26 == 0x0D00) // CSB
		SkCodeParam::bDM1Mode = true;
	// SPX

	//^2066:25E4
	FILE_SEEK(glbDataFileHandle, _4976_524a);
	//^2066:25F8
	if (_4976_3b5d != 0) {
		//^2066:25FF
		dunHeader = reinterpret_cast<File_header *>(ALLOC_MEMORY_RAM(44, 1, 1024));
	}

	// - File header

	//^2066:2617
	if (SKLOAD_READ(dunHeader, 44) == 0)
		return 0;
	//^2066:262F
	si = dunHeader->w8;
	glbPlayerPosX = dunHeader->StartPartyPosX();// si & 0x001F;
	//^2066:263F
	si >>= 5;
	glbPlayerPosY = dunHeader->StartPartyPosY();// si & 0x001F;
	//^2066:264A
	glbPlayerDir = (si >> 5) & 0x0003;
	glbPlayerMap = 0;
	//^2066:265B
	__int16 nMaps = dunHeader->nMaps;	// bp10
	//^2066:2664
	// SPX: Alloc map header (x16), capped to 64 maps (64*16 = 1024 = 0x400)
	if (_4976_3b5d != 0) {
		//^2066:266B
		dunMapsHeaders = reinterpret_cast<Map_definitions *>(ALLOC_MEMORY_RAM(nMaps << 4, afUseUpper, 0x400));
	}

	// - Map definitions

	//^2066:2685
	if (SKLOAD_READ(dunMapsHeaders, nMaps << 4) == 0)
		return 0;
	//^2066:26A2
	if (_4976_3b5d != 0) {
		//^2066:26A9
		dunMapColumnsSumArray = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(nMaps << 1, afUseUpper, 0x400));
	}
	//^2066:26C5
	Bit16u bp0e = 0;
	//^2066:26CC
	for (si = 0; si < nMaps; si++) {
		//^2066:26CE
		dunMapColumnsSumArray[si] = bp0e;
		//^2066:26DE
		bp0e += dunMapsHeaders[si].Column();
		//^2066:26F7
	
		// SPX: adjustment for DM1 mode : put flags for activating gfx for pits, doors, etc ...
		if (SkCodeParam::bDM1Mode == true)
		{
			dunMapsHeaders[si].bGfxFlags = MAPGFX_FLAG__PIT_UPPER_ROOF | MAPGFX_FLAG__PIT_LOWER_GROUND | MAPGFX_FLAG__STAIRS_GOING_UP | MAPGFX_FLAG__STAIRS_GOING_DOWN | MAPGFX_FLAG__TELEPORTER | MAPGFX_FLAG__DOOR_0 | MAPGFX_FLAG__DOOR_1;
			dunMapsHeaders[si].w14 = (3 << 4); // tileset = 3 (keep)
		}
	}
	//^2066:26FD
	_4976_4cb4 = bp0e;
	//^2066:2703
	si = dunHeader->cwListSize;
	//^2066:270B
	if (isNewGame != 0) {
		//^2066:2711
		dunHeader->cwListSize += 300;
	}
	//^2066:2717
	if (_4976_3b5d != 0) {
		//^2066:271E
		dunMapTilesObjectIndexPerColumn = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(bp0e << 1, afUseUpper, 0x400));
		//^2066:273A
		dunGroundStacks = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(dunHeader->cwListSize << 1, afUseUpper, 0x400));
		//^2066:2754
		dunTextData = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(dunHeader->cwTextData << 1, afUseUpper, 0x400));
	}

	// - Index of tiles with objects on them (per column)

	//^2066:277C
	if (SKLOAD_READ(dunMapTilesObjectIndexPerColumn, bp0e << 1) == 0)
		return 0;

	// - List of object IDs of first objects on tiles

	//^2066:2798
	if (SKLOAD_READ(dunGroundStacks, si << 1) == 0)
		return 0;
	//^2066:27B3
	if (isNewGame != 0) {
		//^2066:27B9
		for (di = 0; di < 300; si++, di++) {
			//^2066:27BD
			dunGroundStacks[si] = 0xffff;
			//^2066:27CC
		}
	}

	// - Text Data

	//^2066:27D4
	if (SKLOAD_READ(dunTextData, dunHeader->cwTextData << 1) == 0)
		return 0;
	//^2066:27F5
	if (_4976_5bf2 == 0) {
		//^2066:27FC
		glbTimersMaximumCount = MAX_TIMER_NUMBER;	// = 50
	}

	// - List of XXX

	//^2066:2802
	for (si = 0; si < 16; si++) {
		//^2066:2807
		Bit16u di = dunHeader->nRecords[si];
		if (isNewGame != 0) {
			//^2066:281B
			dunHeader->nRecords[si] = min_value((si == dbCloud) ? 0x300 : 0x400, _4976_0252[RCJ(16,si)] + di);
		}
		//^2066:2849
		Bit16u bp0e = glbItemSizePerDB[si];
		if (_4976_3b5d != 0) {
			//^2066:2859
			glbDBObjectData[si] = ALLOC_MEMORY_RAM(dunHeader->nRecords[si] * bp0e, afUseUpper, 0x400);
		}
		//^2066:2887
		Bit16u *bp04 = (Bit16u *)glbDBObjectData[si];
		if (SKLOAD_READ(glbDBObjectData[si], bp0e * di) == 0)
			return 0;
		//^2066:28BB
		if (_4976_5bf2 == 0) {
			//^2066:28C2
			if (si == 4 || si >= 14) {
				//^2066:28CC
				glbTimersMaximumCount += dunHeader->nRecords[si];
			}
		}
		//^2066:28E0
		if (isNewGame != 0) {
			//^2066:28E6
			bp0e >>= 1;
			bp04 += di * bp0e;
			//^2066:28F5
			for (di = _4976_0252[RCJ(16,si)]; di != 0; di--) {
				*bp04 = 0xffff;
				bp04 += bp0e;
			}
		}
		//^2066:2914
	}
	//^2066:291D
	if (_4976_3b5d != 0) {
		//^2066:2924
		dunMapData = ALLOC_MEMORY_RAM(dunHeader->cbMapData, afUseUpper, 0x400);
	}

	// - Map data

	//^2066:2942
	if (SKLOAD_READ(dunMapData, dunHeader->cbMapData) == 0)
		return 0;
	//^2066:2960
	if (_4976_3b5d != 0) {
		//^2066:296A
		// SPX: 0x400 = 32*32 tiles / bp10 = #maps / _4976_4cb4 = #cols for all maps
		glbMapTileValue = reinterpret_cast<U8 ***>(ALLOC_MEMORY_RAM((_4976_4cb4 + nMaps) * sizeof(void *), afUseUpper, 0x400));
		//^2066:298A
		Bit8u ***bp08 = &glbMapTileValue[nMaps];
		//^2066:299C
		for (di = 0; di < nMaps; di++) {
			//^2066:29A1
			// MARK SPX
			glbMapTileValue[di] = reinterpret_cast<U8 **>(bp08);
			//^2066:29B9
			Bit8u *bp0c = &dunMapData[dunMapsHeaders[di].w0];
			*bp08 = reinterpret_cast<U8 **>(bp0c);
			bp08++;
			//^2066:29E2
			for (si = 1; dunMapsHeaders[di].Column() -1 >= si; si++) {
				//^2066:29E7
				bp0c += dunMapsHeaders[di].Row();
				*bp08 = reinterpret_cast<U8 **>(bp0c);
				bp08++;
				//^2066:2A14
			}
			//^2066:2A2E
		}
	}
	//^2066:2A37
	_4976_5c24 = BETWEEN_VALUE(0, QUERY_GDAT_ENTRY_DATA_INDEX(0x03, 0x00, 0x0B, 0x00), 23) * 0x0555UL;
	//^2066:2A6A
	if (_4976_3b5d != 0) {
		//^2066:2A71
		_3a15_0002();
	}
	//^2066:2A76
	_3df7_0037(!_4976_3b5d);
	//^2066:2A85
	if (_4976_3b5d != 0) {
		//^2066:2A8C
		//!ALT
		_4976_4cb0 = ALLOC_MEMORY_RAM(MAXDEPTH, afUseUpper, 0x400);
		//^2066:2AA4
		//!ALT
		_4976_4c72 = ALLOC_MEMORY_RAM(MAXDEPTH + MAXMAPS, afUseUpper, 0x400);
	}
	//^2066:2ABC
	Bit8u *bp18 = _4976_4c72;
	Bit8u *bp1c = _4976_4cb0;
	Bit16u bp14 = 0;
	*bp1c = 0;
	bp1c++;
	//^2066:2AE4
	for (Bit16u bp12 = 0; bp12 < MAXDEPTH; bp1c++, bp12++) {
		//^2066:2AEB
		for (Bit16u bp1e = 0; bp1e < nMaps; bp1e++) {
			//^2066:2AF2
			if (dunMapsHeaders[bp1e].Level() == bp12) {
				//^2066:2B0A
				*bp18 = (Bit8u)bp1e;
				bp18++;
				bp14++;
			}
			//^2066:2B19
		}
		//^2066:2B24
		*bp18 = 0xff;
		bp18++;
		bp14++;
		*bp1c = (Bit8u)bp14;
		//^2066:2B3A
	}
	ATLASSERT(bp1c - _4976_4cb0 <= MAXDEPTH + 1U);
	ATLASSERT(bp18 - _4976_4c72 <= MAXDEPTH + MAXMAPS + 1U);

	//^2066:2B46
	if (isNewGame != 0) {
		//^2066:2B4C
		ARRANGE_DUNGEON();
	}
	//^2066:2B50
	if (_4976_3b5d != 0) {
		//^2066:2B57
		DECIDE_DEFAULT_DUNGEON_MAP_CHIP_SET();
	}
	//^2066:2B5B
	_4976_3b5d = 0;
	//^2066:2B64

	//CHECK_TILE_RECORDS();

	return 1;
}

void SkWinCore::CHECK_TILE_RECORDS() {
	// check sort order: dbDoor < dbTele < dbText < dbActu == db11 == db12 == db13 < dbCreature < ...
	for (int z = 0; z < dunHeader->nMaps; z++) {
		CHANGE_CURRENT_MAP_TO(z);
		for (int x = 0; x < glbCurrentMapWidth; x++) {
			for (int y = 0; y < glbCurrentMapHeight; y++) {
				ObjectID rl = GET_TILE_RECORD_LINK(x, y);
				if (rl != OBJECT_NULL) {
					int lastDBtype = -1;
					while (rl != OBJECT_END_MARKER && (lastDBtype = rl.DBType()) <= dbActuator) {
						rl = GET_NEXT_RECORD_LINK(rl);
					}
					while (rl != OBJECT_END_MARKER) {
						ATLASSERT(rl.DBType() > dbActuator);
						rl = GET_NEXT_RECORD_LINK(rl);
					}
				}
			}
		}
	}
}

//^2066:01C3
int SkWinCore::SUPPRESS_READER(void *_data, const void *_mask, Bit16u buffSize, Bit32u repeat, Bit16u fill)
{
	Bit8u *data = reinterpret_cast<Bit8u *>(_data);
	const Bit8u *mask = reinterpret_cast<const Bit8u *>(_mask);

	//^2066:01C3
	Bit32u bp0a = 0;
	Bit8u bp04 = _4976_5254;
	Bit8u bp05 = _4976_524e;
	//^2066:01E8
	for (Bit32u bp0e = 0; bp0e < repeat; ) {
		//^2066:01EB
		for (Bit16u si = 0; si < buffSize; si++) {
			//^2066:01F0
			Bit8u bp03 = (fill != 0) ? 0 : (*data);
			//^2066:0205
			Bit8u bp02 = *mask;
			mask++;
			//^2066:0211
			if (bp02 != 0) {
				//^2066:021A
				for (__int8 bp01 = 0x07; bp01 >= 0; bp01--) {
					//^2066:0221
					if (((1 << bp01) & bp02) != 0) {
						//^2066:0232
						if (bp05 == 0) {
							//^2066:0238
							Bit8u bp0f;
							if (FILE_READ(glbDataFileHandle, 1, &bp0f) == 0)
								return 1;
							//^2066:0257
							bp04 = bp0f;
						}
						//^2066:025D
						if ((bp04 & 0x80) != 0) {
							//^2066:0263
							bp04 = (bp04 << 1) | 1;
							bp03 = (1 << bp01) | bp03;
						}
						else {
							//^2066:027B
							bp04 <<= 1;
							bp03 = bp03 & (~(1 << bp01));
						}
						//^2066:028C
						bp0a++;
						bp05++;
						//^2066:029F
						if (bp05 == 8) {
							//^2066:02A3
							bp05 = 0;
						}
					}
					//^2066:02A7
				}
			}
			//^2066:02B3
			*data = bp03;
			data++;
			//^2066:02BF
		}
		//^2066:02C8
		mask -= buffSize;
		bp0e++;
		//^2066:02D6
	}
	//^2066:02EE
	_4976_5254 = bp04;
	_4976_524e = bp05;
	_4976_5258 = bp0a;

	s_testSKSave.Read(_data, _mask, buffSize, repeat);
	return 0;
}

//^2066:030D
int SkWinCore::READ_1BIT(Bit16u *pw)
{
	//^2066:030D
	Bit8u bp01;
	//^2066:0312
	Bit16u si = SUPPRESS_READER(&bp01, glbByte01, 1, 1, 1);
	*pw = bp01;
	return si;
}

//^2066:0569
void SkWinCore::ADD_MINION_ASSOC(ObjectID recordLink)
{
	//^2066:0569
	glbMinionsObjectIDTable[glbMinionsAssocCount] = recordLink;
	//^2066:057D
	glbMinionsAssocCount++;
}

//^2066:15AA
int SkWinCore::READ_RECORD_CHECKCODE(__int16 xpos, __int16 ypos, ObjectID *recordLinkPtr, Bit16u readDir, Bit16u readSub)
{
	// readDir=(read-direction-in-record-link)
	// readSub=(read-subsequent-records)

	//^2066:15AA
	while (true) {
		//^2066:15B0
		Bit16u bp0e;
		if (READ_1BIT(&bp0e) != 0) // read#more-record
			return 1;
		//^2066:15C2
		if (bp0e == 0)
			break;
		//^2066:15CB
		Bit8u bp0c = 0x0f;
		Bit8u bp0b;
		//^2066:15CF
		if (SUPPRESS_READER(&bp0b, &bp0c, 1, 1, 1) != 0) // read#dbtype
			return 1;
		//^2066:15EF
		Bit16u di = bp0b;
		Bit16u bp0a;
		if (readDir != 0 && di != dbCreature) {
			//^2066:1601
			bp0c = 0x03;
			//^2066:1605
			if (SUPPRESS_READER(&bp0b, &bp0c, 1, 1, 1) != 0)
				return 1;
			//^2066:1625
			bp0a = bp0b;
		}
		else {
			//^2066:162F
			bp0a = 0;
		}
		//^2066:1634
		if (di == dbCloud && _4976_3b59 != 0) {
			//^2066:1640
			Bit16u bp10 = 0x7f;
			//^2066:1645
			if (SUPPRESS_READER(&bp0e, &bp10, 2, 1, 1) != 0)
				return 1;
			//^2066:1665
			bp0e = bp0e;
			if (recordLinkPtr == NULL)
				break;
			//^2066:1676
			*recordLinkPtr = 0xff80 | bp0e;
			break;
		}
		//^2066:1685
		ObjectID si = ALLOC_NEW_RECORD(di);
		// SPX : Isn't possible to read a savegame having FFFE or FFFF?
		// SPX : I disable here the assert because it prevents loading some savegames.
		if (!SkCodeParam::bUsePowerDebug)
			ATLASSERT(si != OBJECT_END_MARKER && si != OBJECT_NULL);
		
		si.Dir(bp0a);
		//^2066:169E
		APPEND_RECORD_TO(si, recordLinkPtr, xpos, ypos);
		//^2066:16B3
		void *bp04 = GET_ADDRESS_OF_RECORD(si);
		//^2066:16C0
		const void *bp08 = tableMask[di];
		if (bp08 != NULL) {
			//^2066:16DA
			Bit16u bp12 = 0;
			//^2066:16DF
			switch (di) {
				case dbCreature:
					{
						//^2066:16F6
						bp0c = 0x7f;
						if (SUPPRESS_READER(&bp0b, &bp0c, 1, 1, 1) != 0)
							return 1;
						//^2066:171A
						reinterpret_cast<Creature *>(bp04)->b4 = bp0b;
						//^2066:1724
						if ((QUERY_CREATURE_AI_SPEC_FLAGS(si) & 1) != 0)
							//^2066:1730
							bp08 = _4976_3ac7;
						break;
					}
				case dbContainer:
					{
						//^2066:173A
						bp0c = 0x03;
						if (SUPPRESS_READER(&bp0b, &bp0c, 1, 1, 1) != 0)
							return 1;
						//^2066:175E
						reinterpret_cast<Container *>(bp04)->ContainerType(bp0b);
						//^2066:1774
						if (IS_CONTAINER_MAP(si) != 0) {
							//^2066:177F
							bp08 = _4976_3aef;
							bp12 = 1;
						}
						break;
					}
				case dbMissile:
					{
						//^2066:178E
						if (_4976_3b5b != 0) {
							//^2066:1795
							bp08 = _4976_3b0b;
							bp12 = 1;
						}
						break;
					}
			}
			//^2066:17A2
			if (SUPPRESS_READER(bp04, bp08, glbItemSizePerDB[di], 1, 0) != 0)
				return 1;
			//^2066:17C9
			switch (di) {
				case dbCreature:
					{
						//^2066:17DD
						_4976_3b5b = 1;
						reinterpret_cast<Creature *>(bp04)->possession = OBJECT_END_MARKER;	// 0xFFFE
						if (READ_RECORD_CHECKCODE(
							-1,
							0,
							&reinterpret_cast<GenericContainerRecord *>(bp04)->possession,
							(bp08 != _4976_3ab7) ? 1 : 0,
							1
							) != 0
						) {
							return 1;
						}
						//^2066:181F
						_4976_3b5b = 0;
						break;
					}
				case dbContainer:
					{
						//^2066:1828
						if (bp12 != 0) {
							Bit16u bp14;
							//^2066:182E
							if (READ_1BIT(&bp14) != 0)
								return 1;
							//^2066:1840
							if (bp14 != 0) {
								//^2066:1846
								//^2066:18B2
								ADD_MINION_ASSOC(si);
							}
							//^2066:1848
							reinterpret_cast<Container *>(bp04)->w2 = OBJECT_END_MARKER;	// 0xFFFE
						}
						else {
							//^2066:1854
							if (IS_CONTAINER_MONEYBOX(si) != 0) {
								//^2066:185F
								tableMask[dbMiscellaneous_item] = _4976_3afb;
							}
							//^2066:1869
							reinterpret_cast<Container *>(bp04)->w2 = OBJECT_END_MARKER;	// 0xFFFE
							//^2066:1872
							if (READ_RECORD_CHECKCODE(-1, 0, &reinterpret_cast<Container *>(bp04)->w2, 0, 1) != 0)
								return 1;
							//^2066:1891
							if (IS_CONTAINER_MONEYBOX(si) == 0)
								break;
							//^2066:189F
							tableMask[dbMiscellaneous_item] = _4976_3af7;
							break;
						}
						break;
					}
				case dbMissile:
					{
						//^2066:18AC
						if (bp12 != 0) {
							//^2066:18B2
							ADD_MINION_ASSOC(si);
						}
						else {
							//^2066:18BB
							glbTimersTable[reinterpret_cast<Missile *>(bp04)->TimerIndex()].value = si;
							//^2066:18D1
							reinterpret_cast<Missile *>(bp04)->w2 = OBJECT_END_MARKER;	// 0xFFFE
							_4976_3b59 = 1;
							//^2066:18E0
							if (READ_RECORD_CHECKCODE(-1, 0, &reinterpret_cast<Missile *>(bp04)->w2, 0, 0) != 0)
								return 1;
							//^2066:18FC
							_4976_3b59 = 0;
						}
						break;
					}
				case dbCloud:
					{
						//^2066:1904
						if (READ_1BIT(&bp0e) != 0)
							return 1;
						//^2066:1913
						if (bp0e == 0)
							break;
						//^2066:1919
						Bit16u bp10 = 0x03ff;
						//^2066:191E
						if (SUPPRESS_READER(&bp0e, &bp10, 2, 1, 1) != 0)
							return 1;
						//^2066:193B
						bp0e = bp0e;
						glbTimersTable[bp0e].w8 = si;
						break;
					}
			}
		}
		//^2066:1950
		if (readSub == 0)
			break;
    }
	//^2066:1959
	return 0;
}

//^0CEE:0897
U8 SkWinCore::_0cee_0897(Teleporter **ref, i16 xx, i16 yy)
{
	//^0CEE:0897
	ENTER(0);
	//^0CEE:089B
	if ((GET_TILE_VALUE(xx, yy) >> 5) == ttTeleporter) {
		//^0CEE:08B0
		ObjectID si = GET_TILE_RECORD_LINK(xx, yy);
		*ref = GET_ADDRESS_OF_RECORD1(si);
		while ((si = GET_NEXT_RECORD_LINK(si)) != OBJECT_END_MARKER) {
			//^0CEE:08D2
			if (si.DBType() != dbActuator)
				continue;
			if (GET_ADDRESS_OF_ACTU(si)->ActuatorType() != ACTUATOR_FLOOR_TYPE__CROSS_SCENE) // 0x27: Cross scene
				continue;
			//^0CEE:08F6
			return (((*ref)->Rotation() +2)&3) +1;
			//^0CEE:090E
		}
	}
	//^0CEE:091C
	return 0;
}

//^0CEE:0921
U8 SkWinCore::GET_TELEPORTER_DETAIL(TELE_inf *ref, i16 xx, i16 yy)
{
	//^0CEE:0921
	ENTER(10);
	//^0CEE:0927
	X16 si = 0;
	Teleporter *bp06;
	U8 bp01 = _0cee_0897(&bp06, xx, yy);
	if (bp01 != 0) {
		//^0CEE:0945
		X16 di = glbCurrentMapIndex;
		CHANGE_CURRENT_MAP_TO(bp06->b5_0_7());
		Teleporter *bp0a;
		U8 bp02 = _0cee_0897(&bp0a, bp06->DestinationX(), bp06->DestinationY());
		if (bp02 != 0) {
			//^0CEE:0982
			si = 1;
			ref->b0 = bp01 -1;
			ref->b1 = bp02 -1;
			ref->b2 = bp06->DestinationX();
			ref->b3 = bp06->DestinationY();
			ref->b4 = bp06->b5_0_7();
		}
		//^0CEE:09CF
		CHANGE_CURRENT_MAP_TO(di);
	}
	//^0CEE:09D5
	return U8(si);
}

//^2066:197C
Bit16u SkWinCore::_2066_197c()
{
	//^2066:197C
	ENTER(4);
	//^2066:1981
	Timer *bp04 = glbTimersTable;
	//^2066:198E
	for (Bit16u si = 0; si < glbTimersCount; bp04++, si++) {
		//^2066:1992
		switch (bp04->TimerType()) {
			case tty3C:
			case tty3D:
				//^2066:19A3
				if (_4976_5244 == 0) {
					//^2066:19AA
					return 1;
				}
				//^2066:19AF
				bp04->w8 = 0xfffe;
				//^2066:19B8
				if (READ_RECORD_CHECKCODE(-1, 0, bp04->pv8_0_f(), 0, 0) != 0)
					//^2066:19D5
					//^2066:19AA
					return 1;

				break;
		}
		//^2066:19D7
	}
	//^2066:19E2
	return 0;
}

//^2066:062B
Bit16u SkWinCore::RECOVER_MINION_ASSOC()
{
	//^2066:062B
	ENTER(12);
	//^2066:0631
	Bit16u bp0a = glbMinionsAssocCount;
	//^2066:0637
	ObjectID *bp04 = glbMinionsObjectIDTable;
	//^2066:0644
	for (; bp0a-- != 0; ) {
		//^2066:0647
		ObjectID di = *bp04; bp04++;
		//^2066:0651
		GenericRecord *bp08 = GET_ADDRESS_OF_RECORD(di);
		//^2066:065E
		switch (di.DBType()) {
			case dbContainer:
				{
					//^2066:0672
					Bit16u bp0e = 0x03ff;
					//^2066:0677
					Bit16u bp0c;
					if (SUPPRESS_READER(&bp0c, &bp0e, 2, 1, 1) != 0)
						//^2066:0692
						//^2066:06E1
						return 1;
					//^2066:0694
					Bit16u si = bp0c;
					bp08->castToContainer()->SetContainedObject(ObjectID(0, dbCreature, si));

					break;
				}
			case dbMissile:
				{
					//^2066:069F
					Bit16u bp0e = 0x03ff;
					//^2066:06A4
					Bit16u bp0c;
					if (SUPPRESS_READER(&bp0c, &bp0e, 2, 1, 1) != 0)
						//^2066:06BF
						//^2066:06E1
						return 1;
					//^2066:06C1
					Bit16u si = bp0c;
					bp08->castToMissile()->SetMissileObject(ObjectID(0, dbContainer, si));
				}
		}
		//^2066:06D0
	}
	//^2066:06DD
	return 0;
}

//^2066:19E7
U16 SkWinCore::READ_SKSAVE_DUNGEON()
{
	//^2066:19E7
	Bit16u si;
	for (si=0; si < glbChampionsCount; si++) {
		//^2066:19F1
		ObjectID *bp08 = &glbChampionSquad[si].inventory[0];
		//^2066:1A01
		for (Bit16u di=0; di < 30; di++) {
			//^2066:1A05
			*bp08 = OBJECT_END_MARKER; bp08++;
			//^2066:1A11
		}
		//^2066:1A17
	}
	//^2066:1A1E
	glbLeaderHandPossession.object = OBJECT_END_MARKER;
	Bit16u bp18 = glbCurrentMapIndex;
	//^2066:1A2A
	Bit16u bp16;
	for (bp16=0; dunHeader->nMaps > bp16; bp16++) {
		//^2066:1A32
		CHANGE_CURRENT_MAP_TO(bp16);
		//^2066:1A3B
		for (Bit16u bp0e=0; bp0e < glbCurrentMapWidth; bp0e++) {
			//^2066:1A42
			for (Bit16u bp10=0; bp10 < glbCurrentMapHeight; bp10++) {
				//^2066:1A49
				ObjectID bp12 = GET_TILE_RECORD_LINK(bp0e, bp10);
				while (bp12 != OBJECT_END_MARKER) {
					//^2066:1A58
					if (bp12.DBType() > dbActuator) {
						//^2066:1A66
						GET_ADDRESS_OF_RECORD(bp12)->w0 = OBJECT_END_MARKER;
						//^2066:1A78
						CUT_RECORD_FROM(bp12, NULL, bp0e, bp10);
						break;
					}
					else {
						//^2066:1A8F
						bp12 = GET_NEXT_RECORD_LINK(bp12);
					}
					//^2066:1A9B
				}
				//^2066:1AA1
			}
			//^2066:1AAD
		}
		//^2066:1AB9
	}
	//^2066:1ACE
    CHANGE_CURRENT_MAP_TO(bp18);
	//^2066:1AD7
	for (si = dbCreature; si < dbMax; si++) {
		//^2066:1ADC
		Bit16u *bp08 = reinterpret_cast<Bit16u *>(glbDBObjectData[si]);
		//^2066:1AEF
		Bit16u bp1a = glbItemSizePerDB[si] >> 1;
		for (Bit16u di = dunHeader->nRecords[si]; di-- != 0; bp08 += bp1a) {
			//^2066:1B0A
#if (DM2_EXTENDED_DATABASE == 1)
			if (si == db11 || si == db12 || si == db13)
				continue;
#endif
			reinterpret_cast<GenericRecord *>(bp08)->w0 = OBJECT_NULL;
			//^2066:1B12
		}
		//^2066:1B21
	}
	//^2066:1B27
	glbMinionsObjectIDTable = reinterpret_cast<ObjectID *>(ALLOC_MEMORY_RAM(200, afDefault, 1024));
	//^2066:1B40
	glbMinionsAssocCount = 0;
	//^2066:1B46
	for (si = 0; si < glbChampionsCount; si++) {
		//^2066:1B4A
		ObjectID *bp08 = &glbChampionSquad[si].inventory[0];
		//^2066:1B5A
		for (Bit16u di = 0; di < 30; di++) {
			//^2066:1B5E
			if (READ_RECORD_CHECKCODE(-1, 0, bp08++, 0, 0) != 0) {
				//^2066:1B7C
				goto _1e7e;
			}
			//^2066:1B7F
		}
		//^2066:1B85
	}
	//^2066:1B8C
	if (READ_RECORD_CHECKCODE(-1, 0, &glbLeaderHandPossession.object, 0, 0) != 0) {
		//^2066:1BA3
		goto _1e7e;
	}
	//^2066:1BA6
	for (si = 0; si < glbChampionsCount; si++) {
		//^2066:1BAA
		ObjectID *bp08 = &glbChampionSquad[si].inventory[0];
		//^2066:1BBA
		for (Bit16u di = 0; di < 30; di++, bp08++) {
			//^2066:1BBE
			if (*bp08 == OBJECT_END_MARKER) {
				//^2066:1BC7
				*bp08 = OBJECT_NULL;
			}
			else {
				//^2066:1BCE
				PROCESS_ITEM_BONUS(si, *bp08, di, 0);
			}
			//^2066:1BE0
		}
		//^2066:1BEA
	}
	//^2066:1BF1
	if (glbLeaderHandPossession.object == OBJECT_END_MARKER) {
		//^2066:1BF8
		glbLeaderHandPossession.object = OBJECT_NULL;
	}
	else {
		//^2066:1C00
		PROCESS_ITEM_BONUS(glbChampionLeader, glbLeaderHandPossession.object, -1, 0);
	}
	//^2066:1C14
	if (_2066_197c() != 0) {
		//^2066:1C1C
		goto _1e7e;
	}
	//^2066:1C1F
	bp18 = glbCurrentMapIndex;
	for (bp16 = 0; dunHeader->nMaps > bp16; bp16++) {
		//^2066:1C2D
		CHANGE_CURRENT_MAP_TO(bp16);
		Bit8u *bp04 = *glbCurrentTileMap;
		for (Bit16u bp0e = 0; bp0e < glbCurrentMapWidth; bp0e++) {
			//^2066:1C4F
			for (Bit16u bp10 = 0; bp10 < glbCurrentMapHeight; bp10++) {
				//^2066:1C57
				Bit8u bp13 = *bp04;
				Bit16u bp24 = 0;
				Bit8u bp1b;
				switch (bp13 >> 5) {
					case ttWall:
					case ttFloor:
					case ttStairs:
					case ttMapExit:
						//^2066:1C7A
						bp1b = 0x00; break;
					case ttPit:
						//^2066:1C80
						bp1b = 0x08; break;
					case ttDoor:
						//^2066:1C86
						bp1b = 0x07; break;
					case ttTeleporter:
						{
							//^2066:1C8C
							TELE_inf bp2a;
							if (GET_TELEPORTER_DETAIL(&bp2a, (Bit8u)bp0e, (Bit8u)bp10) != 0) {
								//^2066:1CA3
								bp1b = 0x00;
								if (bp2a.target_z() < bp16) {
									//^2066:1CB1
									bp24 = 1;
								}
							}
							else {
								//^2066:1CB8
								bp1b = 0x08;
							}
							break;
						}
					case ttTrickWall:
						bp1b = 0x04; break;
				}
				//^2066:1CC2
				if (bp1b != 0) {
					if (SUPPRESS_READER(bp04, &bp1b, 1, 1, 0) != 0) {
						//^2066:1CE6
						goto _1e7e;
					}
				}
				//^2066:1CE9
				bp04++;

				// SkD((DLV_FYI, "DBG: (%2d,%2d,%2d,%02X)\n", bp16, bp0e, bp10, 0U +bp13));
				//^2066:1CEC
				if (bp24 == 0) {
					//^2066:1CF5
					ObjectID bp12 = GET_TILE_RECORD_LINK(bp0e, bp10);
					//^2066:1D02
					for (; bp12 != OBJECT_END_MARKER; bp12 = GET_NEXT_RECORD_LINK(bp12)) {
						//^2066:1D05
						// SkD((DLV_FYI, "DBG: #%04X\n", 0U +bp12.w));
						Bit16u bp22 = bp12.DBType();
						const void *bp0c = tableMask[bp22];
						//^2066:1D25
						if (bp0c == NULL)
							continue;
						//^2066:1D2C
						Actuator *bp08 = (Actuator *)GET_ADDRESS_OF_RECORD(bp12);
						if (bp22 == dbActuator) {
							//^2066:1D44
							// SkD((DLV_FYI, "DBG: T  %02X\n", 0U +bp08->ActuatorType()));
							switch (bp08->ActuatorType()) {
								case ACTUATOR_FLOOR_TYPE__CROSS_SCENE: // 0x27: Cross scene
								case ACTUATOR_TYPE_X1B: // 0x1B: -
								case ACTUATOR_TYPE_COUNTER: // 0x1D: Activator, counter
								case ACTUATOR_TYPE_ORNATE_STEP_ANIMATOR: // 0x41: Ornate step animator
								case ACTUATOR_TYPE_ORNATE_ANIMATOR: // 0x2C: Continuous ornate animator
								case ACTUATOR_TYPE_ORNATE_ANIMATOR_2: // 0x32: Activator, ornate animator
								case ACTUATOR_FLOOR_TYPE__SHOP: // 0x30: Shop exhibition
								case ACTUATOR_FLOOR_TYPE__FINITE_ACTIVATOR_RELAY: // 0x2D: Activator, finite activator relay
									//^2066:1DA7
									Bit16u bp1e;
									Bit16u bp20 = 0x01FF;
									if (SUPPRESS_READER(&bp1e, &bp20, 2, 1, 1) != 0) {
										//^2066:1DC9
										goto _1e7e;
									}
									//^2066:1DCC
									bp08->ActuatorData(bp1e);
									break;
							}
						}
						//^2066:1DE1
						if (SUPPRESS_READER(bp08, bp0c, glbItemSizePerDB[bp22], 1, 0) != 0) {
							//^2066:1E06
							goto _1e7e;
						}
						//^2066:1E08
					}
					//^2066:1E1D
					if (READ_RECORD_CHECKCODE(bp0e, bp10, NULL, 1, 1) != 0) {
						//^2066:1E34
						goto _1e7e;
					}
				}
				//^2066:1E36
			}
			//^2066:1E45
		}
		//^2066:1E54
	}
	//^2066:1E69
	CHANGE_CURRENT_MAP_TO(bp18);
	//^2066:1E72
	if (RECOVER_MINION_ASSOC() == 0) {
		//^2066:1E7A
		si = 0;
	}
	else {
		//^2066:1E7E
_1e7e:
		si = 1;
	}
	//^2066:1E81
	DEALLOC_UPPER_MEMORY(200);
	return si;
}

//^2066:2D9C
__int16 SkWinCore::GAME_LOAD()
{
	//^2066:2D9C
	Bit16u bp04 = 0;
	Bit16u si = 0;
	Bit8u bp01 = 0;
	Bit16u bp08;
	Bit16u bp06;
	//^2066:2DAD
	if (glbSpecialScreen != 0) {
		//^2066:2DB4
_2db4:
		bp04 = !_2066_03e0(0);
		//^2066:2DC6
		if (LOAD_NEW_DUNGEON() == 0) {
			//^2066:2DCE
			goto _3262;
		}
		else {
			//^2066:2DD1
			goto _31b8;
		}
	}
	//^2066:2DD4
	bp01 = 0;
	_4976_52f4 = 2;
	//^2066:2DDE
	if (bp01 == 0) {
		//^2066:2DE4
		if (_4976_49a0 != 0 || _4976_5eb0 == 0)
			goto _2e5b;
		//^2066:2DF2
		if (_476d_030a(2) == 1)
			goto _2e5b;
		//^2066:2DFF
		_476d_04e8(2);
	}

	//^2066:2E07
	while (true) {
		//^2066:2E07
		if (_4976_49a0 == 0) {
			//^2066:2E0E
			if (bp01 != 0) {
				//^2066:2E14
				_476d_04e8(2);
			}
			//^2066:2E1C
			Bit16u di = _0aaf_0067(_0aaf_02f8(15, bp01));
			//^2066:2E32
			if (di == 1) {
				//^2066:2E37
				_2066_03e0(0);
				//^2066:2E3E
				//^2066:32B2
				di = -1;
				//^2066:32B5
				return di;
			}
		}
		else {
			//^2066:2E41
			if (bp01 != 0) {
				//^2066:2E47
				_0aaf_0067(_0aaf_02f8(0, bp01));
			}
		}
		//^2066:2E5B
_2e5b:
		if (_4976_49a0 == 0 && _476d_04af(1) != 1) {
			//^2066:2E6F
			//^2066:2F37
			switch (_4976_5eb8) {
				case 0x0000:
					//^2066:2F3E
					bp01 = 0x1d;
					break;
				case 0x0003:
					//^2066:2F4B
					bp01 = 0x1a;
					break;
				case 0x0002:
					//^2066:2F58
					bp01 = 0x16;
					break;
				case 0x0004:
					//^2066:2F65
					bp01 = 0x17;
					break;
			}
		}
		else {
			//^2066:2E72
			i16 bp06 = SELECT_LOAD_GAME();
			//^2066:2E7A
			if (bp06 < 0) {
				//^2066:2E7E
				_4976_525c = 0;
				//^2066:2E84
				//^2066:32B2
				Bit16u di = -1;
				//^2066:32B5
				return di;
			}
			//^2066:2E87
			_4976_525c = bp06;
			_4976_52e2 = bp06 + 0x30;
			bp08 = 0;
			si = 1;
			//^2066:2E9D
			glbDataFileHandle = FILE_OPEN(FORMAT_SKSTR(ptrSKSave_dat, NULL));
			//^2066:2EBD
			if (glbDataFileHandle < 0) {
				//^2066:2EC4
				glbDataFileHandle = FILE_OPEN(FORMAT_SKSTR(ptrSKSave_bak, NULL));
				//^2066:2EE4
				if (glbDataFileHandle >= 0) {
					//^2066:2EE8
					bp08 = 1;
				}
				else {
					//^2066:2EF0
					if (_4976_5bf2 == 0) {
						//^2066:2EF7
						glbDataFileHandle = FILE_OPEN(FORMAT_SKSTR(ptrDungeon_ftl, NULL));
						//^2066:2F17
						if (glbDataFileHandle >= 0) {
							//^2066:2F1B
							bp04 = 1;
							glbSpecialScreen = 1;
							//^2066:2F1B
							goto _2db4;
						}
					}
					//^2066:2F29
					si = 0;
					bp01 = 0x1c;
					_4976_5eb8 = 0x0003;
				}
			}
		}
		//^2066:2F69
		if (_4976_49a0 == 0 && _4976_5eb8 != 1) {
			//^2066:2F77
			continue;
		}

		break;
	}
	//^2066:2F7A
	_4976_5bf6 = 0;
	glbChampionsCount = 0;
	//SPX: changed 0xFFFF to oFFFF
	glbLeaderHandPossession.object = OBJECT_NULL; // 0xFFFF
	//^2066:2F8C
	sksave_header bp6a;
	FILE_READ(glbDataFileHandle, 42, &bp6a);
	//^2066:2FA1
	_4976_5244 = bp6a.bp4c;
	//^2066:2FA7
	_4976_524a = 42;
	//^2066:2FB3
	glbSpecialScreen = !_4976_5bf2;
	//^2066:2FBE
	do {
		if (READ_DUNGEON_STRUCTURE(0) == 0)
			break;
		//^2066:2FCC
		glbSpecialScreen = 0;
		//^2066:2FD2
		SUPPRESS_INIT();

		s_testSKSave.StartRead(FILE_TELL(glbDataFileHandle));

		//^2066:2FD6
		skload_table_60 t1;
		if (SUPPRESS_READER(&t1, _4976_395a, 56, 1, 1) != 0)
			break;
		//^2066:2FF5
		glbGameTick = _4976_4c1a = t1.dwGameTick;	// game tick
		glbRandomSeed = t1.dwRandomSeed;	// random seed
		glbChampionsCount = t1.wChampionsCount;	// player cnt
		glbPlayerPosX = t1.wPlayerPosX;	// column
		glbPlayerPosY = t1.wPlayerPosY;	// row
		glbPlayerDir = t1.wPlayerDir;	// dir
		glbPlayerMap = t1.wPlayerMap;	// map#
		glbChampionLeader = t1.wChampionLeader;	// leader
		glbTimersCount = t1.wTimersCount;	// timer cnt
		_4976_0090 = t1.dw22;
		_4976_4b80 = t1.dw26;
		_4976_4c00 = t1.w30;
		glbPlayerThrowCounter = t1.wPlayerThrowCounter;
		_4976_4c0c = t1.w34;
		glbRainFlagSomething = (Bit8u)t1.wRainFlagSomething;
		glbRainAmbientLightModifier = t1.bRainAmbientLightModifier;
		glbRainDirection = t1.bRainDirection;	// rain dir.
		glbRainStrength = t1.bRainStrength;	// rain str.
		glbRainLevelForSky = t1.bRainLevelForSky;
		glbRainLevelForGround = t1.bRainLevelForGround;
		glbRainMultiplicator = t1.bRainMultiplicator;
		glbRainStormController = t1.wRainStormController;
		glbRainRelated3 = t1.bRainRelated3;
		glbRainRelated2 = t1.bRainRelated2;
		glbRainSpecialNextTick = t1.dwRainSpecialNextTick;
		//^2066:30B5
		if (SUPPRESS_READER(glbIngameGlobVarFlags, _4976_3956, 1, 8, 1) != 0)
			break;
		//^2066:30D3
		if (SUPPRESS_READER(glbIngameGlobVarBytes, _4976_3956, 1, 64, 1) != 0)
			break;
		//^2066:30F1
		if (SUPPRESS_READER(glbIngameGlobVarWords, _4976_3956, 2, 64, 1) != 0)
			break;
		//^2066:310F
		if (SUPPRESS_READER(glbChampionSquad, _4976_3992, 261, glbChampionsCount, 1) != 0) // player ents
			break;
		//^2066:3130
		if (SUPPRESS_READER(&glbGlobalSpellEffects, _4976_3a97, 6, 1, 1) != 0)
			break;
		//^2066:314E
		if (SUPPRESS_READER(glbTimersTable, _4976_3a9d, 10, glbTimersCount, 1) != 0) // timer ents
			break;
		//^2066:3172
		bp06 = glbTimersCount;
		//^2066:3178
		while (bp06 < glbTimersMaximumCount) {
			//^2066:317A
			glbTimersTable[bp06].TimerType(tty00);
			//^2066:318D
			bp06++;
			//^2066:3190
		}
		//^2066:3199
		__SORT_TIMERS();
		//^2066:319F
		if (READ_SKSAVE_DUNGEON() != 0)
			break;
		//^2066:31A9
		PROCEED_GLOBAL_EFFECT_TIMERS();
		_3a15_020f();
		_4976_5bf2 = 1;
		//^2066:31B8
_31b8:
		FILE_CLOSE(glbDataFileHandle);
		//^2066:31C2
		si = 0;
		PROCESS_ACTUATOR_TICK_GENERATOR();
		//^2066:31C9
		_4976_5ca8 = 0;
		//^2066:31CF
		if (glbSpecialScreen != 0) {
			//^2066:31D6
			if (bp04 != 0) {
				//^2066:31DC
				WAIT_SCREEN_REFRESH();
			}
			//^2066:31E1
			//^2066:31E3
			//^2066:3227
			_2066_03e0(0);
		}
		else {
			//^2066:31E5
			_4976_5bf6 = 1;
			//^2066:31EB
			if (bp08 != 0) {
				//^2066:31F1
				FILE_RENAME(FORMAT_SKSTR(ptrSKSave_bak, NULL), FORMAT_SKSTR(ptrSKSave_dat, NULL));
			}
			//^2066:3225
			_2066_03e0(1);
		}
		//^2066:322C
		_0aaf_02f8(0x000E, 0x0000);
		//^2066:3237
		_4976_4bd8 = 0x0001;
		glbPlayerDefeated = 0x0000;
		//^2066:3243
		_2fcf_0b8b(glbPlayerPosX, glbPlayerPosY, glbPlayerMap);
		//^2066:3257
		glbDoLightCheck = 0x0001;
		//^2066:325D
		Bit16u di = 1;
		//^2066:32B5
		return di;
	} while (false);
_3262:
	//^2066:3262
	if (si != 0) {
		//^2066:3266
		si = 0;
		FILE_CLOSE(glbDataFileHandle);
	}
	//^2066:3272
	_0aaf_0067(_0aaf_02f8((_4976_5bf2 == 0) ? 0 : ((_4976_5c9c != 0) ? ((_4976_5ca8 != 0) ? 0x13 : 0x14) : (0x07)), 0x001F));
	//^2066:32A6
	if (_4976_5bf2 == 0) {
		//^2066:32AD
		SK_PREPARE_EXIT();
	}
	//^2066:32B2
	Bit16u di = -1;
	//^2066:32B5
	return di;
}

//^0CEE:0A43
ObjectID SkWinCore::GET_OBJECT_INDEX_FROM_TILE(i16 xx, i16 yy)
{
	//^0CEE:0A43
	ENTER(4);
	//^0CEE:0A49
	i16 cx = xx;
	i16 di = yy;
	U8 *bp04 = glbCurrentTileMap[cx];
	//^0CEE:0A67
	// SPX: Here, some crash because glbCurrentTileMap[cx] can be corrupted for some unknown reason ...
	// In case the pointer is corrupt, just return null ...
	if (SkCodeParam::bUsePowerDebug && !CheckSafePointer(bp04))
		return OBJECT_NULL;
	if (cx < 0 || cx >= glbCurrentMapWidth || di < 0 || di >= glbCurrentMapHeight || (bp04[di] & 0x10) == 0)
		//^0CEE:0A8B
		return OBJECT_NULL;
	//^0CEE:0A90
	U16 si = _4976_4c52[cx];
	while (--di >= 0) {
		//^0CEE:0A9F
		if ((*(bp04++) & 0x10) != 0)
			//^0CEE:0AAB
			si++;
	}
	//^0CEE:0AAF
	return si;
}

//^0CEE:0CB2
void SkWinCore::CUT_RECORD_FROM(ObjectID recordLink, ObjectID *recordLinkLookFor, __int16 xposLookFor, __int16 yposLookFor)
{
	// Cut the record from the target.
	// The record is specified by recordLink.
	// The target is one of recordLinkLookFor or a pair of xposLookFor&yposLookFor.

	SkD((DLV_DBM, "DBM: CUT_RECORD_FROM(%04X,%p(%04X),%2d,%2d)\n"
		, (Bitu)recordLink.w
		, recordLinkLookFor
		, (recordLinkLookFor != NULL) ? (Bitu)recordLinkLookFor->w : 0
		, (Bitu)xposLookFor
		, (Bitu)yposLookFor));

	ATLASSERT(false
		|| (xposLookFor == -1 && yposLookFor == 0) // open the chest?
		|| ((U16)xposLookFor < (U16)glbCurrentMapWidth && (U16)yposLookFor < (U16)glbCurrentMapHeight)
		);

	//^0CEE:0CB2
	ObjectID si = recordLink;
	//^0CEE:0CBB
	if (si == OBJECT_END_MARKER || si == OBJECT_NULL)
		return;
	//^0CEE:0CCB
	si.ClearDir();
	GenericRecord *bp08 = (GenericRecord *)GET_ADDRESS_OF_RECORD(si);
	//^0CEE:0CDB
	ObjectID *bp0c;
	if (xposLookFor >= 0) {
		//^0CEE:0CE4
		Bit16u bp0e = GET_OBJECT_INDEX_FROM_TILE(xposLookFor, yposLookFor);
		Bit16u *bp04 = &dunGroundStacks[bp0e];
		//^0CEE:0D05
		if (bp08->w0 == OBJECT_END_MARKER && ObjectID(*bp04).GetAsNorth() == si) {
			//^0CEE:0D21
			glbCurrentTileMap[xposLookFor][yposLookFor] &= 0xef;
			//^0CEE:0D4D
			Bit16u di = dunHeader->cwListSize -1;
			MOVE_MEMORY(
				bp04 +1,
				bp04,
				(di -bp0e) << 1
				);
			//^0CEE:0D77
			dunGroundStacks[di] = 0xffff;
			//^0CEE:0D86
			bp04 = &_4976_4c52[xposLookFor +1];
			//^0CEE:0D9D
			di = _4976_4cb4 - (dunMapColumnsSumArray[glbCurrentMapIndex] + xposLookFor) -1;
			//^0CEE:0DB7
			while (di-- != 0) {
				//^0CEE:0DB9
				(*bp04)--;
				bp04++;
				//^0CEE:0DC3
			}
			//^0CEE:0DCA
			return;
		}
		//^0CEE:0DCC
		if (ObjectID(*bp04).GetAsNorth() == si) {
			//^0CEE:0DD9
			Bit16u ax = bp08->w0;
			//^0CEE:0DE2
			//^0CEE:0E35
			*bp04 = ax;
			bp08->w0 = OBJECT_END_MARKER;
			return;
		}
		//^0CEE:0DE4
		//^0CEE:0DEA
		bp0c = reinterpret_cast<ObjectID *>(bp04);

		ATLASSERT(*bp04 != 0xFFFE && *bp04 != 0xFFFF);
	}
	else {
		//^0CEE:0DF2
		//^0CEE:0DEA
		bp0c = recordLinkLookFor;
	}
	//^0CEE:0E0B
	while (*bp0c != OBJECT_END_MARKER && bp0c->GetAsNorth() != si) {
		bp0c = &GET_ADDRESS_OF_RECORD(*bp0c)->w0;
	}
	//^0CEE:0E1E
	if (*bp0c != OBJECT_END_MARKER) {
		//^0CEE:0E27
		*bp0c = GET_NEXT_RECORD_LINK(*bp0c);
	}
	//^0CEE:0E38
	bp08->w0 = OBJECT_END_MARKER;
}

//^0CEE:3035
Bit8u SkWinCore::QUERY_CLS2_OF_TEXT_RECORD(ObjectID recordLink)
{
	//^0CEE:3035
	Text *bp04 = GET_ADDRESS_OF_RECORD2(recordLink);
	if (bp04->TextMode() == 1) {
		//^0CEE:3059
		Bit16u si = bp04->SimpleTextExtUsage();
		//^0CEE:306B
		switch (si) {
			case 0x0000: // 0x00 - Creature transformer
			case 0x0002: // 0x02 - Animate image
			case 0x0005: // 0x05 - ?
			case 0x000D: // 0x0d - 2-state switch
				//^0CEE:3080
				return Bit8u(bp04->OrnateIndex());
		}
	}
	//^0CEE:3091
	return -1;
}

//^0CEE:241B
Bit8u SkWinCore::QUERY_CLS2_FROM_RECORD(ObjectID recordLink)
{
	//^0CEE:241B
	if (recordLink != OBJECT_NULL) {
		//^0CEE:2428
		GenericRecord *bp04;
		if (recordLink < OBJECT_EFFECT_FIREBALL) {	// oFF80
			//^0CEE:242E
			bp04 = GET_ADDRESS_OF_RECORD(recordLink);
		}
		else {
			//^0CEE:243E
			return ((Bit8u)recordLink.w) - 0x80;
		}
		//^0CEE:2446
		switch (recordLink.DBType()) {
			case dbText:		// 2
				//^0CEE:24EA
				return QUERY_CLS2_OF_TEXT_RECORD(recordLink);
			case dbActuator:	// 3
				//^0CEE:24D7
				return GET_WALL_DECORATION_OF_ACTUATOR(GET_ADDRESS_OF_ACTU(recordLink));
			case dbCreature:	// 4
				//^0CEE:2461
				return bp04->castToCreature()->CreatureType();
			case dbWeapon:		// 5
				//^0CEE:246B
				return bp04->castToWeapon()->ItemType();
			case dbCloth:		// 6
				//^0CEE:2478
				return bp04->castToCloth()->ItemType();
			case dbScroll:		// 7
				{
				//^0CEE:2484
				//return 0;
				if (SkCodeParam::bUseScrollIDType)
					return bp04->castToScroll()->ItemType();	// SPX: removed "return 0" to get item type instead, allowing any item within scrolls category
				else
					return 0;	// Standard scroll icon; ID is used for text number
				}
			case dbPotion:		// 8	
				//^0CEE:2488
				return bp04->castToPotion()->PotionType();
			case dbContainer:	// 9
				//^0CEE:2494
				return 0
					| (((reinterpret_cast<Container *>(bp04)->b4 >> 1) & 0x0003) << 3)
					|  ((reinterpret_cast<Container *>(bp04)->b5 >> 5) & 0x0007)
					;
			case dbMiscellaneous_item:	//10
				//^0CEE:24B2
				return bp04->castToMisc()->ItemType();
			case db11:			//11
			case db12:			//12
			case db13:			//13
				break;
			case dbMissile:		//14
				//^0CEE:24BE
				return (Bit8u)QUERY_CLS2_FROM_RECORD(bp04->castToMissile()->GetMissileObject());
			case dbCloud:		//15
				//^0CEE:24CB
				return bp04->castToCloud()->CloudType();
		}
	}
	//^0CEE:24F5
	return -1;
}


	//^0CEE:2614
Bit16u SkWinCore::GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(Bit16u actuatorData)
{
	//^0CEE:2614
	//^0CEE:2618
	Bit16u si = actuatorData & 0x01ff;
	//^0CEE:261F
	switch (si >> 7) {
		case 0:
			//^0CEE:2630
			return dbWeapon;
		case 1:
			//^0CEE:2635
			return dbCloth;
		case 2:
			//^0CEE:263A
			return dbMiscellaneous_item;
		case 3:
			//^0CEE:263F
			if (si > 0x01fc)
				break;
			//^0CEE:2645
			if (si == 0x01fc) {
				//^0CEE:264B
				return dbScroll;
			}
			//^0CEE:2650
			if (si >= 0x01e0) {
				//^0CEE:2656
				return dbContainer;
			}
			//^0CEE:265B
			if (si >= 0x01b0) {
				//^0CEE:2661
				return dbCreature;
			}
			//^0CEE:2666
			return dbPotion;
	}
	//^0CEE:266B
	return 0xffff;
}

//^0CEE:2679
Bit8u SkWinCore::GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(Bit16u actuatorData)
{
	// returns a value ranged from 0 to 127, as an item type.

	//^0CEE:2679
	//^0CEE:267C
	Bit16u dx = (actuatorData & 0x01ff);
	switch (dx >> 7) {
		case 1:
			//^0CEE:2699
			dx -= 0x0080;
			break;
		case 2:
			//^0CEE:269F
			dx -= 0x0100;
			break;
		case 3:
			//^0CEE:26A5
			if (dx >= 0x01fc) {
				//^0CEE:26AB
				dx = 0;
				break;
			}
			//^0CEE:26AF
			if (dx >= 0x01e0) {
				//^0CEE:26B5
				dx -= 0x01e0;
				break;
			}
			//^0CEE:26BB
			if (dx >= 0x01b0) {
				//^0CEE:26C1
				dx -= 0x01b0;
				break;
			}
			//^0CEE:26C7
			dx -= 0x0180;
	}
	//^0CEE:26CB
	return (Bit8u)dx;
}

//^0CEE:2DE0
Bit16u SkWinCore::QUERY_CREATURE_AI_SPEC_FLAGS(ObjectID rl)
{
	return QUERY_CREATURE_AI_SPEC_FROM_RECORD(rl)->w0AIFlags;
}

//^0CEE:2D1B
AIDefinition *SkWinCore::QUERY_CREATURE_AI_SPEC_FROM_RECORD(ObjectID rlCreature)
{
	return QUERY_CREATURE_AI_SPEC_FROM_TYPE(GET_ADDRESS_OF_RECORD(rlCreature)->castToCreature()->CreatureType());
}

//^0CEE:23DE
Bit8u SkWinCore::QUERY_CLS1_FROM_RECORD(ObjectID recordLink)
{
	//^0CEE:23DE
	ObjectID di = recordLink;
	//^0CEE:23E6
	if (di != OBJECT_NULL) {
		//^0CEE:23EB
		Bit16u si = di.DBType();
		if (si == dbMissile) {
			//^0CEE:23FA
			return QUERY_CLS1_FROM_RECORD(GET_ADDRESS_OF_RECORDE(di)->GetMissileObject());
		}
		//^0CEE:240F
		return glbGDAT2CatPerDB[si];
	}
	//^0CEE:2415
	return 0xff;
}

//^3E74:0756
tiamat SkWinCore::_3e74_0756(Bit8u *xx, i32 size) { // TODO: Unr
	Unr(); return tiamat::zero();
}

//^2FCF:0CDF
// SPX: _2fcf_0cdf renamed TRY_PUSH_OBJECT_TO
Bit16u SkWinCore::TRY_PUSH_OBJECT_TO(ObjectID rl, i16 xpos, i16 ypos, i16 *xx, i16 *yy)
{
	//^2FCF:0CDF
	ENTER(12);
	//^2FCF:0CE5
	X16 si = RAND02();
	X16 bp0a;
	i8 *bp04 = (rl == OBJECT_NULL) ? (bp0a = glbPlayerDir, _4976_406c[si]) : (bp0a = 0, _4976_407c[si]);
	i16 di;
	for (di = 0; di <= 3; di++) {
		//^2FCF:0D1A
		si = (bp04[di] +bp0a) &3;
		X16 bp06 = xpos + glbXAxisDelta[si];
		X16 bp08 = ypos + glbYAxisDelta[si];
		si = GET_TILE_VALUE(bp06, bp08);
		if (IS_TILE_BLOCKED(U8(si)) == 0 && (si = (si >> 5)) != ttStairs) {
			if (rl.DBType() != dbCreature || (si != ttTeleporter && si != ttPit)) {
				//^2FCF:0D86
				ObjectID bp0c = GET_CREATURE_AT(bp06, bp08);
				if (bp0c == OBJECT_NULL || (rl == OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp0c) & CREATURE_AI_FLAG_8000) != 0)) {
					//^2FCF:0DAF
					*xx = bp06;
					*yy = bp08;
					return 1;
				}
			}
		}
		//^2FCF:0DC6
	}
	//^2FCF:0DCF
	return 0;
}

//^2C1D:1FD1
// SPX: _2c1d_1fd1 renamed GET_CHAMPION_SPECIAL_FORCE
X16 SkWinCore::GET_CHAMPION_SPECIAL_FORCE(U16 player)
{
	//^2C1D:1FD1
	ENTER(0);
	//^2C1D:1FD5
	U16 si = player;
	if (glbChampionSquad[si].curHP() == 0)
		return 0;
	//^2C1D:1FEC
	if (((GET_PLAYER_WEIGHT(si) / 10) + (glbChampionSquad[si].heroFlag & CHAMPION_FLAG_0010)) != 0)	// 0x10
		//^2C1D:2012
		return 50;
	//^2C1D:2017
	return 40;
	//^2C1D:201A
}

//^2C1D:201D
// SPX: _2c1d_201d renamed GET_PARTY_SPECIAL_FORCE
Bit16u SkWinCore::GET_PARTY_SPECIAL_FORCE()
{
	//^2C1D:201D
	ENTER(0);
	//^2C1D:2022
	U16 di = 0;
	U16 si = 0;
	for (; si < glbChampionsCount; si++) {
		di += GET_CHAMPION_SPECIAL_FORCE(si);
	}
	//^2C1D:2037
	return di;
	//^2C1D:2039
}

//^2FCF:01C5
void SkWinCore::_2fcf_01c5(ObjectID recordLink, i16 xx, i16 yy, Bit16u curmap, Bit16u ss)
{
	//^2FCF:01C5
	ENTER(10);
	//^2FCF:01C9
	Timer bp0a;
	bp0a.SetMap(curmap);
	bp0a.SetTick(glbGameTick +5);
	//^2FCF:01EC
	// SPX: though .. tty3D and tty3C seems to be handled exactly the same way!
	bp0a.TimerType((ss != 0) ? tty3D : tty3C);
	//^2FCF:01FB
	bp0a.actor = 0;
	//^2FCF:01FF
	bp0a.Xcoord(xx);
	bp0a.Ycoord(yy);
	bp0a.id8(recordLink);
	//^2FCF:0211
	SET_MINION_RECENT_OPEN_DOOR_LOCATION(recordLink, xx, yy, curmap, 1);
	//^2FCF:0226
	QUEUE_TIMER(&bp0a);
	//^2FCF:0232
	return;
}

//^2C1D:1C0C
X16 SkWinCore::ATTACK_PARTY(Bit16u quantity, Bit16u yy, Bit16u zz)
{
	//^2C1D:1C0C
	ENTER(4);
	//^2C1D:1C12
	X16 di = quantity;
	if (quantity == 0)
		return 0;
	//^2C1D:1C1D
	X16 si = 0;
	X16 bp04 = (di >> 3) +1;
	di -= bp04;
	bp04 <<= 1;
	U16 bp02;
	for (bp02 = 0; bp02 < glbChampionsCount; bp02++) {
		//^2C1D:1C34
		if (WOUND_PLAYER(bp02, max_value(1, di +RAND16(bp04)), yy, zz) != 0) {
			//^2C1D:1C60
			si |= 1 << bp02;
		}
		//^2C1D:1C6A
	}
	//^2C1D:1C76
	return si;
}

//^2C1D:1B0F
// SPX: _2c1d_1b0f renamed PROCESS_POISON / Kentaro says it is "give_poison"
void SkWinCore::PROCESS_POISON(i16 player, Bit16u yy) {
	
	if (SkCodeParam::bUseIngameDebug)
	{
		U8 message[64];
		sprintf((char*)message, "PLAYER %d HAS %d POISON COUNTERS.\n", player, yy);
		DISPLAY_HINT_TEXT(glbChampionColor[player], message);
	}
	//^2C1D:1B0F
	ENTER(14);
	//^2C1D:1B14
	X16 si = yy;
	if (player == -1)
		//^2C1D:1B1D
		return;
	//^2C1D:1B20
	if (player +1 == glbNextChampionNumber)
		//^2C1D:1B2A  
		return;
	//^2C1D:1B2D
	/*sk53b4*/Champion *bp04 = &glbChampionSquad[player];
	//^2C1D:1B3E
	WOUND_PLAYER(player, max_value(1, si >> 6), 0, 0);
	//^2C1D:1B5F
	bp04->heroFlag |= CHAMPION_FLAG_0800;	// 0x800
	bp04->heroFlag |= CHAMPION_FLAG_2000;	// 0x2000
	//^2C1D:1B6B
	si--;
	//^2C1D:1B6C
	if (si == 0)
		//^2C1D:1B70
		return;
	//^2C1D:1B72
	bp04->PoisonValue++;
	//^2C1D:1B76
	Timer bp0e;
	bp0e.TimerType(ttyPoison);
	bp0e.actor = (U8)player;
	bp0e.SetMap(glbPlayerMap);
	bp0e.SetTick(glbGameTick +0x24);
	bp0e.value = si;
	//^2C1D:1BA6  
	QUEUE_TIMER(&bp0e);
	//^2C1D:1BB2
	return;
}

// SPX: Custom, code added, similar to POISON
void SkWinCore::PROCESS_PLAGUE(i16 player, Bit16u counters)
{
	
	if (SkCodeParam::bUseIngameDebug)
	{
		U8 message[64];
		sprintf((char*)message, "PLAYER %d HAS %d PLAGUE COUNTERS.\n", player, counters);
		DISPLAY_HINT_TEXT(glbChampionColor[player], message);
	}
	X16 si = counters;
	if (player == -1)
		return;
	if (player +1 == glbNextChampionNumber)
		return;
	Champion *champion = &glbChampionSquad[player];
	WOUND_PLAYER(player, 1, 0, 0);
	ADJUST_STAMINA(player, max_value(1, si << 4));
	champion->curWater(champion->curWater() -100);
	if (champion->curWater() < WATER_MIN)
		champion->curWater(WATER_MIN);


	champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x800
	champion->heroFlag |= CHAMPION_FLAG_2000;	// 0x2000
	si--;
	if (si == 0)
		return;
	champion->PlagueValue++;

	// Create a new timer
	Timer newtimer;
	newtimer.TimerType(ttyPlague);
	newtimer.actor = (U8)player;
	newtimer.SetMap(glbPlayerMap);
	newtimer.SetTick(glbGameTick +0x24);
	newtimer.value = si;
	QUEUE_TIMER(&newtimer);
	return;
}


//^0CEE:06DC
// SPX TODO related to direction depending on tile (like changing stairs ?)
Bit16u SkWinCore::_0cee_06dc(i16 xx, i16 yy)
{
	//^0CEE:06DC
	ENTER(4);
	//^0CEE:06E2
	X16 di = xx;
	X16 si = yy;
	X16 bp02 = !(GET_TILE_VALUE(di, si) & 8);
	if (bp02 != 0) {
		di += glbXAxisDelta[1];
		si += glbYAxisDelta[1];
	}
	else {
		di += glbXAxisDelta[0];
		si += glbYAxisDelta[0];
	}
	//^0CEE:0712
	X16 bp04 = GET_TILE_VALUE(di, si) >> 5;
	return bp02 + (((bp04 == ttWall || bp04 == ttStairs) ? 1 : 0) << 1);
}

//^13E4:0401
void SkWinCore::ATTACK_CREATURE(ObjectID rl, i16 xx, i16 yy, Bit16u ss, i16 tt, Bit16u quantity)
{
	// quantity=0 to warn the creature. e.g. hazard notice of incoming missile.

	//^13E4:0401
	ENTER(20);
	//^13E4:0407
	U16 di = 0;
	if (rl == OBJECT_NULL) {
		rl = GET_CREATURE_AT(xx, yy);
		if (rl == OBJECT_NULL)
			return;
	}
	//^13E4:0427
	U16 bp12 = ss & 0x4000;
	if (bp12 != 0) {
		ss &= 0xbfff;
		if (RAND01() != 0)
			bp12 = 0;
	}
	//^13E4:0447
	U16 bp14 = ss & 0x2000;
	if (bp14 != 0)
		ss &= 0xdfff;
	//^13E4:0459
	Creature *bp04 = GET_ADDRESS_OF_RECORD4(rl);
	AIDefinition *bp0c = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType());
	U16 bp10 = bp0c->IsStaticObject();
	if (bp04->b5_0_7() == 0xff) {
		if (bp10 == 0)
			return;
		ALLOC_CAII_TO_CREATURE(rl, xx, yy);
	}
	//^13E4:04AC
	CreatureInfoData *bp08 = &glbTabCreaturesInfo[bp04->b5_0_7()];
	bp08->w20 += quantity;
	quantity = bp08->w20;
	//^13E4:04DB
	U16 si;
	U16 bp0e;
	if (bp10 == 0 && tt > 0) {
		//^13E4:04ED
		if ((bp04->w10 & 4) == 0) {
			if (quantity <= 0x1e && (quantity <= 4 || RAND02() != 0) && (((quantity * U32(0x64)) / bp0c->BaseHP) > 15)) {
				//^13E4:0537
				bp04->w10 |= 4;
				bp12 = 1;
			}
		}
		//^13E4:0545
		if (bp12 != 0) {
			//^13E4:054E
			if ((_4976_3752[QUERY_GDAT_CREATURE_WORD_VALUE(bp04->CreatureType(), 1)] & 0x80) == 0 && RAND01() != 0) {
				//^13E4:057A
				si = CALC_VECTOR_DIR(xx, yy, glbPlayerPosX, glbPlayerPosY);
				if ((bp04->w10 & 8) != 0 && RAND02() != 0)
					goto _05bd;
				if ((bp04->b15 & 3) != si && RAND02() == 0) {
					//^13E4:05BD
_05bd:
					si = (si +2) & 3;
				}
				//^13E4:05C6
				if (bp04->b15_0_1() == ((si +2) & 3)) {
					si = (RAND01() != 0) ? 7 : 6;
				}
				//^13E4:05F1
				else if (bp04->b15_0_1() != si) {
					si = (bp04->b15_0_1() == ((si -1) & 3)) ? 7 : 6;
				}
				//^13E4:061A
				else if (RAND02() == 0) {
					si = (RAND01() != 0) ? 6 : 7;
				}
				else {
					//^13E4:0638
					si = 0xffff;
				}
				//^13E4:063B
				if (si != 0xffff) {
					_13e4_0360(rl, xx, yy, U8(si), 0);
				}
			}
		}
		//^13E4:0653
		di = (RAND16(0x64) < tt) ? 1 : 0;
		if (di != 0) {
			//^13E4:066D
			bp0e = ss & 0x8000;
			ss = 1 << (ss & 0xff);
			if (bp0e != 0) {
				bp04->w10 &= ~ss;
			}
			else {
				bp04->w10 |= ss;
			}
		}
	}
	//^13E4:069F
	if (bp10 == 0 && bp14 != 0 && tt == 0) {
		//^13E4:06B1
		di = 1;
	}
	//^13E4:06B1
	else if (di != 0 && ((bp0e == 0 && ((ss & 0x40) != 0)) || bp14 != 0) && (_4976_37a6[RCJ(86,bp08->Command)] & 0x10) == 0) {
		//^13E4:06DE
		di = 1;
	}
	//^13E4:06E3
	else {
		di = 0;
	}
	//^13E4:06E7
	if (bp08->Command != ccmDestroy && (di != 0 || bp04->w6 <= quantity)) {
		//^13E4:0701
		RELEASE_CREATURE_TIMER(rl);
		QUEUE_THINK_CREATURE(xx, yy);
	}
	//^13E4:0717
	return;
}

//^13E4:0004
U8 *SkWinCore::PREPARE_LOCAL_CREATURE_VAR(ObjectID rl, i16 xx, i16 yy, U16 timerType)
{
	SkD((DLV_DBG_CAI, "DBM: PREPARE_LOCAL_CREATURE_VAR(rl=%04X, z=%d, x=%d, y=%d, TiTy=%d)\n"
		, (Bitu)rl.w, (Bitu)glbCurrentMapIndex, (Bitu)xx, (Bitu)yy, (Bitu)timerType));

	//^13E4:0004
	ENTER(14);
	//^13E4:0008
	U8 *bp04 = NULL;
	i16 bp0e = glbCurrentMapIndex;
	glbCurrentMapIndex = -1;
	_1c9a_0648(bp0e);
	glbCreatureSomeX = 0xffff;
	if (_4976_5160 != 0) {
		// reach here when DRAGOTH creates DRAGOTH ATTACK MINION.

		bp04 = ALLOC_MEMORY_RAM(SIZE_LOCAL_CREATURE_VAR, afDefault, 1024); // 0x34e in DM2
		// TODO: fixme
		//ATLASSERT(false);
		COPY_MEMORY(&glbCurrentThinkingCreatureID, bp04, SIZE_LOCAL_CREATURE_VAR);
	}
	_4976_5160 = 1;
	_4976_5161 = 0;
	glbCurrentThinkingCreatureID = rl;
	//^13E4:0073
	Creature *xCreature = glbCurrentThinkingCreatureRec = GET_ADDRESS_OF_RECORD4(rl); // bp08
	CreatureInfoData *xCreatureInfo = (xCreature->b5_0_7() != 0xff) ? &glbTabCreaturesInfo[xCreature->b5_0_7()] : NULL; // bp0c
	if (xCreatureInfo != NULL)	// SPX : NULL should not happen
		SkD((DLV_DBG_CAI, "DBG: CreatureIndex:%d, CreatureType:%02X, 4eceIndex:%u, XX=%02X, YY=%02X\n"
			, (Bitu)rl.DBIndex()
			, (Bitu)xCreature->CreatureType()
			, (Bitu)xCreature->b5_0_7()
			, (Bitu)(U8)xCreatureInfo->x
			, (Bitu)(U8)xCreatureInfo->y
		));
	else
		SkD((DLV_DBG_CAI, "DBG: CreatureIndex:%d, CreatureType:%02X, 4eceIndex:%u, XX=NULL, YY=NULL\n"
			, (Bitu)rl.DBIndex()
			, (Bitu)xCreature->CreatureType()
			, (Bitu)xCreature->b5_0_7()
		));
	//^13E4:00BA
	glbCurrentThinkingCreatureData = xCreatureInfo;
	glbAIDef = QUERY_CREATURE_AI_SPEC_FROM_TYPE(xCreature->CreatureType());
	//^13E4:00DC
	_4976_4ed6 = _1c9a_02c3(xCreature, glbAIDef);
	glbSomeMap_4976_4ee7 = U8(bp0e);
	glbCreatureTimer.SetMap(bp0e);
	glbCreatureTimer.SetTick(glbGameTick);
	//^13E4:0118
	glbCreatureTimer.actor = xCreature->CreatureType();
	glbCreatureTimer.TimerType(U8(timerType));
	glbCreatureTimer.XcoordB(U8(xx));
	glbCreatureTimer.YcoordB(U8(yy));
	glbCreatureAnimationFrame = NULL;
	_4976_4ee6 = 0;
	_4976_4efa = 0xffff;
	//^13E4:014B
	if (xCreatureInfo == NULL && SkCodeParam::bDebugBypassNullPointers == false)
	{
	if (timerType == tty22) {
		_4976_4ee8 = 0;
		_4976_4eea = 0;
		_4976_4ee4 = (xCreatureInfo->Command == -1) ? 0 : xCreatureInfo->Command;
		if (xCreatureInfo != NULL) {
			//^13E4:017D
			ZERO_MEMORY(&xCreatureInfo->w24, 10);
			xCreatureInfo->Command = ccmInv;
		}
	}
	} // SPX: Debug bypass
	//^13E4:019B
	return bp04;
}
//^14CD:0802
// SPX: _14cd_0802 renamed CREATURE_THINK_FLUSH_POSITION
void SkWinCore::CREATURE_THINK_FLUSH_POSITION()
{
	//^14CD:0802
	ENTER(0);
	//^14CD:0805
	if (glbCurrentThinkingCreatureData == NULL && SkCodeParam::bDebugBypassNullPointers == true)
		return;
	glbCurrentThinkingCreatureData->x = xactrNeedReset;
	glbCurrentThinkingCreatureData->y = 0;
	//^14CD:0813
	return;
}
//^1C9A:0A48
// SPX: _1c9a_0a48 renamed CREATURE_SOMETHING_1c9a_0a48
X32 SkWinCore::CREATURE_SOMETHING_1c9a_0a48()
{
	// DIFF!

	//^1C9A:0A48
	ENTER(20);
	if (glbCurrentThinkingCreatureData == NULL && SkCodeParam::bDebugBypassNullPointers == true) // SPX DEBUG
		return 0;
	//^1C9A:0A4D
	i8 bp03 = glbAIDef->b9x;
	U16 bp06 = glbCurrentThinkingCreatureRec->CreatureType();
	U16 bp0c = _4976_4ed6->w0;
	U16 bp0e = _4976_4ed6->w2;
	CreatureAnimationFrame bp14;
	X16 bp02;
	if (glbCreatureAnimationFrame == NULL) {
		bp02 = (glbAIDef->IsStaticObject() != 0) ? glbCurrentThinkingCreatureRec->w12 : 0;
		GET_CREATURE_ANIMATION_FRAME(U8(bp06), glbCurrentThinkingCreatureData->Command, &bp0c, &bp0e, &glbCreatureAnimationFrame, bp02);
		if (glbCreatureAnimationFrame == NULL) {
			ZERO_MEMORY(&bp14, 6);
			glbCreatureAnimationFrame = &bp14;
		}
	}
	//^1C9A:0AE6
	bp02 =glbCurrentThinkingCreatureData->b7;
	if ((glbCreatureAnimationFrame->b4 & 0x80) != 0) {
		//^1C9A:0B01
		i16 si = glbCurrentThinkingCreatureData->Command;
		if (si != ccm24 && si != ccm23 && si != ccm25) {
			//^1C9A:0B1B
			bp02 &= 0xc0;
			si = bp03 & 3;	// bits 1 & 2 => value between 0 and 3
			if (si != 0) {
				si = RAND16(si);
				if (RAND01() != 0) {
					si = (~si) & 7;	// b001 becomes b110 = 0x6
				}
				bp02 |= si;
			}
			//^1C9A:0B4B
			si = (bp03 >> 2) & 3;	// bits 3 & 4
			if (si != 0) {
				si = RAND16(si);
				if (RAND01() != 0) {
					si = (~si) & 7;
				}
				bp02 |= si << 3;
			}
		}
	}
	//^1C9A:0B80
	if ((glbCreatureAnimationFrame->b4 & 0x20) != 0) {
		bp02 |= 0x40;
	}
	else {
		bp02 &= 0xffbf;
	}
	//^1C9A:0B97
	if ((glbCreatureAnimationFrame->b4 & 0x40) != 0) {
		if (RAND01() != 0) {
			bp02 |= 0x40;
		}
		else {
			bp02 &= 0xffbf;
		}
	}
	//^1C9A:0BB7
	glbCurrentThinkingCreatureData->b7 = U8(bp02);
	_4976_4ed6->w0 = bp0c;
	_4976_4ed6->w2 = bp0e;
	//^1C9A:0BD3
	if (glbCreatureAnimationFrame->sound != SOUND_NONE) {	// != 0xFF
		if (SkCodeParam::bUsePowerDebug) { 
			U8 sCreatureName[32];
			QUERY_GDAT_TEXT(GDAT_CATEGORY_CREATURES, U8(bp06), 0x00, sCreatureName);
			SkD((DLV_DBG_SND_CRE, "SND: Creature sound > idx:%02X (%s) snd:%02X xx:%02X yy:%02X x:%02d y:%02d tick:%02d\n"
				, U8(bp06), sCreatureName, glbCreatureAnimationFrame->sound, 0x46, 0x80, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), 1));
		}
		// SPX: this correspond to create any useful sounds for a creature : walk, attack, growl ...
		QUEUE_NOISE_GEN1(GDAT_CATEGORY_CREATURES, U8(bp06), glbCreatureAnimationFrame->sound, 0x46, 0x80, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), 1);
	}
	//^1C9A:0C04
	X32 bp0a;
	i16 si;
	if (glbCurrentThinkingCreatureRec->w10_6_6() != 0) {
		bp0a = i16(min_value(1, glbCreatureAnimationFrame->b4 & 7)) + glbGameTick;
		goto _0cd1;
	}
	//^1C9A:0C2A
	SkD((DLV_DBG_SED2, "DBG: glbCreatureAnimationFrame %04X %04X %02X %02X \n", (Bitu)glbCreatureAnimationFrame->w0, (Bitu)glbCreatureAnimationFrame->w2, (Bitu)glbCreatureAnimationFrame->b4, (Bitu)glbCreatureAnimationFrame->sound));
	si = (glbCreatureAnimationFrame->b4 >> 3) & 3;
	if (si != 0) {
		si = RAND16(si);
	}
	//^1C9A:0C49
	si = (glbCreatureAnimationFrame->b4 & 7) +si;
	if (glbCurrentThinkingCreatureData->Command == ccmDestroy && glbGlobalSpellEffects.FreezeCounter != 0 && glbAIDef->w0_c_c() == 0) {
		//^1C9A:0C79
		si = 3 * si;
	}
	//^1C9A:0C84
	else if (glbIsPlayerSleeping != 0) {
		si <<= 1;
		if (glbCurrentMapIndex != glbPlayerMap && glbCurrentMapIndex != _4976_4c12)
			si <<= 1;
	}
	//^1C9A:0CA0
	else if ((glbCurrentThinkingCreatureRec->w10 & 8) != 0) {
		si = max_value(1, si >> 1);
	}
	//^1C9A:0CBC
	bp0a = si + glbGameTick;
_0cd1:
	if (&bp14 == glbCreatureAnimationFrame)
		//^1C9A:0CE2
		glbCreatureAnimationFrame = NULL;

	//^1C9A:0CEE
	return bp0a;
}
//^13E4:0329
void SkWinCore::UNPREPARE_LOCAL_CREATURE_VAR(U8 *ww)
{
	//^13E4:0329
	ENTER(0);
	//^13E4:032C
	if (ww == NULL) {
		_4976_5160 = 0;
		return;
	}
	//^13E4:033B
	//ATLASSERT(false);
	COPY_MEMORY(ww, &glbCurrentThinkingCreatureID, SIZE_LOCAL_CREATURE_VAR);
	DEALLOC_UPPER_MEMORY(SIZE_LOCAL_CREATURE_VAR);
	//^13E4:035E
	return;
}


//^1C9A:0E14
void SkWinCore::ALLOC_CAII_TO_CREATURE(ObjectID rl, i16 xx, i16 yy)
{
	//^1C9A:0E14
	ENTER(14);
	//^1C9A:0E1A
	X16 si = 0;
	Creature *bp08 = GET_ADDRESS_OF_RECORD4(rl);
	if (bp08->b5 != 0xff)
		return;
	//^1C9A:0E38
	si = bp08->b15_2_2();
	bp08->b15_2_2(1);
	CreatureInfoData *bp04;
	U16 bp0e;
	do {
		//^1C9A:0E4C
		bp04 = glbTabCreaturesInfo;
		for (bp0e = 0; bp0e < glbCreaturesCount; bp04++, bp0e++) {
			if (bp04->CreatureIndex() < 0)
				goto _0ea0;
		}
		//^1C9A:0E79
		for (U16 di = _4976_1a68; _4976_1a68 >= di; ) {
			if (RECYCLE_A_RECORD_FROM_THE_WORLD(dbCreature, 0xff) == OBJECT_NULL) {
				RAISE_SYSERR(SYSTEM_ERROR__CREATURE_ASSOC_FULL);
			}
		}
	} while (true);
	//^1C9A:0EA0
_0ea0:
	bp08->b15_2_2(U8(si));
	_4976_1a68++;
	ZERO_MEMORY(bp04, sizeof(CreatureInfoData));
	bp04->CreatureIndex(rl.DBIndex());
	bp08->b5 = U8(bp0e);
	bp04->TimerIndex(0xffff);
	bp04->Command = ccmInv;
	U8 *bp0c = PREPARE_LOCAL_CREATURE_VAR(rl, xx, yy, 0x22);
	CREATURE_THINK_FLUSH_POSITION();
	bp04->b6_ = U8(glbGameTick >> 2) -1;
	bp04->b4 = U8(glbGameTick) -0x7f;
	//^1C9A:0F2C
	bp04->w12.SetX(glbCreatureTimer.XcoordB());
	bp04->w12.SetY(glbCreatureTimer.YcoordB());
	bp04->w12.SetMap(glbCurrentMapIndex);
	_4976_514e.b1 = 0;
	bp04->b22 = -1;
	bp04->Command2 = ccmInv;
	bp04->b7 = 0;
	//^1C9A:0F78
	QUEUE_THINK_CREATURE(xx, yy);
	//^1C9A:0F84
	bp04->Command = (bp08->w8 == 0xffff) ? ccmSpawn : ccmNeutral;
	//^1C9A:0F9B
	if (glbAIDef->IsStaticObject() == 0) {
		glbCurrentThinkingCreatureRec->w10 |= 0x8000;
		glbCurrentThinkingCreatureRec->w10 &= 0xbfff;
		CREATURE_SOMETHING_1c9a_0a48();
	}
	//^1C9A:0FBA
	UNPREPARE_LOCAL_CREATURE_VAR(bp0c);
	//^1C9A:0FC7
	return;
}

//^0CEE:319E
X16 SkWinCore::_0cee_319e(ObjectID rl)
{
	//^0CEE:319E
	ENTER(2);
	//^0CEE:31A2
	if (IS_OBJECT_ALCOVE(rl) == 0)	// _0cee_317f
		return 0;
	//^0CEE:31B2
	U8 bp01 = QUERY_CLS2_FROM_RECORD(rl);
	if (bp01 == 0xff)
		return 0;
	//^0CEE:31C3
	return QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp01, dtWordValue, GDAT_WALL_ORNATE__DATA_13);
}


//^075F:084D
U16 SkWinCore::ATTACK_WALL(i16 xTo, i16 yTo, i16 xFrm, i16 yFrm, U16 dirTo, ObjectID rlThrown)
{
	//^075F:084D
	ENTER(16);
	//^075F:0853
	ObjectID si = rlThrown;
	U16 bp0c = 0;
	dirTo += 2;
	dirTo &= 3;
	ObjectID di = GET_TILE_RECORD_LINK(xTo, yTo);
	Missile *bp08 = GET_ADDRESS_OF_RECORDE(si);
	for (; di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
		//^075F:0883
		if (di.Dir() != dirTo)
			continue;
		//^075F:0890
		if (true
			&& bp08->GetMissileObject().DBType() != dbCloud 
			&& bp0c == 0 
			&& _0cee_319e(di) != 0 
			&& RAND02() == 0
		) {
			//^075F:08BC
			CUT_RECORD_FROM(si, NULL, xFrm, yFrm);
			si.Dir(di.Dir());
			DELETE_MISSILE_RECORD(si, NULL, xTo, yTo);
			bp0c = 1;
			continue;
		}
		//^075F:08FB
		if (di.DBType() != dbActuator)
			continue;
		ObjectID bp0a = bp08->GetMissileObject();
		if (bp0a.DBType() == dbCloud)
			continue;
		//^075F:0923
		Actuator *bp04 = GET_ADDRESS_OF_ACTU(di);
		U16 bp10 = bp04->ActuatorData();
		U16 bp0e;
		switch (bp04->ActuatorType()) {
			case ACTUATOR_TYPE_FLYING_ITEM_CATCHER: // 0x22 -> Activator, knock sensor (flying item)
				//^075F:0957
				bp0e = (bp10 == 0x1ff || GET_DISTINCTIVE_ITEMTYPE(bp0a) == bp10) ? 1 : 0;
				if ((bp04->RevertEffect() ^ bp0e) == 0)
					continue;
				if (bp04->ActionType() == 3) {
					//^075F:099E
					INVOKE_ACTUATOR(bp04, ((bp04->RevertEffect() ^ bp0e) != 0) ? 0 : 1, 0);
				}
				else {
					//^075F:09BC
					INVOKE_ACTUATOR(bp04, bp04->ActionType(), 0);
				}
				//^075F:09DA
				if (bp0c != 0)
					continue;
				//^075F:09E3
				if (bp04->OnceOnlyActuator() == 0)
					continue;
				//^075F:09F7
				CUT_RECORD_FROM(si, NULL, xFrm, yFrm);
				si.Dir(dirTo);
				DELETE_MISSILE_RECORD(si, NULL, xTo, yTo);
				bp0c = 1;
				continue;
			case ACTUATOR_TYPE_FLYING_ITEM_TELEPORTER: // 0x23 -> Item teleporter (flying item)
				//^075F:0A34
				if (bp0c != 0)
					continue;
				if (bp10 != 0x1ff && GET_DISTINCTIVE_ITEMTYPE(bp0a) != bp10)
					continue;
				CUT_RECORD_FROM(si, NULL, xFrm, yFrm);
				si.Dir(
					((GET_TILE_VALUE(bp04->Xcoord(), bp04->Ycoord()) >> 5) == ttWall)
					? bp04->Direction()
					: bp04->ActionType()
					);
				//^075F:0AB7
				DELETE_MISSILE_RECORD(si, NULL, bp04->Xcoord(), bp04->Ycoord());
				bp0c = 1;
				break;
			default: // ^_0ae1
				break;
		}
		//^075F:0AE1
	}
	//^075F:0AF2
	return bp0c;
}

//^0CEE:32A3
i16 SkWinCore::QUERY_DOOR_DAMAGE_RESIST(U8 cls2)
{
	//^0CEE:32A3
	ENTER(0);
	//^0CEE:32A6
	return QUERY_GDAT_ENTRY_DATA_INDEX(0x0e, cls2, dtWordValue, 0x0e);
	//^0CEE:32B8
}

//^075F:2205
U16 SkWinCore::ATTACK_DOOR(i16 x, i16 y, U16 damage, U16 isSpellAttack, U16 delay)
{
	//^075F:2205
	ENTER(18);
	//^075F:2209
	Door *door = GET_ADDRESS_OF_TILE_RECORD(U8(x), U8(y))->castToDoor();	//*bp04
	// SPX: Disable door controls if "weak door" mode is activated. Controls within are original code
	if (!SkCodeParam::bWeakDoors) {
		if (isSpellAttack != 0 && door->DestroyablebyFireball() == 0)
			return 0;
		//^075F:2233
		if (isSpellAttack == 0 && door->BashablebyChopping() == 0)
			return 0;
		//^075F:224A
		if (QUERY_DOOR_DAMAGE_RESIST(GET_GRAPHICS_FOR_DOOR(door)) <= damage)
			return 0;
	} // End of "weak door"	
	//^075F:2266
	U8 *bp08 = &glbCurrentTileMap[x][y];
	if ((*bp08 & 7) != 4)
		return 0;
	//^075F:228E
	if (delay != 0) {
		//^075F:2294
		Timer bp12;
		bp12.SetMap(glbCurrentMapIndex);
		bp12.SetTick(glbGameTick +delay);
		bp12.TimerType(ttyDoorDestroy);
		bp12.actor = 0;
		bp12.XcoordB(U8(x));
		bp12.YcoordB(U8(y));
		QUEUE_TIMER(&bp12);
	}
	else {
		//^075F:22D9
		*bp08 = (*bp08 & 0xf8) | 5; // Bashed
	}
	return 1;
}

//^2C1D:132C
X16 SkWinCore::_2c1d_132c(i16 ss, U16 tt)
{
	//^2C1D:132C
	ENTER(0);
	//^2C1D:1330
	X16 si = ss & 0xff;
	if (tt != 0) {
		si = _0cd5_0176(si, 3, ((ss & 0x700) >> 8) +4);
	}
	//^2C1D:1358
	return si;
}

//^2C1D:135D
X16 SkWinCore::_2c1d_135d(i16 play, U16 ww)
{
	//^2C1D:135D
	ENTER(8);
	//^2C1D:1363
	Champion *champion = &glbChampionSquad[play];	//*bp04
	U16 bp06 = ww & 0x8000;
	if (bp06 != 0)
		ww &= 0x7fff;
	X16 bp08 = 0;
	//^2C1D:138B
	i16 si;
	U16 di;
	for (si = 0; si <= 1; si++) {
		//^2C1D:138F
		// SPX: Checking armour value
		di = QUERY_GDAT_DBSPEC_WORD_VALUE(champion->Possess(si), GDAT_ITEM_STATS_ARMOR_CLASS);
		if ((di & 0x8000) != 0) {
			bp08 = (((_2c1d_132c(di, bp06) + COMPUTE_PLAYER_ATTACK_OR_THROW_STRENGTH(play, si, 7)) * _4976_3fc8[RCJ(6,ww)]) << ((si == ww) ? 4 : 5)) +bp08;
		}
		//^2C1D:13EF
	}
	//^2C1D:13F5
	si = RAND16((GET_PLAYER_ABILITY(champion, abVit, 0) >> 3) +1);
	if (bp06 != 0)
		si >>= 1;
	if (glbChampionSquad[play].enchantmentAura == ENCHANTMENT_PARTY_SHIELD) {	// == 2
		si += glbChampionSquad[play].enchantmentPower;
	}
	//^2C1D:143A
	si += champion->handDefenseClass[0] +champion->handDefenseClass[1] +bp08;
	if (ww > 1) {
		//^2C1D:1456
		di = QUERY_GDAT_DBSPEC_WORD_VALUE(champion->Possess(ww), GDAT_ITEM_STATS_ARMOR_CLASS);
		si = si +_2c1d_132c(di, bp06);
	}
	//^2C1D:147D
	if ((champion->bodyFlag & (1 << ww)) != 0) {
		si = si -(RAND02() +8);
	}
	//^2C1D:149C
	if (glbIsPlayerSleeping != 0)
		si >>= 1;
	return BETWEEN_VALUE(0, si >> 1, 0x64);
}

//^0CD5:0176
i16 SkWinCore::_0cd5_0176(U16 val, U16 rshift, U16 multiplier)
{
	//^0CD5:0176
	ENTER(0);
	//^0CD5:0179
	return (U32(val) * U32(multiplier)) >> rshift;
}

//^2C1D:0F2A
i16 SkWinCore::_2c1d_0f2a(Champion *ref, X16 ability, i16 tt)
{
	//^2C1D:0F2A
	ENTER(0);
	//^2C1D:0F2E
	i16 si = ATTRIBUTE_VALUE_THRESHOLD - GET_PLAYER_ABILITY(ref, ability, 0);	// 170 - Get_player_ab()
	//^2C1D:0F47
	return (si < 0x10) ? (tt >> 3) : (_0cd5_0176(tt, 7, si));
}

//^2C1D:18AA
Bit16u SkWinCore::WOUND_PLAYER(i16 play, i16 quantity, Bit16u ss, Bit16u tt)
{
	// CSBwinSimilarity: TAG017068,DamageCharacter

	//^2C1D:18AA
	ENTER(12);
	//^2C1D:18B0
	i16 si = quantity;
	if (play == -1)
		return 0;
	if (play +1 == glbNextChampionNumber)
		return 0;
	if (_4976_4c26 != 0)
		return 0;
	if (si <= 0)
		return 0;
	//^2C1D:18DA
	Champion *champion = &glbChampionSquad[play];
	//^2C1D:18EB
	if (champion->curHP() == 0)
		return 0;
	//^2C1D:18F8
	U16 bp0a = tt & 0x8000;
	tt &= 0x7fff;
	if (tt != 0) {
		//^2C1D:190F
		X16 bp08 = 0;
		i16 bp06 = 0;
		U16 di = 0;
		//^2C1D:191B
		for (; bp06 <= 5; bp06++) {
			//^2C1D:191D
			if (((1 << bp06) & ss) != 0) {
				bp08++;
				di += _2c1d_135d(play, ((tt == 4) ? 0x8000 : 0) | bp06);
			}
			//^2C1D:194B
		}
		//^2C1D:1954
		if (bp08 != 0) {
			//^2C1D:195A
			di = di / bp08;
		}
		//^2C1D:1963
		X16 bp0c = 0;
		bp06 = 0;
		//^2C1D:196D
		for (; bp06 <= 1; bp06++) {
			//^2C1D:196F
			if (champion->handCommand[bp06] == 1) {
				bp0c += champion->handDefenseClass[bp06];
			}
			//^2C1D:198A
		}
		//^2C1D:1993
		if (bp0c != 0 ) {
			//^2C1D:1999
			if (QUERY_PLAYER_SKILL_LV(play, SKILL_FIGHTER_PARRY, 1) +(bp0c >> 3) > (RAND() & 15)) {
				//^2C1D:19BD
				if (bp0a != 0 && (si = si -bp0c) <= 0)
					return 0;
				//^2C1D:19D1
				di += bp0c >> 2;
			}
		}
		//^2C1D:19D9
		switch (tt) {
		case 6://^19EC
			//^2C1D:19EC
			bp06 = 0x73 - GET_PLAYER_ABILITY(champion, 0, 0);
			if (bp06 <= 0)
				return 0;
			si = _0cd5_0176(si, 6, bp06);
			goto _1a91;
		case 5://^1A20
			//^2C1D:1A20
			si = _2c1d_0f2a(champion, abAntiMagic, si);
			if (champion->enchantmentAura == ENCHANTMENT_SPELL_SHIELD)	// == 1
				si -= champion->enchantmentPower;
			goto _1a91;
		case 1://^1A44
			//^2C1D:1A44
			si = _2c1d_0f2a(champion, abAntiFire, si);
			if (champion->enchantmentAura == ENCHANTMENT_FIRE_SHIELD)	// == 0
				si -= champion->enchantmentPower;
			break;
		case 2://^1A68
		case 8://^1A68
			//^2C1D:1A68
			di >>= 1;
			di += QUERY_PLAYER_SKILL_LV(play, SKILL_NINJA_GLOBAL, 1);
			break;
		case 3://^1A7A
		case 4://^1A7A
		case 7://^1A7A
			break;
		}
		//^2C1D:1A7A
		if (si <= 0)
			return 0;
		si = _0cd5_0176(si, 6, 0x82 -di);
		//^2C1D:1A91
_1a91:
		if (si <= 0)
			return 0;
		bp06 = _2c1d_0f2a(champion, abVit, (RAND() & 0x7f) +10);
		if (bp06 < si) {
			do {
				//^2C1D:1AB7
				glbChampionsBodyFlags[play] |= (1 << (RAND() & 7)) & ss;
				bp06 <<= 1;
				if (bp06 >= si)
					break;
			} while (bp06 != 0);
		}
		//^2C1D:1AE1
		if (glbIsPlayerSleeping != 0)
			RESUME_FROM_WAKE();
	}
	//^2C1D:1AEC
	glbChampionsPendingDamage[play] += si;
	return si;
}

//^075F:0182
void SkWinCore::_075f_0182(ObjectID rl, X16 xx, X16 yy)
{
	//^075F:0182
	ENTER(4);
	//^075F:0188
	ObjectID si = GET_TILE_RECORD_LINK(xx, yy);
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^075F:0198
		if (si.DBType() == dbActuator) {
			Actuator *bp04 = GET_ADDRESS_OF_ACTU(si);
			if (bp04->ActuatorType() == ACTUATOR_FLOOR_TYPE__MISSILE_EXPLOSION) { // 0x26 -> Activator, missile explosion
				U16 di = bp04->RevertEffect()
					^ ((bp04->ActuatorData() == 0x1ff || bp04->ActuatorData() == rl.MissileType()) ? 1 : 0);
				if (bp04->ActionType() == 3) {
					INVOKE_ACTUATOR(bp04, (di != 0) ? 0 : 1, 0);
				}
				else if (di != 0) {
					INVOKE_ACTUATOR(bp04, bp04->ActionType(), 0);
				}
			}
		}
		//^075F:0240
	}
	//^075F:0251
	return;
}

//^075F:0255
void SkWinCore::CREATE_CLOUD(ObjectID rl, U16 ww, U16 xx, U16 yy, U16 ss)
{
	//^075F:0255
	ENTER(36);
	//^075F:025B
	i16 si = ww;
	ObjectID di = ALLOC_NEW_RECORD(dbCloud);
	if (di == OBJECT_NULL)
		return;
	//^075F:0270
	Cloud *bp04 = GET_ADDRESS_OF_RECORDF(di);
	X16 bp0e;
	X16 bp10;
	if (xx <= 255) {
		bp0e = xx;
		bp10 = yy;
	}
	else {
		bp0e = xx & 0xff;
		bp10 = yy & 0xff;
		xx >>= 8;
		xx--;
		yy >>= 8;
	}
	//^075F:02AF
	if (ss == 0xff) {
		bp04->b2_7_7(1);
	}
	else {
		bp04->b2_7_7(0);
		di.Dir(ss);
	}
	bp04->CloudType(U8(rl.MissileType()));
	bp04->b3_0_f(U8(si));
	X16 bp14;
	if (glbCurrentMapIndex == glbMap_4c28 && xx == glbSomePosX_4c2e && yy == glbSomePosY_4c30) {
		bp14 = 255;
	}
	else {
		bp14 = min_value(255, (si >> 1) +0x80);
	}
	//^075F:0332
	QUEUE_NOISE_GEN2(GDAT_CATEGORY_SPELL_MISSILES, bp04->CloudType(), SOUND_STD_EXPLOSION, 0xfe, xx, yy, 1, 0x6c, U8(bp14));
	APPEND_RECORD_TO(di, NULL, xx, yy);
	U16 bp12;
	if (rl == OBJECT_EFFECT_CLOUD_REBIRTH) {	// oFFE4
		bp12 = 5;
	}
	else if (rl == OBJECT_EFFECT_REFLECTOR) {	// oFF8E
		bp12 = si >> 1;
	}
	else {
		bp12 = 1;
	}
	//^075F:038E
	Timer bp24;
	bp24.SetMap(glbCurrentMapIndex);
	bp24.SetTick(bp12 +glbGameTick);
	bp24.TimerType(ttyCloud);
	bp24.actor = 0;
	bp24.w8 = di;
	bp24.XcoordB(U8(xx));
	bp24.YcoordB(U8(yy));
	QUEUE_TIMER(&bp24);
	//^075F:03DA
	//if (rl == oFF82 || rl == oFF80 || rl == oFFB0 || rl == oFFB1) {
	if (rl == OBJECT_EFFECT_LIGHTNING 
		|| rl == OBJECT_EFFECT_FIREBALL 
		|| rl == OBJECT_EFFECT_THUNDER 
		|| rl == OBJECT_EFFECT_ELECTRIC_SHOCK) {
		//^075F:03F5
		i16 bp18 = xx = bp0e;
		i16 bp1a = yy = bp10;
		X16 bp16 = 1;
		si = (si >> 1) +1;
		si += RAND16(si) +1;
		bp14 = si;
		//^075F:0420
		// SPX: TODO Did I misreplaced something? This does rl == FF80 || rl == FF80 .. ???
		if (rl == OBJECT_EFFECT_FIREBALL || rl == OBJECT_EFFECT_FIREBALL || (si >>= 1) != 0) {
			//^075F:0437
			if (glbCurrentMapIndex == glbMap_4c28 && xx == glbSomePosX_4c2e && yy == glbSomePosY_4c30) {
				ATTACK_PARTY(si, 0x3f, 1);
			}
			//^075F:045F
			di = GET_CREATURE_AT(xx, yy);
			if (di != OBJECT_NULL) {
				//^075F:0476
_0476:
				if (_1c9a_0958(di) == 0) {
					//^075F:0481
					Creature *bp0c = GET_ADDRESS_OF_RECORD4(di);
					AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp0c->CreatureType());
					if (bp08->w24_c_c() == 0 || rl == OBJECT_EFFECT_FIREBALL) {
						//^075F:04B3
						bp12 = bp08->GetFireResistance();
						if (bp12 != 15) {
							//^075F:04C8
							if (bp08->w0_5_5() != 0)
								si >>= 1;
							si -= RAND16((bp12 << 1) +1);
							if (si > 0) {
								ATTACK_CREATURE(di, xx, yy, 0x200d, 0x64, si);
							}
						}
					}
				}
			}
			//^075F:04FC
			if (bp16 != 0) {
				//^075F:0502
				di = _1c9a_03cf(&bp18, &bp1a, ss);
				if (di != OBJECT_NULL && (bp18 != bp0e || bp1a != bp10)) {
					xx = bp18;
					yy = bp18;
					bp16 = 0;
					si = bp14 >> 1;
					goto _0476;
				}
			}
		}
		//^075F:0549
		if (glbCurrentMapIndex == glbPlayerMap) {
			glbDoLightCheck = 1;
		}
	}
	//^075F:0558
	_075f_0182(rl, bp0e, bp10);
}
//^12B4:0D75
// SPX: Creature pushing back another creature or player?
void SkWinCore::_12b4_0d75(i16 xx, i16 yy, i16 ss, i16 tt)
{
	//^12B4:0D75
	ENTER(24);
	//^12B4:0D7B
	ObjectID bp12;
	i16 bp0a;
	i16 bp0c;
	X16 si;
	X16 bp06;
	X16 bp08;
	if (IS_CREATURE_MOVABLE_THERE(xx, yy, ss, &bp12) != 0) {
		//^12B4:0D97
		i16 bp10 = GET_CREATURE_WEIGHT(bp12);
		if (tt >= 0xfe || tt >= bp10 || RAND16(((bp10 -tt) >> 2) +1) == 0) {
			//^12B4:0DCA
			bp06 = xx + glbXAxisDelta[ss];
			bp08 = yy + glbYAxisDelta[ss];
			//^12B4:0DE8
			if (glbCurrentMapIndex == glbMap_4c28 && bp06 == glbSomePosX_4c2e && bp08 == glbSomePosY_4c30) {
				//^12B4:0E03
				_12b4_023f(xx, yy, &bp0a, &bp0c, glbPlayerDir, si = (ss +2) & 3);
			}
			else {
				//^12B4:0E2C
				_1c9a_0247(bp12);
				U8 bp13 = GET_ADDRESS_OF_RECORD4(bp12)->b5_0_7();
				if (bp13 != 0xff) {
					//^12B4:0E4D
					CreatureInfoData *bp18 = &glbTabCreaturesInfo[bp13];
					si = bp18->Command;
					if (si != -1 && si != ccmDestroy && (_4976_37a6[RCJ(86,si)] & 4) != 0) {
						RELEASE_CREATURE_TIMER(bp12);
						QUEUE_THINK_CREATURE(xx, yy);
					}
				}
				//^12B4:0E95
				MOVE_RECORD_TO(bp12, xx, yy, bp06, bp08);
				if (GET_CREATURE_AT(bp06, bp08) != OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp12) & 1) == 0) {
					ATTACK_CREATURE(OBJECT_NULL, bp06, bp08, 0x4002, 0xa, 0);
				}
			}
		}
	}
	//^12B4:0EE3
	if (glbCurrentMapIndex != glbMap_4c28 || xx != glbSomePosX_4c2e || yy != glbSomePosY_4c30)
		return;
	//^12B4:0F07
	i16 di = 0;
	Champion *bp04 = glbChampionSquad;
	si = 0;
	i16 bp0e;
	for (bp0e = 0; bp0e < 4; bp04++, bp0e++) {
		//^12B4:0F13
		if (bp04->curHP() != 0  && RAND02() == 0) {
			//^12B4:0F2D
			// SPX: Creature has just bumped back the player
			QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, bp04->HeroType(), SOUND_CHAMPION_BUMP, 0xfe, xx, yy, 1, 0x64, 0xc8);
			di = (GET_PLAYER_WEIGHT(bp0e) / 10) +di;
			si++;
		}
		//^12B4:0F6A
	}
	//^12B4:0F78
	if (si == 0)
		return;
	di = di / si;
	di += 0x28;
	if (tt >= 0xfe || tt > di) {
		PERFORM_MOVE(((ss - glbPlayerDir) & 3) +3);
	}
	//^12B4:0FA5
	return;
}
//^32CB:0054
U16 SkWinCore::QUERY_CREATURE_5x5_POS(Creature *ref, U16 dir)
{
	// center is 12. most still object is at 5x5pos 12.

	//     0  1  2  3  4 ->X
	//   |--|--|--|--|--|
	// 0 | 0| 1| 2| 3| 4|
	//   |--|--|--|--|--|
	// 1 | 5| 6| 7| 8| 9|
	//   |--|--|--|--|--|
	// 2 |10|11|12|13|14|
	//   |--|--|--|--|--|
	// 3 |15|16|17|18|19|
	//   |--|--|--|--|--|
	// 4 |20|21|22|23|24|
	// V y

	//^32CB:0054
	ENTER(4);
	//^32CB:0058
	if (ref->b5_0_7() == 0xff)
		return 12;
	sk1c9a02c3 *bp04 = _1c9a_02c3(ref, QUERY_CREATURE_AI_SPEC_FROM_TYPE(ref->CreatureType()));
	i16 _5x5 = _4976_5a98[_4937_000f(bp04->w0, &bp04->w2)][0];
	return ROTATE_5x5_POS(_5x5, dir);
}
//^098D:000F
void SkWinCore::_098d_000f(i16 xx, i16 yy, U16 ww, U16 *x2, U16 *y2)
{
	//^098D:000F
	ENTER(0);
	//^098D:0012
	*x2 = (xx << 2) + (ww % 5);
	*y2 = (yy << 2) + (ww / 5);
	//^098D:0046
	return;
}
//^29EE:000F
void SkWinCore::_29ee_000f()
{
	//^29EE:000F
	ENTER(54);
	//^29EE:0014
	U8 bp01 = (_4976_4ddc != 0) ? 0xe : 2;
	sk3f6c bp36;
	_0b36_0c52(&bp36, 9, 1);
	FILL_ENTIRE_PICT(reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp36.w0)), glbPaletteT16[COLOR_BLACK]);
	//^29EE:0053
	i16 si = 0x28;
	for (; si < 0x2e; bp01 += 2, si++) {
		//^29EE:0058
		DRAW_ICON_PICT_ENTRY(0x1, 0x3, bp01, &bp36, si, -1);
	}
	//^29EE:007E
	_0b36_0cbe(&bp36, 1);
	if (_4976_4ddc != 0) {
		_1031_0541(6);
	}
	else {
		_1031_0541(5);
	}
	//^29EE:00A0
	return;
}

//^1C9A:08BD
U16 SkWinCore::_1c9a_08bd(Creature *ref)
{
	//^1C9A:08BD
	ENTER(4);
	//^1C9A:08C3
	X16 si = 0;
	X16 di = ref->b5_0_7();
	if (di != 255) {
        CreatureInfoData *bp04 = &glbTabCreaturesInfo[di];
		if (bp04->Command == ccmJump) {
			switch (bp04->b31) {
				case 1:
				case 2:
					return 1;
			}
		}
		//^1C9A:0908
		return 0;
	}
	//^1C9A:090C
	return si;
}

//^1C9A:0912
U16 SkWinCore::IS_CREATURE_FLOATING(ObjectID rl)
{
	//^1C9A:0912
	ENTER(4);
	//^1C9A:0916
	Creature *bp04 = GET_ADDRESS_OF_RECORD4(rl);
	if (QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType())->w10_2_2() == 0) {
		if (_1c9a_08bd(bp04) == 0)
			return 0;
	}
	//^1C9A:094F
	return 1;
}

//^2FCF:0109
Bit16u SkWinCore::IS_OBJECT_FLOATING(ObjectID rl)
{
	// return 0 if object can fall down.
	// return 1 if object cannot be fall down.

	//^2FCF:0109
	ENTER(0);
	//^2FCF:010D
	U16 si = rl.DBType();
	if (si == dbCreature) {
		return IS_CREATURE_FLOATING(rl);
	}
	//^2FCF:0128
	return (si == dbMissile || si == dbCloud) ? 1 : 0;
}

//^2676:000A
void SkWinCore::MARK_DYN_LOAD(U32 aa)
{
	//^2676:000A
	ENTER(4);
	//^2676:000E
	ATLASSERT(_4976_5300 < 400U);
	SkLoadEnt *bp04 = &_4976_52fc[_4976_5300]; _4976_5300++;
	bp04->w0(0);
	bp04->x2.cls1(U8(aa >> 24));
	bp04->x2.cls2(U8(aa >> 16));
	bp04->x2.cls3(U8(aa >>  8));
	bp04->x2.cls4(U8(aa      ));
	//^2676:0068
	return;
}

//^2676:008F
void SkWinCore::MARK_DYN_EXCLUDE_RANGE(U32 ent4, U8 cls4)
{
	//^2676:008F
	ENTER(0);
	//^2676:0092
	MARK_DYN_LOAD(ent4);
	_4976_52fc[_4976_5300 -1].MarkContinuousExcluded();
	MARK_DYN_LOAD((ent4 & 0xffffff00) | cls4);
	//^2676:00CE
	return;
}

//^2676:006A
void SkWinCore::_2676_006a(U32 aa)
{
	//^2676:006A
	ENTER(0);
	//^2676:006D
	MARK_DYN_LOAD(aa);
	_4976_52fc[_4976_5300 -1].MarkExcluded();
	//^2676:008D
	return;
}

//^2676:00D0
void SkWinCore::_2676_00d0(U8 cls1, U8 cls2, U8 cls4)
{
	//^2676:00D0
	ENTER(2);
	//^2676:00D4
	X16 bp02 = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, dtWordValue, cls4);
	if (bp02 == 0)
		return;
	cls2 = U8(bp02);
	if (cls2 != 0) {
		//^2676:00FD
		MARK_DYN_LOAD(cls2 +0xffff0d00);
	}
	//^2676:010F
	bp02 >>= 8;
	if (bp02 != 0) {
		//^2676:011A
		MARK_DYN_LOAD(U8(bp02) +0xffff0d00);
	}
	//^2676:012F
	return;
}

//^01B0:194D
U16 SkWinCore::IS_SCARD_BUSY() //#DS=04BF
{
#if UseAltic
	;
#else
	//^01B0:194D
	ENTER(0);

	DOSIMPL();

//		//^01B0:1950
//		switch (glbSoundCardType) {
//			case 0:
//			case 1:
//			case 3:
//			case 4:
//			case 5:
//				//^01B0:1962
//				return sndLockSoundBuffer;
//
//			case ScardTandy:
//				//^01B0:1968
//				__asm mov ah,0x81
//				__asm int 0x1a
//				__asm rcl ax,1
//				__asm ret
//		}
#endif
	//^01B0:1973
	return 0;
}

//^01B0:1983
void SkWinCore::_01b0_1983() //#DS=04BF
{
	//^01B0:1983
	ENTER(0);
	//^01B0:1986
	LOADDS(0x3083);
	while (IS_SCARD_BUSY() != 0);
	//^01B0:1995
	return;
}

//^47EB:02D3
void SkWinCore::_47eb_02d3(U32 aa)
{
	//^47EB:02D3
	ENTER(0);
	//^47EB:02D6
	_01b0_1983();
	//^47EB:02DE
	return;
}

//^482B:060E
void SkWinCore::_482b_060e()
{
	//^482B:060E
	ENTER(0);
	//^482B:0611
	_47eb_02d3(0);
	_4976_49d0 = 0;
	//^482B:0622
	return;
}

//^3E74:1953
X16 SkWinCore::QUERY_NEXT_GDAT_ENTRY(SkEntIter *ref)
{
//LOGX(("QUERY_NEXT_GDAT_ENTRY from SGDAT ptr %08X : GDAT %s", ref, DEBUG_SKGDATENT(ref)));
	// 0 if not found
	// 1 if found

	//^3E74:1953
	ENTER(22);
	//^3E74:1959
	X8 bp05 = ref->x2.x2.cls2(); // cls2
	X8 bp06 = ref->x2.x2.cls4(); // cls4
	X16 bp0e = ((ref->x2.w0_0_e()) == 1) ? 1 : 0;
	X8 bp07;
	X8 bp08;
	if (bp0e != 0) {
		bp07 = ref->x8.x2.cls2();
		bp08 = ref->x8.x2.cls4();
	}
	else {
		bp07 = bp05;
	}
	//^3E74:199D
	X16 bp0c = ref->w0;
	if (bp0c != 0) {
		ref->w0 = 0;
		ref->cls1cur(ref->x2.x2.cls1());
		//^3E74:19B7
		if (ref->cls1cur() == 0xff) {
			ref->cls1cur(0x00);
			//^3E74:19C0
_19c0:
			ref->cls1base(U8(glbGDatEntries.w12));
		}
		//^3E74:19C8
		else if (bp0e != 0) {
			ref->cls1base(ref->x8.x2.cls1());
			//^3E74:19D9
			if (ref->cls1base() == 0xff) {
				goto _19c0;
			}
		}
		else {
			//^3E74:19DF
			ref->cls1base(ref->x2.x2.cls1());
		}
		//^3E74:19EA
		if (ref->cls1cur() < 0 || ref->cls1cur() > ref->cls1base() || ref->cls1base() > glbGDatEntries.w12)
			goto _1cd4;
	}
	do {
		//^3E74:1A13
		X16 bp0a = glbGDatEntries.pw0[ref->cls1cur()];
		U16 si;
		U16 di;
		if (glbGDatEntries.pw0[ref->cls1cur() +1] != bp0a) {
			//^3E74:1A47
			RawEntry *bp04;
			if (bp0c == 0) {
				si = ref->w24 +1;
				bp04 = ref->pv14 +1;
				if (ref->w26 > si)
					goto _1c0a;
				goto _1c82;
			}
			//^3E74:1A7E
			ref->cls3cur(ref->x2.x2.cls3());
			if (ref->cls3cur() == fmtInvalid) {
				//^3E74:1A8D
				ref->cls3cur(0x00);
				//^3E74:1A92
_1a92:
				ref->cls3base(U8(glbGDatEntries.pw0[ref->cls1cur() +1]) -bp0a -1);
			}
			//^3E74:1AAE
			else if (bp0e != 0) {
				ref->cls3base(ref->x8.x2.cls3());
				//^3E74:1ABF
				if (ref->cls3base() == fmtInvalid)
					goto _1a92;
			}
			else {
				//^3E74:1AC5
				ref->cls3base(ref->x2.x2.cls3());
			}
			//^3E74:1AD3
			bp0a += ref->cls3cur();
			si = ref->w24 = glbGDatEntries.pw4[bp0a++];
			ref->w22 = bp0a;
			ref->w26 = glbGDatEntries.pw4[ref->w22];
			ref->pv14 = bp04 = &glbGDatEntries.pv8[si];
			do {
				//^3E74:1B3E
				if (ref->w26 > si) {
					//^3E74:1B4A
					if (bp05 != 0xff) {
						//^3E74:1B5F
						X8 bp15 = (bp06 == 0xff) ? 0 : bp06;
						RawEntry *bp12 = &glbGDatEntries.pv8[-1];
						di = si;
						X16 bp14 = ref->w26 +1;
						do {
							//^3E74:1B8A
							si = (di +bp14) >> 1;
							bp04 = &bp12[si];
							// SkD((DLV_BUGHERE,"DBG: SI=%04X,DI=%04X,bp14=%04X\n"
							//	, 0U +si, 0U +di, 0U +bp14));
							if (si == di) {
								//^3E74:1BB5
								if (ref->w26 > si) {
									//^3E74:1BC1
									si++;
									bp04++;
									if (bp04->cls2 <= bp07)
										break;
								}
								goto _1c82;
							}
							//^3E74:1BDF
							if (bp04->cls2 == bp05) {
								if (bp04->cls4 <= bp15)
									break;
								//^3E74:1BF3
								goto _1c00;
							}
							//^3E74:1BF5
							if (bp04->cls2 > bp05) {
								//^3E74:1C00
_1c00:
								bp14 = si;
							}
							else {
								//^3E74:1C05
								di = si;
							}
						} while (true);
						//^3E74:1C09
						--si;
					}
_1c0a:
					do {
						//^3E74:1C0A
						if (bp04->cls2 > bp07)
							break;
						//^3E74:1C15
						if ((bp0e != 0) ? ((bp06 == 0xff || (bp04->cls4 >= bp06 && bp04->cls4 <= bp08))) : (bp06 == 0xff || bp04->cls4 == bp06)) {
							//^3E74:1C4A
							ref->w24 = si;
							ref->pv14 = bp04;
							return 1;
						}
						//^3E74:1C65
						if (ref->w26 <= ++si)
							break;
						//^3E74:1C71
						bp04++;
					} while (true);
				}
				//^3E74:1C82
_1c82:
				ref->cls3cur(ref->cls3cur() +1);
				if (ref->cls3cur() > ref->cls3base())
					break;
				si = ref->w26;
				ref->w26 = glbGDatEntries.pw4[++ref->w22];
			} while (true);
		}
		//^3E74:1CB9
		ref->cls1cur(ref->cls1cur() +1);
		if (ref->cls1cur() > ref->cls1base())
			break;
		bp0c = 1;
	} while (true);
_1cd4:
	ref->pv14 = NULL;
	ref->cls1cur(0xff);
	ref->cls1base(0xff);
	return 0;
}
//^3E74:1562
SkEnt4 SkWinCore::MAKE_ENT4(U8 cls1, U8 cls2, U8 cls3, U8 cls4)
{
	//^3E74:1562
	ENTER(4);
	//^3E74:1566
	SkEnt4 b4;
	b4.cls1(cls1);
	b4.cls2(cls2);
	b4.cls3(cls3);
	b4.cls4(cls4);
	return b4;
}
//^482B:0624
void SkWinCore::_482b_0624(U8 cls1, U8 cls2, U8 cls4)
{
	//^482B:0624
	ENTER(4);
	//^482B:0628
	if (QUERY_SND_ENTRY_INDEX(cls1, cls2, cls4) == 0 && _4976_49d4[0][0] < _4976_5d58) {
		sk5f06 *bp04 = &_4976_5f06[_4976_49d4[0][0]];
		bp04->category = cls1;
		bp04->index = cls2;
		bp04->entry = cls4;
		bp04->w5 = 0xffff;
		_4976_49d4[0][0]++;
	}
	//^482B:0682
	return;
}
//^3E74:18FA
U16 SkWinCore::TRACK_UNDERLAY(U16 ww)
{
	//^3E74:18FA
	ENTER(0);
	//^3E74:18FF
	X16 di = 0;
	X16 cx = _4976_5d78 +1;
	do {
		X16 si = (di +cx) >> 1;
		if (si == di) {
			return 0xffff;
		}
		if (ww < _4976_5d0c[si -1].w0) {
			cx = si;
			continue;
		}
		if (ww > _4976_5d0c[si -1].w0) {
			di = si;
			continue;
		}
		return _4976_5d0c[si -1].w2;
	} while (true);
}

//^3E74:00ED
X16 SkWinCore::_3e74_00ed(sk5d12 *ref, shelf_memory ps)
{
	//^3E74:00ED
	ENTER(4);
	//^3E74:00F2
	X16 si = 0;
	if (ref == NULL)
		return si;
	//^3E74:010C
	if (ps.AtEMS()) {
		//^3E74:011A
		if (ref->Is4EMS() && ref->t4 <= tiamat(ps) && ref->t0 >= tiamat(ps)) {
			//^3E74:014F
			return 1;
		}
		//^3E74:0154
		return 0;
	}
	//^3E74:0158
	U8 *bp04 = REALIZE_GRAPHICS_DATA_MEMORY(ps);
	if (t2ptr(ref->t4) <= bp04 && t2ptr(ref->t0) >= bp04)
		return 1;
	return 0;
}

tiamat SkWinCore::s2t(shelf_memory s) {
	return tiamat(s);
}
shelf_memory SkWinCore::t2s(tiamat t) {
	switch (t.Area()) {
		case 0:
			return shelf_memory::From_cram(t.val);
		case 1:
			return shelf_memory::From_cems(t.val -0x200000);
	}
	ATLASSERT(false);
	return shelf_memory();
}
U8 *SkWinCore::t2ptr(tiamat t) {
	switch (t.Area()) {
		case 0: return &cram[t.val];
		case 1: return &cems[t.val -0x200000];
	}
	ATLASSERT(false);
	return NULL;
}
tiamat SkWinCore::ptr2t(U8 *pb) {
	U32ptr val;
	val = pb -cram;
	if (val < sizeof(cram)) {
		tiamat v; v.val = (U32)val; return v;
	}
	val = pb -cems;
	if (val < sizeof(cems)) {
		tiamat v; v.val = (U32)val +0x200000; return v;
	}
	ATLASSERT(false);
	return tiamat::zero();
}

//^3E74:3200
void SkWinCore::_3e74_3200(X16 ww) { // TODO: Unr
	Unr();
}

//^4726:0162
void SkWinCore::MAP_EMS_TO_PTR(U32 xx, U32 yy, U8 **ss, U8 **tt)
{
//!	//^4726:0162
//!	ENTER(14);
//!	//^4726:0168
//!	if (xx > yy) {
//!		//^4726:017A
//!		X32 bp0e = xx;
//!		xx = yy;
//!		yy = bp0e;
//!		U8 **bp08 = ss;
//!		ss = tt;
//!		tt = bp08;
//!	}
//!	//^4726:01C2
//!	U16 bp04 = U16(xx >> 14);
//!	U16 di = U16(xx) & 0x3fff;
//!	U16 bp06 = U16(yy >> 14);
//!	U16 si = U16(yy) & 0x3fff;
//!	U8 bp01 = 0;
//!	U8 bp02 = U8(bp06 -bp04);
//!	__asm mov  ah,0x44
//!	__asm mov  al,[bp01]
//!	__asm mov  bx,[bp04]
//!	__asm mov  dx,[_4976_5ea4]
//!	__asm int  0x67
//!	bp01++;
//!	bp04++;
//!	__asm mov  ah,0x44
//!	__asm mov  al,[bp01]
//!	__asm mov  bx,[bp04]
//!	__asm mov  dx,[_4976_5ea4]
//!	__asm int  0x67
//!	*ss = &_4976_5ea0[di];
//!	if (bp02 >= 2) {
//!		//^4726:023A
//!		bp02 = 2;
//!		__asm mov  ah,0x44
//!		__asm mov  al,[bp02]
//!		__asm mov  bx,[bp06]
//!		__asm mov  dx,[_4976_5ea4]
//!		__asm int  0x67
//!		bp02++;
//!		bp06++;
//!		__asm mov  ah,0x44
//!		__asm mov  al,[bp02]
//!		__asm mov  bx,[bp06]
//!		__asm mov  dx,[_4976_5ea4]
//!		__asm int  0x67
//!		bp02 = 2;
//!	}
//!	//^4726:0266
//!	else if (bp02 == 1) {
//!		//^4726:026C
//!		bp02 = 2;
//!		bp06++;
//!		__asm mov  ah,0x44
//!		__asm mov  al,[bp02]
//!		__asm mov  bx,[bp06]
//!		__asm mov  dx,[_4976_5ea4]
//!		__asm int  0x67
//!		bp02 = 1;
//!	}
//!	else {
//!		//^4726:0287
//!		bp02 = 0;
//!	}
//!	//^4726:028B
//!	*tt = &_4976_5ea0[si + (bp02 << 14)];
}

//^4726:02AC
U8 *SkWinCore::_4726_02ac()
{
	//^4726:02AC
	ENTER(4);
	//^4726:02B0
	if (_4976_4968 != 0) {
		//^4726:02B7
		U8 *bp04 = EMS_MAP_BANK_TO_MEMORY(_4976_5eac + (+6), 1);
		WRITE_UI16(bp04,-6,8);
		WRITE_UI16(bp04,-4,_4976_00f6);
		WRITE_UI16(bp04,-2,_4976_00f8);
		return bp04;
	}
	return NULL;
}

//^3E74:2F41
void SkWinCore::_3e74_2f41(sk5d12 *ref)
{
	//^3E74:2F41
	ENTER(28);
	//^3E74:2F47
	shelf_memory bp08 = t2s(ref->t0);
	shelf_memory bp04 = bp08 -2;
	//^3E74:2F63
	while (ref->t8 < tiamat(bp04)) {
		//^3E74:2F66
		X16 si = READ_UI16(REALIZE_GRAPHICS_DATA_MEMORY(bp04),+0);
		i32 bp0c = ((QUERY_GDAT_RAW_DATA_LENGTH(si & 0x7fff) +1) & 0xfffe) +4;
		bp04 -= (bp0c);
		if ((si & 0x8000) == 0) {
			//^3E74:2FA8
			bp08 -= (bp0c);
			if (bp04 + (+2) != bp08) {
				//^3E74:2FC7
				// SPX: I crashed here with custom dungeon/gdat, at that point, map_ems_to_ptr has no effective code.
				if (!SkCodeParam::bUsePowerDebug)
					ATLASSERT(false);
				U32 bp10 = bp04.val -0x001FFFFE;
				U32 bp14 = bp08.val -0x00200000;
				do {
					//^3E74:2FEB
					// SPX: problem here with unitialized bp18 & bp1c and no written code to map_ems_to_ptr
					U8 *bp18 = 0;	// U8 *bp18;
					U8 *bp1c = 0;	// U8 *bp1c;
					MAP_EMS_TO_PTR(bp10, bp14, &bp18, &bp1c);
					if (!SkCodeParam::bUsePowerDebug || (bp18 != 0 && bp1c != 0) )
						COPY_MEMORY(bp18, bp1c, (bp0c > 0x4000) ? 0x4000 : bp0c);
					bp0c -= 0x4000;
					if (bp0c <= 0)
						break;
					bp10 += 0x4000;
					bp14 += 0x4000;
				} while (true);
				//^3E74:3068
				glbShelfMemoryTable[si] = bp08 + (+2);
			}
		}
		//^3E74:3086
	}
	//^3E74:30A3
	ref->t8 = s2t(bp08);
	_4726_02ac();
	//^3E74:30B9
	return;
}

//^3E74:30BD
void SkWinCore::_3e74_30bd(sk5d12 *ref)
{
	//^3E74:30BD
	ENTER(12);
	//^3E74:30C3
	if (ref->t0.IsZero())
		return;
	//^3E74:30DB
	if (ref->Is4EMS() != 0) {
		_3e74_2f41(ref);
		return;
	}
	//^3E74:30F5
	U8 *bp08 = t2ptr(ref->t0);
	U8 *bp04 = PTR_PADD(bp08,-2);
	for (; t2ptr(ref->t8) < bp04; ) {
		//^3E74:311D
		X16 si = READ_UI16(bp04,+0);
		X32 bp0c = ((QUERY_GDAT_RAW_DATA_LENGTH(si & 0x7fff) +1) & 0xfffe) +4;
		bp04 -= bp0c;
		if ((si & 0x8000) == 0) {
			//^3E74:3153
			bp08 -= bp0c;
			if (bp04 +2 != bp08) {
				//^3E74:3180
				COPY_MEMORY(bp04 +2, bp08, bp0c);
				glbShelfMemoryTable[si] = CONVERT_PHYS_TO_SHELF_FORM(bp08 +2);
			}
		}
		//^3E74:31D0
	}
	//^3E74:31EB
	ref->t8 = ptr2t(bp08);
	//^3E74:31FC
	return;
}
//^3E74:0017
X32 SkWinCore::_3e74_0017(sk5d12 *ref)
{
	//^3E74:0017
	ENTER(4);
	//^3E74:001B
	X32 bp04 = 0;
	if (ref->t0.IsntZero()) {
		if (ref->Is4EMS()) {
			bp04 = tiamat::Size(ref->t0, ref->t4);
		}
		else {
			bp04 = tiamat::Size(ref->t0, ref->t4);
		}
	}
	//^3E74:0079
	return bp04;
}

//^3E74:0081
i32 SkWinCore::_3e74_0081(sk5d12 *ref) { // TODO: Unr
	Unr(); return 0;
}

//^3E74:32FB
tiamat SkWinCore::_3e74_32fb(sk5d12 *ss, U8 *tt, i32 ww) { // TODO: Unr
	Unr(); return tiamat();
}

//^0AAF:081B
void SkWinCore::DRAW_DIALOGUE_PROGRESS(X32 xx)
{
	//^0AAF:081B
	ENTER(8);
	//^0AAF:081F
	if (_4976_4bd8 == 0)
		return;
	//^0AAF:0826
	SRECT bp08;
	QUERY_EXPANDED_RECT(0x1da, &bp08);
	bp08.cx = i16((bp08.cx * xx) / 1000);
	if (bp08.cx <= 0)
		return;
	FIRE_FILL_BACKBUFF_RECT(&bp08, glbPaletteT16[COLOR_ORANGE]);
	_0aaf_002f();
	//^0AAF:0878
	return;
}

//^3E74:5133
shelf_memory SkWinCore::_3e74_5133(U8 cls1, U8 cls2, U8 cls3, U8 cls4)
{
	//^3E74:5133
	ENTER(0);
	//^3E74:5137
	U16 si = QUERY_GDAT_ENTRY_DATA_INDEX(cls1, cls2, cls3, cls4);
	return glbShelfMemoryTable[si];
}
//^47EB:00A4
void SkWinCore::_47eb_00a4(sk5f0a *ref)
{
	//^47EB:00A4
	ENTER(4);
	//^47EB:00A8
	sk5f0a **bp04 = &ref->pv8;
	*bp04 = _4976_5efa;
	_4976_5efa = ref;
	//^47EB:00D7
	return;
}

//^482B:0684
void  SkWinCore::_482b_0684()
{
	//^482B:0684
	ENTER(6);
	//^482B:068A
	for (U16 si = 0; si < _4976_49d4[0][0]; si++) {
		//^482B:068F
		sk5f06 *bp04 = &_4976_5f06[si];
		if (bp04->w5 != 0xffff)
			continue;
		X16 di =  QUERY_GDAT_ENTRY_DATA_INDEX(bp04->category, bp04->index, dtSnd, bp04->entry);
		X16 bp06 = _482b_015c(di);
		if (bp06 != 0) {
			bp04->w0 = _4976_5f06[bp06 -1].w0;
			bp04->w5 = di;
			continue;
		}
		//^482B:06F7
		if (_4976_49d4[0][1] >= _4976_5cae)
			break;
		bp04->w5 = di;
		bp04->w0 = _4976_49d4[0][1];
		_4976_5f0a[bp04->w0].ps0 = _3e74_5133(bp04->category, bp04->index, dtSnd, bp04->entry) + (2);
		//^482B:074F
		_4976_5f0a[bp04->w0].w4 = QUERY_GDAT_ENTRY_DATA_LENGTH(bp04->category, bp04->index, dtSnd, bp04->entry) -2;
		//^482B:0780
		_4976_5f0a[bp04->w0].w6 = 0x157C;	// 5500
		//^482B:0795
		_47eb_00a4(&_4976_5f0a[bp04->w0]);
		_4976_49d4[0][1]++;
		//^482B:07B4
	}
	//^482B:07BE
	return;
}

//^3E74:32A2
tiamat SkWinCore::_3e74_32a2(sk5d12 *ref, i32 xx)
{
	//^3E74:32A2
	ENTER(0);
	//^3E74:32A6
	X16 si = (ref->Is4EMS() != 0) ? 1 : 0;
	if (si != 0) {
		//^3E74:32BE
		ref->t8 -= xx;
	}
	else {
		//^3E74:32D9
		ref->t8 -= xx;
	}
	//^3E74:32ED
	return ref->t8;
}

//^3E74:33A4
void SkWinCore::LOAD_DYN4(SkLoadEnt *ref, i16 aa)
{
	//^3E74:33A4
	ENTER(92);
	//^3E74:33AA
	X16 bp38 = 0;
	X16 bp3a = 0;
	U8 *bp04 = ALLOC_MEMORY_RAM(glbGDatNumberOfData, afZeroMem, 1024);
	// flags: XY-#####
	//           ref. cnt
	//         pool flag?
	//        pool flag?
	if (_4976_5c8a == 0) {
		_482b_07c2(0);
	}
	SkLoadEnt *bp08 = ref;
	i16 bp12 = 0;
	//^3E74:33ED
	SkEntIter bp5c;
	X16 si;
	X16 bp2e;
	SkLoadEnt bp40; // @28 bp40 // smily :P
	for (; bp12 < aa; bp12++) {
		//^3E74:33F0
		bp5c.w0 = 1;
		bp5c.x2 = *bp08;
		bp2e = bp5c.x2.w0();
		if ((bp2e & 0x7fff) == 1) {
			//^3E74:3419
			bp5c.x8 = bp08[1]; bp08++; bp12++;
		}

LOGX(("LOAD_DYN4: %02d / %02d", bp12, aa));
LOGX(("LOAD_DYN4: MASK: %s", DEBUG_SKLOADENT((U8*)bp08) ));

		SkD((DLV_DYN, "Dyn: Test(%04X,%02X,%02X,%02X,%02X)\n"
			, 0U +bp08->w0(), 0U +bp08->x2.cls1(), 0U +bp08->x2.cls2(), 0U +bp08->x2.cls3(), 0U +bp08->x2.cls4()));
		// ATLASSERT(!(bp08->b2 == 7 && bp08->b3 == 0 && bp08->b4 == 255 && bp08->b5 == 255));
		while (QUERY_NEXT_GDAT_ENTRY(&bp5c) != 0) {
			//^3E74:3441
			X8 bp2c = bp5c.cls3cur();
			if (bp2c == 0xb || bp2c == 0xc || ((si = bp5c.pv14->data) & 0x8000) != 0)
				continue;
			//^3E74:3469
			SkD((DLV_DYN, "Dyn: Match(%02X,%02X,%02X,%02X,%5u)\n"
				, 0U +bp5c.cls1cur(), 0U +bp5c.pv14->cls2, 0U +bp5c.cls3cur(), 0U +bp5c.pv14->cls4, 0U +bp5c.pv14->data));
			U8 bp2b = bp04[si];
			if ((bp2e & 0x8000) != 0) {
				//^3E74:3489
				bp2b &= 0x1f;
				if (bp2b > 0 && bp2b != 0x1f) {
					//^3E74:34A0
					--bp04[si];
				}
				continue;
			}
			//^3E74:34B9
			if (bp2b != 0) {
				if ((bp2b & 0x1f) != 0x1f) {
					//^3E74:34CB
					++bp04[si];
				}
				continue;
			}
			//^3E74:34E4
			if (bp2c == 2) {
				if (_482b_015c(si) != 0 || _4976_5bee[2] != 0)
					continue;
			}
			//^3E74:34E4
			bp04[si] = 1;
			X16 bp36 = _4976_481a[RCJ(15,bp2c)];
			//^3E74:3523
			if ((bp36 & _4976_5d12.w12) != 0 && (bp36 & _4976_5d7e.w12) == 0) {
				//^3E74:3533
				bp04[si] |= 0x40;
			}
			//^3E74:354C
			else if ((bp36 & _4976_5d7e.w12) != 0 && (bp36 & _4976_5d12.w12) == 0) {
				//^3E74:355C
				bp04[si] |= 0x80;
			}
			//^3E74:3573
		}
		//^3E74:3585
		bp08++;
		if (aa -1 == bp12 && bp3a == 0) {
			bp3a = 1;
			bp12--;
			bp08 = &bp40;
			bp40.w0(0);
			bp40.x2 = MAKE_ENT4(0x15,0xfe,0x01,0xfe); // add our smily ":P" once
		}
		//^3E74:35D0
	}
	//^3E74:35DE
	for (si = 0; si < glbGDatNumberOfData; si++) {
		//^3E74:35E2
		bp12 = bp04[si];
		if (bp12 != 0) {
			if ((bp12 & 0x1f) != 0) {
				bp04[si] = (bp12 & 0xe0) | 0x21;
			}
			else {
				bp04[si] &= 0x20;
			}
		}
		//^3E74:3640
	}
	//^3E74:3647
	bp08 = ref;
	bp12 = 0;
	//^3E74:3658
	for (; bp12 < aa; bp08++, bp12++) {
		//^3E74:365B
		bp5c.w0 = 1;
		bp5c.x2 = *bp08;
		bp2e = bp5c.x2.w0();
		if ((bp2e & 0x7fff) == 1) {
			bp08++; bp12++;
			bp5c.x8 = *bp08;
			if (bp5c.x2.x2.cls3() != fmtInvalid && (bp5c.x2.x2.cls3() > fmtSound || bp5c.x2.x2.cls3() < fmtSound))
				continue;
			bp5c.x8.x2.cls3(fmtSound);
			bp5c.x2.x2.cls3(fmtSound);
		}
		//^3E74:36C0
		if ((bp2e & 0x8000) != 0)
			continue;
		if (bp5c.x2.x2.cls3() != fmtInvalid && bp5c.x2.x2.cls3() != fmtSound)
			continue;
		//^3E74:36D3
		bp5c.x2.x2.cls3(fmtSound);
		while (QUERY_NEXT_GDAT_ENTRY(&bp5c) != 0) {
			//^3E74:36D9
			si = bp5c.pv14->data & 0x7fff;
			if ((bp04[si] & 1) == 0) {
				if (_482b_015c(si) == 0)
					continue;
			}
			//^3E74:3709
			_482b_0624(bp5c.cls1cur(), bp5c.pv14->cls2, bp5c.pv14->cls4);
			//^3E74:3721
		}
		//^3E74:3730
	}
	//^3E74:374D
	if (_4976_5d78 != 0) {
		for (si = 0; si < glbGDatNumberOfData; si++) {
			//^3E74:375B
			if ((bp04[si] & 1) == 0)
				continue;
			X16 di;
			if ((di = TRACK_UNDERLAY(si)) != 0xffff) {
				while ((bp04[di] & 1) == 0) {
					bp04[di] |= bp04[si] & 0xc1;
					if (TRACK_UNDERLAY(di) == 0xffff)
						break;
				}
			}
			//^3E74:37D2
		}
		//^3E74:37D9
	}
	goto _38db;

	do {
		//^3E74:37DC
		FREE_INDEXED_MEMENT(_4976_5d5e->w10());
		//^3E74:37E9
_37e9:
		;
	} while (_4976_5d5e != NULL);
	//^3E74:37FB
	for (si = 0; si < glbGDatNumberOfData; si++) {
		//^3E74:3800
		shelf_memory bp08 = glbShelfMemoryTable[si];
		if (bp08.Absent())
			continue;
		//^3E74:3823
		if (_3e74_00ed(&_4976_5d12, bp08) == 0 && _3e74_00ed(&_4976_5d7e, bp08) == 0)
			continue;
		bp12 = bp04[si];
		bp12 &= ((bp12 & 1) != 0) ? 0xfff9 : 0x0020;
		bp04[si] = U8(bp12);
		_3e74_3200(si);
		//^3E74:3898
	}
	//^3E74:38A2
	_3e74_30bd(&_4976_5d12);
	_3e74_30bd(&_4976_5d7e);
	_4976_5cf8 += tiamat::Size(_4976_5d12.t8, _4976_5d12.t4);
	SkD((DLV_CPX,"CPX: _4976_5cf8 += %u\n", (Bitu)tiamat::Size(_4976_5d12.t8, _4976_5d12.t4)));
	_4976_5d12.t4 = _4976_5d12.t8;
	//^3E74:38DB
_38db:
	X32 bp1a = 0;
	X32 bp16 = 0;
	X32 bp1e = _3e74_0017(&_4976_5d7e);
	U32 bp22 = tiamat::Size(_4976_5d12.t0, ptr2t(reinterpret_cast<U8 *>(_4976_5ce6)));
	//^3E74:3915
	i32 bp10;
	for (si = 0; si < glbGDatNumberOfData; si++) {
		//^3E74:391A
		bp12 = bp04[si] = bp04[si] & 0xe1;
		shelf_memory bp08 = glbShelfMemoryTable[si];
		if (bp08.Present()) {
			//^3E74:3975
			bp10 = ((READ_UI16(REALIZE_GRAPHICS_DATA_MEMORY(bp08),-2) +1) & 0xfffe) +4;
			if (_3e74_00ed(&_4976_5d12, bp08) != 0) {
				//^3E74:39B7
				bp04[si] |= 0x0a;
				if ((bp12 & 1) == 0) {
					bp04[si] |= 0x40;
				}
				//^3E74:39EC
_39ec:
				bp16 += bp10;
			}
			else {
				//^3E74:39FB
				if (_3e74_00ed(&_4976_5d7e, bp08) != 0) {
					bp04[si] |= 0x14;
					if ((bp12 & 1) == 0) {
						bp04[si] |= 0x80;
					}
					goto _3abe;
				}
				//^_3a49
				bp04[si] = 0;
			}
			continue;
		}
		//^3E74:3A62
		if ((bp12 & 1) != 0) {
			bp10 = ((bp08.SizeIfAbsent() +1) & 0xfffe) +4;
			if (bp1e == 0 || (bp12 & 0x40) != 0) {
				//^3E74:3A8D
				bp04[si] |= 8;
				goto _39ec;
			}
			else {
				//^3E74:3AA7
				bp04[si] |= 0x10;
				//^3E74:3ABE
_3abe:
				bp1a += bp10;
			}
		}
		//^3E74:3ACA
	}
	//^3E74:3AD4
	if (bp1a > bp1e) {
		//^3E74:3AEC
		for (si = 0; (bp22 -bp16 > _4976_480f) && (bp1a > bp1e) && (si < glbGDatNumberOfData); si++) {
			//^3E74:3AF0
			if ((bp04[si] & 0x94) == 0x10) {
				bp04[si] ^= 0x18;
				bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
				bp16 += bp10;
				bp1a -= bp10;
			}
			//^3E74:3B4A
		}
		//^3E74:3B80
		for (si = 0; (bp22 -bp16 > _4976_480f) && (bp1a > bp1e) && (si < glbGDatNumberOfData); si++) {
			//^3E74:3B84
			if ((bp04[si] & 0x90) == 0x10) {
				bp04[si] ^= 0x18;
				bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
				bp16 += bp10;
				bp1a -= bp10;
			}
			//^3E74:3BDE
		}
		//^3E74:3C14
		for (si = 0; (bp1a > bp1e) && (si < glbGDatNumberOfData); si++) {
			//^3E74:3C18
			if ((bp04[si] & 0x11) == 0x10) {
				bp04[si] = bp04[si] & 0xef;
				bp1a -= ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
			}
			//^3E74:3C78
		}
		//^3E74:3C91
		if (_4976_5bee[3] == 0) {
			//^3E74:3C9D
			for (si = 0; (bp1a > bp1e) && (si < glbGDatNumberOfData); si++) {
				//^3E74:3CA1
				if ((bp04[si] & 0x94) == 0x10) {
					bp04[si] ^= 0x18;
					bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
					bp16 += bp10;
					bp1a -= bp10;
				}
				//^3E74:3CFB
			}
			//^3E74:3D14
			for (si = 0; (bp1a > bp1e) && (si < glbGDatNumberOfData); si++) {
				//^3E74:3D18
				if ((bp04[si] & 0x90) == 0x10) {
					bp04[si] ^= 0x18;
					bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
					bp16 += bp10;
					bp1a -= bp10;
				}
				//^3E74:3D72
			}
		}
	}
	//^3E74:3D8B
	for (si = 0; (bp1e -bp1a >= 6) && (si < glbGDatNumberOfData); si++) {
		//^3E74:3D8F
		if ((bp04[si] & 0x48) == 8) {
			bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
			if (i32(bp1e -bp1a) >= bp10) {
				//^3E74:3DD8
				bp04[si] ^= 0x18;
				bp1a += bp10;
				bp16 -= bp10;
			}
		}
		//^3E74:3E01
	}
	//^3E74:3E22
	for (si = 0; (bp22 -bp16 <= _4976_480f) && (si < glbGDatNumberOfData); si++) {
		//^3E74:3E26
		if ((bp04[si] & 9) == 8) {
			bp04[si] = bp04[si] & 0xf7;
			bp16 += ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
		}
		//^3E74:3E86
	}
	//^3E74:3EAA
	X32 bp2a = bp22 -bp16;
	_4976_5d62 = bp1e -bp1a;
	_4976_5d26 = bp2a - _4976_5ca0;
	_4976_5d66 = bp2a;
	i32 bp26;
	if (_4976_5c8a == 0) {
		if (_4976_5d26 < 0 || _4976_5d62 < 0) {
			//^3E74:3F1B
			if (bp38 == 0) {
				bp38 = 1;
				goto _37e9;
			}
			//^3E74:3F29
			RAISE_SYSERR(SYSTEM_ERROR__LOAD_DYN4);
		}
		//^3E74:3F31
		bp26 = tiamat::Size(_4976_5d12.t8, _4976_5d12.t0 -bp16);
		//^3E74:3F59
		for (si = 0; si < glbGDatNumberOfData; si++) {
			//^3E74:3F5D
			bp12 = bp04[si];
			if ((bp12 & 6) != 0 && (bp12 & 0x18) == 0) {
				bp04[si] &= 0x20;
				FREE_INDEXED_MEMENT(si);
				_3e74_3200(si);
			}
			//^3E74:3FA7
		}
		//^3E74:3FAE
		if (bp26 > 0) {
			//^3E74:3FBC
			GUARANTEE_FREE_CPXHEAP_SIZE(bp26);
		}
		//^3E74:3FC8
		_3e74_2b30();
		if (bp26 > 0) {
			//^3E74:3FDA
			_4976_5cf8 -= bp26;
			SkD((DLV_CPX,"CPX: _4976_5cf8 -= %u\n", (Bitu)bp26));
			_4976_5d12.t4 = _4976_5d12.t0 -bp16;
		}
		X16 bp32;
		do {
			bp32 = 0;
			//^3E74:4006
			for (si = 0; si < glbGDatNumberOfData; si++) {
				//^3E74:400B
				bp12 = bp04[si];
				tiamat bp08;
				if ((bp12 & 0xc) == 0xc) {
					bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
					if (_3e74_0081(&_4976_5d12) < bp10) {
						//^3E74:405C
						_3e74_30bd(&_4976_5d12);
						if (_3e74_0081(&_4976_5d12) < bp10) {
							//^3E74:407C
							bp32 = 1;
							continue;
						}
					}
					//^3E74:4084
					bp08 = _3e74_32fb(&_4976_5d12, REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]), bp10);
					_3e74_3200(si);
					goto _4173;
				}
				//^3E74:40BE
				else if ((bp12 & 0x12) != 0x12) {
					continue;
				}
				else {
					//^3E74:40CC
					bp10 = ((QUERY_GDAT_RAW_DATA_LENGTH(si) +1) & 0xfffe) +4;
					if (_3e74_0081(&_4976_5d7e) < bp10) {
						//^3E74:40F7
						_3e74_30bd(&_4976_5d7e);
						if (_3e74_0081(&_4976_5d7e) < bp10) {
							bp32 = 1;
							continue;
						}
					}
					//^3E74:411A
					bp08 = _3e74_32fb(&_4976_5d7e, REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si]), bp10);
					_3e74_3200(si);
					if ((_4976_5d7e.w12 & 0x8000) != 0) {
						//^3E74:4159
						glbShelfMemoryTable[si] = t2s(bp08);
					}
					else {
						//^3E74:4173
_4173:
						glbShelfMemoryTable[si] = CONVERT_PHYS_TO_SHELF_FORM(t2ptr(bp08));
					}
					//^3E74:419B
					bp04[si] ^= 6;
					//^3E74:41B2
				}
			}
			//^3E74:41BC
		} while (bp32 != 0);
		//^3E74:41C5
		_3e74_30bd(&_4976_5d12);
		_3e74_30bd(&_4976_5d7e);
		if (bp26 < 0) {
			//^3E74:41E7
			_4976_5cf8 -= bp26;
			SkD((DLV_CPX,"CPX: _4976_5cf8 -= %u\n", (Bitu)bp26));
			_4976_5d12.t4 = _4976_5d12.t0 -bp16;
		}
		//^3E74:420E
		X16 bp34 = 0;
		//^3E74:4213
		for (si = 0; si < glbGDatNumberOfData; si++) {
			//^3E74:4218
			if (_4976_4bd8 != 0 && (si & 0x3f) == 0) {
				//^3E74:4225
				DRAW_DIALOGUE_PROGRESS((((si +1) * 500) / glbGDatNumberOfData) + 500);
			}
			//^3E74:4250
			bp12 = bp04[si] & 0xffdf;
			if (bp12 == 0 || (bp12 & 6) != 0)
				continue;
			//^3E74:427F
			X16 bp30;
			bp10 = (((bp30 = QUERY_GDAT_RAW_DATA_LENGTH(si)) +1) & 0xfffe) +4;
			sk5d12 *bp0c = ((bp12 & 8) != 0) ? &_4976_5d12 : &_4976_5d7e;
			//^3E74:42AD
			tiamat bp08 = _3e74_32a2(bp0c, bp10);
			if (bp0c->Is4EMS() != 0) {
				//^3E74:42D1
				WRITE_UI16(REALIZE_GRAPHICS_DATA_MEMORY(t2s(bp08) + (bp10) - (2)),+0,si);
				bp08 = ptr2t(REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[si] = t2s(bp08 + (2))));
			}
			else {
				//^3E74:432A
				glbShelfMemoryTable[si] = CONVERT_PHYS_TO_SHELF_FORM(t2ptr(bp08 +2));
				WRITE_UI16(t2ptr(bp08),+bp10 -4,si);
			}
			//^3E74:4380
			WRITE_UI16(t2ptr(bp08),-2,bp30);
			if (bp34 == 0) {
				_2066_03e0(0);
				GRAPHICS_DATA_OPEN();
				bp34 = 1;
			}
#if DEBUG_SPEC	// SPX: would remove this as debug test ?
			if (si == 1332) {
				U32 pos1 = QUERY_GDAT_RAW_DATA_FILE_POS(1);
				U32 len1 = QUERY_GDAT_RAW_DATA_LENGTH(1);
				ATLASSERT(pos1 == 71728 && len1 == 3836);
				U32 pos = QUERY_GDAT_RAW_DATA_FILE_POS(1332);
				U32 len = QUERY_GDAT_RAW_DATA_LENGTH(1332);
				ATLASSERT(pos == 380964 && len == 168);
			}
#endif
//LOGX(("LOAD_GDAT_RAW_DATA call from LOAD_DYN4"));
			LOAD_GDAT_RAW_DATA(si, glbShelfMemoryTable[si]);
			SkD((DLV_GLD, "GLD: Dyn4-load Raw#%4d at S(%08lX)\n", (Bitu)si, (Bitu)glbShelfMemoryTable[si].val));
			//^3E74:43CC
		}
		//^3E74:43D6
		if (bp34 != 0)
			GRAPHICS_DATA_CLOSE();
		//^3E74:43E0
		_4976_5ce2 = t2ptr(_4976_5d12.t4);
		_482b_0684();
		if (_4976_4bd8 != 0) {
			DRAW_DIALOGUE_PROGRESS(1000);
		}
	}
	//^3E74:4406
	DEALLOC_UPPER_MEMORY(glbGDatNumberOfData);
	//^3E74:4412
	return;
}

//^48AE:03DE
// SPX: Isn't a load misc only for money item ??
void SkWinCore::LOAD_MISCITEM()
{
	//^48AE:03DE
	ENTER(4);
	//^48AE:03E4
	if (glbMiscItemsLoaded != 0)
		return;
	//^48AE:03EE
	glbMiscItemsLoaded = 1;
	//^48AE:03F4
	// SPX: Original code loads 128 (0x80) items, GDAT can contain more!
	X8 max = ITEM_MISC_LOAD_MAX;	// 0x80
	if (SkCodeParam::bUseDM2ExtendedMode)
		max = ITEM_LOAD_MAX_EXTEND_1;
	for (X8 item = 0; item < max; item++) {
		//^48AE:03FB
		if ((QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_MISCELLANEOUS, item, dtWordValue, GDAT_ITEM_STATS_GEN_FLAGS) & ITEM_FLAG_CURRENCY) == 0)
			continue;
		U16 moneyValue = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_MISCELLANEOUS, item, dtWordValue, GDAT_ITEM_STATS_MONEY_VALUE);
		//^48AE:0429
		i16 si;
		for (si = 0; si < glbCountMoneyItems; si++) {
			//^48AE:042D
			if (glbMoneyItemsValueTable[si] >= moneyValue)
				break;
			//^48AE:0437
		}
		//^48AE:043E
		if (si < glbCountMoneyItems) {
			//^48AE:0444
			i16 bp04 = (glbCountMoneyItems -si) << 1;
			MOVE_MEMORY(&glbMoneyItemsValueTable[si], &glbMoneyItemsValueTable[si +1], bp04);
			MOVE_MEMORY(&glbMoneyItemsIDTable[si], &glbMoneyItemsIDTable[si +1], bp04);
		}
		//^48AE:048B
		glbMoneyItemsValueTable[si] = moneyValue;
		glbMoneyItemsIDTable[si] = item +0x100;
		glbCountMoneyItems++;
		//^48AE:04A7
	}
	//^48AE:04B3
	return;
}

//^3DF7:000A
// SPX: _3df7_000a renamed SET_TIMER_WEATHER
void SkWinCore::SET_TIMER_WEATHER(U32 tickDelta)
{
	//^3DF7:000A
	ENTER(10);

	if (SkCodeParam::bUseDM2ExtendedMode && fDebugRainSpeed != 1)
		tickDelta = (U32) ((float) tickDelta / (float) fDebugRainSpeed);

	SkD((DLV_DBG_RAIN, "Rain timer duration = %03d (will hit at %d)\n"
		, tickDelta
		, glbGameTick +tickDelta
		));


	//^3DF7:000E
	Timer bp0a;
	bp0a.SetMap(0);
	bp0a.SetTick(glbGameTick +tickDelta);
	bp0a.TimerType(ttyWeather);
	bp0a.actor = 0;
	QUEUE_TIMER(&bp0a);
	//^3DF7:0035
	return;
}
//^3DF7:0037
// SPX: some sort of init, called from read_structure
void SkWinCore::_3df7_0037(X16 ww)
{
	//^3DF7:0037
	ENTER(4);
	//^3DF7:003B
	if (ww != 0) {
		_4976_5c28 = 0;
		if (glbRainMultiplicator == 0)
			glbRainMultiplicator = 1;
	}
	else {
		//^3DF7:005B
		UPDATE_GLOB_VAR(0x40, 0, 6);
		glbRainSpecialNextTick = glbGameTick +5;
		glbRainAmbientLightModifier = 0;
		glbRainFlagSomething = 0;
		X32 bp04;
		if (_4976_47fc != 0) {
			glbRainLevelForGround = 0;
			bp04 = RAND16(0x1f4);
			glbRainRelated2 = 3;
			glbRainMultiplicator = 1;
		}
		else {
			//^3DF7:00B1
			bp04 = RAND16(0x1f40) +0x1f4;	// RAND16(8000) + 500
			glbRainRelated2 = U8(RAND02());
			glbRainMultiplicator = RAND16(3) +1;
		}
		glbRainLevelForSky = 1;
		glbRainStrength = 0;
		glbRainStormController = 0;
		_4976_5c28 = 0;
		glbRainDirection = U8(RAND02());
		// SPX: This might be the initial rain timer : NOPE, it must be still called ingame (when there is no rain)
		SET_TIMER_WEATHER(bp04);
	}
	//^3DF7:0108
	glbRainThunderRandom = RAND16(3) +2;
	glbRainSomeLightMod = _4976_4764[RCJ(24,((glbGameTick + _4976_5c24) / 0x555) % 0x18)];
	_4976_47fc = 0;
	//^3DF7:014B
	return;
}
//^3DF7:075F
// SPX: _3df7_075f renamed RETRIEVE_ENVIRONMENT_CMD_CD_FW
X16 SkWinCore::RETRIEVE_ENVIRONMENT_CMD_CD_FW(DistantEnvironment *ref)
{
	//^3DF7:075F
	ENTER(128);
	//^3DF7:0763
	U8 bp80[128];
	if (QUERY_GDAT_TEXT(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, ref->envImg, bp80)[0] == 0)
		return 0;
	//^3DF7:078B
	ref->cmCD = QUERY_CMDSTR_TEXT(bp80, reinterpret_cast<const Bit8u *>(EnvCM_CD));
	ref->w6 = ref->w4 = 0;
	ref->cmFW = U8(QUERY_CMDSTR_TEXT(bp80, reinterpret_cast<const Bit8u *>(EnvCM_FW)));
	ref->b9 = ref->b8 = 0x40;
	return 1;
}
//^098D:04C7
X16 SkWinCore::_098d_04c7(X16 rcno1, X16 rcno2, X16 scale, X16 *ss, X16 *tt)
{
	//^098D:04C7
	ENTER(10);
	//^098D:04CD
	i16 si = scale;
	SRECT *bp04 = QUERY_RECT(&glbRectNoTable, rcno1);
	if (bp04 == NULL) {
		return -1;
	}
	//^098D:04F2
	SRECT *bp08 = QUERY_RECT(&glbRectNoTable, rcno2);
	if (bp08 == NULL) {
		return -1;
	}
	si = BETWEEN_VALUE(0, si, 0x64);
	if (si == 0) {
		*ss = 0;
		*tt = 0;
		return rcno1;
	}
	//^098D:0535
	i16 bp0a = bp08->cx -bp04->cx;
	*ss = (bp0a * si) / 100;
	i16 di = bp08->cy -bp04->cy;
	*tt = (di * si) / 100;
	return rcno1;
}

//^3DF7:014D
// SPX: _3df7_014d renamed UPDATE_WEATHER
void SkWinCore::UPDATE_WEATHER(U16 aa)	// aa = 1 when called from timer, aa = 0 else
{
	//^3DF7:014D
	ENTER(46);
	//^3DF7:0153
	glbRainFlagSomething = tlbRainScene[RCJ(5,glbRainSceneType)][0];
	if (aa != 0) {
		//^3DF7:0167
		if (++glbRainRelated3 > 0x1f) {
			//^3DF7:0172
			_3df7_0037(0);
			return;
		}

		SkD((DLV_DBG_RAIN, "Update Weather >> cnt = %03d + %03d (idx1:%d idx2:%d pw:%d)\n"
			, glbRainLevelForGround, tlbRainRelated[RCJ(128,glbRainRelated2 + glbRainRelated3)]
			, glbRainRelated2, glbRainRelated3, glbRainMultiplicator
			));

		//^3DF7:017C
		_4976_5c28 = glbRainStormController;
		glbRainStormController += tlbRainRelated[RCJ(128,glbRainRelated2 + glbRainRelated3)] * glbRainMultiplicator;
		glbRainStormController = BETWEEN_VALUE(0, glbRainStormController, 255);
		SET_TIMER_WEATHER(U32(RAND16(0x100)) +0x32);	// RAND16(256) + 50
		return;
	}
	//^3DF7:01D5
	if (glbGameTick >= glbRainSpecialNextTick) {
		//^3DF7:01EA
		glbRainSomeLightMod = _4976_4764[RCJ(24,((glbGameTick + _4976_5c24) / 0x555) % 0x18)];
		glbRainSpecialNextTick = glbGameTick +0x555;

		SkD((DLV_DBG_RAIN, "Update Weather >> lightmod = %d / next tick = %d\n"
			, glbRainSomeLightMod
			, glbRainSpecialNextTick
			));

		if (glbRainFlagSomething != 0)
			RECALC_LIGHT_LEVEL();
	}
	//^3DF7:023B
	X16 bp0a = 0;
	X16 bp10;
	X16 bp12;
	if (glbRainStormController != 0) {
		//^3DF7:024A
		bp10 = (RAND() & 15) + (0x100 - glbRainStormController);
		bp12 = (glbRainStormController >= 0xcd) ? 0x28 : 7;
		glbRainLevelForSky = U8(glbRainStormController);
		if (glbRainStrength == 0)
		{
			//^3DF7:027E
			glbRainStrength = (RAND16(bp10) <= 7) ? 1 : 0;
		}
		else
		{
			glbRainStrength = U8(glbRainStormController);
		}

		SkD((DLV_DBG_RAIN, "Update Weather >> lvl=%03d / cnt=%03d (v1:%d v2:%d pw:%d) / tick=%d\n"
			, glbRainStrength
			, glbRainLevelForGround
			, glbRainRelated2, glbRainRelated3, glbRainMultiplicator
			, glbGameTick
			));

		//^3DF7:029B
		if (glbRainStrength != 0 && glbRainLevelForGround < 0xff) {
			//^3DF7:02A9
			if (false
				|| (glbRainStrength >= RAIN_THRESHOLD_LEVEL_3)
				|| (glbRainStrength >= RAIN_THRESHOLD_LEVEL_2 || (glbGameTick & 1) == 0)
				|| (glbRainStrength >= RAIN_THRESHOLD_LEVEL_1 || (glbGameTick % 3) == 0)
				|| (U16(glbGameTick & 3) == 0)
			) {
				//^3DF7:02EF
				glbRainLevelForGround++;
			}
		}
		//^3DF7:02F3
		if (glbRainHasThunderImage != 0) {
			bp0a = (RAND16(bp10) <= bp12) ? 1 : 0;
		}
	}
	else {
		//^3DF7:0314
		if (glbRainLevelForGround > 0 && (glbGameTick % 3) == 0)
			//^3DF7:0330
			--glbRainLevelForGround;
		bp0a = (RAND16(0x40) == 0) ? 1 : 0;
		glbRainStrength = 0;
		glbRainLevelForSky = 1;
	}
	//^3DF7:0354
	if (glbRainFlagSomething == 0)
		return;
	if (glbRecalcLightIndicator != 0) {
		glbRecalcLightIndicator = 0;
		RECALC_LIGHT_LEVEL();
	}
	DistantEnvironment *bp04 = &_4976_5c2a[0];
	if (glbRainHasCloudSky != 0 && glbRainLevelForSky >= 0x10) {
		//^3DF7:0388
		if (glbRainLevelForSky >= 0x80) {
			glbRainAmbientLightModifier = 1;
			bp04->envImg = GFX_ENVIRONMENT_IMG_SKY_CLOUDS+2;	// 0x69 Dark clouds
		}
		else if (glbRainLevelForSky >= 0x40) {
			//^3DF7:03A4
			bp04->envImg = GFX_ENVIRONMENT_IMG_SKY_CLOUDS+1;	// 0x68 Medium clouds
		}
		else {
			//^3DF7:03AD
			bp04->envImg = GFX_ENVIRONMENT_IMG_SKY_CLOUDS;	// 0x67 Grey clouds
		}
		//^3DF7:03B4
		if (RETRIEVE_ENVIRONMENT_CMD_CD_FW(bp04) != 0)
			//^3DF7:03C5
			bp04++;
	}
	//^3DF7:03C9
	if (glbRainHasWetGround != 0 && glbRainLevelForGround >= 0x40) {
		if (glbRainLevelForGround >= 0xc0) {
			//^3DF7:03DE
			bp04->envImg = GFX_ENVIRONMENT_IMG_WET_GROUND+2;	// 0x6C Big water puddles
		}
		else if (glbRainLevelForGround >= 0x80) {
			//^3DF7:03EE
			bp04->envImg = GFX_ENVIRONMENT_IMG_WET_GROUND+1;	// 0x6B Medium water puddles
		}
		else {
			//^3DF7:03F7
			bp04->envImg = GFX_ENVIRONMENT_IMG_WET_GROUND;	// 0x6A Small water puddles
		}
		//^3DF7:03FE
		if (RETRIEVE_ENVIRONMENT_CMD_CD_FW(bp04) != 0)
			//^3DF7:040F
			bp04++;
	}
	//^3DF7:0413
	i16 si;
	i16 di;
//	printf("glbRainStormController = %d (%d / %d) \n", glbRainStormController, 0x3c, 0xb6);
	if (bp0a != 0) {
		//^3DF7:041C
		bp0a = 0;
		X16 bp18 = (glbRainStormController < 0xb6) ? 1 : 0;
		if (bp18 != 0) {
			UPDATE_GLOB_VAR(0x40, 0x0, 0x6);
		}
		//^3DF7:0447
		X16 bp0e = 0;
		if (glbRainStormController >= 0x3c && RAND02() != 0) {
			//^3DF7:0462
			bp0e = 8;
			// SPX: 0x6C only found in ROOF set
			X16 bp16 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_THUNDER_POSITION);	// 0x6C
			if (bp16 != 0) {
				//^3DF7:0480
				// SPX: Will animate the Lightning Rod machine
				INVOKE_MESSAGE(di = (bp16 >> 8), si = (bp16 & 0xff), 0, 0, glbGameTick +1);
				// SPX: and get sound of thunder
				QUEUE_NOISE_GEN2(GDAT_CATEGORY_SPELL_MISSILES, missileThunderBolt, SOUND_STD_EXPLOSION, 0xfe, di, si, 1, 0x6c, U8(RAND16(0x20)));
			}
			else {
				do {
					//^3DF7:04D4
					di = RAND16(0x20);
					si = RAND16(0x20);
					if (di < 0 || di >= glbCurrentMapWidth || si < 0 || si >= glbCurrentMapHeight)
						continue;
					//printf("Thunder located at :%d %d\n", di, si);
					//^3DF7:0508
					ExtendedTileInfo bp2e;
					SUMMARIZE_STONE_ROOM(&bp2e, 0, di, si);
					if (bp2e.w0 != 1)
						continue;
					//^3DF7:0522
					TELE_inf bp1e;
					if (GET_TELEPORTER_DETAIL(&bp1e, U8(di), U8(si)) != 0)
						continue;
					//^3DF7:0538
					if (glbPlayerMap == glbCurrentMapIndex && glbPlayerPosX == di && glbPlayerPosY == si && glbRainStormController < 0xb6)
						continue;
					//^3DF7:0558
					if (glbGameTick < 0x1770)
						continue;
					//^3DF7:056F
					//printf("glbRainThunderRandom (static random?)= %d  over global 0x40 = %d\n", glbRainThunderRandom, GET_GLOB_VAR(0x40));
					if (GET_GLOB_VAR(0x40) <= glbRainThunderRandom)
						continue;
					//^3DF7:0580
					ObjectID bp14 = GET_CREATURE_AT(di, si);
					AIDefinition *bp08;
					i16 bp0c;
					if (bp14 != OBJECT_NULL) {
						//^3DF7:0591
						bp08 = QUERY_CREATURE_AI_SPEC_FROM_RECORD(bp14);
						if (bp08->ArmorClass == AI_DEF_ARMOR_MAX)
							continue;
						//^3DF7:05AD
						bp0c = CALC_SQUARE_DISTANCE(glbPlayerPosX, glbPlayerPosY, di, si);
						if (bp0c > 2) {
							if (bp0c > 3)
								continue;
							if (CALC_VECTOR_DIR(glbPlayerPosX, glbPlayerPosY, di, si) != glbPlayerDir)
								continue;
						}
					}
					//^3DF7:05E8
					CREATE_CLOUD(OBJECT_EFFECT_THUNDER, glbRainStormController, di, si, 255);
					if (glbChampionInventory == 0 && glbIsPlayerSleeping == 0)
						break;
					//^3DF7:0609
					if (bp18 != 0)
						break;
					//^3DF7:060F
					// SPX: glbPlayerPosX = x1, glbPlayerPosY = y1, di = x2, si = y2
					bp0c = CALC_SQUARE_DISTANCE(glbPlayerPosX, glbPlayerPosY, di, si);
					if (bp0c > 3)
						break;
					//^3DF7:062A
					if (CALC_VECTOR_DIR(glbPlayerPosX, glbPlayerPosY, di, si) != glbPlayerDir)
						break;
					//^3DF7:0642
					UPDATE_GLOB_VAR(0x41, 1, 3);
					break;
					//^3DF7:0652
				} while (--bp0e != 0);
			}
		}
		//^3DF7:065A
		if (bp0e == 0 && RAND01() != 0) {
			//^3DF7:0669
			bp04->envImg = U8(RAND16(3)) + GFX_ENVIRONMENT_IMG_THUNDER;	// 0x64 = thunder 1 => 0x66 = thunder 3
			if (RETRIEVE_ENVIRONMENT_CMD_CD_FW(bp04) != 0) {
				bp0a = 1;
				_098d_04c7(bp04->cmCD, bp04->cmCD +1, RAND16(0x64), &bp04->w4, &bp04->w6);
				bp04->cmFW = U8(RAND02());
				bp04++;
			}
		}
		//^3DF7:06D1
		if (bp0a != 0) {
			if (glbThunderJustCast == 0) {
				X16 bp0c;
				if (glbRainStormController == 0) {
					bp0c = RAND16(10) +5;
				}
				else {
					bp0c = 0x4c - (glbRainStormController / glbRainMultiplicator);
				}
				//^3DF7:070A
				bp0c = BETWEEN_VALUE(1, bp0c, 15);
				//SPX: Get sound of distant thunder
				QUEUE_NOISE_GEN1(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, SOUND_DEFAULT_STORM, 0x19, 0x40, glbPlayerPosX, glbPlayerPosY, bp0c);
				SkD((DLV_DBG_THUNDER, "Thunder at distance %d!\n", bp0c));
				glbThunderJustCast = 1;
			}
			else {
				//^3DF7:0743
				glbThunderJustCast = 0;
			}
		}
		//^3DF7:0749
		glbRecalcLightIndicator = 1;
		RECALC_LIGHT_LEVEL();
	}
	//^3DF7:0754
	bp04->envImg = 0xff;

#if (DM2_EXTENDED_MODE == 1)
	{	// Activate ambient sound, checking global variable then issuing a first Ambient Sound timer that will regenerate itself.
		if (glbXAmbientSoundActivated != 1)
		{
			glbXAmbientSoundActivated = 1;
			Timer xTimerRef;
			xTimerRef.SetMap(glbCurrentMapIndex);
			xTimerRef.SetTick(glbGameTick + 1);
			xTimerRef.TimerType(ttyAmbientSound);
			xTimerRef.actor = 0;
			xTimerRef.value = 0;
			QUEUE_TIMER(&xTimerRef);
		}
	}
#endif

	//^3DF7:075B
	return;
}

//^2676:0131
void SkWinCore::LOAD_LOCALLEVEL_DYN()
{
	//^2676:0131
	ENTER(60);
	//^2676:0137
	X16 bp3c = 0;
	_4976_5300 = 0;
	_4976_52fc = reinterpret_cast<SkLoadEnt *>(ALLOC_MEMORY_RAM(sizeof(SkLoadEnt) * 400, 0,  1024));
	U8 *bp14 = ALLOC_MEMORY_RAM(0xfa, afZeroMem, 1024); // creature existance-on-level bytes?
	U8 *bp18 = ALLOC_MEMORY_RAM(0xfa, afZeroMem, 1024); // wall ornate existance-on-level bytes?
	U8 *bp1c = ALLOC_MEMORY_RAM(0xfa, afZeroMem, 1024); // floor ornate existance-on-level bytes?
	//^2676:01A6
	MARK_DYN_LOAD(0x01ff02ff); // Mark: Interface - main screen, snd, all
    MARK_DYN_LOAD(0x18ff02ff); // Mark: Teleporter, all, snd, all
	MARK_DYN_LOAD(0x07ff02ff); // Mark: Interface - character sheet, all, snd, all
	if (_4976_5bee[0] != 0) {
		MARK_DYN_LOAD(0x0dff02ff); // Mark: Missiles, all, snd, all
	}
	else {
		//^2676:01D9
		MARK_DYN_LOAD(0x0d0002ff); // Mark: Missiles, fireball, snd, all
		_4976_52fc[_4976_5300 -1].MarkContinuous();
		MARK_DYN_LOAD(0x0d2f02ff); // Mark: Missiles, 0x2F(?), snd, all
		MARK_DYN_LOAD(0x0d7e02ff); // Mark: Missiles, 0x7E(?), snd, all
		_4976_52fc[_4976_5300 -1].MarkContinuous();
		MARK_DYN_LOAD(0x0d9f02ff); // Mark: Missiles, 0x9F(?), snd, all
	}
	//^2676:0231
	MARK_DYN_LOAD(0x10ff02ff); // Mark: Weapons, all, snd, all
	_4976_52fc[_4976_5300 -1].MarkContinuous();
	MARK_DYN_LOAD(0x15ff02ff); // Mark: Misc, all, snd, all
	MARK_DYN_LOAD(0x03ff02ff); // Mark: Messages, all, snd, all
	MARK_DYN_LOAD(0x08fe02ff); // Mark: Dungeon graphics, 0xFE, snd, all
	MARK_DYN_LOAD(0x16fe02ff); // Mark: Champions, 0xFE, snd, all
	MARK_DYN_LOAD(0x09fe02ff); // Mark: Wall ornates, 0xFE, snd, all
	MARK_DYN_LOAD(0x0afe02ff); // Mark: Floor ornates, 0xFE, snd, all
	MARK_DYN_LOAD(0x01ffffff); // Mark: Interface - main screen, all, all, all
	MARK_DYN_LOAD(0x01000400); // Mark: Interface - main screen, 0x00, rect, 0x00
	_4976_52fc[_4976_5300 -1].MarkExcluded();
	MARK_DYN_LOAD(0x01000600); // Mark: Interface - main screen, 0x00, raw06, 0x00
	_4976_52fc[_4976_5300 -1].MarkExcluded();
	MARK_DYN_LOAD(0x0100070a); // Mark: Interface - main screen, 0x00, raw07, 0x0A
	_4976_52fc[_4976_5300 -1].MarkExcluded();
	MARK_DYN_LOAD(0x1cffffff); // Mark: Japanese fonts, all, all, all
	MARK_DYN_LOAD(0x1a80ffff); // Mark: Dialog boxes, Load/cancel, all, all
	MARK_DYN_LOAD(0x1a81ffff); // Mark: Dialog boxes, Save/cancel, all, all
	MARK_DYN_LOAD(0x0300ffff); // Mark: Messages, 0x00, all, all
	MARK_DYN_LOAD(0x0700ffff); // Mark: Interface - character sheet, 0x00, all, all
	if (_4976_5bee[0] != 0) {
		MARK_DYN_LOAD(0x0dffffff); // Mark: Missiles, all, all, all
	}
	else {
		MARK_DYN_LOAD(0x0d00ffff); // Mark: Missiles, fireball, all, all
		_4976_52fc[_4976_5300 -1].MarkContinuous();
		MARK_DYN_LOAD(0x0d2fffff); // Mark: Missiles, 0x2F(?), all, all
		MARK_DYN_LOAD(0x0d7effff); // Mark: Missiles, 0x7E(?), all, all
		_4976_52fc[_4976_5300 -1].MarkContinuous();
		MARK_DYN_LOAD(0x0d9fffff); // Mark: Missiles, 0x9F(?), all, all
	}
	//^2676:039D
	MARK_DYN_LOAD(0x10ffffff); // Mark: Weapons, all, all, all
	_4976_52fc[_4976_5300 -1].MarkContinuous();
	MARK_DYN_LOAD(0x15ffffff); // Mark: Misc, all, all, all
	MARK_DYN_LOAD(0xffff01f9); // Mark: All, all, image, 0xF9(Map chip)
	MARK_DYN_EXCLUDE_RANGE(0x0fff0510, 0x39); // Mark: Creature, all, text, 0x10(My enemies) to 0x39(?)
	//^2676:03E1
	_4976_52fc[_4976_5300 -1].MarkIncluded();
	U8 *bp08 = *glbCurrentTileMap;
	U16 *bp10 = &dunGroundStacks[*_4976_4c52];
	i16 bp26 = 0;
	i16 si;
	for (; bp26 < glbCurrentMapWidth; bp26++) {
		//^2676:0429
		i16 bp28 = 0;
		for (; bp28 < glbCurrentMapHeight; bp28++) {
			//^2676:0431
			U16 bp2a = *(bp08++);
			if ((bp2a & 0x10) != 0) {
				ObjectID di = *bp10; bp10++;
				//^2676:0450
				do {
					Actuator *bp0c;
					Text *bp20;
					switch (di.DBType()) {
						case dbActuator: //^_0468
							//^2676:0468
							if (_4976_5bee[0] != 0)
								break;
							bp0c = GET_ADDRESS_OF_ACTU(di);
							switch (bp0c->ActuatorType()) {
								case ACTUATOR_TYPE_CREATURE_GENERATOR: // 0x2E: Creature generator
									//^2676:049B
									if (U8(bp2a >> 5) != ttWall)
										break;
									bp14[bp0c->ActuatorData()] = 1;
									break;
								case ACTUATOR_TYPE_CHAMPION_MIRROR: // SPX: Add for DM1 retrocompatibility / 0x7F: Activator, champion mirror
								case ACTUATOR_TYPE_RESURECTOR: // 0x7E: Activator, resuscitation
									//^2676:04C1
									MARK_DYN_LOAD((U8(bp0c->ActuatorData()) << 16) + 0x1600ffff); // Mark: Champions, xxx, all, all
									break;
								case ACTUATOR_FLOOR_TYPE__CROSS_SCENE: // 0x27: Cross scene
									//^2676:04E3
									if (U8(bp2a >> 5) != ttTeleporter)
										break;
									si = bp0c->ActuatorData() -1;
									if (si == glbCurrentMapIndex)
										break;
									U8 *bp24 = &glbMapTileValue[si << 2][dunMapsHeaders[si].RawColumn()][dunMapsHeaders[si].RawRow()];
									si = dunMapsHeaders[si].CreaturesTypes() -1;
									for (; si >= 0; si--) {
										//^2676:0580
										bp14[bp24[si]] |= 2;
									}
									break;
							}
							break;
						case dbText: //^_0599
							//^2676:0599
							bp20 = GET_ADDRESS_OF_RECORD2(di);
							if (bp20->TextMode() != 1)
								break;
							switch (bp20->SimpleTextExtUsage()) {
								case 14://^05D5
									//^2676:05D5
									bp3c = 1;
									break;
								case 0://^05DC
								case 2://^05DC
								case 4://^05DC
								case 5://^05DC
								case 6://^05DC
								case 7://^05DC
								case 8://^05DC
								case 10://^05DC
								case 13://^05DC
								case 15://^05DC
								case 16://^05DC
								case 17://^05DC
									//^2676:05DC
									if (U8(bp2a >> 5) == ttWall) {
										bp18[bp20->OrnateIndex()] = 1;
										break;
									}
									else {
										bp1c[bp20->OrnateIndex()] = 1;
										break;
									}
								case 1://^061A
								case 3://^061A
								case 9://^061A
								case 11://^061A
								case 12://^061A
									break;
							}
							break;
					}
					//^2676:061A
					di = GET_NEXT_RECORD_LINK(di);
					//^2676:0623
				} while (di != OBJECT_END_MARKER);
			}
			//^2676:062B
		}
		//^2676:063A
	}
	//^2676:0649
	U16 bp02;
	if (_4976_5bee[0] == 0) {
		//^2676:0655
		for (bp02 = 0; bp02 < glbChampionsCount; bp02++) {
			//^2676:065D
			MARK_DYN_LOAD(0x16000100 + (glbChampionSquad[bp02].HeroType() << 16)); // Mark: Champions, xxx, image, 0x00(wake)
			//^2676:067E
			MARK_DYN_LOAD(0x160002ff + (glbChampionSquad[bp02].HeroType() << 16)); // Mark: Champions, xxx, snd, all
			//^2676:069F
			MARK_DYN_EXCLUDE_RANGE(0x16000508 + (glbChampionSquad[bp02].HeroType() << 16), 0xb); // Mark: Champions, xx, text, 0x08 to 0x0B
			//^2676:06C3
			_4976_52fc[_4976_5300 -1].MarkIncluded();
			//^2676:06D9
		}
	}
	//^2676:06E8
	if (_4976_5bee[0] != 0 || (_4976_5c8a != 0 && glbChampionsCount != 4)) {
		//^2676:06FD
		// SPX: x16 GDAT2 Champion category
		MARK_DYN_LOAD(0x16ffffff); // Mark: Champions, all, all, all
	}
	//^2676:0708
	if (_4976_5bee[0] != 0 || dunMapLocalHeader->UseTeleporter() != 0) {
		// SPX: x18 GDAT2 Teleporter category
		MARK_DYN_LOAD(0x18ffffff); // Mark: Teleporter, all, all, all
	}
	//^2676:072C
	glbMapDoorType[0] = (dunMapLocalHeader->UseDoor0() != 0) ? dunMapLocalHeader->DoorType0() : 0xff;
	glbMapDoorType[1] = (dunMapLocalHeader->UseDoor1() != 0) ? dunMapLocalHeader->DoorType1() : 0xff;
	//^2676:076C
	X16 bp2e;
	X16 bp2c;
	if (_4976_5bee[0] != 0) {
		bp2e = 1;
		MARK_DYN_LOAD(0x0effffff); // Mark: Doors, all, all, all
	}
	else {
		bp2e = 0;
		bp2c = 0;
		for (bp02 = 0; bp02 < 2; bp02++) {
			//^2676:078E
			U8 bp03 = glbMapDoorType[bp02];
			if (bp03 != 0xff) {
				bp2c = 1;
				if (QUERY_GDAT_ENTRY_DATA_INDEX(0xe, bp03, dtWordValue, 0x40) == 0) {
					bp2e = 1;
				}
				MARK_DYN_LOAD(0x0e00ffff + (bp03 << 16)); // Mark: Doors, xxx, all, alll
			}
			//^2676:07CE
		}
		//^2676:07D7
		if (bp2c != 0) {
			MARK_DYN_LOAD(0x0efe02ff); // Mark: Doors, 0xFE, snd, all
		}
	}
	//^2676:07E9
	U8 bp03 = dunMapLocalHeader->MapGraphicsStyle();
	glbMapGraphicsSet = bp03;
	glbMistyMap = QUERY_GDAT_ENTRY_DATA_INDEX(0x8, bp03, dtWordValue, 0x69);
	si = QUERY_GDAT_ENTRY_DATA_INDEX(0x8, dunMapLocalHeader->MapGraphicsStyle(), dtWordValue, 0x6b);
	if (si != 0) {
		bp1c[si & 0xff] = 1;
	}
	//^2676:0843
	if (_4976_5bee[0] != 0)
		bp03 = 0xff;
	//^2676:084E
	MARK_DYN_LOAD(0x0800ffff + (bp03 << 16)); // Mark: Dungeon graphics, xxx, all, all
	MARK_DYN_LOAD(0x1700ffff + (bp03 << 16)); // Mark: Skullkeep and weather, xxx, all, all
	if (_4976_5bee[0] == 0) {
		//^2676:0884
		if (bp2e == 0) {
			//^2676:088A
			MARK_DYN_EXCLUDE_RANGE(0x08000106 + (bp03 << 16), 0x1a); // Mark: Dungeon graphics, xxx, image, 0x06 to 0x1A (door's track far)
			MARK_DYN_EXCLUDE_RANGE(0x080001d3 + (bp03 << 16), 0xd8); // Mark: Dungeon graphics, xxx, image, 0xD3 to 0xD8 (door's track near)
		}
		//^2676:08BD
		if (dunMapLocalHeader->UseUpperPitfall() == 0) {
			MARK_DYN_EXCLUDE_RANGE(0x0800016b + (bp03 << 16), 0x79); // Mark: Dungeon graphics, xxx, image, 0x6B to 0x79 (visible lower pitfall)
		}
		//^2676:08E5
		if (dunMapLocalHeader->UseLowerPitfall() == 0) {
			MARK_DYN_EXCLUDE_RANGE(0x08000199 + (bp03 << 16), 0xa0); // Mark: Dungeon graphics, xxx, image, 0x99 to 0xA0 (visible upper pitfall)
		}
		//^2676:0910
		if (dunMapLocalHeader->w2_2_2() == 0) {
			MARK_DYN_EXCLUDE_RANGE(0x08000182 + (bp03 << 16), 0x89); // Mark: Dungeon graphics, xxx, image, 0x82 to 0x89 (invisible lower pitfall)
		}
		//^2676:093C
		if (dunMapLocalHeader->UseUpStaircase() == 0) {
			MARK_DYN_EXCLUDE_RANGE(0x080001c7 + (bp03 << 16), 0xcc); // Mark: Dungeon graphics, xxx, image, 0xC7 to 0xCC (up stair case parts)
		}
		//^2676:0968
		if (dunMapLocalHeader->UseDownStaircase() == 0) {
			MARK_DYN_EXCLUDE_RANGE(0x080001cd + (bp03 << 16), 0xd2); // Mark: Dungeon graphics, xxx, image, 0xCD to 0xD2 (down stair case parts)
		}
		//^2676:0994
		if (dunMapLocalHeader->w2_6_6() == 0 && bp3c == 0) {
			//^2676:09AC
			_2676_006a(0x08000103 + (bp03 << 16));
			MARK_DYN_EXCLUDE_RANGE(0x080001fc + (bp03 << 16), 0xfe); // Mark: Dungeon graphics, xxx, image, 0xFC to 0xFE (message board)
		}
	}
	//^2676:09DC
	glbRainSceneType = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_SCENE_RAIN);	// 0x66
	if (_4976_5bee[0] == 0 && tlbRainScene[RCJ(5,glbRainSceneType)][0] != 0) {
		MARK_DYN_LOAD(0x0d30ffff); // Mark: Missiles, thunder, all, all
	}
	//^2676:0A13
	for (bp02 = 0; dunMapLocalHeader->WallGraphics() > bp02; bp02++) {
		bp18[_4976_4dc2[bp02]] = 1;
	}
	//^2676:0A3F
	if (_4976_5bee[0] != 0) {
		MARK_DYN_LOAD(0x09ffffff); // Mark: Wall ornates, all, all, all
	}
	else {
		for (bp02 = 0; bp02 < 0xfa; bp02++) {
			//^2676:0A5A
			if (bp18[bp02] != 0) {
				MARK_DYN_LOAD(0x0900ffff + (bp02 << 16)); // Mark: Wall ornates, xxx, all, all
				_2676_00d0(0x9, U8(bp02), 0x40);
			}
			//^2676:0A8A
		}
	}
	//^2676:0A94
	for (bp02 = 0; bp02 < dunMapLocalHeader->FloorGraphics(); bp02++) {
		bp1c[_4976_4cba[bp02]] = 1;
	}
	//^2676:0AC0
	if (_4976_5bee[0] != 0) {
		MARK_DYN_LOAD(0x0affffff); // Mark: Floor ornates, all, all, all
	}
	else {
		for (bp02 = 0; bp02 < 0xfa; bp02++) {
			//^2676:0ADB
			if (bp1c[bp02] != 0) {
				MARK_DYN_LOAD(0x0a00ffff + (bp02 << 16)); // Mark: Floor ornates, xxx, all, all
			}
			_2676_00d0(0xa, U8(bp02), 0x40);
			//^2676:0B0B
		}
	}
	//^2676:0B15
	if (_4976_5bee[0] != 0) {
		MARK_DYN_LOAD(0x0bffffff); // Mark: Door ornates, all, all, all
	}
	else {
		for (bp02 = 0; dunMapLocalHeader->DoorDecorationGraphics() > bp02; bp02++) {
			//^2676:0B30
			MARK_DYN_LOAD(0x0b00ffff + (glbMapDoorOrnatesList[bp02] << 16)); // Mark: Door ornates, xxx, all, all
			//^2676:0B49
		}
	}
	//^2676:0B5C
	if (_4976_5bee[0] != 0 || bp2e != 0) {
		MARK_DYN_LOAD(0x0cffffff); // Mark: Door buttons, all, all, all
	}
	//^2676:0B74
	for (bp02 = 0; bp02 < dunMapLocalHeader->CreaturesTypes(); bp02++) {
		//^2676:0B7B
		bp14[glbMapCreaturesTypeNumber[bp02]] = 1;
		//^2676:0B90
	}
	//^2676:0BA6
	if (_4976_5bee[0] != 0) {
		MARK_DYN_LOAD(0x0fffffff); // Mark: Creatures, all, all, all
	}
	//^2676:0BB8
	for (bp03 = 0; bp03 < 0xfa; bp03++) {
		//^2676:0BBF
		if (QUERY_GDAT_CREATURE_WORD_VALUE(bp03, 6) != 0) {
			bp14[bp03] = 1;
		}
		//^2676:0BDE
		if (bp14[bp03] == 0 || _4976_5bee[0] != 0)
			continue;
		//^2676:0BFD
		if ((bp14[bp03] & 1) != 0 || _4976_5bee[1] != 0) {
			//^2676:0C14
			MARK_DYN_LOAD(0x0f00ffff + (bp03 << 16)); // Mark: Creatures, xxx, all, all
			MARK_DYN_EXCLUDE_RANGE(0x0f0001fa + (bp03 << 16), 0xfd); // Mark: Creatures, xxx, image, 0xFA to 0xFD (mask?)
			_2676_00d0(0xf, bp03, 0x40);
		}
		else {
			//^2676:0C54
			MARK_DYN_EXCLUDE_RANGE(0x0f00fffa + (bp03 << 16), 0xfd); // Mark: Creatures, xxx, all, 0xFA to 0xFD (mask?)
			_4976_52fc[_4976_5300 -1].MarkIncluded();
		}
		//^2676:0C83
	}
	//^2676:0C8F
	if (_4976_5c8a == 0)
		_482b_060e();
	//^2676:0C9B
	LOAD_DYN4(_4976_52fc, _4976_5300);
	if (_4976_5c8a == 0)
		LOAD_MISCITEM();
	//^2676:0CBB
	glbRainHasThunderImage = U8(QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, dtImage, GDAT_ENVWTH_THUNDER_1)); // 0x64 thunder
	glbRainHasWetGround = U8(QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, dtImage, GDAT_ENVWTH_WETGROUND_1)); // 0x6a wet floor
	glbRainHasCloudSky = U8(QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, dtImage, GDAT_ENVWTH_CLOUDSKY_1)); // 0x67 ceil cloud
	glbRainHasRainFall = U8(QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, dtImage, GDAT_ENVWTH_RAINFALL_STRAIGHT_1)); // 0x71 vertical direct rain fall
	glbSceneColorKey = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_SCENE_COLORKEY); // colorkey
    glbSceneFlags = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, GDAT_GFXSET_SCENE_FLAGS);
	//^2676:0D39
	DEALLOC_UPPER_MEMORY(0xfa);
	DEALLOC_UPPER_MEMORY(0xfa);
	DEALLOC_UPPER_MEMORY(0xfa);
	DEALLOC_UPPER_MEMORY(0x960);
	if (_4976_5c8a != 0)
		return;
	//^2676:0D73
	i16 bp38;
	i16 bp3a;
	QUERY_GDAT_IMAGE_METRICS(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_FLOOR, &bp38, &bp3a); // floor
	U16 bp32 = (bp38 & 0xffff) * bp3a;
	//^2676:0D99
	i16 bp34;
	i16 bp36;
	QUERY_GDAT_IMAGE_METRICS(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_CEIL, &bp34, &bp36); // ceil
	U16 bp30 = (bp34 & 0xffff) * bp36;
	//^2676:0DBF
	_4976_5be6 = _4976_00f4 -bp30;
	if (_4976_5be6 > bp32) {
		_4976_5be6 -= bp32;
		SET_SRECT(&_4976_5938, 0, bp36, _4976_00f6, _4976_00f8 -(bp36 +bp3a));
	}
	else {
		_4976_5be6 = 0;
	}
	//^2676:0DFE
	_4976_022c = 1;
	UPDATE_WEATHER(0);
	RECALC_LIGHT_LEVEL();
	//^2676:0E11
	return;
}

//^32CB:2730
void SkWinCore::CHANCE_TABLE_OPERATION()
{
	//^32CB:2730
	ENTER(12);
	//^32CB:2736
	if (_4976_5aa2 == 0 || glbTableToMove != OBJECT_NULL)
		return;
	//^32CB:274A
	i16 bp0a;
	i16 bp0c;
	_443c_08ab(&bp0a, &bp0c, &_4976_5dae.rc4.cy);
	i16 bp02 = bp0a - _4976_00e8;
	i16 di = bp0c - _4976_00ea;
	if (bp02 < 0 || di < 0 || bp02 >= _4976_00f6 || glbScreenHeight - _4976_00ea <= di)
		return;
	//^32CB:279D
	bp02 -= _4976_00f6 >> 1; // horz pos in viewport
	di -= _4976_00f8 >> 1; // vert pos in viewport
	X16 si;
	X16 bp04;
	X16 bp06;
	X16 bp08;
	if (ABS16(bp02) < 20) {
		//^32CB:27BA
		if (ABS16(di) < 15)
			goto _28bc;
		si = (di < 0) ? 0 : 3; // 0=move forward, 3=move back
	}
	//^32CB:27D6
	else if (bp02 < 0) {
		//^32CB:27DC
		if (ABS16(di) < 15) {
			si = 5; // 5=move forward left
		}
		else if (di < 0) {
			si = 0; // 0=move forward
		}
		else {
			si = 4; // 4=move back left
		}
	}
	else if (ABS16(di) < 15) {
		//^32CB:2804
		si = 1; // 1=move forward right
	}
	else if (di < 0) {
		//^32CB:280D
		si = 0;
	}
	else {
		//^32CB:280F
		si = 2; // 2=move back right
	}
	//^32CB:2812
	bp04 = (_4976_4366[RCJ(6,si)] + glbPlayerDir) & 3;
	bp06 = glbPlayerPosX;
	bp08 = glbPlayerPosY;
	bp06 += glbXAxisDelta[bp04];
	bp08 += glbYAxisDelta[bp04];
	if (IS_TILE_BLOCKED(GET_TILE_VALUE(bp06, bp08)) == 0) {
		//^32CB:2861
		bp04 = (_4976_4360[RCJ(6,si)] + glbPlayerDir) & 3;
		if (IS_CREATURE_MOVABLE_THERE(glbPlayerPosX + glbXAxisDelta[glbPlayerDir], glbPlayerPosY + glbYAxisDelta[glbPlayerDir], bp04, NULL) != 0) {
			//^32CB:28A3
			HIGHLIGHT_ARROW_PANEL(_4976_435a[RCJ(6,si)], _4976_434e[RCJ(6,si)], 1);
			goto _28bf;
		}
	}
	//^32CB:28BC
_28bc:
	si = 6;
_28bf:
	glbTargetTypeMoveObject = si;
	//^32CB:28C3
	return;
}

//^32CB:4069
void SkWinCore::_32cb_4069(i16 xx, i16 yy, X16 ww, U16 *ss, U16 *tt)
{
	//^32CB:4069
	ENTER(12);
	//^32CB:406F
	i16 si = ww;
	if (si == 0)
		return;
	//^32CB:4079
	if (si > 3)
		si = 3;
	si--;
	//^32CB:4082
	i16 di = *ss;
	i16 bp02 = *tt;
	i16 bp04 = ABS16(xx -di);
	if (bp04 == 0) {
		if (yy < bp02) {
			*tt -= _4976_44ba[RCJ(3,si)];
		}
		else {
			*tt += _4976_44ba[RCJ(3,si)];
		}
		return;
	}
	//^32CB:40C8
	i16 bp06 = ABS16(bp02 -yy);
	if (bp06 == 0) {
		if (xx < di) {
			//^32CB:40E1
			*ss -= _4976_44ba[RCJ(3,si)];
			return;
		}
		else {
			//^32CB:40EB
			*ss += _4976_44ba[RCJ(3,si)];
			return;
		}
	}
	//^32CB:40F9
	X16 bp0a = !(((yy < bp02) ? 1 : 0) ^ ((xx < di) ? 1 : 0));
	X16 bp0c = !(((bp04 < bp06) ? 1 : 0) ^ bp0a);
	X16 bp08 = (((xx < di) ? 1 : 0) << 2) | (bp0a << 1) | bp0c;
	*ss += _4976_447a[si][bp08][0];
	*tt += _4976_447a[si][bp08][1];
	//^32CB:4181
	return;
}

//^32CB:4185
// SPX: _32cb_4185 renamed _32cb_4185_TILE_ROOM_TILE_ROOM
void SkWinCore::_32cb_4185_TILE_ROOM(i16 xx, i16 yy, i16 cellPos, i16 dir)
{
	//^32CB:4185
	ENTER(34);
	//^32CB:418B
	i16 bp06 = xx;
	i16 bp08 = yy;
	CALC_VECTOR_W_DIR(dir, _4976_40e8[cellPos][1], _4976_40e8[cellPos][0], &bp06, &bp08);
	tblCellTilesRoom[cellPos].posx = U8(bp06);
	tblCellTilesRoom[cellPos].posy = U8(bp08);
	//^32CB:41EB
	SUMMARIZE_STONE_ROOM(&tblCellTilesRoom[cellPos].xsrd, dir, bp06, bp08);
	if (glbIsPlayerMoving != 0 && cellPos == 0) {
		//^32CB:4224
		if (tblCellTilesRoom->xsrd.w0 == 0) {
			if (tblCellTilesRoom[3].xsrd.w0 == 5) {
				//^32CB:4239
				tblCellTilesRoom->xsrd.w0 = (5);
			}
			else {
				//^32CB:4241
				tblCellTilesRoom->xsrd.w6[0] = (0xff);
				tblCellTilesRoom->xsrd.w6[1] = (0xff);
				tblCellTilesRoom->xsrd.w6[2] = (0xff);
				tblCellTilesRoom->xsrd.w6[3] = (0xff);
				tblCellTilesRoom->xsrd.w6[4] = (0);
				tblCellTilesRoom->xsrd.w4 = (0xfffe);
			}
			//^32CB:4269
			X16 si;
			for (si = 1; si <= 2; si++) {
				//^32CB:426F
				ExtendedTileInfo *bp04 = &tblCellTilesRoom[si].xsrd;
				bp04->w4 = (0xfffe);
				bp04->w2 = (tblCellTilesRoom[si +3].xsrd.w2 & 0xe0);
				X16 bp22;
				bp04->w0 = (bp22 = tblCellTilesRoom[si +3].xsrd.w0);
				switch (bp22) {
					case 0x00://^42E4
						//^32CB:42E4
						bp04->w6[3] = (255);
						bp04->w6[2] = (255);
						bp04->w6[1] = (255);
						bp04->w6[0] = (255);
						bp04->xvalue = (0xffff);
						break;
					case 0x02://^4302
						//^32CB:4302
						bp04->w0 = (1);
						bp04->w2 = (0);
						break;
					case 0x01://^4312
					case 0x05://^4312
					case 0x10://^4312
						//^32CB:4312
						bp04->w6[2] = (0xff);
						break;
				}
				//^32CB:431B
				(*_4976_5a7c)[si] = 0;
				(*_4976_5be2)[si] = 0;
				//^32CB:4347
			}
		}
		//^32CB:4352
		else if (tblCellTilesRoom->xsrd.w0 == 0x11) {
			//^32CB:435D
			tblCellTilesRoom->xsrd.w0 = (1);
			tblCellTilesRoom->xsrd.w2 = (0);
			tblCellTilesRoom->xsrd.w6[2] = (0xff);
		}
	}
	//^32CB:436F
	(*_4976_5a7c)[cellPos] = 0;
	(*_4976_5be2)[cellPos] = 0;
	if (cellPos < 0x10 && tblCellTilesRoom[cellPos].xsrd.w0 != 0) { // if it is not wall
		//^32CB:43B8
		U8 *bp1e = &_4976_5a84[_4976_44c5[RCJ(16,cellPos)][0]][_4976_44c5[RCJ(16,cellPos)][1]];
		i16 si;
		//^32CB:43E9
		for (si = 0; si < 5; bp1e += 17, si++) {
			//^32CB:43ED
			i16 bp20;
			//^32CB:43ED
			for (bp20 = 0; bp20 < 4; bp20++) {
				//^32CB:43F4
				bp1e[bp20] = U8(cellPos);
				//^32CB:4400
			}
			//^32CB:4409
		}
	}
	//^32CB:4413
	ObjectID bp18 = tblCellTilesRoom[cellPos].xsrd.id4();
	ATLASSERT(bp18 != OBJECT_NULL);
	if (bp18 != OBJECT_END_MARKER) {
		//^32CB:4430
		U16 bp0c;
		U16 bp0e;
		_098d_000f(xx, yy, _4976_44c1[RCJ(4,dir)], &bp0c, &bp0e);
		do {
			//^32CB:4451
			i16 bp1a = bp18.DBType();
			if (bp1a == dbCreature) {
				//^32CB:4465
				i16 bp16;
				if (_4976_5aa2 != 0 && cellPos == 3) {
					//^32CB:4472
					bp16 = _4976_41d0[RCJ(7,glbTargetTypeMoveObject)];
					bp16 = ROTATE_5x5_POS(bp16, _4976_44bd[RCJ(4,dir)]);
				}
				else {
					//^32CB:4492
					bp16 = QUERY_OBJECT_5x5_POS(bp18, 0);
				}
				//^32CB:44A1
				U16 bp10;
				U16 bp12;
				_098d_000f(bp06, bp08, bp16, &bp10, &bp12);
				Creature *bp04 = GET_ADDRESS_OF_RECORD4(bp18);
				if (cellPos != 0) {
					//^32CB:44D1
					X16 bp14 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType())->b34;
					_32cb_4069(bp0c, bp0e, bp14, &bp10, &bp12);
				}
				//^32CB:4505
				i16 bp0a;
				i16 di;
				switch (dir) {
					case 0: //^_4518
						//^32CB:4518
						bp0a = bp10 -bp0c;
						di = bp0e -bp12;
						break;
					case 1: //^_4529
						bp0a = bp12 -bp0e;
						di = bp10 -bp0c;
						break;
					case 2: //^_453a
						//^32CB:453A
						bp0a = bp0c -bp10;
						di = bp12 -bp0e;
						break;
					default: //^_454b
						//^32CB:454B
						bp0a = bp0e -bp12;
						di = bp0c -bp10;
						break;
				}
				//^32CB:455C
				if (di < 0x11 && ABS16(bp0a) < 10) {
					while (di >= 0 && _4976_5aa4[bp0a +10][di] != 0xff) {
						//^32CB:4577
						di--;
					}
					//^32CB:4593
					if (di >= 0) {
						//^32CB:459A
						_4976_5aa4[bp0a +10][di] = U8(cellPos);
					}
				}
			}
			//^32CB:45B4
			else if (bp1a == dbMissile) {
				//^32CB:45BA
				(*_4976_5a7c)[cellPos] |= U32(1) << QUERY_OBJECT_5x5_POS(bp18, _4976_5aa0);
			}
			//^32CB:45E7
			else if (bp1a >= dbWeapon && bp1a <= dbMiscellaneous_item) {
				//^32CB:45F3
				// SPX: Added here w0 == 17 (door tile) so that item on door tile is always displayed, even if door is open
				// w6[0] represents open door state where 0 is fully open and 1 to 4 semi closed to closed status; so when w6[0] != 0 means does not take when door is open! (why?)
				if (tblCellTilesRoom[cellPos].xsrd.w0 == 1 || tblCellTilesRoom[cellPos].xsrd.w0 == 17 || tblCellTilesRoom[cellPos].xsrd.w6[0] != 0) {
//					if (_4976_5a80[cellPos].x2.w0 == 1 || _4976_5a80[cellPos].x2.w6[0] != 0) {
					//^32CB:461D
					(*_4976_5be2)[cellPos] |= U32(1) << QUERY_OBJECT_5x5_POS(bp18, _4976_5aa0);
				}
			}
			//^32CB:4654
		} while ((bp18 = GET_NEXT_RECORD_LINK(bp18)) != OBJECT_END_MARKER);
	}
	//^32CB:4669
	return;
}
//^098D:0C13
void SkWinCore::TRIM_BLIT_RECT(i16 xx, i16 yy, i16 ss, i16 tt)
{
	//^098D:0C13
	ENTER(0);
	//^098D:0C16
	SET_SRECT(&_4976_4bca, xx, yy, _4976_00f6 -ss -xx, _4976_00f8 -tt -yy);
	//^098D:0C43
	return;
}
//^32CB:59CA
// SPX: _32cb_59ca renamed SET_GRAPHICS_FLIP_FROM_POSITION
X16 SkWinCore::SET_GRAPHICS_FLIP_FROM_POSITION(X16 aa, X16 ww, X16 xx, X16 yy)
{
	//^32CB:59CA
	ENTER(0);
	//^32CB:59CE
	X16 si = (xx +yy +ww + dunMapLocalHeader->MapOffsetX() + dunMapLocalHeader->MapOffsetY() + dunMapLocalHeader->Level()) & 1;
	switch (aa) {
		case 1: //^_5a0a
			//^32CB:5A0A
			if ((glbSceneFlags & 8) != 0) {
				if ((glbSceneFlags & 0x10) != 0) {
					//^32CB:5A1A
					if ((U16(glbGameTick) & 7) > 3)
						return 1;
					return 0;
				}
				//^32CB:5A33
				return si;
			}
			//^32CB:5A35
			if ((glbSceneFlags & 0x40) != 0)
				return glbPlayerDir & 1;
			return 0;
		case 0x20: //^_5a41
			//^32CB:5A41
			if ((glbSceneFlags & 2) != 0) {
				if ((glbSceneFlags & 4) != 0) {
					if ((U16(glbGameTick) & 7) <= 3)
						return 1;
					return 0;
				}
				//^32CB:5A6D
				return !si;
			}
			//^32CB:5A76
			if ((glbSceneFlags & 0x20) != 0)
				return glbPlayerDir & 1;
			//^32CB:5A86
			return 0;
		default: //^_5a8a
			//^32CB:5A8A
			return si;
	}
}
//^32CB:076E
void SkWinCore::DRAW_DUNGEON_GRAPHIC(U8 cls1, U8 cls2, U8 cls4, X16 rectno, i16 colorkey, U16 mirrorflip)
{
	//^32CB:076E
	ENTER(314);
	//^32CB:0773
	X16 si = rectno;
	ExtendedPicture bp013a;
	QUERY_GDAT_SUMMARY_IMAGE(&bp013a, U8(cls1), U8(cls2), U8(cls4));
	_0b36_037e(bp013a.b58, U8(_4976_5a88), colorkey, -1, bp013a.w56);
	//^32CB:07AB
	bp013a.colorKeyPassThrough = colorkey;
	bp013a.rectNo = si;
	bp013a.pb44 = _4976_4c16;
	bp013a.mirrorFlip = mirrorflip;
	if (glbIsPlayerMoving != 0) {
		if (si == 700) {
			bp013a.w34 += _4976_00fa;
		}
		else if (si == 701) {
			bp013a.w34 += _4976_00fc;
		}
	}
	//^32CB:07EB
	DRAW_PICST(QUERY_PICST_IT(&bp013a));
	//^32CB:0801
	return;
}
//^098D:0C45
void SkWinCore::_098d_0c45()
{
	//^098D:0C45
	ENTER(0);
	//^098D:0C48
	_4976_4bca.cx = 0;
	//^098D:0C4E
	return;
}

//^32CB:56BC
// SPX: _32cb_56bc renamed ENVIRONMENT_DRAW_DISTANT_ELEMENT
void SkWinCore::ENVIRONMENT_DRAW_DISTANT_ELEMENT(DistantEnvironment *ref, X16 dir, X16 xx, X16 yy)
{
	//^32CB:56BC
	ENTER(6);
	//^32CB:56C2
	X16 bp02;	// SPX => bp02 = mirror flip
	if (ref->cmCD == 0)
		return;
	if (ref->cmFW == 8 && SET_GRAPHICS_FLIP_FROM_POSITION(1, dir, xx, yy) != 0) {
		bp02 = 1;
	}
	else if (ref->cmFW == 2 && SET_GRAPHICS_FLIP_FROM_POSITION(0x20, dir, xx, yy) != 0) {
		bp02 = 1;
	}
	else if (ref->cmFW == 0x40 && SET_GRAPHICS_FLIP_FROM_POSITION(1, dir, xx, yy) != 0) {
		bp02 = 1;
	}
	else if (ref->cmFW == 0x20 && SET_GRAPHICS_FLIP_FROM_POSITION(0x20, dir, xx, yy) != 0) {
		bp02 = 1;
	}
	else {
		bp02 = 0;
	}
	//^32CB:5761
	X16 bp04 = ref->b8;
	X16 bp06 = ref->b9;
	X16 di = ref->w4;
	X16 si = ref->w6;
	if (glbIsPlayerMoving != 0)
	{
		//^32CB:5785
		di = CALC_STRETCHED_SIZE(di, 0x34);
		si = CALC_STRETCHED_SIZE(si, 0x34);
		bp04 = CALC_STRETCHED_SIZE(bp04, 0x34);
		bp06 = CALC_STRETCHED_SIZE(bp06, 0x34);
		if (ref->b8 == 0x40) {
			di += _4976_00fe.x;
			if (ref->cmCD == 0x1771) {	// 0x1771 = 6001
				//^32CB:57D1
				si += _4976_4681;
			}
			else {
				si += _4976_00fe.y;
			}
		}
		else {
			//^32CB:57DD
			si += _4976_467f;
		}
	}
	// SPX: the CD command seems to hold the rectno of the element.
	// CD = 6000, img = 0 for the distant Skullkeep image
	// CD = 6001, img = 99 (0x63) for the distant horizon
	// CD = 6002, img = {100, 101, 102} for distant lightning
	// CD = 6004, img = {103, 104, 105} for the cloudy skies
	// CD = 6005, img = {106, 107, 108} for the wet ground
	U16 iElementRecto = ref->cmCD;	// TODO : original was ref->cmCD & 0x8000 => SPX: I don't get that 0x8000 as it will give rectno 0 then display nothing ...
	SkD((DLV_DBG_DIST, "Distant Element >> CD=%d FW=%d / Img=%02d, rectno=%d\n"
		, ref->cmCD, ref->cmFW
		, ref->envImg
		, iElementRecto
		));
	//^32CB:57E1
	QUERY_TEMP_PICST(bp02, bp04, bp06, 0, 0, 0, iElementRecto, -1, glbSceneColorKey, -1, GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, ref->envImg);
	glbTempPicture.w32 += di;
	glbTempPicture.w34 += si;
	DRAW_TEMP_PICST();        
	//^32CB:5820
	return;
}

//^32CB:54CE
i16 SkWinCore::_32cb_54ce(X16 dir, i16 *xx, i16 *yy, X16 xl, X16 yl)
{
	//^32CB:54CE
	ENTER(4);
	//^32CB:54D4
	i16 si;
	X16 di;
	switch (dir) {
		case 0://^54E3
			//^32CB:54E3
			si = *xx -yl;
			di = xl -*xx;
			break;
		case 1://^54F9
			//^32CB:54F9
			si = xl -*xx;
			di = yl -*yy;
			break;
		case 2://^550C
			//^32CB:550C
			si = yl -*yy;
			di = *xx -xl;
			break;
		case 3://^5522
			//^32CB:5522
			si = *xx -xl;
			di = *yy -yl;
			break;
	}
	//^32CB:5538
	*xx = di;
	*yy = si;
	if (si < 1)
		return 0;
	//^32CB:554D
	U16 bp02 = di * di + si * si;
	if (bp02 <= 2)
		return 1;
	//^32CB:5567
	U16 cx = bp02 >> 1;
	U16 bp04;
	do {
		//^32CB:556E
		bp04 = cx;
		cx = (cx +(bp02 / cx)) >> 1;
		//^32CB:5582
	} while (cx < bp04);
	//^32CB:5589
	return bp04;
}

//^32CB:5598
// SPX: _32cb_5598 renamed ENVIRONMENT_SET_DISTANT_ELEMENT
X16 SkWinCore::ENVIRONMENT_SET_DISTANT_ELEMENT(DistantEnvironment *ref, U8 *str, X16 dir, X16 xx, X16 yy)
{
	//^32CB:5598
	ENTER(12);
	//^32CB:559E
	ref->w4 = ref->w6 = 0;
	X16 bp02 = QUERY_CMDSTR_TEXT(str, reinterpret_cast<const Bit8u *>(EnvCM_MV));
	if (bp02 == 0) {
		//^32CB:55C4
		ref->b8 = 0x40;
		ref->b9 = 0x40;
		return 1;
	}
	//^32CB:55D7
	if (bp02 == 1) {
		//^32CB:55E0
		i16 bp08 = xx + dunMapLocalHeader->MapOffsetX();
		i16 bp0a = yy + dunMapLocalHeader->MapOffsetY();
		X16 bp0c = QUERY_CMDSTR_TEXT(str, reinterpret_cast<const Bit8u *>(EnvCM_XLocation));
		X16 di = QUERY_CMDSTR_TEXT(str, reinterpret_cast<const Bit8u *>(EnvCM_YLocation));
		i16 si = _32cb_54ce(dir, &bp08, &bp0a, bp0c, di);
		if (bp0a >= 1) {
			//^32CB:564B
			X16 bp04 = QUERY_CMDSTR_TEXT(str, reinterpret_cast<const Bit8u *>(EnvCM_FD));
			X16 bp06 = max_value(1, 0x40 -(si -bp04));
			bp06 = (((bp06 << 7) >> 6) +1) >> 1;
			//^32CB:5683
			ref->w4 = (i32(bp08) * 210) / si;
			ref->b8 = ref->b9 = X8(bp06);
			return 1; // SPX: Element is visible
		}
	}
	//^32CB:56B6
	return 0; // SPX: Element is not visible (wrong direction)
}

//^32CB:5824
// SPX: _32cb_5824 renamed ENVIRONMENT_DISPLAY_ELEMENTS
void SkWinCore::ENVIRONMENT_DISPLAY_ELEMENTS(X16 dir, X16 xx, X16 yy)
{
	//^32CB:5824
	ENTER(134);
	//^32CB:582A
	X16 di = xx; // xpos
	X16 si = yy; // ypos
	DistantEnvironment *bp04;
	if (glbRainFlagSomething != 0) {
		//^32CB:5837
		bp04 = &_4976_5c2a[0];
		//^32CB:583F
		while (bp04->envImg != 0xff) {
			//^32CB:5841
			ENVIRONMENT_DRAW_DISTANT_ELEMENT(bp04++, dir, di, si);
		}
	}
	//^32CB:5861
	U8 bp05;
	U8 bp0086[128];
	if (_4976_4683 != glbMapGraphicsSet) {
		//^32CB:586D
		_4976_4683 = glbMapGraphicsSet;
		_4976_592a = 1;
		ZERO_MEMORY(_4976_592b, 13);
		//^32CB:5888
		for (bp05 = 0; bp05 <= 0x63; bp05++) {
			//^32CB:588E
			if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, dtImage, bp05) == 0)
				continue;
			//^32CB:58A6
			if (QUERY_GDAT_TEXT(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, bp05, bp0086)[0] == 0)
				continue;
			//^32CB:58C8
			_4976_592b[bp05 >> 3] = _4976_592b[bp05 >> 3] | (1 << (bp05 & 7));
			_4976_592a = 0;
			//^32CB:58F5
		}
	}
	//^32CB:58FE
	if (_4976_592a != 0)
		return;
	//^32CB:5908
	bp04 = &_4976_5c2a[0];
	//^32CB:5910
	// SPX: Cool! up to 100 distant elements to have in sky/background!
	// 0x63 contains the horizon graphics ..
	for (bp05 = 0; bp05 <= 0x63; bp05++) {
		//^32CB:5917
		if ((_4976_592b[bp05 >> 3] & (1 << (bp05 & 7))) == 0)
			continue;
		//^32CB:5939
		QUERY_GDAT_TEXT(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, bp05, bp0086);
		//^32CB:5951
		if (ENVIRONMENT_SET_DISTANT_ELEMENT(bp04, bp0086, dir, di, si) == 0)
			continue;
		//^32CB:596D
		bp04->envImg = bp05;
		bp04->cmCD = QUERY_CMDSTR_TEXT(bp0086, reinterpret_cast<const Bit8u *>(EnvCM_CD2));
		bp04->cmFW = U8(QUERY_CMDSTR_TEXT(bp0086, reinterpret_cast<const Bit8u *>(EnvCM_FW2)));
		ENVIRONMENT_DRAW_DISTANT_ELEMENT(bp04, dir, di, si);
		//^32CB:59BA
	}
	//^32CB:59C6
	return;
}
//^32CB:5C67
void SkWinCore::_32cb_5c67()
{
	//^32CB:5C67
	ENTER(8);
	//^32CB:5C6D
	i16 si;
	for (si = 0; si < 0x15; si++) {
		//^32CB:5C72
		if (tblCellTilesRoom[si].xsrd.w0 != 1)
			continue;
		//^32CB:5C86
		TELE_inf bp08;
		if (GET_TELEPORTER_DETAIL(&bp08, U8(tblCellTilesRoom[si].posx), U8(tblCellTilesRoom[si].posy)) == 0)
			continue;
		//^32CB:5CBC
        i16 di;
		for (di = 0; di < 4; di++) {
			//^32CB:5CC0
			U8 bp01 = _4976_408c[RCJ(21,si)][RCJ(4,di)];
			if (bp01 < 0)
				continue;
			//^32CB:5CD0
			if (tblCellTilesRoom[bp01].xsrd.w0 != 7)
				continue;
			//^32CB:5CE4
			tblCellTilesRoom[bp01].xsrd.w0 = (0);
			//^32CB:5CFA
		}
		//^32CB:5D00
	}
	//^32CB:5D09
	return;
}
//^32CB:5A8F
void SkWinCore::_32cb_5a8f()
{
	//^32CB:5A8F
	ENTER(14);
	//^32CB:5A94
	X32 bp04 = 0;
	X32 bp08 = 0;
	i16 bp0e = 0;
	for (; bp0e < 0x10; bp0e++) {
		//^32CB:5AAF
		if (tblCellTilesRoom[bp0e].xsrd.w0 == 0) {
			//^32CB:5AC4
			bp08 |= U32(1) << bp0e;
		}
		//^32CB:5AD7
	}
	//^32CB:5AE0
	bp04 |= _4976_4684[RCJ(4,U16(bp08 >> 1) & 3)];
	bp04 |= _4976_4694[RCJ(8,(U16(bp08 >> 3) & 7) | (((U16(bp08) &    8) != 0) ? (U16(bp08     ) & 6) : 0))];
	bp04 |= _4976_46b4[RCJ(8,(U16(bp08 >> 6) & 7) | (((U16(bp08) & 0x40) != 0) ? (U16(bp08 >> 3) & 6) : 0))];
	//^32CB:5B7D
	bp04 |= _4976_46d4[RCJ(8,(U16(bp08 >>11) & 7) | (((U16(bp08) &0x800) != 0) ? (U16(bp08 >> 6) & 6) : 0))];
	//^32CB:5BC1
	X16 si = U16(bp08) | U16(bp04);
	if ((si & 0x1000) != 0 && ((si & 0x4000) != 0 || (si & 0x200) != 0)) {
		//^32CB:5BDB
		bp04 |= 0x280000;
	}
	//^32CB:5BE5
	if ((si & 0x2000) != 0 && ((si & 0x8000) != 0 || (si & 0x400) != 0)) {
		//^32CB:5BF7
		bp04 |= 0x500000;
	}
	//^32CB:5C01
	X32 bp0c = 1;
	//^32CB:5C0B
	for (bp0e = 0; bp0e <= 0x16; bp0e++) {
		//^32CB:5C12
		if ((bp04 & bp0c) != 0 && tblCellTilesRoom[bp0e].xsrd.w0 == 0) {
			//^32CB:5C37
			tblCellTilesRoom[bp0e].xsrd.w0 = (7);
		}
		//^32CB:5C4B
		bp0c = bp0c << 1;
		//^32CB:5C5B
	}
	//^32CB:5C64
	return;
}

//^48AE:01AF
U8 SkWinCore::_48ae_01af(X16 xx, X16 yy)
{
	//^48AE:01AF
	ENTER(0);
	//^48AE:01B4
	X16 di = xx;
	if ((di & 0x400) == 0 || (di & 0x200) != 0) {
		return 15;
	}
	//^48AE:01CD
	X16 si = di & 15;
	if (si != 0) {
		//^48AE:01D8
		// TODO: fixme
		return READ_UI8(&_4976_49d4[RCJ(5,si)][0], yy);
	}
	return 0;
}

//^32CB:347F
// SPX: _32cb_347f renamed MAKE_PUT_DOWN_ITEM_CLICKABLE_ZONE
void SkWinCore::MAKE_PUT_DOWN_ITEM_CLICKABLE_ZONE(X16 xx, ObjectID rl, i16 yy, X16 zz)
{
	//^32CB:347F
	ENTER(4);
	//^32CB:3485
	sk4d1a *bp04 = &_4976_4d1a[xx];
	if (_4976_4d1a[xx].w8 == OBJECT_NULL) {
		//^32CB:34A7
		COPY_MEMORY(&glbTempPicture.rc36, &bp04->rc0, sizeof(SRECT));
		i16 si = bp04->rc0.cy;
		if (si < 15) {
			if (si < 11) {
				//^32CB:34D0
				bp04->rc0.cy = 11;
			}
			//^32CB:34D6
			bp04->rc0.y += (si >> 1) -7;
		}
		//^32CB:34E4
		si = bp04->rc0.cx;
		if (si < 14) {
			//^32CB:34F5
			bp04->rc0.cx = 14;
			bp04->rc0.x += si -7;
		}
	}
	else {
		X16 di;
		//^32CB:3506
		di = max_value(bp04->rc0.x + bp04->rc0.cx, glbTempPicture.rc36.x + glbTempPicture.rc36.cx);
		bp04->rc0.x = min_value(bp04->rc0.x, glbTempPicture.rc36.x);
		bp04->rc0.cx = di - bp04->rc0.x;
		//^32CB:354A
		di = max_value(bp04->rc0.y + bp04->rc0.cy, glbTempPicture.rc36.y + glbTempPicture.rc36.cy);
		bp04->rc0.y = min_value(bp04->rc0.y, glbTempPicture.rc36.y);
		bp04->rc0.cy = di + bp04->rc0.y;
	}
	//^32CB:358A
	_4976_4d1a[xx].b11 = U8(zz);
	_4976_4d1a[xx].w8 = rl;
	_4976_4d1a[xx].b10 = U8(yy);
	//^32CB:35BD
	return;
}

//^32CB:3991
// SPX: _32cb_3991 renamed DRAW_PUT_DOWN_ITEM
void SkWinCore::DRAW_PUT_DOWN_ITEM(ObjectID rl, i16 cellPos, i16 dir, Creature *ref)
{
	//^32CB:3991
	ENTER(22);
	//^32CB:3997
	ObjectID di = rl;
	if (di == OBJECT_END_MARKER)
		return;
	//^32CB:39A2
	i16 bp0a = glbTabYAxisDistance[RCJ(23,cellPos)];
	if (bp0a > 3) // ignore D4
		return;
	X16 si = 0;
	X16 bp10;
	X16 bp12;
	if (ref != NULL) {
		//^32CB:39C0
		AIDefinition *bp04 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(ref->CreatureType());
		bp10 = bp04->w30;
		bp12 = bp04->w32;
	}
	do {
		i16 bp0c = di.DBType();
		if (bp0c < dbWeapon || bp0c > dbMiscellaneous_item)
			continue;
		//^32CB:3A02
		if (((di.Dir() - _4976_5aa0) & 3) != dir)
			continue;
		//^32CB:3A16
		ObjectID bp06;
		X16 bp08;
		X16 bp0e;
		i16 bp14;
		i16 bp16;
		if (ref != NULL) {
			if ((bp10 & 0x400) == 0 && ((bp10 >> 4) & 15) == 0) {
				//^32CB:3A33
				QUERY_EXPANDED_RECT(bp12, &_4976_4d1a[_4976_4dde].rc0);
				_4976_4d1a[_4976_4dde].b11 = 2;
				_4976_4d1a[_4976_4dde].w8 = di;
				_4976_4d1a[_4976_4dde].b10 = X8(cellPos);
				_4976_4dde++;
				return;
			}
			//^32CB:3A80
			DRAW_ITEM(di, cellPos, 0, 0, si, ref, 1, 0, 0);
			si++;
			si &= 15;
			if ((U8(_48ae_01af(bp10, 0)) & (1 << dir)) != 0) {
				//^32CB:3ABE
				bp08 = dir +4;
				bp0e = 2;
				goto _3b77;
			}
		}
		else {
			//^32CB:3ACF
			DRAW_ITEM(di, cellPos, 0, 0, si, NULL, 1, 0, 0);
			si++;
			si &= 15;
			if (cellPos == 0 || (cellPos == 3 && dir > 1)) {
				//^32CB:3B06
				bp14 = tblCellTilesRoom[cellPos].posx;
				bp16 = tblCellTilesRoom[cellPos].posy;
				bp06 = _1c9a_03cf(&bp14, &bp16, di.Dir());
				if (bp06 == OBJECT_NULL || IS_CREATURE_FLOATING(bp06) != 0 || (_0cee_2df4(bp06) & 0x2000) != 0) {
					//^32CB:3B6C
					bp08 = dir;
					bp0e = 1;
					//^32CB:3B77
_3b77:
					MAKE_PUT_DOWN_ITEM_CLICKABLE_ZONE(bp08, di, cellPos, bp0e);
				}
			}
		}
		//^32CB:3B88
	} while ((di = GET_NEXT_RECORD_LINK(di)) != OBJECT_END_MARKER);
	//^32CB:3B99
	return;
}

//^48AE:07BF
X16 SkWinCore::DIR_FROM_5x5_POS(X16 _5x5)
{
	//^48AE:07BF
	ENTER(0);
	//^48AE:07C3
	X16 si = _5x5;
	if (si == 6) // north west
		return 0;
	if (si == 8) // north east
		return 1;
	if (si == 18) // south east
		return 2;
	if (si == 16) // south west
		return 3;
	if (si == 12) // center
		return 4;
	//^48AE:07F7
	return -1;
}

//^32CB:3E08
void SkWinCore::_32cb_3e08(ObjectID rl, X16 xx, U32 yy, Creature *ref)
{
	//^32CB:3E08
	ENTER(12);
	//^32CB:3E0E
	i16 di = xx;
	if (rl == OBJECT_END_MARKER || _4976_415b[RCJ(23,di)] == -1)
		return;
	//^32CB:3E24
	_4976_421a = OBJECT_END_MARKER;
	if (di > 15)
		return;
	//^32CB:3E32
	X16 bp0a = _4976_4453[RCJ(16,di)];
	if (bp0a == 3)
		return;
    //^32CB:3E43
	U32 bp04 = 0;
	i16 si;
	for (si = 0; si < 4; si++) {
		//^32CB:3E51
		X16 bp0c = _4976_4447[RCJ(3,bp0a)][RCJ(4,si)];
		U32 bp08 = U32(1) << bp0c;
		if ((bp08 & yy) != 0) {
			//^32CB:3E82
			DRAW_PUT_DOWN_ITEM(rl, di, DIR_FROM_5x5_POS(bp0c), ref);
			continue;
		}
		//^32CB:3E9F
		bp04 |= bp08;
		//^32CB:3EAB
	}
	//^32CB:3EB1
	if (bp04 != 0) {
		_4976_421a = rl;
		_4976_5a8a = bp04;
		_4976_5a8e = ref;
	}
	//^32CB:3ED9
	return;
}

//^32CB:2BE6
void SkWinCore::SUMMARY_DRAW_CREATURE(ObjectID rl, i16 cellPos, U32 ss)
{
	// SkD((DLV_BUGHERE, "DBG: SUMMARY_DRAW_CREATURE(%04X,%5d,%08X)\n"
	//	, rl.w, cellPos, ss));

	//^32CB:2BE6
	ENTER(14);
	//^32CB:2BEC
	ObjectID di = rl;
	X16 si = cellPos;
	if (glbIsPlayerMoving != 0 && si == 0)
		return;
	//^32CB:2C00
	i16 bp0e = glbTabYAxisDistance[RCJ(23,si)];
	//^32CB:2C08
	for (; di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
		//^32CB:2C0B
		if (di.DBType() != dbCreature)
			continue;
		//^32CB:2C1B
		Creature *bp04 = GET_ADDRESS_OF_RECORD4(di);
		CreatureInfoData *bp08;
		if (bp04->b5_0_7() == 0xff) {
			//^32CB:2C32
			bp08 = 0;
		}
		else {
			//^32CB:2C3E
			bp08 = &glbTabCreaturesInfo[bp04->b5_0_7()];
		}
		//^32CB:2C5C
		AIDefinition *bp0c = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType());
		QUERY_CREATURE_PICST(si, bp0e, bp04, bp08, di);
		DRAW_TEMP_PICST();
		if (bp0c->IsStaticObject() == 0 || bp0c->w30_0_3() == 0 || bp0e >= 4)
			continue;
		//^32CB:2CA4
		if (tblCellTilesRoom[si].xsrd.w0 == 0x11) {
			//^32CB:2CB8
			ss = 0x3ff;
		}
		//^32CB:2CC2
		_32cb_3e08(bp04->GetPossessionObject(), si, ss, bp04);
		//^32CB:2CDE
	}
	//^32CB:2CEF
	return;
}

//^32CB:2CF3
void SkWinCore::_32cb_2cf3(U8 cls2, U16 scale64, U16 mirrorFlip, U16 rectno)
{
	//^32CB:2CF3
	ENTER(0);
	//^32CB:2CF7
	U16 si = scale64;
	si = BETWEEN_VALUE(8, si & 0xfffe, 64);
	QUERY_GDAT_SUMMARY_IMAGE(&glbTempPicture, 0xd, cls2, 0x41);
	glbTempPicture.w32 = glbTempPicture.w28;
	glbTempPicture.w34 = glbTempPicture.w30;
	glbTempPicture.w30 = glbTempPicture.w28 = 0;
	glbTempPicture.w26 = 0;
	glbTempPicture.rectNo = rectno;
	glbTempPicture.colorKeyPassThrough = 10;	// hard set color key!
	glbTempPicture.pb44 = _4976_4c16;
	glbTempPicture.mirrorFlip = mirrorFlip;
	glbTempPicture.w54 = glbTempPicture.w52 = si;
	_0b36_037e(glbTempPicture.b58, i8(_4976_5a88), 10, -1, glbTempPicture.w56);
	QUERY_PICST_IT(&glbTempPicture);
	//^32CB:2D89
	return;
}

//^32CB:2D8C
void SkWinCore::_32cb_2d8c(ObjectID rl, X16 yy, X32 aa)
{
	//^32CB:2D8C
	ENTER(46);
	//^32CB:2D92
	X16 di = yy;
	ObjectID bp0c = rl;
	if (bp0c == OBJECT_END_MARKER)
		return;
	//^32CB:2DA3
	if (_4976_4172[RCJ(23,di)] < 0)
		return;
	//^32CB:2DAD
	X16 bp1c = glbTabYAxisDistance[RCJ(23,di)];
	i16 si = 0;
	for (; si < 5; si++) {
		//^32CB:2DBA
		X16 bp1a = _4976_436c[RCJ(4,_4976_5aa0)][RCJ(5,si)];
		rl = bp0c;
		do {
			//^32CB:2DD2
			if (rl.DBType() == dbCloud) {
				//^32CB:2DE3
				i16 bp18 = rl.Dir();
				Cloud *bp08 = GET_ADDRESS_OF_RECORDF(rl);
				X8 bp15 = bp08->CloudType();
				if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_SPELL_MISSILES, bp15, dtImage, 0x14) != 0) {	// specifically to handle "reflector" haze
					if (si == 4) {
						DRAW_TELEPORTER_TILE(di, GDAT_CATEGORY_SPELL_MISSILES, bp15);
					}
					continue;
				}
				//^32CB:2E34
				if (((bp08->b2_7_7() != 0) ? ((bp1a == 0xffff) ? 1 : 0) : ((bp1a == bp18) ? 1 : 0)) == 0)
					continue;
				//^32CB:2E6A
				X16 bp26 = 0;
				X16 bp0e = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_SPELL_MISSILES, bp15, dtWordValue, 0) & RAND02();
				X16 bp14;
				if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_SPELL_MISSILES, bp15, dtWordValue, 0x41) != 0) {
					//^32CB:2EA3
					bp14 = 0xff;
				}
				else {
					//^32CB:2EAA
					bp14 = bp08->b3_0_f();
				}
				//^32CB:2EB7
				if (di == 0) {
					//^32CB:2EBE
					bp26 = 1;
					if (bp15 == 0x30) {
						//^32CB:2EC9
						UPDATE_GLOB_VAR(0x41, 1, 3);
					}
					else {
						//^32CB:2EDA
_2eda:
						X16 bp0a = 0;
						bp18 = bp14 >> 5;
						if (bp18 != 0) {
							bp0a++;
							if (bp18 > 3)
								bp0a++;
						}
						//^32CB:2EF8
						U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(GDAT_CATEGORY_SPELL_MISSILES, bp15, U8(bp0a) +0x42);
						ALLOC_IMAGE_MEMENT(GDAT_CATEGORY_SPELL_MISSILES, bp15, bp0a +0x42);
						X16 bp24 = READ_UI16(bp04,-2) * READ_UI16(bp04,-4);
						//^32CB:2F34
						SRECT bp2e;
						_44c8_20a4(
							bp04,
							_4976_4c16,
							NULL,
							QUERY_EXPANDED_RECT(4, &bp2e),
							(RAND() & 0x1f) + (bp24 - 0x28),
							RAND16(bp24 -0x28),
							_4976_00f6,
							0,
							_32cb_0649(0xd, bp15, bp0a +0x42, 0)
							);
						continue;
					}
				}
				else {
					//^32CB:2FB2
					if (bp15 == 0x30) {
						UPDATE_GLOB_VAR(0x40, 1, 3);
					}
					//^32CB:2FC6
					if (bp1c == 0 && si >= 3)
						continue;
				}
				//^32CB:2FD4
				X16 bp1e;
				if (bp08->b2_7_7() != 0) {
					bp1e = 12;
				}
				else {
					bp1e = _4976_014c[RCJ(4,bp18)];
				}
				//^32CB:2FF8
				X16 bp20 = ROTATE_5x5_POS(bp1e, _4976_5aa0);
				if (((1 << bp20) & aa) == 0)
					continue;
				//^32CB:3027
				i16 bp22 = _4976_418e[RCJ(6,bp1c)][2 -(bp20 / 5)];
				X16 bp10 = QUERY_CREATURE_BLIT_RECTI(di, bp1e, glbPlayerDir) |0x8000;
				X16 bp12 = (max_value(0x30, bp14 +1) * bp22) >> 8;
				_32cb_2cf3(bp15, bp12, bp0e, bp10);
				i16 bp0a = bp14 -0xa0;
				if (bp0a > 0) {
					bp0a = 0xc0 - bp0a;
					if (bp26 != 0 && glbTabYAxisDistance[0] == bp1c)
						//^32CB:30A9
						bp0a = 0x1e;
					//^32CB:30AE
					glbTempPicture.w34 += (_4976_00f8 << 3) / bp0a;
					if (bp08->b2_7_7() == 0) {
						//^32CB:30CD
						bp0a = (_4976_00f6 << 3) / bp0a;
						if (si == 1 || si == 4) {
							//^32CB:30E4
							bp0a = -bp0a;
						}
						//^32CB:30EC
						glbTempPicture.w32 += bp0a;
					}
				}
				//^32CB:30F3
				glbTempPicture.w32 = CALC_STRETCHED_SIZE(glbTempPicture.w32, bp22);
				glbTempPicture.w34 = CALC_STRETCHED_SIZE(glbTempPicture.w34, bp22);
				DRAW_TEMP_PICST();
				if (bp26 != 0) {
					goto _2eda;
				}
			}
			//^32CB:3122
		} while ((rl = GET_NEXT_RECORD_LINK(rl)) != OBJECT_END_MARKER);
		//^32CB:3136
	}
	//^32CB:313F
	return;
}
//^32CB:3EDD
void SkWinCore::_32cb_3edd(i16 xx)
{
	//^32CB:3EDD
	ENTER(0);
	//^32CB:3EE0
	if (_4976_421a != OBJECT_END_MARKER) {
		//^32CB:3EE7
		_32cb_3e08(_4976_421a, xx, _4976_5a8a, _4976_5a8e);
	}
	_4976_421a = OBJECT_END_MARKER;
	//^32CB:3F0B
	return;
}

//^32CB:4681
void SkWinCore::DRAW_DEFAULT_DOOR_BUTTON(U8 cls1, U8 cls2, U8 cls4, i16 iViewportCell)	// U8 cls1, U8 cls2, U8 cls4, i16 ww
{
	//^32CB:4681
	ENTER(4);
	//^32CB:4687
	X16 iViewportCellLocal = iViewportCell;	// X16 di = ww
	i16 iButtonRectno = tlbRectnoDoorButton[RCJ(14,iViewportCellLocal)]; // i16 si
	if (iButtonRectno < 0 || cls2 == 0xff)
		return;
	//^32CB:469B
    X16 iYDistance = glbTabYAxisDistance[RCJ(23,iViewportCellLocal)]; // X16 bp04
	X16 iStretchScale = tlbDistanceStretch[RCJ(5,iYDistance)];	// X16 bp02
	QUERY_TEMP_PICST(0, iStretchScale, iStretchScale, 0, 0, iYDistance, 
		QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOOR_BUTTONS, cls2, dtWordValue, 8) * 5 + iButtonRectno +1950,
		-1, glbSceneColorKey, -1, cls1, cls2, cls4
		);
	DRAW_TEMP_PICST();
	//^32CB:46F9
	if (iButtonRectno == 3 || iButtonRectno == 4) {	// 3 is D1, 4 is D0
		//^32CB:4703
		MAKE_BUTTON_CLICKABLE(&glbTempPicture.rc36, 4, U8(iViewportCellLocal));
	}
	//^32CB:4711
	return;
}

//^32CB:4715
// SPX: _32cb_4715 renamed DRAW_DOOR_FRAMES
void SkWinCore::DRAW_DOOR_FRAMES(i16 iViewportCell, X16 yy)	// i16 xx, X16 yy
{
	//^32CB:4715
	ENTER(16);
	//^32CB:471B
	//i16 si = iViewportCell; // si
	X8 gfxset = glbMapGraphicsSet;	// bp0f
	X16 colorkey = glbSceneColorKey;		// di
	ObjectID bp0e = tblCellTilesRoom[iViewportCell].xsrd.w6[1];
	Door *door = GET_ADDRESS_OF_RECORD0(bp0e);	//*bp04
	// SPX: 0x40 = GDAT_DOOR_NO_FRAMES entry. Only used for the ROOTS door type (BETA)
	if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, glbMapDoorType[door->DoorType()], dtWordValue, GDAT_DOOR_NO_FRAMES) == 0) {
		//^32CB:4770
		if ((yy & 1) != 0) {
			//^32CB:4777
			X8 bp05 = tlbGraphicsDoorRoofSlits[RCJ(14,iViewportCell)];	// 0x12 to 0x17 is door roof slit
			if (bp05 != 0xff) {
				//^32CB:4782
				// tlbRectnoDoorRoofSlits
				DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, gfxset, bp05, tlbRectnoDoorRoofSlits[RCJ(14,iViewportCell)], colorkey, DRAW_FLAG_FLIP_NONE);
			}
		}
		//^32CB:479B
		X16 iLocalCell;	// X16 bp0c
		X16 iFrameLeft;	// X16 bp08
		X16 iFrameRight;	// X16 bp0a
		if (glbGeneralFlipGraphics != 0) {
			//^32CB:47A2
			iLocalCell = tlbDoorSideFramesReorder[RCJ(23,iViewportCell)];
			iFrameLeft = 1;	// 1 = right
			iFrameRight = 0;	// 0 = left
		}
		else {
			//^32CB:47B6
			iLocalCell = iViewportCell;
			iFrameLeft = 0;	// 0 = left
			iFrameRight = 1;	// 1 = right
		}
		//^32CB:47C3
		if ((yy & 2) != 0) {	// left door frame
			//^32CB:47CA
			// X8 bp05 = tlbGraphicsDoorSideFrames[RCJ(14,bp0c)][RCJ(2,bp08)]
			X8 iDoorFrameGfx = tlbGraphicsDoorSideFrames[RCJ(14,iLocalCell)][RCJ(2,iFrameLeft)];	// door side frames (28 slots divided into 2 parts (2 * 14))
			if (iDoorFrameGfx != 0xFF) {
				//^32CB:47DD
				QUERY_TEMP_PICST(0, 64, 64, 0, 0, 0, QUERY_CREATURE_BLIT_RECTI(iViewportCell, 10, 0), 4, colorkey, -1, GDAT_CATEGORY_GRAPHICSSET, gfxset, iDoorFrameGfx); // door frame left
				DRAW_TEMP_PICST();
			}
		}
		//^32CB:480E
		if ((yy & 4) != 0) {	// right door frame (holding button)
			//^32CB:4818
			// X8 bp05 = tlbGraphicsDoorSideFrames[RCJ(14,bp0c)][RCJ(2,bp0a)];
			X8 iDoorFrameGfx = tlbGraphicsDoorSideFrames[RCJ(14,iLocalCell)][RCJ(2,iFrameRight)];
			if (iDoorFrameGfx != 0xFF) {
				//^32CB:482E
				QUERY_TEMP_PICST(1, 64, 64, 0, 0, 0, QUERY_CREATURE_BLIT_RECTI(iViewportCell, 14, 0), 3, colorkey, -1, GDAT_CATEGORY_GRAPHICSSET, gfxset, iDoorFrameGfx); // door frame right
				DRAW_TEMP_PICST();
				//^32CB:485F
				if (door->Button() != 0) {
					//^32CB:4870
					// SPX: Here, it is always the default 0 ... How could we custom this?
					// At least, it could be set along the current wallset index? or door type ? ...
					DRAW_DEFAULT_DOOR_BUTTON(GDAT_CATEGORY_DOOR_BUTTONS, 0, door->ButtonState() * 5, iViewportCell);
					// Image for released button is 0
					// Image for pushed button is 5 because there are 5 rectnos for buttons depending on distance.
				}
				else {
					//^32CB:4887
					// In case there is a custom button (from wall ornates gfx)
					if (tblCellTilesRoom[iViewportCell].xsrd.w6[2] != 0xff) {
						//^32CB:489C
						DRAW_DEFAULT_DOOR_BUTTON(GDAT_CATEGORY_WALL_GFX, U8(tblCellTilesRoom[iViewportCell].xsrd.w6[2]) & 0xff, U8(tblCellTilesRoom[iViewportCell].xsrd.w6[2] >> 8) +1, iViewportCell);
					}
				}
			}
		}
	}
	//^32CB:48D1
	return;
}

//^32CB:48D5
X16 SkWinCore::_32cb_48d5(U16 xx, i16 yy) 
{
	//^32CB:48D5
	ENTER(0);
	//^32CB:48D9
	i16 si = (((xx << 7) +64) / yy) >> 1;
	if (CALC_STRETCHED_SIZE(si, yy) < xx)
		//^32CB:48FB
		return si +1;
	//^32CB:4900
	return si;
}

//^32CB:4905
// SPX: _32cb_4905 renamed DRAW_DOOR
void SkWinCore::DRAW_DOOR(i16 iCellPos, X16 yy, X16 zz, X32 aa)	// i16 xx, X16 yy, X16 zz, X32 aa
{
	//^32CB:4905
	ENTER(348);
	//^32CB:490B
	if (yy != 0) {
		//^32CB:4911
		DRAW_DOOR_FRAMES(iCellPos, yy);
	}
	//^32CB:491D
	if (aa != 0) {
		//^32CB:4925
		DRAW_STATIC_OBJECT(iCellPos, aa, 0);
	}
	
	//^32CB:4937
	U16 iDoorState = tblCellTilesRoom[iCellPos].xsrd.w6[0];	// U16 bp06
	X16 iStretchDual;	// X16 si
	if (iDoorState != 0) {	// 0 = open. 1 - 3 = intermediate state. 4 = closed. 5 = destroyed
		//^32CB:4955
		ObjectID bp0c = tblCellTilesRoom[iCellPos].xsrd.w6[1];
		i16 iYDist = glbTabYAxisDistance[RCJ(23,iCellPos)];	// i16 bp08
		if (iYDist <= 3) {
			//^32CB:497D
			i16 iInvertedYDist = tlbInvertedDoorDistance[RCJ(5,iYDist)];	// i16 bp18
			if (iInvertedYDist >= 0) {
				//^32CB:498F
				i16 iDoorPosRectno = tlbRectnoDoorPosition[RCJ(16,iCellPos)];	// i16 bp1a
				if (iDoorPosRectno >= 0) {
					//^32CB:49A2
					Door *xDoor = GET_ADDRESS_OF_RECORD0(bp0c);	// Door *bp04
					U8 iDoorGDATIndex = glbMapDoorType[xDoor->DoorType()];	// U8 bp0e
					X16 iDoorColorPassThrough = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtWordValue, GDAT_IMG_COLORKEY_1);	// X16 bp12
					if (iDoorColorPassThrough != 0)
					{
						// SPX BEGIN
						U8 mirroredDoor = 0;	// by default there is no mirror/flip, so value = 0
						// SPX TEST: Here we can make pseudo animated door like DM1 force field, by playing with the mirror bit
						if (SkCodeParam::bUseDM2ExtendedMode)
						{
							mirroredDoor = QUERY_GDAT_DOOR_IS_MIRRORED(iDoorGDATIndex);
							if (mirroredDoor)
							{
								// RAND02 => 0 to 3
								// Flips: 0 = none, 1 = x, 2 = y, 3 = x & y
								mirroredDoor = RAND02();
							}
						}
						// SPX END

						//^32CB:49DE
						U8 iDoorImg = U8(iYDist) -1;	// U8 bp0f / Check image no from distance; note: distance 0 would give image 0xFF.
						// Door at Y=1 uses image 0 ; Y=2 => image 1 ; Y=3 => image 2 ; Y=0 has normally no specific image, it is image 0 streched.
						iStretchDual = 0x40;	// si = 0x40 = 64 <=> 100%
						X16 iLightPalette = 0;	// X16 bp0a	// 0 = light -> 4 = dark
						if (iYDist == 0 || QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtImage, iDoorImg) == 0) {	// 0xe
							//^32CB:4A09
							if (iYDist != 0) {
								//^32CB:4A0F
								iLightPalette = iYDist;
								iStretchDual = tlbDistanceStretch[RCJ(5,iLightPalette)];	// SPX: iLightPalette is used whereas mostly iYDist is used instead. Aren't they just the same?
							}
							else {
								//^32CB:4A21
								iStretchDual = 0x71;	// si = 0x71 = 113 <=> 176%
							}
							//^32CB:4A24
							iDoorImg = 0;
						}
						//^32CB:4A28
						X16 iOrnateIndex = xDoor->OrnateIndex();	// X16 di
						i16 iCacheNo;	// i16 bp16
#if (DM2_EXTENDED_MODE == 1)
						if (iOrnateIndex != 0 || iDoorState == 5 || glbGlobalSpellEffects.SeeThruWalls > 0) {	// + window spell effect
#else
						if (iOrnateIndex != 0 || iDoorState == 5) {	// If there is any ornate or door is destroyed
#endif
							//^32CB:4A43
							ExtendedPicture xPicture;	// ExtendedPicture bp015c;
							// Get door graphics
							//bp16 = QUERY_MULTILAYERS_PIC(&bp015c, GDAT_CATEGORY_DOORS, bp0e, bp0f, si, si, bp0a, 0, bp12, -1);	// 0xe
							iCacheNo = QUERY_MULTILAYERS_PIC(&xPicture, GDAT_CATEGORY_DOORS, iDoorGDATIndex, iDoorImg, iStretchDual, iStretchDual, iLightPalette, mirroredDoor, iDoorColorPassThrough, -1);	// 0xe
							DRAW_PICST(&xPicture);
							FREE_PICT_MEMENT(&xPicture);
							X16 iStretchHorizontal;	// X16 bp20
							X16 iStretchVertical;	// X16 bp22
							if (iStretchDual == 0x40) {
								//^32CB:4A88
								i16 bp1c;
								i16 bp1e;
								
								QUERY_GDAT_IMAGE_METRICS(GDAT_CATEGORY_DOORS, iDoorGDATIndex, 0, &bp1c, &bp1e);	// 0xe
								iStretchHorizontal = _32cb_48d5(glbTempPicture.width, bp1c);
								iStretchVertical = _32cb_48d5(glbTempPicture.height, bp1e);
								
							}
							else {
								//^32CB:4AC4
								iStretchVertical = iStretchHorizontal = iStretchDual;
							}
							//^32CB:4ACC
							// If there is an ornate on the door ...
							if (iOrnateIndex != 0) {
								//^32CB:4AD0
								iOrnateIndex--;
								U8 iOrnateGDATIndex = glbMapDoorOrnatesList[iOrnateIndex];	// (bp0d) Get the real ornate gfx from the current map door ornate list.
								// SPX: Get ornate
								X16 iColorTransparencyOverlay = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOOR_GFX, iOrnateGDATIndex, dtWordValue, GDAT_IMG_COLORKEY_1);	// X16 bp14
								if (iColorTransparencyOverlay == 0) {
									//^32CB:4AEE
									iColorTransparencyOverlay = 9;	// SPX: This is the "colorkey" index (generally not set in any GDAT2).
								}
								//^32CB:4AF3
								// SPX: draw the ornate over the door // added for 
								//QUERY_TEMP_PICST(0, bp20, bp22, 0, 0, bp08, 
								
								if (!SkCodeParam::bUseDM2ExtendedMode)
									QUERY_TEMP_PICST(mirroredDoor, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, 
										(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOOR_GFX, iOrnateGDATIndex, dtWordValue, GDAT_DOOR_ORNATE__POSITION) << 2) + iInvertedYDist +0x7d0,
										-1, iColorTransparencyOverlay, -1, GDAT_CATEGORY_DOOR_GFX, iOrnateGDATIndex, GDAT_DOOR_DECORATION_MASK
										);
								else if (SkCodeParam::bUseDM2ExtendedMode)
								{	// SPX: use the colorkey 10 (by default) or what's in GDAT instead of -1 for activating 'pass through' bitmaps
									X16 iColorPassThrough = 10;	// 10 is standard DARK GREEN
									iColorPassThrough = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOOR_GFX, iDoorGDATIndex, dtWordValue, GDAT_IMG_COLORKEY_1);
									if (iColorPassThrough == 0)
										iColorPassThrough = 10;
									QUERY_TEMP_PICST(mirroredDoor, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, 
										(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOOR_GFX, iOrnateGDATIndex, dtWordValue, GDAT_DOOR_ORNATE__POSITION) << 2) + iInvertedYDist +0x7d0,
										-1, iColorTransparencyOverlay, iColorPassThrough, GDAT_CATEGORY_DOOR_GFX, iOrnateGDATIndex, GDAT_DOOR_DECORATION_MASK
										);
								}

								glbTempPicture.pb44 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(iCacheNo));
								DRAW_TEMP_PICST();
							}
							//^32CB:4B45
							if (iDoorState == 5) {	// If door is destroyed .. then draw destroyed mask instead of any ornate
								//^32CB:4B4B
								X16 iColorTransparencyOverlay = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtWordValue, GDAT_IMG_DOOR_COLORKEY_2);	// X16 bp14
								if (iColorTransparencyOverlay == 0)
									iColorTransparencyOverlay = 9;	// 9 is standard CYAN

								// SPX: (2016-10-30) Get the destroyed door mask and use default one if available
								if (!SkCodeParam::bUseFixedMode)
								QUERY_TEMP_PICST(0, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, 
									(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtWordValue, GDAT_DOOR_DESTROYED_MASK_POSITION) << 2) + iInvertedYDist +0x7d0,
									-1, iColorTransparencyOverlay, iDoorColorPassThrough, GDAT_CATEGORY_DOORS, iDoorGDATIndex, GDAT_DOOR_DESTROYED_MASK
									);
								else if (SkCodeParam::bUseFixedMode)
								{
									U16 iDoorDestroyedGDATIndex = iDoorGDATIndex;
									// Check if there is a destroyed mask for the current door
									U16 iDoorDestroyedMask = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtImage, GDAT_DOOR_DESTROYED_MASK);
									if (iDoorDestroyedMask == (U16)-1) // not found, get the default one
										iDoorDestroyedGDATIndex = GDAT_ITEM_DEFAULT_INDEX;
									QUERY_TEMP_PICST(0, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, 
										(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtWordValue, GDAT_DOOR_DESTROYED_MASK_POSITION) << 2) + iInvertedYDist +0x7d0,
										-1, iColorTransparencyOverlay, iDoorColorPassThrough, GDAT_CATEGORY_DOORS, iDoorDestroyedGDATIndex, GDAT_DOOR_DESTROYED_MASK
										);								
								}
								// End SPX: (2016-10-30) 
								
								glbTempPicture.pb44 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(iCacheNo));
								DRAW_TEMP_PICST();
							}
#if (DM2_EXTENDED_MODE == 1)
							if (glbGlobalSpellEffects.SeeThruWalls > 0 && iYDist == 1 && yy == 7) {	// If Window spell is active, and display only if distance = 1 and just in front
								
								X16 iColorTransparencyOverlay = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtWordValue, GDAT_IMG_DOOR_COLORKEY_2);	// X16 bp14
								if (iColorTransparencyOverlay == 0)
									iColorTransparencyOverlay = 9;	// 9 is standard CYAN
								
								{
									U16 iDoorSeeThruGDATIndex = iDoorGDATIndex;
									
									U16 iDoorSeeThruMask = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtImage, GDAT_DOOR_SEE_THRU);
									if (iDoorSeeThruMask == (U16)-1) // not found, get the default one
										iDoorSeeThruGDATIndex = GDAT_ITEM_DEFAULT_INDEX;
									QUERY_TEMP_PICST(0, iStretchHorizontal, iStretchVertical, 0, 0, iYDist, 
										(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorGDATIndex, dtWordValue, GDAT_DOOR_DESTROYED_MASK_POSITION) << 2) + iInvertedYDist +0x7d0,
										-1, iColorTransparencyOverlay, iDoorColorPassThrough, GDAT_CATEGORY_DOORS, iDoorSeeThruGDATIndex, GDAT_DOOR_SEE_THRU
										);								
								}
								
								glbTempPicture.pb44 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(iCacheNo));
								DRAW_TEMP_PICST();
							}
#endif
							//^32CB:4BBC
							xPicture.colorKeyPassThrough = xPicture.b58[iDoorColorPassThrough];
							xPicture.w56 = 0;
							_0b36_00c3(iCacheNo, &xPicture);
							// SPX: that draws the main door (without ornate)
							COPY_MEMORY(&xPicture, &glbTempPicture, sizeof(ExtendedPicture));
							glbTempPicture.pb44 = _4976_4c16;
						}
						else {
							//^32CB:4C0C
							iCacheNo = -1;
							//QUERY_TEMP_PICST(0, si, si, 0, 0, bp0a, -1, -1, bp12, -1, 0xe, bp0e, bp0f);
							QUERY_TEMP_PICST(mirroredDoor, iStretchDual, iStretchDual, 0, 0, iLightPalette, -1, -1, iDoorColorPassThrough, -1, GDAT_CATEGORY_DOORS, iDoorGDATIndex, iDoorImg);
						}
						//^32CB:4C36
						// SPX: this part change position of door when in intermediate state
						if (iDoorState < 4) {	// 4 = closed. < 4 => intermediate state. 0 = opened
							//^32CB:4C3C
							iDoorPosRectno = iDoorPosRectno + iDoorState;
							if (xDoor->OpeningDir() == 0) // 0 = horizontal
							{
								X16 iWidth = 0;	// SPX: added this to not reuse "di" variable, already used for ornate index
								//^32CB:4C56
								glbTempPicture.width >>= 1;
								iWidth = glbTempPicture.width;
								glbTempPicture.w4 |= 0x10;
								glbTempPicture.w14 = glbTempPicture.w14 + iWidth;
								glbTempPicture.rectNo = iDoorPosRectno + 6;
								DRAW_TEMP_PICST();	// will draw RIGHT part of the door
								glbTempPicture.w14 = glbTempPicture.w14 + iWidth;
								iDoorPosRectno += 3;
							}
						}
						// Explanation on door rectno offsets:
						// 0 = closed
						// 1 - 3 = vertical positions (, ,  closed)
						// 4 - 6 = horizontal left positions (, ,  closed)	=> hence +3 on rectno for horizontal opening
						// 7 - 9 = horizontal right positions (, ,  closed)	=> hence +6 on rectno for horizontal opening
						//^32CB:4C86
						glbTempPicture.rectNo = iDoorPosRectno;
						DRAW_TEMP_PICST();	// draw the door or LEFT part for horizontal opening
						if (iCacheNo >= 0) {
							//^32CB:4C96
							FREE_TEMP_CACHE_INDEX(iCacheNo);
						}
					}
				}
			}
		}
	}
	//^32CB:4C9F
	if (zz != 0) {
		//^32CB:4CA5
		DRAW_DOOR_FRAMES(iCellPos, zz);
	}
	//^32CB:4CB1
	if (aa != 0) {
		//^32CB:4CB9
		_32cb_2d8c(tblCellTilesRoom[iCellPos].xsrd.w4, iCellPos, aa);
	}
	//^32CB:4CDB
	return;
}

//^32CB:4CDF
// SPX: _32cb_4cdf renamed DRAW_DOOR_TILE
void SkWinCore::DRAW_DOOR_TILE(i16 iCellPos)	// i16 xx
{
	//^32CB:4CDF
	ENTER(6);
	//^32CB:4CE5
	//i16 si = xx; <= iCellPos
	if (_4976_455e[RCJ(16,iCellPos)] == 0)
		return;
	X32 bp04 = 0x1000;
	if (tblCellTilesRoom[iCellPos].xsrd.w6[0] != 5) {
		//^32CB:4D13
		bp04 = 0x1000;
	}
	// SPX: draw objects on door tile behind the door
	DRAW_STATIC_OBJECT(iCellPos, 0x3ff, (iCellPos != 0) ? 1 : 0);
	X16 bp06 = 0;
	X16 di = 0;
	switch (iCellPos) {
		case 0://^4D4E	// SPX: player is on the tile of the door
			//^32CB:4D4E
			if (bp04 != 0) {
				//^32CB:4D56
				DRAW_STATIC_OBJECT(iCellPos, bp04, 0);
			}
			DRAW_DOOR(iCellPos, 6, 0, 0);
			_32cb_2d8c(tblCellTilesRoom[iCellPos].xsrd.w4, iCellPos, 0x01ffffff);
			return;
		case 7://^4D96
			//^32CB:4D96
			di = 1;
            bp06 = 4;
			goto _4dc0;
		case 8://^4DA0
			//^32CB:4DA0
			di = 1;
			bp06 = 2;
			goto _4dc0;
		case 12://^4DA2
			//^32CB:4DA2
			di = 2;
			bp06 = 4;
			goto _4dc0;
		case 13://^4DA7
			//^32CB:4DA7
			di = 4;
			bp06 = 2;
			goto _4dc0;
		case 11://^4DAC
			//^32CB:4DAC
			di = 6;
			goto _4dc0;
		case 4://^4DB1
			//^32CB:4DB1
			di = 1;
            bp06 = 4;
			goto _4dc0;
		case 5://^4DB3
			di = 1;
			bp06 = 2;
			goto _4dc0;
		case 3://^4DBD
		case 6://^4DBD
			di = 7;
			goto _4dc0;
		case 14://^4DC0
		case 15://^4DC0
			//^32CB:4DC0
_4dc0:
			DRAW_DOOR(iCellPos, di, bp06, bp04);
			break;
		case 1://^4DD2
		case 2://^4DD2
		case 9://^4DD2
		case 10://^4DD2
			break;
	}
	//^32CB:4DD2
	// SPX: draw objects on door tile before the door
	DRAW_STATIC_OBJECT(iCellPos, 0x01fffc00 & (~bp04), 1);
	_32cb_3edd(iCellPos);
	//^32CB:4DF8
	return;
}

//^32CB:4ECC
// SPX: _32cb_4ecc renamed DRAW_STAIRS_SIDE
void SkWinCore::DRAW_STAIRS_SIDE(i16 xx)
{
	//^32CB:4ECC
	ENTER(4);
	//^32CB:4ED2
	i16 di = xx;
	U8 gfxset = glbMapGraphicsSet;	// bp02
	i16 bp04 = glbSceneColorKey;
	if (di > 8)
		return;
	//^32CB:4EE6
	X16 si = (tblCellTilesRoom[di].xsrd.w6[0] != 0) ? 1 : 0;
	X8 bp01 = tlbGraphicsStairsSide[RCJ(9,di)][RCJ(2,si)];	// bp01	, table containing 0xC7 to 0xD2 = side stairs (wood ramp)
	if (bp01 != 0xff) {
		//^32CB:4F12
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, gfxset, bp01, _4976_4600[RCJ(9,di)][RCJ(2,si)], bp04, 0);
	}
	//^32CB:4F37
	return;
}

//^32CB:4E1C
// SPX: _32cb_4e1c renamed DRAW_STAIRS_FRONT
void SkWinCore::DRAW_STAIRS_FRONT(i16 xx)
{
	//^32CB:4E1C
	ENTER(4);
	//^32CB:4E22
	U8 gfxset = glbMapGraphicsSet;	// bp04
	U16 colorkey = glbSceneColorKey;		// di
	X16 si = (tblCellTilesRoom[xx].xsrd.w6[0] != 0) ? 1 : 0;
	i16 bp02 = _4976_45ae[RCJ(16,xx)][RCJ(2,si)];
	if (bp02 < 0)
		return;
	//^32CB:4E5F
	X8 bp03 = tlbGraphicsStairsFront1[RCJ(16,xx)][RCJ(2,si)];
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_GRAPHICSSET, gfxset, dtImage, bp03) != 0) {
		//^32CB:4E80
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, gfxset, bp03, bp02, colorkey, 0);
		return;
	}
	//^32CB:4E99
	QUERY_TEMP_PICST(1, 64, 64, 0, 0, 0, bp02, -1, colorkey, -1, 8, gfxset, tlbGraphicsStairsFront2[RCJ(16,xx)][RCJ(2,si)]);
	DRAW_TEMP_PICST();
	//^32CB:4EC8
	return;
}
//^32CB:245A
// SPX: _32cb_245a renamed DRAW_PIT_TILE
void SkWinCore::DRAW_PIT_TILE(i16 xx)
{
	//^32CB:245A
	ENTER(6);
	//^32CB:2460
	i16 si = xx;
	X8 bp03 = glbMapGraphicsSet;
	X16 bp06 = glbSceneColorKey;
	i16 bp02 = _4976_4282[RCJ(16,si)];
	if (bp02 < 0)
		return;
	if (si < 11 || tblCellTilesRoom[si].xsrd.w6[0] == 0) {
		//^32CB:2497
		X16 di = tlbGraphicsFlip[RCJ(16,si)];	// di
		if (si == 0) {
			//^32CB:24A3
			di = (SET_GRAPHICS_FLIP_FROM_POSITION(1, _4976_5aa0, _4976_5a9c, _4976_5a9e) != 0) ? 1 : 0;
		}
		//^32CB:24C4
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, bp03
			, (tblCellTilesRoom[si].xsrd.w6[0] != 0) ? tlbGraphicsPitHidden[RCJ(16,si)] : tlbGraphicsPitNormal[RCJ(16,si)], bp02, bp06, di);
	}
	//^32CB:24F7
	return;
}
//^32CB:1F3E
// SPX: _32cb_1f3e renamed DRAW_EXTERNAL_TILE
X16 SkWinCore::DRAW_EXTERNAL_TILE(i16 xx)
{
	//^32CB:1F3E
	ENTER(356);
	//^32CB:1F44
	i16 si = xx;
	X8 bp14 = _4976_4230[RCJ(23,si)];
	if (bp14 == 0xff)
		return 0;
	//^32CB:1F55
	i16 bp06 = tblCellTilesRoom[si].posx;
	i16 bp08 = tblCellTilesRoom[si].posy;
	i16 bp18 = glbTabYAxisDistance[RCJ(23,si)];
	//^32CB:1F86
	TELE_inf bp2a; // bp2a-bp26
	if (bp18 > 3 && GET_TELEPORTER_DETAIL(&bp2a, U8(bp06), U8(bp08)) == 0)
		return 0;
	//^32CB:1FA6
	U16 bp02 = tblCellTilesRoom[si].xsrd.w6[2];
	X16 bp16 = bp02 >> 8;
	bp14 += X8(bp16);
	X8 bp13 = X8(bp02);
	if (bp13 == 0xff || bp13 == 0)
		return 0;
	//^32CB:1FDF
	X16 bp04 = 0;
	if (glbTabXAxisDistance[RCJ(23,si)] == 0) {
		//^32CB:1FEB
		if (QUERY_GDAT_ENTRY_DATA_INDEX(0xa, bp13, dtWordValue, 7) == 0) {
			//^32CB:2001
			bp04 = glbGeneralFlipGraphics;
			if ((bp18 & 1) == 0) {
				//^32CB:200E
				bp04 ^= 1;
			}
		}
	}
	//^32CB:2015
	else if (glbTabXAxisDistance[RCJ(23,si)] >= 1) {
		//^32CB:201C
		bp04 = 1;
	}
	//^32CB:2021
	X16 bp0e = QUERY_GDAT_ENTRY_DATA_INDEX(0xa, bp13, dtWordValue, 4);
	if (bp0e == 0) {
		//^32CB:203A
		bp0e = glbSceneColorKey;
	}
	//^32CB:2040
	X16 bp0a = QUERY_GDAT_ENTRY_DATA_INDEX(0xa, bp13, dtWordValue, 5);
	X16 bp12;
	if (bp0a == 0) {
		//^32CB:2059
		bp0a = 12;
		bp12 = 0;
	}
	else {
		//^32CB:2065
		bp12 = bp0a >> 8;
		bp0a = (bp0a & 0xff) -1;
	}
	//^32CB:2078
	X16 bp0c = QUERY_CREATURE_BLIT_RECTI(si, bp0a, 0);
	X16 bp10 = 0x40;
	if (QUERY_GDAT_ENTRY_IF_LOADABLE(0xa, bp13, dtImage, bp14) == 0) {
		//^32CB:20A6
		bp14 = _4976_4247[RCJ(23,si)] +X8(bp16);
		bp10 = tlbDistanceStretch[RCJ(5,bp18)];
	}
	//^32CB:20BC
	X16 bp1a;
	X16 bp22;
	X16 bp24;
	i16 di;
	X16 bp20;
	ExtendedPicture bp0164;
	X16 bp1c;
	if (glbTabXAxisDistance[RCJ(23,si)] == 0 && bp18 != 0) {
		//^32CB:20CF
		X16 bp1e = QUERY_GDAT_ENTRY_DATA_INDEX(0xa, bp13, dtWordValue, 0x63);
		if ((bp1c = GET_TELEPORTER_DETAIL(&bp2a, U8(bp06), U8(bp08))) != 0 || bp1e != 0) {
			//^32CB:2107
			QUERY_TEMP_PICST(bp04, bp10, bp10, 0, 0, bp18, bp0c, bp12, -3, -3, 0xa, bp13, bp14);
			QUERY_TEMP_PICST(bp04, bp10, bp10, glbTempPicture.w28, glbTempPicture.w30, bp18, bp0c, bp12, bp0e, -1, 0xa, bp13, bp14 +0xc8);
			DRAW_TEMP_PICST();
			//^32CB:2168
			bp06 = bp2a.b2;
			bp08 = bp2a.b3;
			bp1a = _4976_5aa0;
			_4976_5aa0 = bp2a.b1;
			bp22 = glbCurrentMapIndex;
			CHANGE_CURRENT_MAP_TO(bp2a.b4);
			_4976_4212 = 1;
			bp24 = glbTabYAxisDistance[RCJ(23,si)];
			CALC_VECTOR_W_DIR(_4976_5aa0, -bp24, 0, &bp06, &bp08);
			//^32CB:21C4
			for (di = 4; di >= bp24; di--) {
				//^32CB:21C9
				_32cb_4185_TILE_ROOM(bp06, bp08, _4976_422b[RCJ(5,di)], _4976_5aa0);
				//^32CB:21E1
			}
			//^32CB:21E7
			for (di = 4; di > bp24; di--) {
				//^32CB:21EC
				DRAW_STATIC_OBJECT(_4976_422b[RCJ(5,di)], 0x01ffffff, 1);
				//^32CB:2201
			}
			//^32CB:2207
			CHANGE_CURRENT_MAP_TO(bp22);
			_4976_4212 = 0;
			_4976_5aa0 = bp1a;
			DRAW_STATIC_OBJECT(si, 0x000003ff, 1);
			bp20 = QUERY_MULTILAYERS_PIC(
				&bp0164, GDAT_CATEGORY_FLOOR_GFX, bp13, bp14, bp10, bp10, bp18, bp04, bp0e,
				QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_FLOOR_GFX, bp13, dtWordValue, GDAT_IMG_FLOOR_COLORKEY_2)	// 0xa
				);
			if (bp1e != 0) {
				//^32CB:226E
				_32cb_0c7d(&bp0164, bp20, bp0e);
			}
			else {
				//^32CB:2283
				FILL_ENTIRE_PICT(reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp20)), bp0164.b58[bp0e]);
			}
			//^32CB:22A5
			bp0164.pb44 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp20));
			DRAW_PICST(&bp0164);
			FREE_PICT_MEMENT(&bp0164);
			bp0164.colorKeyPassThrough = bp0164.b58[bp0e];
			bp0164.pb44 = _4976_4c16;
			bp0164.rectNo = bp0c;
			bp0164.w26 = bp12;
			bp0164.w56 = 0;
			_0b36_00c3(bp20, &bp0164);
			DRAW_PICST(&bp0164);
			FREE_TEMP_CACHE_INDEX(bp20);
			return bp1c;
		}
	}
	//^32CB:2331
	QUERY_TEMP_PICST(bp04, bp10, bp10, 0, 0, bp18, bp0c, bp12, bp0e, -1, 0xa, bp13, bp14);
	DRAW_TEMP_PICST();
	//^32CB:2361
	return 0;
}
//^32CB:2367
// SPX: _32cb_2367 renamed DRAW_PIT_ROOF
void SkWinCore::DRAW_PIT_ROOF(i16 xx)
{
	//^32CB:2367
	ENTER(10);
	//^32CB:236D
	i16 si = xx;
	X8 gfxset = glbMapGraphicsSet;	//bp07
	X16 bp0a = glbSceneColorKey;
	if (si > 8 || (glbSceneFlags & 1) == 0)
		return;
	//^32CB:238F
	i16 bp04 = tblCellTilesRoom[si].posx;
	i16 bp06 = tblCellTilesRoom[si].posy;
	i16 bp02 = LOCATE_OTHER_LEVEL(glbCurrentMapIndex, -1, &bp04, &bp06, NULL);
	if (bp02 < 0)
		return;
	//^32CB:23DB
	bp02 = glbMapTileValue[bp02][bp04][bp06];
	if ((bp02 >> 5) != 2 || (bp02 & 8) == 0)
		return;
	//^32CB:240B
	X16 di = _4976_4279[RCJ(9,si)];
	if (si == 0) {
		//^32CB:2417
		di = (SET_GRAPHICS_FLIP_FROM_POSITION(0x20, _4976_5aa0, _4976_5a9c, _4976_5a9e) != 0) ? 1 : 0;
	}
	//^32CB:2438
	DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, gfxset, tlbGraphicsPitRoof[RCJ(9,si)], _4976_425e[RCJ(9,si)], bp0a, di);
	//^32CB:2456
	return;
}

//^32CB:3143
// SPX: _32cb_3143 renamed DRAW_FLYING_ITEM
void SkWinCore::DRAW_FLYING_ITEM(ObjectID rl, i16 cellPos, X16 _5x5)
{
	//^32CB:3143
	ENTER(32);
	//^32CB:3149
	if (rl == OBJECT_END_MARKER)
		return;
	//^32CB:3152
	i16 di = DIR_FROM_5x5_POS(_5x5);
	if (di == -1)
		return;
	//^32CB:3165
	X16 bp1a = glbTabYAxisDistance[RCJ(23,cellPos)];
	if (bp1a == 0 && di >= 2)
		return;
	//^32CB:317E
	i16 bp1c = glbTabXAxisDistance[RCJ(23,cellPos)];
	if (_4976_415b[RCJ(23,cellPos)] < 0)
		return;
	//^32CB:3193
	X16 bp1e = tblCellTilesRoom[cellPos].posx;
	X16 bp20 = tblCellTilesRoom[cellPos].posy;
	X16 si;
	do {
		//^32CB:31BE
		if (QUERY_OBJECT_5x5_POS(rl, _4976_5aa0) != _5x5)
			continue;
		//^32CB:31D4
		if (rl.DBType() != dbMissile)
			continue;
        //^32CB:31E5
		i16 bp08 = QUERY_CREATURE_BLIT_RECTI(cellPos, _5x5, 0);
        X16 bp0c = _48ae_011a(rl);
		if (bp0c == 0xffff) {
			//^32CB:320A
			ObjectID bp18 = ObjectID(GET_ADDRESS_OF_RECORDE(rl)->GetMissileObject(), rl.Dir());
			DRAW_ITEM(bp18, cellPos, 0, 0xffa4, -1, NULL, 1, 0, 0);
			continue;
		}
		//^32CB:324D
		Missile *bp04 = GET_ADDRESS_OF_RECORDE(rl);
		U8 bp12 = QUERY_CLS1_FROM_RECORD(rl);
		U8 bp11 = QUERY_CLS2_FROM_RECORD(rl);
		X16 bp0e = (bp12 == 0xd) ? 1 : 0;
		X16 bp10;
		i16 bp16;
		//^32CB:3284
		if ((bp0e == 0 || bp04->EnergyRemaining() == 0xff) && bp1a == 0) {
			//^32CB:3298
			bp10 = bp16 = 0x40;
		}
		else {
			//^32CB:32A3
			bp16 = (bp1a << 1) -(di >> 1);
			if (bp16 < 0)
				continue;
			//^32CB:32B8
			bp10 = bp16 = _4976_41a9[RCJ(7,bp16)];
			if (bp0e != 0) {
				//^32CB:32CD
				bp10 = max_value(8, CALC_STRETCHED_SIZE((((bp04->EnergyRemaining() << 7) / 255) +1) >> 1, bp10));
			}
		}
		//^32CB:32FB
		si = 0;
		X8 bp13;
		if (bp0c == 3) {
			//^32CB:3303
			bp13 = 8;
		}
		else {
			//^32CB:330A
			X16 bp0a = glbTimersTable[bp04->TimerIndex()].Direction();
			if ((bp0a & 1) != (_4976_5aa0 & 1)) {
				//^32CB:3338
				bp13 = 0xc;
				if (bp0c == 0) {
					if (di == 0 || di == 3) {
						//^32CB:334B
						si |= 1;
					}
					//^32CB:334F
					if (((bp1e +bp20) & 1) == 0) {
						si ^= 1;
					}
				}
				//^32CB:3364
				else if (((_4976_5aa0 +1) & 3) == bp0a) {
					si |= 1;
				}
			}
			//^32CB:3376
			else {
				if (bp0c == 0) {
					if (((bp1e +bp20) & 1) != 0) {
						//^32CB:3387
						si |= 2;
						if (di < 2) {
							//^32CB:3390
							bp13 = 8;
						}
						else {
							//^32CB:3396
							bp13 = 9;
						}
					}
					//^32CB:339C
					else if (di >= 2) {
						//^32CB:33A1
						//^32CB:3390
						bp13 = 8;
					}
					else {
						//^32CB:33A3
						bp13 = 9;
					}
				}
				//^32CB:33A9
				else if (bp0c == 2 || (bp0c == 1 && bp0a != _4976_5aa0)) {
					//^32CB:33BE
					//^32CB:3390
					bp13 = 8;
				}
				else {
					//^32CB:33C0
					bp13 = 10;
				}
				//^32CB:33C4
				if (bp1c < 1 && (bp1c != 0 || (di != 1 && di != 2))) {
					//^32CB:33DA
					si |= 1;
				}
				//^32CB:33DE
				if ((di & 1) != 0 && bp12 == 0xd) {
					//^32CB:33EA
					si |= 2;
				}
			}
		}
		//^32CB:33EE
		X16 bp06;
		if (bp12 == 0xd) {
			//^32CB:33F4
			bp06 = QUERY_GDAT_ENTRY_DATA_INDEX(0xd, bp11, dtWordValue, 0x01);
		}
		else {
			bp06 = 3;
		}
		//^32CB:3410
		QUERY_TEMP_PICST(si & bp06, bp10, bp10, 0, 0, bp1a, bp08 | 0x8000, 0, 10, -1, bp12, bp11, bp13);
		glbTempPicture.w32 += CALC_STRETCHED_SIZE(0, bp16);
		glbTempPicture.w34 = CALC_STRETCHED_SIZE(-92, bp16);
		DRAW_TEMP_PICST();
		//^32CB:3467
	} while ((rl = GET_NEXT_RECORD_LINK(rl)) != OBJECT_END_MARKER);
	//^32CB:347B
	return;
}

//^32CB:3B9D
// SPX: _32cb_3b9d renamed DRAW_STATIC_OBJECT
void SkWinCore::DRAW_STATIC_OBJECT(i16 xx, X32 ss, X16 ww)
{
	//^32CB:3B9D
	ENTER(28);
	
	//^32CB:3BA3
	i16 si = xx;
	if (si > 15 || _4976_43e5[RCJ(16,si)] == 0)
		return;
	//^32CB:3BB8
	X16 bp1c = tblCellTilesRoom[si].xsrd.w0;
	ObjectID bp16 = tblCellTilesRoom[si].xsrd.w4;
	X16 bp0c = _4976_43f5[RCJ(16,si)][0];
	X16 bp0e = _4976_43f5[RCJ(16,si)][1];
	const U8 *displayOrder;	// *bp04 
	if (glbTabXAxisDistance[RCJ(23,si)] < 0) { // at left
		//^32CB:3BFF
		displayOrder = tlbDisplayOrderLeft;
	}
	//^32CB:3C06
	else if (glbTabXAxisDistance[RCJ(23,si)] == 0) { // at center
		//^32CB:3C0D
		displayOrder = tlbDisplayOrderCenter;
	}
	else { // at right
		//^32CB:3C14
		displayOrder = tlbDisplayOrderRight;
	}
	//^32CB:3C1C
	for (X16 di = 0; ((si == 0) ? 15 : 25) > di; di++) {
		//^32CB:3C21
		X16 bp08 = displayOrder[di];
		X32 bp1a = (U32(1) << bp08) & ss;
		if (bp1a == 0)
			continue;
		//^32CB:3C4C
		// SPX: some problem here : if (*_4976_5be2)[si] is zero on a door (open) then no item will be drawn!
		if (((*_4976_5be2)[si] & bp1a) != 0) {
			//^32CB:3C68
			DRAW_PUT_DOWN_ITEM(bp16, si, DIR_FROM_5x5_POS(bp08), NULL);
		}
		//^32CB:3C81
		X16 bp10 = _4976_4415[RCJ(25,bp08)][0] +bp0c;
		X16 bp12 = bp0e -_4976_4415[RCJ(25,bp08)][1];
		if (bp1c == 0 || _4976_5a84[bp10][bp12] == si) {
			//^32CB:3CC8
			U8 bp13 = _4976_5aa4[bp10][bp12];
			if (bp13 != 0xff) {
				//^32CB:3CE6
				if (((1 << bp08) & ss) != 0) {
					//^32CB:3D04
					SUMMARY_DRAW_CREATURE(tblCellTilesRoom[bp13].xsrd.w4, bp13, ss);
					_4976_5aa4[bp10][bp12] = 0xff;
					if ((*_4976_5a7c)[si] != 0) {
						//^32CB:3D54
						U16 bp06;
						for (bp06 = di -7; bp06 < di; bp06++) {
							//^32CB:3D5E
							X16 bp0a = displayOrder[bp06];
							if (((1 << bp0a) & *(*_4976_5a7c)) != 0) {
								//^32CB:3D99
								DRAW_FLYING_ITEM(bp16, si, bp0a);
							}
							//^32CB:3DA7
						}
					}
				}
			}
		}
		//^32CB:3DAF
		if (((*_4976_5a7c)[si] & bp1a) != 0) {
			//^32CB:3DCB
			DRAW_FLYING_ITEM(bp16, si, bp08);
		}
		//^32CB:3DD9
	}
	//^32CB:3DED
	if (ww != 0) {
		//^32CB:3DF3
		_32cb_2d8c(bp16, si, ss);
	}
	//^32CB:3E04
	return;
}

//^32CB:24FB
// SPX: _32cb_24fb renamed DRAW_TELEPORTER_TILE; though it can display REFLECTOR
void SkWinCore::DRAW_TELEPORTER_TILE(i16 xx, X16 cls1, X16 cls2)
{
	//^32CB:24FB
	ENTER(60);
	//^32CB:2501
	if (xx > 15)
		return;
	//^32CB:250A
	X8 *bp04 = _4976_42f2[RCJ(23,xx)];
	X16 bp0e = _4976_42d2[RCJ(16,xx)];
	X16 bp10 = 0;
	X8 bp13 = bp04[1] & 0x7f;
	X16 bp16 = ((bp13 & 0x80) != 0) ? 1 : 0;
	i16 bp18 = bp04[2];
	i16 bp1a = bp04[3];
	SRECT bp22;
	if (QUERY_BLIT_RECT(NULL, &bp22, bp0e, &bp18, &bp1a, -1) == NULL)
		return;
	//^32CB:2583
	U8 *bp08;
	Picture bp3c;
	U8 *bp0c;
	if (bp04[1] == 0xff) {
		bp08 = NULL;
	}
	else {
		//^32CB:259A
		bp3c.b8 = U8(cls1);
		bp3c.b9 = U8(cls2);
		bp3c.b11 = bp13;
		bp08 = QUERY_PICST_IMAGE(&bp3c);
		ALLOC_PICT_MEMENT(&bp3c);
		if (bp16 != 0) {
			//^32CB:25D3
			X16 bp12 = ALLOC_TEMP_CACHE_INDEX();
			X16 bp24;
			X16 si;
			bp0c = ALLOC_NEW_PICT(bp12, si = READ_UI16(bp08,-4), bp24 = READ_UI16(bp08,-2), 4);
			bp08 = QUERY_PICT_BITS(&bp3c);
			X16 di = READ_UI16(bp08,-4) & 1;
			if (di != 0)
				//^32CB:2622
				di = 2 -di;
			//^32CB:2629
			FIRE_BLIT_PICTURE(
				bp08, bp0c, 
				ALLOC_TEMP_ORIGIN_RECT(si -di, bp24), 0, 0, 
				si, si, -1, 1, 4, 4, NULL);
			FREE_PICT_MEMENT(&bp3c);
			_0b36_00c3(bp12, &bp3c);
			ALLOC_PICT_MEMENT(&bp3c);
		}
	}
	//^32CB:2688
    bp0c = QUERY_GDAT_IMAGE_ENTRY_BUFF(U8(cls1), U8(cls2), 0x14);
	if (bp04[1] != 0xff) {
		//^32CB:26AA
		bp08 = QUERY_PICT_BITS(&bp3c);
	}
	//^32CB:26BC
	_44c8_20a4(
		bp0c, 
		_4976_4c16, 
		bp08, 
		&bp22, 
		(bp04[0] +RAND01()) << 4, 
		RAND() & 255,
		_4976_00f6, 
		bp10, 
		_32cb_0649(U8(cls1), U8(cls2), 0x14, bp10)
		);
	if (bp04[1] != 0xff) {
		//^32CB:2720
		FREE_PICT_MEMENT(&bp3c);
	}
	//^32CB:272C
	return;
}

//^32CB:4F3B
void SkWinCore::DRAW_WALL(i16 iViewportCell)	// i16 xx
{
	//^32CB:4F3B
	ENTER(12);
	//^32CB:4F41
	U8 iMapGfx = glbMapGraphicsSet;	// bp02
	i16 iColorkey1 = glbSceneColorKey;	// bp06
	i8 iXDist = glbTabXAxisDistance[RCJ(23,iViewportCell)];	// bp07
	i16 iYDist = glbTabYAxisDistance[RCJ(23,iViewportCell)];	// bp0c
	//^32CB:4F5F
	U8 bp01 = (iYDist > 1) ? GDAT_WALL_ORNATE__DATA_6F : GDAT_WALL_ORNATE__DATA_6E;	// SPX TODO: unknown GDAT values! never seen them in any GDAT
	X16 si = 0;
	X16 di = 0;
	U16 bp0a = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, bp01);
	if (iYDist > 1) { // dist 2,3,4
		//^32CB:4F91
		if (tblCellTilesRoom[4].xsrd.w0 == 0 && (di = (bp0a >> 8)) == 0) {
			//^32CB:4FA5
			di = _4976_463c[RCJ(6,glbMapGraphicsSet)];
		}
		//^32CB:4FB2
		if (tblCellTilesRoom[5].xsrd.w0 == 0) {
			//^32CB:4FBD
			si = bp0a & 0xff;
			if (si == 0) {
				//^32CB:4FC9
				si = _4976_4648[RCJ(6,glbMapGraphicsSet)];
			}
		}
	}
	//^32CB:4FD8
	else if (iYDist > 0) { // dist 1
		//^32CB:4FDE
		if (tblCellTilesRoom[0].xsrd.w0 == 0 && (di = (bp0a >> 8)) == 0) {
			//^32CB:4FF5
			di = _4976_4624[RCJ(6,glbMapGraphicsSet)];
		}
		//^32CB:5002
		if (tblCellTilesRoom[2].xsrd.w0 == 0 && (si = (bp0a & 0xff)) == 0) {
			//^32CB:5019
			si = _4976_4630[RCJ(6,glbMapGraphicsSet)];
		}
	}
	//^32CB:5026
	if (di != 0 || si != 0) {
		//^32CB:502E
		TRIM_BLIT_RECT(di, 0, si, 0);
	}
	//^32CB:503C
	X16 bFlip = (iXDist <= 0) ? 0 : 1;	// (bp04) 0 = left / 1 = right
	//^32CB:504E
	if (iViewportCell >= 0x10) { // wall at D4
		//^32CB:5054
		if (iXDist == -2 || iXDist == 2) {
			//^32CB:5060
			bFlip = 0;	// left
		}
		bFlip ^= glbGeneralFlipGraphics;
		bp01 = 0x32;	// 0x32 : D4 wall front
	}
	//^32CB:5071
	else if (glbGeneralFlipGraphics != 0) {
		//^32CB:5078
		bp01 = tlbDoorSideFramesReorder[RCJ(23,iViewportCell)] -80;
		if (QUERY_GDAT_ENTRY_IF_LOADABLE(GDAT_CATEGORY_GRAPHICSSET, iMapGfx, dtImage, bp01) == 0) {
			if (iXDist == 0) {
				//^32CB:509F
				bFlip = 1;	// right
			}
			//^32CB:50A4
			bp01 = bp01 +0x72;	// 0x72 is pit side D2 ...
		}
	}
	else {
		//^32CB:50AE
		bp01 = iViewportCell +0x22;	// 0x23 is wall side D0
	}

	// SPX: 2016-11-11 : attempt having See Through Wall masks on wall
#if (DM2_EXTENDED_MODE == 1)	// Check for possible thru wall gfx
	{
	
		if (glbGlobalSpellEffects.SeeThruWalls > 0 && iViewportCell == 3)	// front D1 wall
		{
			i16 iColorkey2 = -1;
			ExtendedPicture xExtPicWall;
			i16 iPicture = 0;
			bp01 = 0x025;	// D1 wall

			iColorkey1 = 10;	// would be dark green / pass through (see what's behind wall)
			iColorkey2 = 9;		// would be cyan / transparent (see wall)
			
			iPicture = QUERY_MULTILAYERS_PIC(&xExtPicWall, GDAT_CATEGORY_GRAPHICSSET, iMapGfx, bp01, 0x40, 0x40, 0, bFlip, iColorkey1, -1);
			//iPicture = QUERY_MULTILAYERS_PIC(&xExtPicWall, GDAT_CATEGORY_GRAPHICSSET, 0xFE, 0xF2, 0x40, 0x40, 0, bFlip, iColorkey1, -1); // test wall
			DRAW_PICST(&xExtPicWall);
			FREE_PICT_MEMENT(&xExtPicWall);

			X16 iScale = 0x40;
			X16 bp20 = 0x40;
			X16 bp22 = 0x40;;
			//--- Put the metrics of that image to the TEMP image
			if (iScale == 0x40)
			{
				i16 bp1c;
				i16 bp1e;
				
				QUERY_GDAT_IMAGE_METRICS(GDAT_CATEGORY_GRAPHICSSET, iMapGfx, bp01, &bp1c, &bp1e);	// 0xe
				bp20 = _32cb_48d5(glbTempPicture.width, bp1c);
				bp22 = _32cb_48d5(glbTempPicture.height, bp1e);
				
			}
			else {
				bp22 = bp20 = iScale;
			}

			//------ part to get and draw the see thru walls
			if (1)
			{
				U16 iWallSetIndex = iMapGfx;
			
				U16 iWallSeeThruMask = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, iMapGfx, dtImage, GDAT_GFXSET_SEE_THRU);
				if (iWallSeeThruMask == (U16)-1) // not found, get the default one
					iWallSetIndex = GDAT_ITEM_DEFAULT_INDEX;	// 0xFE
				
				i16 iRectNo = QUERY_CREATURE_BLIT_RECTI(3, 11, 0);	// That gets currently the best result for positionning 'see through wall' mask

				QUERY_TEMP_PICST(bFlip, bp20, bp22, 0, 0, 
					(glbIsPlayerMoving != 0) ? -iYDist : 0, 
					iRectNo,
					-1, iColorkey2, iColorkey1,
					GDAT_CATEGORY_GRAPHICSSET, iWallSetIndex, GDAT_GFXSET_SEE_THRU
					);

				glbTempPicture.pb44 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(iPicture));
				DRAW_TEMP_PICST();
			}
			//------

			//--- Get correct pass through color
			xExtPicWall.colorKeyPassThrough = xExtPicWall.b58[iColorkey1];
			xExtPicWall.w56 = 0;
			_0b36_00c3(iPicture, &xExtPicWall);
			COPY_MEMORY(&xExtPicWall, &glbTempPicture, sizeof(ExtendedPicture));
			glbTempPicture.pb44 = _4976_4c16;
			glbTempPicture.rectNo = 3 + 0x2BE;
			DRAW_TEMP_PICST();
			if (iPicture >= 0)
				FREE_TEMP_CACHE_INDEX(iPicture);
		}
		else
		{
			QUERY_TEMP_PICST(bFlip, 0x40, 0x40, 0, 0, (glbIsPlayerMoving != 0) ? -iYDist : 0, iViewportCell +0x2be, 0xffff, iColorkey1, -1, GDAT_CATEGORY_GRAPHICSSET, iMapGfx, bp01);
			DRAW_TEMP_PICST(); // draw wall
		}

	}
#else
	//^32CB:50B6
	QUERY_TEMP_PICST(bFlip, 0x40, 0x40, 0, 0, (glbIsPlayerMoving != 0) ? -iYDist : 0, iViewportCell +0x2be, 0xffff, iColorkey1, -1, GDAT_CATEGORY_GRAPHICSSET, iMapGfx, bp01);
	DRAW_TEMP_PICST(); // draw wall
#endif
	_098d_0c45();
	//^32CB:50FA
	return;
}
//^32CB:50FE
// SPX: _32cb_50fe renamed DRAW_WALL_TILE
void SkWinCore::DRAW_WALL_TILE(i16 iViewportCell)	// i16 xx
{
	//^32CB:50FE
	ENTER(0);
	//^32CB:5102
	i16 iLocalViewportCell = iViewportCell;	//i16 si = xx;
	DRAW_WALL(iLocalViewportCell);
	switch (_4976_4654[RCJ(23,iLocalViewportCell)]) {
		case 1: //^_5121	// front vision
			//^32CB:5121
			DRAW_WALL_ORNATE(iLocalViewportCell, 0, 1);
			break;
		case 3: //^_5127	// side
			//^32CB:5127
			DRAW_WALL_ORNATE(iLocalViewportCell, 0, 1);
			goto _5133;
		case 2: //^_5133	// side
			//^32CB:5133
_5133:
            DRAW_WALL_ORNATE(iLocalViewportCell, glbTabXAxisDistance[RCJ(23,iLocalViewportCell)], 1);
			break;
	}
	//^32CB:5143
	return;
}

//^32CB:5146
// SPX: _32cb_5146 renamed DRAW_DUNGEON_TILES
void SkWinCore::DRAW_DUNGEON_TILES()
{
	//^32CB:5146
	ENTER(10);
	//^32CB:514C
	U32 bp04 = 0x01ffffff;
	i16 bp08 = 0;
	for (; bp08 < 20; bp08++) {
		static const char * pszTblDrawOrder = {"D4L2,D4R2,D4L1,D4R1,D4  ,D3L2,D3R2,D3L1,D3R1,D3  ,D2L2,D2R2,D2L1,D2R1,D2  ,D1L1,D1R1,D1  ,D0L1,D0R1"};
		// D4L2| 0|19
		// D4R2| 1|20
		// D4L1| 2|17
		// D4R1| 3|18
		// D4  | 4|16
		// D3L2| 5|14
		// D3R2| 6|15
		// D3L1| 7|12
		// D3R1| 8|13
		// D3  | 9|11
		// D2L2|10| 9
		// D2R2|11|10
		// D2L1|12| 7
		// D2R1|13| 8
		// D2  |14| 6
		// D1L1|15| 4
		// D1R1|16| 5
		// D1  |17| 3
		// D0L1|18| 1
		// D0R1|19| 2
		SkD((DLV_DBG_CELL, "DBG: Summary#%02d (%.4s)\n", (Bitu)bp08, &pszTblDrawOrder[5*bp08]));

		//^32CB:515E
		IBMIO_USER_INPUT_CHECK();
		i16 si;
		X16 bp06 = tblCellTilesRoom[si = _4976_466b[RCJ(20,bp08)]].xsrd.w0;
		ObjectID di = tblCellTilesRoom[si].xsrd.id4();
		if (si > 15) { // at D4
			//^32CB:5196
			X16 bp0a = bp06;
			switch (bp0a) {
				case 0x00://^51B5
					//^32CB:51B5
					if (di != OBJECT_END_MARKER) {
						//^32CB:51BA
						SUMMARY_DRAW_CREATURE(di, si, 0x01ffffff);
					}
					//^32CB:51C8
					DRAW_WALL_TILE(si);
					continue;
				case 0x01://^51D1
				case 0x02://^51D1
				case 0x05://^51D1
					//^32CB:51D1
					DRAW_EXTERNAL_TILE(si);
					goto _51d7;
				case 0x11://^51D7
					//^32CB:51D7
_51d7:
					if (di == OBJECT_END_MARKER)
						continue;
					//^32CB:51DF
					SUMMARY_DRAW_CREATURE(di, si, 0x01ffffff);
					continue;
			}
			continue;
		}
		//^32CB:51F0
		if (si == 3) // at D1F
			//^32CB:51F5
			_4976_4dda = bp06;
		switch (bp06) {
			case 0://^520D // wall
				//^32CB:520D
				if (di != OBJECT_END_MARKER) {
					//^32CB:5212
					SUMMARY_DRAW_CREATURE(di, si, 0x01ffffff);
				}
				//^32CB:5220
				//^32CB:5222
				DRAW_WALL_TILE(si);
				continue;
			case 17://^5224
				//^32CB:5224
				DRAW_DOOR_TILE(si);
				continue;
			case 18://^522B
				//^32CB:522B
				DRAW_STAIRS_SIDE(si);
				goto _52d1;
			case 19://^5233
				//^32CB:5233
				DRAW_STAIRS_FRONT(si);
				goto _52d1;
			case 2://^523B // pit
				//^32CB:523B
				DRAW_PIT_TILE(si);
				goto _52b1;
			case 16://^5243	// seeing door frame slot in front from door tile
				//^32CB:5243
				if (si == 3) {
					//^32CB:5248
					// Check if this door type has door frames of not. if so, then draw the door frame
					if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, glbMapDoorType[GET_ADDRESS_OF_RECORD0(tblCellTilesRoom[3].xsrd.w6[2])->DoorType()], dtWordValue, GDAT_DOOR_NO_FRAMES) == 0) {
						//^32CB:5279
						QUERY_TEMP_PICST(
							glbGeneralFlipGraphics, 0x2b, 0x2b, 0, 0, 2, QUERY_CREATURE_BLIT_RECTI(3, 2, 0), 0xffff, 
							glbSceneColorKey, -1, GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, 6
							);
						DRAW_TEMP_PICST();
					}
				}
				goto _52b1;
			case 1://^52B1 // floor
			case 5://^52B1 // teleporter
				//^32CB:52B1
_52b1:
				bp04 = (DRAW_EXTERNAL_TILE(si) != 0) ? 0x01fffc00 : 0x01ffffff;
				DRAW_PIT_ROOF(si);
				//^32CB:52D1
_52d1:
				DRAW_STATIC_OBJECT(si, bp04, 1);
				if (bp06 == 5)	// teleporter
				{
					//^32CB:52E8
					DRAW_TELEPORTER_TILE(si, GDAT_CATEGORY_TELEPORTERS, 0); // DRAW_TELEPORTER_TILE(si, 0x18, 0)
				}
				break;
			case 3://^52F4 // stair case
			case 4://^52F4 // door
			case 6://^52F4 // false wall
			case 7://^52F4 // map exit
			case 8://^52F4
			case 9://^52F4
			case 10://^52F4
			case 11://^52F4
			case 12://^52F4
			case 13://^52F4
			case 14://^52F4
			case 15://^52F4
				break;
		}
		//^32CB:52F4
	}
	//^32CB:5300
	return;
}

//^3E74:5A0C
void SkWinCore::COPY_SKIMAGE_HEADER(const U8 *xx, U8 *yy)
{
	//^3E74:5A0C
	ENTER(0);
	//^3E74:5A0F
	COPY_MEMORY(
		&xx[-6],
		&yy[-6],
		6
		);
	//^3E74:5A41
	return;
}

//^0B36:15E5
void SkWinCore::APPLY_MIRROR_FLIP_TO(const U8 *blitSrc, U8 *blitDst, X16 mirrorFlip)
{
	//^0B36:15E5
	ENTER(2);
	//^0B36:15EB
	X16 si = READ_UI16(blitSrc,-4);
	X16 bp02 = READ_UI16(blitSrc,-2);
	X16 di = READ_UI16(blitSrc,-6);
	COPY_SKIMAGE_HEADER(blitSrc, blitDst);
	FIRE_BLIT_PICTURE(blitSrc, blitDst, ALLOC_TEMP_ORIGIN_RECT(si, bp02), 0, 0, si, si, -1, mirrorFlip, di, di, NULL);
	//^0B36:1643
	return;
}

//^32CB:0753
void SkWinCore::DRAW_MIRRORED_PIC(const U8 *blitSrc, U8 *blitDst)
{
	//^32CB:0753
	ENTER(0);
	//^32CB:0756
	APPLY_MIRROR_FLIP_TO(blitSrc, blitDst, 1);
	//^32CB:076C
	return;
}

//^32CB:0B11
// SPX: _32cb_0b11 renamed DRAW_RAIN
void SkWinCore::DRAW_RAIN()
{
	//^32CB:0B11
	ENTER(20);
	//^32CB:0B16
	if (glbRainStrength == 0 || tlbRainScene[RCJ(5,glbRainSceneType)][2] == 0)
		return;
	//^32CB:0B31
	i16 bp0a = _4976_00f6;
	i16 bp0c = _4976_00f8;
	SRECT bp14;
	if (QUERY_BLIT_RECT(NULL, &bp14, 0x2be, &bp0a, &bp0c, -1) == NULL)
		return;
	//^32CB:0B64
	U8 bp07;
	U16 bp06;
	QUERY_RAINFALL_PARAM(&bp07, &bp06);
	U8 *bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x17, glbMapGraphicsSet, bp07);
	ALLOC_IMAGE_MEMENT(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, bp07);
	X16 si;
	if (bp06 == 1) {
		//^32CB:0BA5
		si = ALLOC_TEMP_CACHE_INDEX();
		ALLOC_NEW_PICT(si, READ_UI16(bp04,-4), READ_UI16(bp04,-2), 4);
		bp04 = QUERY_GDAT_IMAGE_ENTRY_BUFF(0x17, glbMapGraphicsSet, bp07);
		DRAW_MIRRORED_PIC(bp04, reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(si)));
		bp04 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(si));
	}
	//^32CB:0BFD
	_44c8_20a4(bp04, _4976_4c16, NULL, &bp14, READ_UI16(bp04,-4) * READ_UI16(bp04,-2) -40 -(RAND() & 0x1f), RAND() & 255, _4976_00f6, 0,
		_32cb_0649(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, bp07, 0)
		);
	if (bp06 == 1) {
		//^32CB:0C61
		FREE_TEMP_CACHE_INDEX(si);
	}
	//^32CB:0C68
	FREE_IMAGE_MEMENT(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, bp07);
	//^32CB:0C7A
	return;
}

//^32CB:5340
// SPX: _32cb_5340 renamed DRAW_PLAYER_TILE (which display the current tile the player is on)
void SkWinCore::DRAW_PLAYER_TILE()
{
	//^32CB:5340
	ENTER(14);
	//^32CB:5346
	X16 bp06;
	X16 bp0e;
	bp06 = bp0e = tblCellTilesRoom->xsrd.w0;
	X16 di;
	X16 si;
	switch (bp0e) {
		case 0x10://^536D
			{
				//^32CB:536D
				Door *door = GET_ADDRESS_OF_RECORD0(tblCellTilesRoom->xsrd.w6[1]);	//*bp04
				if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, glbMapDoorType[door->DoorType()], dtWordValue, GDAT_DOOR_NO_FRAMES) != 0)
					break;
				//^32CB:53A6
				DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_DOOR_FRAME_FRONT_D1, QUERY_CREATURE_BLIT_RECTI(0, 2, 0), glbSceneColorKey, glbGeneralFlipGraphics);
				break;
			}
		case 0x13://^53CE
			//^32CB:53CE
			si = tblCellTilesRoom->xsrd.w6[0];
			DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet
//					, (si != 0) ? 0x39 : 0x4D
				, (si != 0) ? GDAT_GFXSET_STAIRS_RAMP_UP_S0_L : GDAT_GFXSET_STAIRS_RAMP_DOWN_S0_L
				, (si != 0) ? 0x32b : 0x338, glbSceneColorKey, 0);
			DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet
//					, (si != 0) ? 0x3a : 0x4e
				, (si != 0) ? GDAT_GFXSET_STAIRS_RAMP_UP_S0_R : GDAT_GFXSET_STAIRS_RAMP_DOWN_S0_R
				, (si != 0) ? 0x32c : 0x339, glbSceneColorKey, 0);
			break;
		case 0x02://^542E
			//^32CB:542E
			DRAW_PIT_TILE(0);
			break;
		case 0x11://^5437
			//^32CB:5437
			DRAW_DOOR_TILE(0);
			di = 0;
			goto _5495;
	}
	//^32CB:5442
	DRAW_PIT_ROOF(0);
	TELE_inf bp0c;
	if ((di = GET_TELEPORTER_DETAIL(&bp0c, tblCellTilesRoom->posx, tblCellTilesRoom->posy)) == 0) {
		//^32CB:546B
		DRAW_EXTERNAL_TILE(0);
	}
	//^32CB:5472
	DRAW_STATIC_OBJECT(0, 0x01ffffff, 0);
	if (bp06 == 5)
	{
		//^32CB:5488
		DRAW_TELEPORTER_TILE(0, 0x18, 0);
	}
	//^32CB:5495
_5495:
	DRAW_RAIN();
	if (di != 0) {
		//^32CB:549D
		DRAW_EXTERNAL_TILE(0);
	}
	//^32CB:54A4
	_32cb_2d8c(tblCellTilesRoom->xsrd.w4, 0, 0x01ffffff);
	//^32CB:54BA
	return;
}

//^32CB:5D0D
// SPX: _32cb_5d0d renamed DISPLAY_VIEWPORT
void SkWinCore::DISPLAY_VIEWPORT(Bit16u dir, i16 xx, i16 yy)
{
	//^32CB:5D0D
	ENTER(6);
	//^32CB:5D13
	IBMIO_USER_INPUT_CHECK();
	// SPX: glbLightLevel is between 0 (light) and 5 (dark). Palette is thereafter controlled by value between 0 (light) and 64 (dark)
	// Having *10 makes 0 to 50 -> loss of darkest colors. Having *13 makes 0 to 65 -> full range (full darkness)
	_4976_5a88 = glbLightLevel * 10;	
	//_4976_5a88 = glbLightLevel * 12;	// SPX: * 13 seems more appropriate to get darkest values
	_4976_5aa0 = dir;
	_4976_5a9c = xx;
	_4976_5a9e = yy;
	tblCellTilesRoom = reinterpret_cast<CellTileDetail *>(ALLOC_MEMORY_RAM(sizeof(CellTileDetail) * 23, afDefault, 1024));
	_4976_5a84 = reinterpret_cast<U8 (*)[17]>(ALLOC_MEMORY_RAM(358, afZeroMem, 1024));
	_4976_5aa4 = reinterpret_cast<U8 (*)[17]>(ALLOC_MEMORY_RAM(358, afDefault, 1024));
	FILL_STR(*_4976_5aa4, 358, 255, 1);
	_4976_5a7c = reinterpret_cast<U32 (*)[23]>(ALLOC_MEMORY_RAM(4*23, afZeroMem, 1024));
	_4976_5be2 = reinterpret_cast<U32 (*)[23]>(ALLOC_MEMORY_RAM(4*23, afZeroMem, 1024));
	_4976_4bc8 = 1;
	INIT_BACKBUFF();
	_4976_4dde = 9;
	i16 si;

	SkD((DLV_MOVE, "DISPLAY_VIEWPORT: dir:%d x:%d y:%d darkness:%d\n"
		, dir
		, xx
		, yy
		, _4976_5a88));
	

	//^32CB:5DDB
	for (si = 0; si < 9; si++) {
		//^32CB:5DDF
		_4976_4d1a[si].w8 = OBJECT_NULL;
		//^32CB:5DEE
	}
	//^32CB:5DF4
	IBMIO_USER_INPUT_CHECK();
	_4976_5aa2 = (_4976_4ddc != 0 || glbTableToMove != OBJECT_NULL) ? 1 : 0;
	CHANCE_TABLE_OPERATION();
	//^32CB:5E15
	for (si = 0x16; si >= 0; si--) {
		//^32CB:5E1A
		_32cb_4185_TILE_ROOM(xx, yy, si, _4976_5aa0);
		//^32CB:5E2C
	}

	//   |--|--|--|--|--|--|--|
	// 4 |21|19|17|16|18|20|22|
	//   |--|--|--|--|--|--|--|
	// 3 |  |14|12|11|13|15|  |
	//   |--|--|--|--|--|--|--|
	// 2 |  | 9| 7| 6| 8|10|  |
	//   |--|--|--|--|--|--|--|
	// 1 |  |  | 4| 3| 5|  |  |
	//   |--|--|--|--|--|--|--|
	// 0 |  |  | 1| 0| 2|  |  |
	//   |--|--|--|--|--|--|--|
	SkD((DLV_DBG_CELL, "DBG: U r at (%2u,%2u,%2u) %u\n"
		"|-------|-------|-------|-------|-------|-------|-------|\n"
		"|       |%02X %04X|%02X %04X|%02X %04X|%02X %04X|%02X %04X|       |\n"
		"|-------|-------|-------|-------|-------|-------|-------|\n"
		"|       |%02X %04X|%02X %04X|%02X %04X|%02X %04X|%02X %04X|       |\n"
		"|-------|-------|-------|-------|-------|-------|-------|\n"
		"|       |%02X %04X|%02X %04X|%02X %04X|%02X %04X|%02X %04X|       |\n"
		"|-------|-------|-------|-------|-------|-------|-------|\n"
		"|       |       |%02X %04X|%02X %04X|%02X %04X|       |       |\n"
		"|-------|-------|-------|-------|-------|-------|-------|\n"
		"|       |       |%02X %04X|%02X %04X|%02X %04X|       |       |\n"
		"|-------|-------|-------|-------|-------|-------|-------|\n"
		, (Bitu)glbPlayerMap, (Bitu)glbPlayerPosX, (Bitu)glbPlayerPosY, (Bitu)glbPlayerDir
		, (Bitu)tblCellTilesRoom[19].xsrd.w0, (Bitu)tblCellTilesRoom[19].xsrd.w4
		, (Bitu)tblCellTilesRoom[17].xsrd.w0, (Bitu)tblCellTilesRoom[17].xsrd.w4
		, (Bitu)tblCellTilesRoom[16].xsrd.w0, (Bitu)tblCellTilesRoom[16].xsrd.w4
		, (Bitu)tblCellTilesRoom[18].xsrd.w0, (Bitu)tblCellTilesRoom[18].xsrd.w4
		, (Bitu)tblCellTilesRoom[20].xsrd.w0, (Bitu)tblCellTilesRoom[20].xsrd.w4

		, (Bitu)tblCellTilesRoom[14].xsrd.w0, (Bitu)tblCellTilesRoom[14].xsrd.w4
		, (Bitu)tblCellTilesRoom[12].xsrd.w0, (Bitu)tblCellTilesRoom[12].xsrd.w4
		, (Bitu)tblCellTilesRoom[11].xsrd.w0, (Bitu)tblCellTilesRoom[11].xsrd.w4
		, (Bitu)tblCellTilesRoom[13].xsrd.w0, (Bitu)tblCellTilesRoom[13].xsrd.w4
		, (Bitu)tblCellTilesRoom[15].xsrd.w0, (Bitu)tblCellTilesRoom[15].xsrd.w4

		, (Bitu)tblCellTilesRoom[ 9].xsrd.w0, (Bitu)tblCellTilesRoom[ 9].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 7].xsrd.w0, (Bitu)tblCellTilesRoom[ 7].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 6].xsrd.w0, (Bitu)tblCellTilesRoom[ 6].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 8].xsrd.w0, (Bitu)tblCellTilesRoom[ 8].xsrd.w4
		, (Bitu)tblCellTilesRoom[10].xsrd.w0, (Bitu)tblCellTilesRoom[10].xsrd.w4

		, (Bitu)tblCellTilesRoom[ 4].xsrd.w0, (Bitu)tblCellTilesRoom[ 4].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 3].xsrd.w0, (Bitu)tblCellTilesRoom[ 3].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 5].xsrd.w0, (Bitu)tblCellTilesRoom[ 5].xsrd.w4

		, (Bitu)tblCellTilesRoom[ 1].xsrd.w0, (Bitu)tblCellTilesRoom[ 1].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 0].xsrd.w0, (Bitu)tblCellTilesRoom[ 0].xsrd.w4
		, (Bitu)tblCellTilesRoom[ 2].xsrd.w0, (Bitu)tblCellTilesRoom[ 2].xsrd.w4
		));

#if DLV_DBG_CEL2
	{
		char mass[21*54 +1];
		// 54 x 21
		strcpy(mass,
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"----+----+-----+----+----+ +----+----+-----+----+----\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"----+----+-----+----+----+ +----+----+-----+----+----\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"----+----+-----+----+----+ +----+----+-----+----+----\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"----+----+-----+----+----+ +----+----+-----+----+----\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\n"
			"XXXX|XXXX|XXXXX|XXXX|XXXX| |XXXX|XXXX|XXXXX|XXXX|XXXX\0"
			);
		static const U8 tblX[] = {0,1,2,3, 5,6,7,8, 10,11,12,13,14, 16,17,18,19, 21,22,23,24};
		static const U8 tblY[] = {0, 2,3,4,5, 7,8,9,10, 12,13,14,15, 17,18,19,20};
		for (int yc=0; yc<17; yc++) {
			int xc;
			for (xc=0; xc<21; xc++) {
				U8 v = U8(_4976_5aa4[xc][16 -yc]);
				char t = '.';
				if (0 <= v && v <= 9) t = v + '0';
				else if (10 <= v && v <= 15) t = v + 'A' -10;

				mass[54*tblY[yc] +tblX[xc]] = t;
			}
			for (xc=0; xc<21; xc++) {
				U8 v = U8(_4976_5a84[xc][16 -yc] & 15);
				char t = '.';
				if (0 <= v && v <= 9) t = v + '0';
				else if (10 <= v && v <= 15) t = v + 'A' -10;

				mass[54*tblY[yc] +28 +tblX[xc]] = t;
			}
		}
		SkD((DLV_DBG_CEL2, "DBG: L=enemy map, R=movable map\n%s\n", mass));
	}
#endif

	//^32CB:5E31
	X16 di = 0;
	X16 bp02 = 0;
	X8 bp03 = 0xff;
	if (tblCellTilesRoom[7].xsrd.w0 == 0 && tblCellTilesRoom[6].xsrd.w0 == 0 && tblCellTilesRoom[8].xsrd.w0 == 0) // wall at D2
		//^32CB:5E57
		bp03 = 0x71;
	if (tblCellTilesRoom[4].xsrd.w0 == 0 && tblCellTilesRoom[3].xsrd.w0 == 0 && tblCellTilesRoom[5].xsrd.w0 == 0) // wall at D1
		//^32CB:5E74
		bp03 = 0x70;
	//^32CB:5E78
	if (bp03 != 0xff) { // trim ceil(bp02) and floor(di) to omit hidden area by drawing wall
		U16 bp06 = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, dtWordValue, bp03);
		di = bp06 >> 8;
		bp02 = bp06 & 0xff;
		if (di == 0) {
			if (bp03 == 0x71) {
				di = _4976_4718[RCJ(6,glbMapGraphicsSet)]; // D2 to D0
			}
			else {
				//^32CB:5EBC
				di = _4976_4700[RCJ(6,glbMapGraphicsSet)]; // D1 to D0
			}
		}
		//^32CB:5EC9
		if (bp02 == 0) {
			if (bp03 == 0x71) {
				//^32CB:5ED5
				bp02 = _4976_470c[RCJ(6,glbMapGraphicsSet)]; // envisible D2 to D0
			}
			else {
				//^32CB:5EE4
				bp02 = _4976_46f4[RCJ(6,glbMapGraphicsSet)]; // envisible D1 to D0
			}
		}
	}
	//^32CB:5EF4
	TRIM_BLIT_RECT(0, 0, 0, bp02);
	if (SET_GRAPHICS_FLIP_FROM_POSITION(0x20, dir, xx, yy) != 0) {
		//^32CB:5F1B
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_CEIL, 0x2bc, -1, 1); // draw ceil
	}
	else {
		//^32CB:5F1F
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_CEIL, 0x2bc, -1, 0); // draw ceil
	}
	//^32CB:5F35
	_098d_0c45();
	TRIM_BLIT_RECT(0, di, 0, 0);
	if (SET_GRAPHICS_FLIP_FROM_POSITION(1, dir, xx, yy) != 0) {
		//^32CB:5F5F
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_FLOOR, 0x2bd, -1, 1); // draw floor
	}
	else {
		//^32CB:5F63
		DRAW_DUNGEON_GRAPHIC(GDAT_CATEGORY_GRAPHICSSET, glbMapGraphicsSet, GDAT_GFXSET_FLOOR, 0x2bd, -1, 0); // draw floor
	}
	//^32CB:5F79
	_098d_0c45();
	glbGeneralFlipGraphics = SET_GRAPHICS_FLIP_FROM_POSITION(0, dir, xx, yy);
	IBMIO_USER_INPUT_CHECK();
	ENVIRONMENT_DISPLAY_ELEMENTS(dir, xx, yy);
	_32cb_5c67();
	_32cb_5a8f();
	DRAW_DUNGEON_TILES(); // render walls, flying items
	IBMIO_USER_INPUT_CHECK();
	DRAW_PLAYER_TILE(); // render current player tile
	IBMIO_USER_INPUT_CHECK();
#if UseAltic
	DEALLOC_UPPER_MEMORY(92);
	DEALLOC_UPPER_MEMORY(92);
	DEALLOC_UPPER_MEMORY(358);
	DEALLOC_UPPER_MEMORY(358);
	DEALLOC_UPPER_MEMORY(414);
#else
	DEALLOC_UPPER_MEMORY(414+358+358+92+92);
#endif
	//^32CB:5FCE
	return;
}
//^2C1D:1C7C
void SkWinCore::ADJUST_STAMINA(Bit16u player, i16 drain)
{
	// CSBwinSimilarity: TAG01742a,AdjustStamina

	//^2C1D:1C7C
	ENTER(4);
	//^2C1D:1C82
	X16 di = player;
	if (di == 0xffff)
		return;
	//^2C1D:1C8A
	Champion *champion = &glbChampionSquad[di];	//*bp04
	champion->curStamina(champion->curStamina() -drain);
	i16 si = champion->curStamina();
	if (si <= 0) {
		//^2C1D:1CAE
		champion->curStamina(0);
		WOUND_PLAYER(di, (-si) >> 1, 0, 0);
	}
	//^2C1D:1CC7
	else if (champion->maxStamina() < si) {
		champion->curStamina(champion->maxStamina());
	}
	//^2C1D:1CD8
	if (ABS16(drain) >= 10) {
		//^2C1D:1CE6
		champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x800
	}
	//^2C1D:1CEF
	return;
}
//^2C1D:203D
Bit16u SkWinCore::GET_PLAYER_WEIGHT(Bit16u player)
{
	// Returns player's weight. Also include weight of leader's hand item.

	//^2C1D:203D
	ENTER(0);
	//^2C1D:2042
	X16 di = player;
	if (glbChampionSquad[di].curHP() == 0)
		return 0;
	X16 si = glbChampionSquad[di].curWeight();
	if (di == glbChampionLeader) {
		//^2C1D:206C
		si += glbLeaderItemWeight;
	}
	return si;
}
//^2C1D:0FFC
Bit16u SkWinCore::MAX_LOAD(Champion *ref)
{
	// CSBwinSimilarity: TAG016508,MaxLoad

	//^2C1D:0FFC
	ENTER(0);
	//^2C1D:1001
	X16 si = (GET_PLAYER_ABILITY(ref, abStr, 0) << 3) +100;
	si = STAMINA_ADJUSTED_ATTR(ref, si);
	X16 di = ref->bodyFlag;
	if (di != 0) {
		si -= si << (((di & 0x10) != 0) ? 2 : 3);
	}
	//^2C1D:104B
	si += 9;
	si -= si % 10;
	return si;
}
//^482B:05BF
void SkWinCore::_482b_05bf(Bit16u xx)
{
	//^482B:05BF
	ENTER(0);
	//^482B:05C2
	if (xx != 0) {
		if (_4976_49d2 > 0) {
			PLAY_SOUND(_4976_49d2, _4976_5efe);
		}
		_4976_49d2 = 0;
		return;
	}
	if (_4976_49d0 > 0) {
		PLAY_SOUND(_4976_49d0, _4976_5f02);
	}
	//^482B:0606
	_4976_49d0 = 0;
	//^482B:060C
	return;
}
//^3E74:5673
X32 SkWinCore::_3e74_5673(X32 cacheHash, U16 *piYaCacheIndex, X16 ifTryInsert)
{
	//^3E74:5673
	ENTER(2);
	//^3E74:5677
	if (glbGameTick != _4976_5d2a) {
		//^3E74:568A
		_3e74_44ad();
	}
	//^3E74:568E
	U16 bp02;
	if (FIND_ICI_FROM_CACHE_HASH(cacheHash, &bp02) == 0) {
		//^3E74:56A4
		*piYaCacheIndex = (ifTryInsert != 0) ? INSERT_CACHE_HASH_AT(cacheHash, bp02) : 0xffff;
		return 0;
	}
	//^3E74:56CB
	*piYaCacheIndex = _4976_5c7e[bp02];
	return *reinterpret_cast<i32 *>(_3e74_48c9(QUERY_MEMENTI_FROM(*piYaCacheIndex | 0x8000))) -22;
}

//^1C9A:0247
void SkWinCore::_1c9a_0247(ObjectID rl)
{
	//^1C9A:0247
	ENTER(2);
	//^1C9A:024C
	i16 si = rl.DBIndex();
	U16 bp02;
	if (_3e74_5673(0x20000000 | si | glbCurrentThinkingCreatureID.DBIndex(), &bp02, 0) != 0) {
		//^1C9A:0281
		FREE_TEMP_CACHE_INDEX(bp02);
	}
	//^1C9A:028A
	if (_3e74_5673(0x28000000 | si | glbCurrentThinkingCreatureID.DBIndex(), &bp02, 0) != 0) {
		//^1C9A:02B7
		FREE_TEMP_CACHE_INDEX(bp02);
	}
	//^1C9A:02C0
	return;
}

//^0CEE:159B
void SkWinCore::QUERY_MESSAGE_TEXT(U8 *str, ObjectID rl, Bit16u ww)
{
	//^0CEE:159B
	ENTER(154);
	//^0CEE:15A1
	U16 si = 0;
	//^0CEE:15A3
	U8 bp009a[128];
	U8 *bp04 = bp009a;
	//^0CEE:15AD
	U8 bp19 = 0xff;
	//^0CEE:15B1
	Text *bp10;
	U16 bp18;
	if (rl.DBType() == dbScroll) {
		//^0CEE:15BF
		Scroll *_bp10 = GET_ADDRESS_OF_RECORD7(rl);
		//^0CEE:15CD
		U16 bp14 = _bp10->w2_a_f();
		//^0CEE:15DD
		if (bp14 > 1) {	// original: if (bp14 != 0) // fixed to > 1 as it is done in DMDC2
			//^0CEE:15E1
			bp19 = U8(bp14);	// get text number reference which is within GDAT
			//^0CEE:15E4
			goto _1678;
		}
		//^0CEE:15E7
		// SPX: else, get text reference from dungeon.dat
		bp10 = &reinterpret_cast<Text *>(static_cast<U8 *>(glbDBObjectData[dbText]))[_bp10->ReferredText() & 0x03ff];
	}
	else {
		ATLASSERT(rl.DBType() == dbText);

		//^0CEE:1609
		bp10 = GET_ADDRESS_OF_RECORD2(rl);
	}
	//^0CEE:1617
	//^0CEE:161A
	bp18 = bp10->TextMode();
	//^0CEE:1626
	if (bp18 == 0 || (bp18 == 1 && bp10->SimpleTextExtUsage() == 14)) {
		//^0CEE:164B
		if (bp10->TextVisibility() != 0 || (ww & 0x8000) != 0) {
			//^0CEE:1663
			if (bp18 == 1) {
				//^0CEE:1669
				bp19 = bp10->TextIndex() & 0xff;
			}
			//^0CEE:167B
_1678:
			ww = ww & 0x7fff;
			//^0CEE:1684
			U8 bp15;
			if (ww == 1) {
				//^0CEE:168A
				*(bp04++) = vbLf;
				//^0CEE:1694
				bp15 = ' ';
			}
			//^0CEE:1698
			bp15 = vbLf;
			//^0CEE:169C
			if (bp19 != 0xff) {
				//^0CEE:16A2
				// SPX: text message stored in GDAT and not DUNGEON.DAT
				bp04 += SK_STRLEN(QUERY_GDAT_TEXT(GDAT_CATEGORY_MESSAGES, 0x00, bp19, bp04));
			}
			else {
				//^0CEE:16C7
				U16 bp14 = 0;
				//^0CEE:16CC
				U16 di = 0;
				//^0CEE:16CE
				U16 *bp0c = &dunTextData[bp10->TextIndex()];

				while (true) {
					//^0CEE:16ED
					U16 bp12;
					if (bp14 == 0) {
						//^0CEE:16F3
						si = *(bp0c++);
						//^0CEE:16FD
						bp12 = (si >> 10) & 0x1f;
					}
					//^0CEE:1704
					else if (bp14 == 1) {
						//^0CEE:170A
						bp12 = (si >> 5) & 0x1f;
					}
					else {
						//^0CEE:1711
						bp12 = si & 0x1f;
					}
					//^0CEE:1713
					//^0CEE:1719
					bp14 = ++bp14 % 3;
					//^0CEE:1729
					if (di != 0) {
						//^0CEE:172D
						*bp04 = 0;
						//^0CEE:1734
						const U8 *bp08;
						if (di == 30) {
							//^0CEE:1739
							bp08 = reinterpret_cast<const Bit8u *>(_4976_0262[bp12]);
						}
						else {
							//^0CEE:1744
							bp08 = reinterpret_cast<const Bit8u *>(_4976_0362[bp12]);
						}
						//^0CEE:174C
						//^0CEE:1752
						SK_STRCAT(bp04, bp08);
						//^0CEE:1766
						bp04 += SK_STRLEN(bp08);
						//^0CEE:1776
						di = 0;
						//^0CEE:1778
						continue;
					}
					//^0CEE:177B
					if (bp12 < 0x1c) {
						//^0CEE:1781
						if (bp12 == 0x1a) {
							//^0CEE:1787
							bp12 = 0x20;
							//^0CEE:179F
							//^0CEE:178C
							*(bp04++) = U8(bp12);
							//^0CEE:17B9
							continue;
						}
						//^0CEE:178E
						else if (bp12 == 0x1b) {
							//^0CEE:1794
							bp12 = 0x2e;
							//^0CEE:1799
							//^0CEE:179F
							*(bp04++) = U8(bp12);
							//^0CEE:17B9
							continue;
						}
						else {
							//^0CEE:179B
							bp12 += 0x41;
							//^0CEE:179F
							*(bp04++) = U8(bp12);
							//^0CEE:17B9
							continue;
						}
					}
					//^0CEE:17A7
					else if (bp12 == 0x1c) {
						//^0CEE:17AD
						*(bp04++) = bp15;
						//^0CEE:17B9
						continue;
					}
					//^0CEE:17BC
					else if (bp12 <= 0x1e) {
						//^0CEE:17C2
						di = bp12;
						//^0CEE:17C5
						continue;
					}
					else {
						//^0CEE:17C0
						break;
					}
				}
			}
		}
	}
	//^0CEE:17C8
	*bp04 = 0;
	//^0CEE:17CF
	FORMAT_SKSTR(bp009a, str);
	//^0CEE:17E3
	return;
}

//^0CEE:3202
// SPX: _0cee_3202 renamed IS_REBIRTH_ALTAR()
Bit16u SkWinCore::IS_REBIRTH_ALTAR(ObjectID rl)
{
	//^0CEE:3202
	ENTER(2);
	U8 isViAltar = 0;
	//^0CEE:3206
	U8 wallOrnateNo = QUERY_CLS2_FROM_RECORD(rl);	// bp01
	//^0CEE:3211
	if (wallOrnateNo == 0xff)
		//^0CEE:3215
		return 0;
	//^0CEE:3219
	// SPX: This value was present in no wall graphics since VI ALTAR has been dropped in DM2; however, it works!
	isViAltar = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, wallOrnateNo, dtWordValue, GDAT_WALL_ORNATE__IS_REBIRTH_ALTAR); //0x0c
	return isViAltar;
}

//^2FCF:164E
X16 SkWinCore::_2fcf_164e(ObjectID xx, ObjectID yy)
{
	//^2FCF:164E
	ENTER(0);
	//^2FCF:1653
	ObjectID si = xx;
	if (si.DBType() == dbContainer && QUERY_CLS2_FROM_RECORD(si) < 8) {
		//^2FCF:1672
		si = GET_ADDRESS_OF_RECORD9(si)->GetContainedObject();
		while (si != OBJECT_END_MARKER) {
			//^2FCF:1683
			ObjectID di = GET_DISTINCTIVE_ITEMTYPE(si);
			if (di != yy) {
				//^2FCF:1691
				if (_2fcf_164e(si, yy) == 0)
					goto _16a4;
			}
            //^2FCF:169F
			return 1;
			//^2FCF:16A4
_16a4:
			si = GET_NEXT_RECORD_LINK(si);
		}
	}
	//^2FCF:16B2
	return 0;
}

//^2FCF:16FF
Bit16u SkWinCore::_2fcf_16ff(ObjectID rl)
{
	//^2FCF:16FF
	ENTER(14);
	//^2FCF:1705
	X16 bp0c = 0;
	X16 bp0a = 0;
	Champion *champion = glbChampionSquad;	//*bp04
	ObjectID di;
	U16 si = 0; // uninited val
	ObjectID *bp08;
	for (; bp0a < glbChampionsCount; bp0a++, champion++) {
		//^2FCF:1719
		if (champion->curHP() == 0)
			continue;
		bp08 = champion->inventory;
		for (si = 0; si < INVENTORY_MAX_SLOT && bp0c == 0; si++) {
			//^2FCF:1737
			di = *bp08; bp08++;
			//^2FCF:1741
_1741:
			U16 bp0e = GET_DISTINCTIVE_ITEMTYPE(di);
			if (bp0e == rl || _2fcf_164e(di, rl) != 0)
				return 1;
			//^2FCF:1763
		}
		//^2FCF:176F
	}
	//^2FCF:1780
	if (glbRightPanelType == RIGHT_PANEL_CONTAINER) {	// 5
		//^2FCF:1787
		for (si = 0; si < CONTAINER_MAX_SLOT; si++) {	// < 8
			//^2FCF:178B
			di = glbCurrentContainerItems[si];
			if (di == OBJECT_NULL)
				continue;
			if (GET_DISTINCTIVE_ITEMTYPE(di) != rl)
				continue;
			return 1;
			//^2FCF:17A8
		}
	}
	//^2FCF:17AE
	if (bp0c == 0) {
		bp0c = 1;
		di = glbLeaderHandPossession.object;
		goto _1741;
	}
	return 0;
}
//^3A15:0447
// SPX: Count timers until timer number xx
// SPX: _3a15_0447 renamed GET_TIMER_NEW_INDEX
Bit16u SkWinCore::GET_TIMER_NEW_INDEX(Bit16u xx)
{
	//^3A15:0447
	ENTER(4);
	//^3A15:044C
	U16 *bp04 = glbTimerNextEntries;
	i16 si;
	for (si = 0; si < glbTimersActiveCount; si++) {
		//^3A15:045D
		if (*(bp04++) == xx)
			break;
	}
	if (si >= glbTimersActiveCount) {
		RAISE_SYSERR(SYSTEM_ERROR__TIMER_BEYOND_MAX);
	}
	//^3A15:0481
	return si;
}

//^01B0:1997
// SPX: _01b0_1997 renamed BLEND_TO_SNDBUFF_TANDY
void SkWinCore::BLEND_TO_SNDBUFF_TANDY(void *ref, Bit16u xx, Bit16u yy, Bit16u zz) { // TODO: Unr
	Unr();
}

void SkWinCore::_01b0_0ec3(X16 xx) { // TODO: Unr
	Unr();
}

//^01B0:1A6D
// SPX: _01b0_1a6d renamed BLEND_TO_SNDBUFF_GENERAL
void SkWinCore::BLEND_TO_SNDBUFF_GENERAL(U8 *buff, Bit16u buffSize, Bit16u volume, Bit16u caller, Bit16u ss, Bit16u tt)
{
	//^01B0:1A6D
	ENTER(6);
	//^01B0:1A73
	X16 si = volume;
	U16 di = caller;
	if (si == 0)
		return;
	//^01B0:1A80
	if (di > 0x1f40 && tt != 0) {
		//^01B0:1A8C
		di >>= 1;
		buffSize >>= 1;
		_01b0_14d9 = 1;
	}
	else {
		//^01B0:1AA3
		_01b0_14d9 = 0;
	}
	//^01B0:1AAA
	if (glbSoundBlasterBasePort == 0)
		return;
	//^01B0:1AB4
	if (_04bf_04f1 != 0) {
		//^01B0:1ABC
		if (_04bf_04f3 != 0) {
			//^01B0:1AC3
			U16 bp02;
			for (bp02 = 0; bp02 < 0x100; bp02++) {
				//^01B0:1ACA
				X8 bp05 = (ss == 7)
					? _04bf_03d6[RCJ(220,(bp02 * 220) >> 8)]
					: ((((bp02 +0x80) * si) >> 8) +0x80)
					;
				_01b0_13d8[bp02] = bp05;
				//^01B0:1B00
			}
		}
		//^01B0:1B0A
		_04bf_04f1 =  si;
		if (ss == 7) {
			//^01B0:1B14
			_01b0_0ec3(si);
            _04bf_04f3 = 0;
		}
	}
	//^01B0:1B20
	bool jne = (sndLockSoundBuffer != 0);
	sndSoundToPlayBuffer = buff;
	sndLockSoundBuffer = buffSize;
	if (!jne) {
		//^01B0:1B3F
		U16 bp04;
		switch (ss) {
		case 5://^1B51	// Sound card type 5
			//^01B0:1B51
			glbSoundFreq_13ce = 0x1551;	// 0x1551 = 5457 (*2 = 10914)
			goto _1b7b;
		case 3://^1B5A	// Sound card type 3
			//^01B0:1B5A
			glbSoundFreq_13ce = 0x1624;	// 0x1624 = 5668 (*2 = 11336)
			goto _1b7b;
		case 7://^1B63	// Sound card type 7
			//^01B0:1B63
			outportb(_01b0_14db, 0x40);
			glbSoundFreq_13ce = 0x15e9;
			goto _1b7b;
		case ScardSBlaster://^1B74	// Sound card type 6
			//^01B0:1B74
			glbSoundFreq_13ce = 0x159e;	// 0x159e = 5534 (*2 = 11068)
			//^01B0:1B7B
_1b7b:
			bp04 = 0x001234dc / di;
			_01b0_13c8 = bp04;
		case 4://^1B92
			break;
		}
	}
	//^01B0:1B92
	//^01B0:1B93
	return;
}

//^01B0:1BA1
// SPX: _01b0_1ba1 renamed BLEND_TO_SNDBUFF_SNDCARD_4
void SkWinCore::BLEND_TO_SNDBUFF_SNDCARD_4(void *ref, Bit16u xx, Bit16u yy, Bit16u zz) { // TODO: Unr
	Unr();
}

//^47EB:02E0
Bit16u SkWinCore::_47eb_02e0(SoundStructure *xx, SoundStructure *yy)
{
	//^47EB:02E0
	ENTER(0);
	//^47EB:02E4
	U16 si;
	if (xx->b4 > yy->b4)
		//^47EB:02F4
		return si = 1;
	//^47EB:02F9
	if (yy->b4 == yy->b4) {
		//^47EB:0309
		U8 cl = xx->b8;
		U8 dl = yy->b8;
		if (cl >= dl)
			return si = 1;
		return si = 0;
	}
	//^47EB:032C
	return si = 0;
}
//^47EB:0048
Bit8u *SkWinCore::_47eb_0048(shelf_memory info, Bit16u physPage0to3)
{
#if UseAltic
	return REALIZE_GRAPHICS_DATA_MEMORY(info);
#else
//!	//^47EB:0048
//!	ENTER(4);
//!	//^47EB:004C
//!	U8 *bp04;
//!	if (info.AtEMS()) {
//!		//^47EB:005A
//!		bp04 = EMS_MAP_BANK_TO_MEMORY(info -0x00200000, physPage0to3);
//!	}
//!	else {
//!		//^47EB:0075
//!		bp04 = ((info & 0x000ffff0) << 12) | (info & 15);
//!	}
//!	//^47EB:009C
//!	return bp04;
#endif
}

//^0CEE:317F
//SPX: _0cee_317f renamed IS_OBJECT_ALCOVE
X16 SkWinCore::IS_OBJECT_ALCOVE(ObjectID rl)
{
	//^0CEE:317F
	ENTER(0);
	//^0CEE:3182
	if (IS_WALL_ORNATE_ALCOVE(QUERY_CLS2_FROM_RECORD(rl)) == 1)
		return 1;
	return 0;
}
//^19F0:2024
X16 SkWinCore::_19f0_2024(ObjectID rl, i16 ss, i16 tt)
{
	//^19F0:2024
	ENTER(20);
	//^19F0:202A
	ObjectID si = rl;
	i16 di;
	X16 bp10;
	X16 bp0e;
	if ((_4976_4ef2 & 0x10) != 0 && IS_CONTAINER_CHEST(si) != 0) {
		//^19F0:2040
		Container *bp08 = GET_ADDRESS_OF_RECORD9(si);
		bp0e = si.Dir();
		si = bp08->GetContainedObject();
		bp10 = 0xf;
	}
	else if (si.DBType() == dbCreature && (_4976_4ef2 & 0x28) != 0) {
		//^19F0:207A
		Creature *bp04 = GET_ADDRESS_OF_RECORD4(si);
		AIDefinition *bp0c = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType());
		bp10 = bp0c->IsStaticObject();
		if (((bp10 != 0) ? (_4976_4ef2 & 8) : (_4976_4ef2 & 0x20)) != 0) {
			//^19F0:20C0
			bp0e = 8;
			si = bp04->GetPossessionObject();
			bp10 = (bp10 != 0) ? _48ae_01af(bp0c->w30, tt) : 0xf;
		}
	}
	else {
		//^19F0:20BD
		return 0xffff;
	}
	//^19F0:20EF
	X8 bp14[4];
	for (di = 0; di < 4; bp10 >>= 1, di++) {
		//^19F0:20F3
		bp14[di] = U8(bp10 & 1);
		//^19F0:20FB
	}
	//^19F0:2104
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^19F0:2106
		if (bp14[si.Dir()] != 0) {
			//^19F0:2116
			if (CREATURE_CAN_HANDLE_IT(si, ss) != 0 || _19f0_2024(si, ss, tt) != 0xffff) {
				//^19F0:2138
				if (bp0e == 8) {
					bp0e = bp0e +si.Dir();
				}
				//^19F0:214B
				return bp0e;
			}
		}
		//^19F0:2150
	}
	//^19F0:215E
	return 0xffff;
}

//^19F0:2165
i16 SkWinCore::_19f0_2165(X16 aa, i16 xx, i16 yy, i16 ss, i16 tt, i16 vv, i16 ww)
{
	//^19F0:2165
	ENTER(12);
	SkD((DLV_DBG_SED3, "DBG: _19f0_2165 %04X %04X %04X %04X %04X %04X %04X \n", (Bitu)aa, (Bitu)xx, (Bitu)yy, (Bitu)ss, (Bitu)tt, (Bitu)vv, (Bitu)ww));
	//^19F0:216B
	X16 bp0c = aa & 0x80;
	X16 bp02;
	if (bp0c != 0) {
		//^19F0:2178
		aa &= 0xff7f;
		bp02 = 0xffff;
	}
	X16 bp0a;
	U16 bp04;
	ObjectID di;
	i16 si;
	//^19F0:2182
	if (_4976_4ef2 != 0) {
		//^19F0:218C
		if (ss == -1) {
			//^19F0:2192
			bp0a = 0;
			ss = xx +glbXAxisDelta[vv];
			tt = yy +glbYAxisDelta[vv];
		}
		else {
			//^19F0:21B7
			bp0a = (xx != ss || yy != tt) ? 0 : 1;
			if (bp0a == 0 && vv == -1) {
				//^19F0:21DB
				vv = CALC_VECTOR_DIR(xx, yy, ss, tt);
			}
		}
		//^19F0:21F2
		_19f0_045a(ss, tt);
		if (aa != 0 || (U8(_4976_521c) & 0x10) != 0) {
			//^19F0:2212
			if (U8(_4976_521c >> 5) == 0) {
				if (_4976_522c == 0xff) {
					//^19F0:2229
					_4976_522c = 0;
					_4976_522d = 0;
					if (bp0a == 0 && (_4976_4ef2 & 4) != 0) {
						//^19F0:2241
						_4976_522e[0] = (vv +2) & 3;
						if (_4976_521e == OBJECT_NULL) {
							//^19F0:2252
							_4976_521e = GET_TILE_RECORD_LINK(ss, tt);
						}
						//^19F0:2262
						for (di = _4976_521e; di != OBJECT_END_MARKER && (si = di.DBType()) <= dbActuator; di = GET_NEXT_RECORD_LINK(di)) {
							//^19F0:2268
							if (IS_OBJECT_ALCOVE(di) == 0)	// _0cee_317f
								continue;
							//^19F0:2273
							if (di.Dir() == _4976_522e[0]) {
								//^19F0:2282
								_4976_522d = 1;
							}
							else {
								//^19F0:2289
								_4976_522c = 1;
							}
							//^19F0:228E
						}
						//^19F0:22AB
						_4976_5220 = di;
					}
				}
				//^19F0:22AF
				if (_4976_522d == 0)
					goto _2474;
				if (aa == 1) {
					bp02 = ccm19;
					goto _2484;
				}
				//^19F0:22C7
				bp02 = ccm1A;
				bp04 = _4976_522e[0];
				di = _4976_5220;
				for (; di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
					//^19F0:22D9
					if (di.Dir() == bp04 && (si = di.DBType()) != dbCreature && si < dbMissile) {
						//^19F0:22F7
						if (CREATURE_CAN_HANDLE_IT(di, ww) != 0)
							goto _2484;
						//^19F0:2309
						if (_19f0_2024(di, ww, vv) != 0xffff)
							goto _2484;
					}
					//^19F0:231F
				}
				goto _2474;
			}
			//^19F0:2330
			if (_4976_522c == 0xff) {
				//^19F0:2337
				_4976_522c = 0;
				_4976_522e[0] = 0xff;
			}
			//^19F0:2341
			if (bp0a == 0 && glbCurrentMapIndex == glbCreatureMap && ss == glbCreaturePosX && tt != glbCreaturePosY)
				goto _2474;
			//^19F0:2365
			if ((_4976_4ef2 & ((bp0a != 0) ? 1 : 0x2a)) == 0)
				goto _2474;
			//^19F0:237C
			if (aa == 1) {
				//^19F0:2382
				if (bp0a == 0)
					//^19F0:238B
					bp02 = ccmPlaceMerchandise;
				goto _2484;
			}
			//^19F0:2393
			(bp0a == 0);
			//^19F0:2397
			for (di = _19f0_04bf(); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
				//^19F0:239E
				bp04 = di.Dir();
				si = di.DBType();
				if (si >= dbCreature && si <= dbMissile) {
					//^19F0:23C0
					if ((si != dbCreature && CREATURE_CAN_HANDLE_IT(di, ww) != 0) || (bp04 = _19f0_2024(di, ww, vv)) != 0xffff) {
						//^19F0:23EA
						if (bp04 >= 8) {
							//^19F0:23F0
							bp02 = ccmMeleeAttack;
							bp04 &= 3;
							goto _2484;
						}
						X8 bp05;
						X16 bp08;
						//^19F0:23FD
						if (_4976_522e[0] == 0xff) {
							if (bp0a != 0) {
								//^19F0:240A
								if (vv == -1) {
									bp05 = 0xf;
									bp08 = 0;
								}
								else {
									bp05 = 3;
									bp08 = vv;
								}
							}
							else {
								//^19F0:2427
								bp05 = 0xc;
								bp08 = vv;
							}
							//^19F0:2431
							for (si = 0; si < 4; si++) {
								//^19F0:2435
								_4976_522e[bp08] = bp05 & 1;
								bp08 = (bp08 + 1) & 3;
								bp05 >>= 1;
								//^19F0:244E
							}
						}
						//^19F0:2454
						if (_4976_522e[bp04] != 0)
							goto _2484;
						_4976_522c = 1;
					}
				}
				//^19F0:246A
			}
		}
	}
	//^19F0:2474
_2474:
	if (bp0c != 0)
		//^19F0:247A
		_4976_4ee5 = xactrNo;
	//^19F0:247F
	return 0;

	//^19F0:2484
_2484:
	if (bp0c != 0) {
		//^19F0:248D
		if (vv == -1) {
			//^19F0:2493
			vv = glbCurrentThinkingCreatureRec->b15_0_1();
		}
		//^19F0:24A1
		if (bp0a != 0 || _19f0_0559(vv) == 0) {
			//^19F0:24B6
			glbCurrentThinkingCreatureData->b29 = U8(vv);
			if (aa == 1) {
				//^19F0:24CA
				if (bp02 == ccm19) {
					//^19F0:24D0
					bp04 = vv;
				}
				else if (bp02 == ccmPlaceMerchandise) {
					//^19F0:24DF
					di = _19f0_050f();
					si = _48ae_01af(_0cee_2df4(di), vv);
					if (si == 0)
						goto _2474;
					//^19F0:2502
					si = i16(COMPUTE_POWER_4_WITHIN(si, RAND16(_1c9a_0598(si)) +1));
					ATLASSERT(si != 0);
					for (bp04 = 0; (si & 1) == 0; si >>= 1, bp04++);
				}
				else {
					//^19F0:253B
					si = RAND01();
					if (bp0a == 0) {
						//^19F0:2548
						si += 2;
					}
					//^19F0:254A
					bp04 = (vv +si) & 3;
					bp02 = _4976_38e8[RCJ(4,si)];
				}
			}
			//^19F0:2563
			else if (bp02 == X16(ccmInv)) {
				si = (bp04 - glbCurrentThinkingCreatureData->b29 +1) & 3;
				if (bp0a == 0) {
					bp02 = (si < 2) ? ccm2B : ccm2C;
				}
				else {
					bp02 = (si < 2) ? ccm0C : ccm0D;
					//^19F0:25AB
					if (si == 0) {
						//^19F0:25AF
						glbCurrentThinkingCreatureData->b29 = (glbCurrentThinkingCreatureData->b29 -1) & 3;
					}
					else if (si == 3) {
						//^19F0:25C0
						glbCurrentThinkingCreatureData->b29 = (glbCurrentThinkingCreatureData->b29 +1) & 3;
					}
					//^19F0:25D4
					if ((_4976_3752[_4976_4efa] & 0x1000) != 0 && glbCurrentThinkingCreatureData->b29 != glbCurrentThinkingCreatureRec->b15_0_1()) {
						//^19F0:25FB
						_19f0_0559(glbCurrentThinkingCreatureData->b29);
						return 1;
					}
				}
			}
			//^19F0:260C
			glbCurrentThinkingCreatureData->w24.SetX(glbCreatureSomeX);
			glbCurrentThinkingCreatureData->w24.SetY(glbCreatureSomeY);
			glbCurrentThinkingCreatureData->w24.SetMap(glbCreatureSomeZMap);
			//^19F0:2644
			glbCurrentThinkingCreatureData->b28 = U8(bp04);
			glbCurrentThinkingCreatureData->ItemToThrow = U8(ww);
			glbCurrentThinkingCreatureData->b32 = U8(aa);
			glbCurrentThinkingCreatureData->Command = U8(bp02);
			_4976_4ee5 = xactrAgain;
		}
	}
	//^19F0:2665
	return 1;
}

//^0CEE:0184
ObjectID *SkWinCore::OVERSEE_RECORD(ObjectID *ref, Bit8u dir, ObjectID **recordMatched, U16 (SkWinCore::*pfnFinder)(ObjectID *ref, void *pvUser), void *pvUser, Bit16u alsoCreaturePossessions, Bit16u alsoContainedObjects)
{
	//^0CEE:0184
	ENTER(8);
	//^0CEE:018A
	U16 di = alsoCreaturePossessions;
	U16 si = alsoContainedObjects;
	//^0CEE:0190
	for (ObjectID *bp08 = ref; *ref != OBJECT_END_MARKER && *ref != OBJECT_NULL; ref = &GET_ADDRESS_OF_RECORD(*ref)->w0) {
		//^0CEE:019F
		if (dir != 0xff) {
			//^0CEE:01A5
			if (ref->Dir() != dir)
				//^0CEE:01B7
				continue;
		}
		//^0CEE:01BA
		if (ref->DBType() == dbCreature && di != 0) {
			//^0CEE:01CF
			ObjectID *bp04 = &GET_ADDRESS_OF_RECORD4(*ref)->possession;
			//^0CEE:01E0
			bp04 = OVERSEE_RECORD(bp04, 255, recordMatched, pfnFinder, pvUser, di, si);
			//^0CEE:020D
			if (bp04 != NULL) {
				//^0CEE:0212
				return bp04;
			}
		}
		//^0CEE:021B
		if (si != 0 && IS_CONTAINER_CHEST(*ref) != 0) {
			//^0CEE:022F
			ObjectID *bp04 = &GET_ADDRESS_OF_RECORD(*ref)->w0;
			//^0CEE:0241
			bp04 = &bp04[1];
			//^0CEE:024F
			bp04 = OVERSEE_RECORD(bp04, 255, recordMatched, pfnFinder, pvUser, di, si);
			//^0CEE:0279
			if (bp04 != NULL) {
				//^0CEE:0281
				//^0CEE:0212
				return bp04;
			}
		}
		//^0CEE:0283
		if ((this->*pfnFinder)(ref, pvUser) != 0) {
			//^0CEE:0299
			*recordMatched = bp08;
            //^0CEE:02A9
			return ref;
		}
		//^0CEE:02B1
	}
	//^0CEE:02D5
	return NULL;
}

//^3A15:0381
int SkWinCore::_3a15_0381(Timer *xx, Timer *yy)
{
	//^3A15:0381
	if (xx->GetTick() >= yy->GetTick()) {
		//^3A15:03B8
		Bit16u si =  (xx->GetTick() == yy->GetTick()) ? 1 : 0;
		//^3A15:03EC
		if (si != 0 && (xx->TimerType() > yy->TimerType()))
			//^3A15:03FE
			return 1;
		//^3A15:0400
		if (si != 0) {
			//^3A15:0404
			si = (xx->TimerType() == yy->TimerType()) ? 1 : 0;
			//^3A15:041D
			if (si != 0) {
				//^3A15:0421
				if (xx->actor > yy->actor) {
					//^3A15:043D
					return 1;
				}
			}
		}
		//^3A15:0431
		if (si == 0)
			//^3A15:0433
			return 0;
		//^3A15:0435
		if ((Bit16u)xx <= (Bit16u)yy)
			//^3A15:043D
			return 1;
		//^3A15:043B
		return 0;
	}
	//^3A15:043D
	return 1;
}

//^3A15:0486
void SkWinCore::_3a15_0486(Bit16u xx)
{
	//^3A15:0486
	//^3A15:048C
	Bit16u di = xx;
	_4976_4762 = -1;
	Bit16u bp06 = glbTimersCount -1;
	//^3A15:049C
	if (bp06 == 0)
		//^3A15:04A0
		return;
	//^3A15:04A3
	Bit16u bp0a = glbTimerNextEntries[di];
	//^3A15:04B3
	Timer *bp04 = &glbTimersTable[bp0a];
	//^3A15:04C8
	Bit16u bp08 = 0;
	//^3A15:04CD
	for (; di > 0; ) {
		//^3A15:04CF
		Bit16u si = (di -1) >> 1;
		//^3A15:04D6
		if (_3a15_0381(bp04, &glbTimersTable[glbTimerNextEntries[si]]) == 0)
			//^3A15:0500
			break;
		//^3A15:0502
		glbTimerNextEntries[di] = glbTimerNextEntries[si];
		//^3A15:051C
		di = si;
		//^3A15:051E
		bp08 = 1;
		//^3A15:0523
	}
	//^3A15:0527
	if (bp08 == 0) {
		//^3A15:0530
		bp06 = (bp06 -1) >> 1;
		//^3A15:0539
		while (di <= bp06) {
			//^3A15:053C
			Bit16u si = (di << 1) +1;
			//^3A15:0544
			if ((si +1) < glbTimersCount) {
				//^3A15:054A
				if (_3a15_0381(&glbTimersTable[glbTimerNextEntries[si +1]], &glbTimersTable[glbTimerNextEntries[si]]) != 0) {
					//^3A15:0590
					si++;
				}
			}
			//^3A15:0591
			if (_3a15_0381(&glbTimersTable[glbTimerNextEntries[si]], bp04) == 0)
				//^3A15:05BD
				break;
			//^3A15:05BF
			glbTimerNextEntries[di] = glbTimerNextEntries[si];
			//^3A15:05D9
			di = si;
			//^3A15:05DB
		}
	}
	//^3A15:05E3
	glbTimerNextEntries[di] = bp0a;
	//^3A15:05F3
	return;
}

//^3A15:0696
Bit16u SkWinCore::QUEUE_TIMER(Timer *ref)
{
	ATLASSERT(ref->TimerType() != 0xcc);

	//ATLASSERT(ref->GetMap() != 0 || ref->TimerType() != tty1E);
	//printf("Timers : AC:%d / C:%d / MX:%d\n", glbTimersActiveCount, glbTimersCount, glbTimersMaximumCount);

	//^3A15:0696
	if (ref->TimerType() == 0) {
		//^3A15:06A5
		return 0xffff;
	}
	//^3A15:06AB
	if (glbTimersCount == glbTimersMaximumCount) {
		//^3A15:06B4
		RAISE_SYSERR(SYSTEM_ERROR__TIMER_MAX_REACHED);
	}
	//^3A15:06BC
	Bit16u si = glbTimerIndexNextAvailable;
	//^3A15:06CD
	glbTimerIndexNextAvailable = glbTimersTable[si].w0_0_f();
	//^3A15:06D5
	glbTimersTable[si] = *ref;

	SkD((DLV_DBG_TIMER, "DBG: Timer#%03d(%6u,%2u,%02X,%02X,%04X,%04X) Added.\n"
		, (Bitu)si
		, (Bitu)ref->GetTick(), (Bitu)ref->GetMap(), (Bitu)ref->TimerType()
		, (Bitu)ref->actor, (Bitu)ref->value, (Bitu)ref->w8
		));

	//^3A15:06F3
	if (glbTimersActiveCount <= si) {
		//^3A15:
		glbTimersActiveCount = si +1;
	}
	//^3A15:06FF
	__int16 di = _4976_4762;
	//^3A15:0704
	if (di < 0) {
		//^3A15:0708
		di = glbTimersCount;
	}
	//^3A15:070C
	_4976_4762 = -1;
	glbTimersCount++;
	//^3A15:0716
	glbTimerNextEntries[di] = si;
	//^3A15:0723
	_3a15_0486(di);
	//^3A15:0729
	return si;
}

//^01B0:1C8D
void SkWinCore::_01b0_1c8d(Bit16u xx) //#DS=04BF
{
	//^01B0:1C8D
	//^01B0:1C91
	if (sndLockSoundBuffer == 0) {
		//^01B0:1C9B
		switch (glbSoundCardType) {
			case 3:
				//^01B0:1CAF
				glbSoundFreq_13ce = 0x16b6;	// 0x16b6 = 5814

				break;
			case 5:
				//^01B0:1CB8
				glbSoundFreq_13ce = 0x1779;	// 0x1779 = 6009
			
				break;
			case ScardSBlaster:
				//^01B0:1CC1
				glbSoundFreq_13ce = 0x170e;	// 0x170e = 5902

				break;
		}
		//^01B0:1CC8
		Bit16u bp02 = 0x001234dc / sndSoundPlaybackFrequency;
		//^01B0:1CDB
		_01b0_13c8 = bp02;
	}
	//^01B0:1CE2
	if (xx > sndLockSoundBuffer)
		//^01B0:1CEC
		sndLockSoundBuffer = xx;
	//^01B0:1CF0
	return;
}

//^01B0:1CF3
// SPX: Isn't caller a playback frequency ?
Bit16u SkWinCore::IBMIO_SBLASTER_BLEND_TO_SNDBUFF(Bit8u *buff, Bit16u buffSize, __int8 volume, Bit16u caller) //#DS=04BF
{
#if UseAltic
	skwin.SndPlayHi(buff, buffSize, volume);
	return 1;
#else
	//^01B0:1CF3
	//^01B0:1CF9
	Bit16u bp02 = 0;
	//^01B0:1CFE
	if (sndSoundInBuffer != 0 && glbSoundBlasterBasePort != 0) {
		//^01B0:1D12
		if (Bit32u(sndSoundPlaybackFrequency * buffSize) / caller <= sndSoundBufferSize) {
			//^01B0:1D36
			volume >>= 1;
			//^01B0:1D3B
			Bit8u *di = sndSoundToPlayBuffer;
			Bit16u bx = _01b0_14dd;
			Bit16u dx = sndSoundToPlayBufferSize;
			Bit8u *si = buff;
			//^01B0:1D51
			Bit16u bp06;
			if (glbFreqComparator != caller) {
				//^01B0:1D5A
				Bit16u bp04 = buffSize;
				bp06 = 0;
				//^01B0:1D65
				if (glbFreqComparator > caller) {
					//^01B0:1D95
					ATLASSERT(false);
				}
				else {
					//^01B0:1DCB
					ATLASSERT(false);
				}
			}
			else {
				//^01B0:1D6A
				Bit16u cx = buffSize;
				//^01B0:1D6D
				bp06 = cx;

				do {
					//^01B0:1D70
					__int16 val = __int16(__int8(di[bx])) + (((__int16(*(si++)) * __int16(volume)) << 1) >> 8);

					if (val < -128)
						val = -128;
					if (val > 127)
						val = 127;

					di[bx] = (Bit8u)val;

					//^01B0:1D87
					bx++;
					//^01B0:1D88
					if (bx >= dx) {
						bx = 0;
					}
					//^01B0:1D8F
				} while (--cx != 0);
			}
			//^01B0:1DFF
			//^01B0:1E01
			_01b0_1c8d(bp06);
			//^01B0:1E09
			bp02 = 1;
		}
	}
	//^01B0:1E0E
	return bp02;
#endif
}

//^01B0:1E15
Bit16u SkWinCore::IBMIO_BLEND_TO_SNDBUFF(Bit8u *buff, Bit16u buffSize, Bit8u volume, Bit16u caller) //#DS=04BF
{
	// it blends your wave data to sndbuff.

	//^01B0:1E15
	//^01B0:1E1B
	Bit8u di = volume;
	Bit16u si = caller;
	//^01B0:1E21
	LOADDS(0x3083);
	//^01B0:1E27
	Bit16u bp02 = 0;
	//^01B0:1E2C
	if (sndSoundInBuffer != 0) {
		//^01B0:1E33
		if (glbSoundCardType == 3 || glbSoundCardType == 5 || glbSoundCardType == ScardSBlaster) {
			//^01B0:1E48
			bp02 = IBMIO_SBLASTER_BLEND_TO_SNDBUFF(buff, buffSize, di, si);
		}
	}
	else {
		//^01B0:1E5F
		switch (glbSoundCardType) {
			case ScardTandy:
				//^01B0:1E71
				BLEND_TO_SNDBUFF_TANDY(buff, buffSize, di, si);
				//^01B0:1E80
				break;
			case 3:
				//^01B0:1E82
				BLEND_TO_SNDBUFF_GENERAL(buff, buffSize, di, si, 3, 0);

				break;
			case 4:
				//^01B0:1E88
				BLEND_TO_SNDBUFF_SNDCARD_4(buff, buffSize, di, si);
				//^01B0:1E9A
				break;
			case 5:
				//^01B0:1E9C
				BLEND_TO_SNDBUFF_GENERAL(buff, buffSize, di, si, 5, 1);

				break;
			case ScardSBlaster:
				//^01B0:1EA2
				BLEND_TO_SNDBUFF_GENERAL(buff, buffSize, di, si, 6, 0);

				break;
			case 7:
				//^01B0:1EA8
				BLEND_TO_SNDBUFF_GENERAL(buff, buffSize, di, si, 7, 1);

				break;
		}
	}
	//^01B0:1EBE
	return bp02;
}

//^47EB:0333
void SkWinCore::_47eb_0333(SoundStructure *ref)
{
	//^47EB:0333
	//^47EB:0339
	Bit16u bp08 = 0;
	//^47EB:033E
	__int16 si = ref->b6;
	__int16 di = ref->b7;
	//^47EB:034F
	U8 *bp04 = &ref->b8;	// volume
	//^47EB:035E
	bp04[0] = (__int8)(((ref->b5 << 8) / (si * si + di * di + 8)) >> 8);
	//^47EB:0388
	Bit8u cl;
	if (si == 0) {
		//^47EB:038C
		cl = 8;
	}
	//^47EB:0390
	else if (di == 0) {
		//^47EB:0394
		if (si < 0) {
			//^47EB:0398
			cl = 15;
		}
		else {
			//^47EB:039C
			cl = 1;
		}
	}
	else {
		//^47EB:03A0
		if (si < 0) {
			//^47EB:03A4
			si = -si;
			bp08 = 1;
		}
		//^47EB:03AF
		if (di < 0) {
			//^47EB:03B3
			di = -di;
		}
		//^47EB:03B9
		Bit16u bp06 = (si << 11) / di;
		cl = 0;

		//^47EB:03C7
		while (_4976_49c0[cl++] > bp06);
	}

	//^47EB:03DA
	if (bp08 != 0) {
		//^47EB:03E0
		bp04[1] = 16 - cl;
		bp04[2] = cl;
	}
	else {
		//^47EB:03EF
		bp04[1] = cl;
		bp04[2] = 16 - cl;
	}
	//^47EB:03FC
	//^47EB:0400
	return;
}

//^47EB:014F
// SPX: _47eb_014f renamed PLAY_SOUND
Bit16u SkWinCore::PLAY_SOUND(Bit16u xx, SoundStructure *ref)
{
	SkD((DLV_DBG_SND_OUT, "SND: Play sound xx:%02X struct:%04X\n"
		, U16(xx), ref));

	//^47EB:014F
	//^47EB:0155
	if (xx == 0)
		//^47EB:015B
		return 0;
	//^47EB:0160
	Bit16u bp02 = 0;
	SoundStructure *bp06 = ref;
	//^47EB:0171
	for (; bp02 < xx; bp02++, bp06++) {
		//^47EB:0173
		_47eb_0333(bp06);
		//^47EB:0180
		bp06->b11 = (Bit8u)bp02;
		//^47EB:018A
	}

	Bit16u bp10 = 0;
	do {
		//^47EB:0199
		bp06 = ref;
		//^47EB:01AA
		Bit16u bp0c = bp06->b11;
		//^47EB:01B6
		for (bp06++, bp02++; bp02 < xx; bp02++, bp06++) {
			//^47EB:01C1
			Bit16u bp0e = bp06->b11;
			//^47EB:01CD
			if (_47eb_02e0(&ref[bp0c], &ref[bp0e]) == 0) {
				//^47EB:01F8
				WRITE_UI8(bp06,-1,(Bit8u)bp0e);
				//^47EB:0202
				bp06->b11 = (Bit8u)bp0c;
				//^47EB:0209
				bp10 = 1;
			}
			else {
				//^47EB:0210
				bp0c = bp0e;
			}
			//^47EB:0216
		}
		//^47EB:0225
	} while (bp10 != 0);
	//^47EB:022E
	U16 si = 0;
	U16 di = 0;
	//^47EB:0232
	while (di < _4976_49be) {
		while (si < xx) {
			//^47EB:0234
			Bit16u bp0c = ref[si].b11;
			si++;
			//^47EB:024A
			bp06 = &ref[bp0c];
			//^47EB:025D
			Bit8u *bp0a = &bp06->b8;
#if UseAltic
			skwin.SndPlayLo(_47eb_0048(bp06->pv0->ps0, 0), bp06->pv0->w4, bp06->b6, bp06->b7);
#else
			//^47EB:026C
			if (IBMIO_BLEND_TO_SNDBUFF(_47eb_0048(bp06->pv0->ps0, 0), bp06->pv0->w4, *bp0a, PLAYBACK_FREQUENCY) CALL_IBMIO == 0)
			//^47EB:02A7
				return si;
#endif
		}
		//^47EB:02AE
		di++;
	}
	//^47EB:02B5
	return si;
}

//^482B:0101
Bit16u SkWinCore::QUERY_SND_ENTRY_INDEX(Bit8u cls1, Bit8u cls2, Bit8u cls4)
{
	//^482B:0101
	//^482B:0105
	for (Bit16u si=0; si < _4976_49d4[0][0]; si++) {
		//^482B:0109
		if (_4976_5f06[si].category == cls1) {
			//^482B:011F
			if (_4976_5f06[si].index == cls2) {
				//^482B:0135
				if (_4976_5f06[si].entry == cls4) {
					//^482B:014B
					return si +1;
				}
			}
		}
		//^482B:0150
	}
	//^482B:0157
	return 0;
}

//^482B:018B
void SkWinCore::QUEUE_NOISE_GEN1(Bit8u cls1, Bit8u cls2, Bit8u cls4, Bit8u xx, Bit8u yy, __int16 xpos, __int16 ypos, __int16 tickDelta)
{
	//^482B:018B
	//^482B:0191
	if (tickDelta > 0 && glbCurrentMapIndex != glbMap_4c28 && glbCurrentMapIndex != _4976_4c12) {
		//^482B:01A6
		return;
	}
	//^482B:01A9
	if (_4976_49d0 == 20) {
		//^482B:01B0
		return;
	}
	//^482B:01B3
	Bit16u bp0e = QUERY_SND_ENTRY_INDEX(cls1, cls2, cls4);
	//^482B:01C9
	if (bp0e == 0) {
		//^482B:01CD
		return;
	}
	//^482B:01D0
	if (glbIsPlayerSleeping != 0) {
		//^482B:01D7
		yy >>= 1;
	}
	//^482B:01DA
	if (tickDelta > 1) {
		//^482B:01E3
		Bit16u bp10 = 0;
		//^482B:01E8
		__int16 si;
		for (si = 0; si < 8; si++) {
			//^482B:01EC
			if (glbSoundList[si].w0 == 0) {
				//^482B:01FF
				bp10 = 1;
				//^482B:0204
				break;
			}
			//^482B:0206
		}
		//^482B:020C
		if (bp10 == 0) {
			//^482B:0212
			return;
		}
		//^482B:0215
		SoundEntryInfo *snd = &glbSoundList[si];	//*bp04
		//^482B:022C
		snd->w0 = 1;
		snd->category = cls1;
		snd->index = cls2;
		snd->entry = cls4;
		snd->w8 = xx;
		snd->w10 = yy;
		snd->b5 = (Bit8u)glbCurrentMapIndex;
		snd->b6 = (Bit8u)xpos;
		snd->b7 = (Bit8u)ypos;
		//^482B:026C
		Timer bp1a;
		bp1a.SetMap(glbCurrentMapIndex);
		bp1a.SetTick(glbGameTick +tickDelta -1);
		bp1a.TimerType(ttySound);
		bp1a.actor = xx;
		bp1a.value = si;
		//^482B:02A8
		QUEUE_TIMER(&bp1a);
		//^482B:02B4
		return;
	}
	//^482B:02B7
	sk5f0a *bp08 = &_4976_5f0a[_4976_5f06[bp0e -1].w0];
	//^482B:02DC
	if (tickDelta > 0) {
		//^482B:02E2
		xpos += dunMapLocalHeader->MapOffsetX() - dunMapsHeaders[glbPlayerMap].MapOffsetX() - glbPlayerPosX;
		//^482B:0308
		ypos += dunMapLocalHeader->MapOffsetY() - dunMapsHeaders[glbPlayerMap].MapOffsetY() - glbPlayerPosY;
	}
	else {
		//^482B:0330
		xpos -= glbPlayerPosX;
		ypos -= glbPlayerPosY;
	}
	//^482B:033C
	__int16 si;
	switch (glbPlayerDir) {
		case 1:
			//^482B:0350
			si = xpos;
			xpos = ypos;
            //^482B:035B
			ypos = -si;
			//^482B:0360
			break;
		case 2:
			//^482B:0362
			xpos = -xpos;
			//^482B:036D
			//^482B:035B
			ypos = -ypos;
			//^482B:0360
			break;
		case 3:
			//^482B:036F
			si = xpos;
			xpos = -ypos;
			ypos = si;

			break;
	}
	//^482B:037D
	SoundStructure *bp0c;
	__int16 di;
	if (tickDelta < 0) {
		//^482B:0383
		if (_4976_49d2 == 6)
			//^482B:038A
			return;
		//^482B:038D
		bp0c = _4976_5efe;
		di = _4976_49d2;
	}
	else {
		//^482B:03A0
		bp0c = _4976_5f02;
		di = _4976_49d0;
	}
	//^482B:03B1
	for (si=0; si < di; si++) {
		//^482B:03B5
		if (bp0c[si].pv0 != bp08) {
			//^482B:03D2
			if (bp08->pv0 != bp0c[si].pv0)
				//^482B:03F8
				continue;
		}
        //^482B:03FA
		if (bp0c[si].b6 == xpos && bp0c[si].b7 == ypos)
			//^482B:0426
			return;

		//^482B:0429
	}
	//^482B:042E
	bp0c[di].pv0 = &_4976_5f0a[_4976_5f06[bp0e -1].w0];
	//^482B:0467
    bp0c[di].b4 = xx;
	bp0c[di].b5 = yy;
	bp0c[di].b6 = (__int8)xpos;
	bp0c[di].b7 = (__int8)ypos;
	//^482B:04B3
	if (tickDelta == 0) {
		//^482B:04B9
		PLAY_SOUND(1, &bp0c[di]);
	}
	//^482B:04D5
	else if (tickDelta > 0) {
		//^482B:04DB
		_4976_49d0++;
	}
	else {
		//^482B:04E1
		_4976_49d2++;
	}
	//^482B:04E5
	return;
}

//^482B:00BF
//void SkWinCore::QUEUE_NOISE_GEN2(Bit8u cls1, Bit8u cls2, Bit8u cls4, Bit8u cls2alt, __int16 xpos, __int16 ypos, Bit16u tickDelta, Bit8u ss, Bit8u tt)
void SkWinCore::QUEUE_NOISE_GEN2(Bit8u cls1, Bit8u cls2, Bit8u iSoundID, Bit8u cls2alt, __int16 xpos, __int16 ypos, Bit16u tickDelta, Bit8u ss, Bit8u tt)
{
	//^482B:00BF
	//^482B:00C2
	// SPX: In the case of sound at cls2 is not found, use the default with cls2alt
	QUEUE_NOISE_GEN1(
		cls1,
		(QUERY_SND_ENTRY_INDEX(cls1, cls2, iSoundID) != 0) ? cls2 : cls2alt,
		iSoundID,
		ss,
		tt,
		xpos,
		ypos,
		tickDelta
		);
	//^482B:00FF
	//SkD((DLV_BUGHERE,"Player sound (%02X,%02X,%02X) alt (%02X) to (%02d,%02d) / Delta = %02d / ss/tt = %02X,%02X\n"
	//	, (Bitu)cls1, (Bitu)cls2, (Bitu)cls4, (Bitu)cls2alt, xpos, ypos, tickDelta, ss, tt) );

	return;		
}

//^3A15:061A
// SPX: _3a15_061a renamed DELETE_TIMER
void SkWinCore::DELETE_TIMER(Bit16u xx)
{
	//^3A15:061A
	//^3A15:061F
	Bit16u si = xx;
	//^3A15:0622
	if (_4976_4762 >= 0) {
		//^3A15:0629
		_3a15_0486(_4976_4762);
	}
	//^3A15:0632
	glbTimersTable[si].TimerType(tty00);
	//^3A15:0644
	glbTimersTable[si].w0_0_f(glbTimerIndexNextAvailable);
	//^3A15:0657
	glbTimerIndexNextAvailable = si;
	//^3A15:065B
	glbTimersCount--;
	//^3A15:065F
	Bit16u di = glbTimersCount;
	//^3A15:0664
	if (di != 0) {
		//^3A15:0668
		si = GET_TIMER_NEW_INDEX(si);
		//^3A15:0670
		if (si != di) {
			//^3A15:0674
			glbTimerNextEntries[_4976_4762 = si] = glbTimerNextEntries[di];
		}
	}
	//^3A15:0692
	return;
}

//^2FCF:1587
void SkWinCore::INVOKE_MESSAGE(__int16 xpos, __int16 ypos, Bit16u dir, Bit16u actionType, Bit32u tick)
{
	SkD((DLV_DBM, "DBM: INVOKE_MESSAGE(%2d,%2d,%d,%d,%6u) M:%2d\n"
		, (Bitu)xpos, (Bitu)ypos, (Bitu)dir, (Bitu)actionType, (Bitu)tick, (Bitu)glbCurrentMapIndex));

	//^2FCF:1587
	//^2FCF:158B
	Timer bp0a;
	bp0a.SetMap(glbCurrentMapIndex);
	bp0a.SetTick(tick);
	//^2FCF:15A6
	bp0a.TimerType(tty04);
	//^2FCF:15AA
	if (actionType != 0) {
		//^2FCF:15B1
		if (actionType != 1) {
			//^2FCF:15B6
			if (actionType == 2) {
				//^2FCF:15C3
				// SPX: Why not directly if actionType == 2 then actor = 2 ?
				bp0a.actor = 2;
			}
		}
		else {	// Then >= 3
			//^2FCF:15BD
			bp0a.actor = 3;
		}
	}
	else { // Then = 1 ...
		//^2FCF:15C9
		bp0a.actor = 1;
	}
	// And no other else ? what happens if = 0 ?
	//^2FCF:15CD
	bp0a.Xcoord((Bit8u)xpos);
	bp0a.Ycoord((Bit8u)ypos);
	bp0a.Value2((Bit8u)dir);
	bp0a.ActionType((Bit8u)actionType);
	//^2FCF:15E5
	QUEUE_TIMER(&bp0a);
}

//^0CEE:2515
void SkWinCore::SET_ITEMTYPE(ObjectID recordLink, Bit8u itemType)
{
	//^0CEE:2515
	//^0CEE:251A
	ObjectID si = recordLink;
	//^0CEE:251D
	if (si != OBJECT_NULL && si < OBJECT_EFFECT_FIREBALL) {	// oFF80
		//^0CEE:252D
		GenericRecord *_bp04 = GET_ADDRESS_OF_RECORD(si);
		//^0CEE:2539
		switch (si.DBType()) {
			case dbCreature:
				{
					Creature *bp04 = _bp04->castToCreature();

					//^0CEE:2554
					bp04->CreatureType(itemType);
					//^0CEE:255E
					break;
				}
			case dbWeapon:
				{
					Weapon *bp04 = _bp04->castToWeapon();

					//^0CEE:2560
					//^0CEE:25C0
					bp04->ItemType(itemType);

					break;
				}
			case dbCloth:
				{
					Cloth *bp04 = _bp04->castToCloth();

					//^0CEE:2562
					//^0CEE:25C0
					bp04->ItemType(itemType);

					break;
				}
			case dbScroll:
				{
					break;
				}
			case dbPotion:
				{
					Potion *bp04 = _bp04->castToPotion();

					//^0CEE:2564
					bp04->PotionType(itemType);
					//^0CEE:2578
					break;
				}
			case dbContainer:
				{
					Container *bp04 = _bp04->castToContainer();

					//^0CEE:257A
					bp04->ContainerFullType(itemType);
					//^0CEE:25AA
					if (bp04->ContainerType() == 1) {
						//^0CEE:25B8
						bp04->w6_0_f(0xffff);
					}
					break;
				}
			case dbMiscellaneous_item:
				{
					Miscellaneous_item *bp04 = _bp04->castToMisc();

					//^0CEE:25C0
					bp04->ItemType(itemType);

					break;
				}
		}
	}
	//^0CEE:25D4
}

//^0CEE:14D9
ObjectID SkWinCore::ALLOC_NEW_DBITEM(Bit16u itemspec)
{
	SkD((DLV_DBM, "DBM: ALLOC_NEW_DBITEM(%04X)\n"
		, (Bitu)itemspec));

	//^0CEE:14D9
	//^0CEE:14DE
	Bit16u di = itemspec;
	//^0CEE:14E1
	ObjectID si = ALLOC_NEW_RECORD(GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(di) | (di & 0x8000));
	//^0CEE:14F8
	if (si != OBJECT_NULL) {
		//^0CEE:14FD
		SET_ITEMTYPE(si, GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(di));
	}
	//^0CEE:150D
	return si;
}

//^0CEE:30A6
Bit8u SkWinCore::GET_WALL_DECORATION_OF_ACTUATOR(Actuator *ref)
{
	//^0CEE:30A6
	Bit16u si = ref->GraphicNumber();
	if (si != 0) {
		//^0CEE:30BE
		Bit8u *bp04 = &glbCurrentTileMap[glbCurrentMapWidth -1][glbCurrentMapHeight + dunMapLocalHeader->CreaturesTypes()];
		//^0CEE:30ED
		return bp04[si -1];
	}
	//^0CEE:30F6
	return -1;
}

//^0CEE:30FB
Bit8u SkWinCore::GET_FLOOR_DECORATION_OF_ACTUATOR(Actuator *ref)
{
	//^0CEE:30FB
	//^0CEE:3100
	Bit16u si = ref->GraphicNumber();
	//^0CEE:310F
	if (si != 0) {
		//^0CEE:3113
		Bit8u *bp04 = &glbCurrentTileMap[glbCurrentMapWidth -1][glbCurrentMapHeight + dunMapLocalHeader->CreaturesTypes() + dunMapLocalHeader->WallGraphics()];
		//^0CEE:3150
		return bp04[si -1];
	}
	else {
		//^0CEE:3159
		return 0xff;
	}
}

// DM1:
// Gold coin = 127, DM2 = 264
// The DM1 activation list is different and static
Bit16u SkWinCore::GET_DM1_DISTINCTIVE_ITEMTYPE(ObjectID recordLink)
{
	X16 iSearchIndex = 0;
	// get the object type of record in the form of uniquely identified number.
	// e.g. it always returns 2 if you get any type of weapon Torch record.
	// returns 511 if record is no meaningful to distinct.

	if (recordLink != OBJECT_NULL)
	{
		Bit8u iItemID = QUERY_CLS2_FROM_RECORD(recordLink);	// item type index
		Bit16u iItemDB = recordLink.DBType();
		//if (di == DB_CATEGORY_MISC_ITEM)
		//	return 119 + bp01;
		// Search through the table of conversion item to get the DM1 item value
		for (iSearchIndex = 0; iSearchIndex < 200; iSearchIndex++)
		{
			if (iItemDB == glbDM1ItemConv[iSearchIndex].iItemDB &&
				iItemID == glbDM1ItemConv[iSearchIndex].iItemID)
				return iSearchIndex;
			// SPX: TODO : special state for multi-state items (compass, torches, charged/discharged items)
		}
	}
	return 511;
}


//^0CEE:2391
Bit16u SkWinCore::GET_DISTINCTIVE_ITEMTYPE(ObjectID recordLink)
{
	// get the object type of record in the form of uniquely identified number.
	// e.g. it always returns 2 if you get any type of weapon Torch record.
	// returns 511 if record is no meaningful to distinct.

	if (SkCodeParam::bDM1Mode == true)
		return GET_DM1_DISTINCTIVE_ITEMTYPE(recordLink);

	//^0CEE:2391
	//^0CEE:2397
	if (recordLink != OBJECT_NULL) {
		//^0CEE:239D
		Bit8u bp01 = QUERY_CLS2_FROM_RECORD(recordLink);
		//^0CEE:23A9
		Bit16u di = recordLink.DBType();
		//^0CEE:23B4
		Bit16u si = glbActivationItemRangePerDB[di];
		//^0CEE:23BC
		if ((si & 0x8000) != 0) {
			//^0CEE:23C2
			si &= 0x7fff;
			bp01 = 0;
		}
		//^0CEE:23CA
		return si + bp01;
	}
	else {
		//^0CEE:23D7
		return 511;
	}
}

//^2FCF:15F3
void SkWinCore::INVOKE_ACTUATOR(Actuator *ref, Bit16u actionType, __int16 delayPlus)
{
	//^2FCF:15F3
	//^2FCF:15F6
	INVOKE_MESSAGE(
		ref->Xcoord(),
		ref->Ycoord(),
		ref->Direction(),
		actionType,
        glbGameTick + ref->Delay() + delayPlus
		);
	//^2FCF:164C
	return;
}

//^1C9A:0694
U16 SkWinCore::_1c9a_0694(ObjectID *ref, void *pv)
{
	//^1C9A:0694
	ENTER(0);
	//^1C9A:0697
	return (*ref == OBJECT_END_MARKER || GET_DISTINCTIVE_ITEMTYPE(*ref) == *(U16 *)pv) ? 1 : 0;
}

//^1C9A:06BD
ObjectID *SkWinCore::_1c9a_06bd(ObjectID recordLink, Bit16u ss, Bit16u dir)
{
	//^1C9A:06BD
	//^1C9A:06C1
	ObjectID *bp04 = 0;
	//^1C9A:06CB
	if (recordLink != OBJECT_NULL) {
		//^1C9A:06D1
		Creature *creature = GET_ADDRESS_OF_RECORD4(recordLink);	//*bp08
		//^1C9A:06E0
		ObjectID *bp0c;
		bp04 = OVERSEE_RECORD(
			&creature->possession,
			(Bit8u)dir,
			&bp0c,
			&SkWinCore::_1c9a_0694,
			&ss,
			0,
			0
			);
		//^1C9A:070F
		if (bp04 != NULL && *bp04 == 0xFFFE)
			//^1C9A:0720
			bp04 = NULL;
	}
	//^1C9A:072A
	return bp04;
}

//^2FCF:2444
// SPX: _2fcf_2444	renamed	PLACE_OR_REMOVE_OBJECT_IN_ROOM			(CSBWin:Code11f52.cpp/PlaceOrRemoveObjectInRoom)
void SkWinCore::PLACE_OR_REMOVE_OBJECT_IN_ROOM(__int16 xpos, __int16 ypos, ObjectID recordLink, Bit16u ss, Bit16u place, Bit16u uu)
{
	// CSBWin:Code11f52.cpp/PlaceOrRemoveObjectInRoom (TAG013380)
	// PlaceOrRemoveObjectInRoom(
    //                   i32 mapX,
    //                   i32 mapY,
    //                   RN object,          // RNnul refers to the party
    //                   bool unchangedRoom, // object is in same room as before
    //                   bool place,         // place object rather than remove
    //                   MMRECORD *pmmr)

	// you placed an item at floor.		_2fcf_2444(  3,  5,2801,1,1,0) @ 22
	// you took an item from floor.		_2fcf_2444(  3,  5,2801,1,0,0) @ 22
	//									_2fcf_2444(  3,  5,6009,1,0,0) @ 22

	// you have insert a key to hole	_2fcf_2444(  4,  5,E979,0,1,0) @ 22
	// you have no one at leader's hand	_2fcf_2444(  3,  5,FFFF,1,0,0) @ 22

	// you are moving		_2fcf_2444(  3,  3,FFFF,0,0,0) @ 22
	// you have moved		_2fcf_2444(  3,  2,FFFF,0,1,0) @ 22

	// creature is moving	_2fcf_2444(  8,  2,1055,0,0,0) @ 16
	// creature has moved	_2fcf_2444(  8,  3,1055,0,1,0) @ 16

	// creature has removed	_2fcf_2444(  1,  6,10EB,0,0,0) @ 22
	//						_2fcf_2444(  3,  5,10EB,1,0,0) @ 22

	// creature has dropped	_2fcf_2444(  3,  3,6009,0,1,0) @ 22

	//CSBWin:/PlaceOrRemoveObjectInRoom (TAG013380)

	//^2FCF:2444
	//^2FCF:244A
	ObjectID *bp1c = 0;
	//^2FCF:2454
	Bit16u bp0e;
	Bit16u di;
	/*SkD((DLV_TWEET, "Tweet: Invoked _2fcf_2444 (x:%d, y:%d, object:%s) (s:%d, t:%d, y:%d) \n"
		, xpos, ypos, static_cast<LPCSTR>(getRecordNameOf(recordLink)), ss, tt, uu
		));*/
	if (recordLink != OBJECT_NULL) {
		//^2FCF:245A
		bp0e = recordLink.DBType();
		//^2FCF:2466
		di = GET_DISTINCTIVE_ITEMTYPE(recordLink);
		//^2FCF:2471
		ObjectID bp2c = GET_CREATURE_AT(xpos, ypos);
		//^2FCF:2481
		if (bp2c != OBJECT_NULL) {
			//^2FCF:2486
			Creature *bp08 = GET_ADDRESS_OF_RECORD4(bp2c);
			//^2FCF:2495
			AIDefinition *bp0c = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp08->CreatureType());
			//^2FCF:24A9
			if (uu != 0 && (place == FCT_REMOVE_OFF || (bp0c->IsStaticObject() != 0 && bp0c->w30_11_11() != 0))) {
				//^2FCF:24C7
				bp1c = &bp08->possession;
			}
		}
	}
	else {
		//^2FCF:24D7
		bp0e = 0xffff;
		di = 0xffff;
	}
	//^2FCF:24DF
	if (place == FCT_REMOVE_OFF && bp0e != 0xffff) {
		//^2FCF:24EB
		if (bp1c == NULL) {
			//^2FCF:24F3
			CUT_RECORD_FROM(recordLink, NULL, xpos, ypos);
		}
		else {
			//^2FCF:24FF
			CUT_RECORD_FROM(recordLink, bp1c, -1, 0);
		}
	}
	//^2FCF:2514
	Bit16u bp2a = glbCurrentTileMap[xpos][ypos];
	//^2FCF:252E
	Bit16u bp1e;
	if ((bp2a >> 5) == ttWall) {
		//^2FCF:2535
		bp1e = recordLink.Dir();
	}
	else {
		//^2FCF:2540
		bp1e = 0xffff;
	}
	//^2FCF:2545
	Bit16u bp26 = 0;
	Bit16u bp24 = 0;
	Bit16u bp22 = 0;
	Bit16u bp20 = 0;
	//^2FCF:2553
	ObjectID si = GET_TILE_RECORD_LINK(xpos, ypos);
	//^2FCF:2562
	if (si == OBJECT_NULL) {
		//^2FCF:256B
		for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^2FCF:256E
			Bit16u bp12 = si.DBType();
			//^2FCF:2579
			if (bp12 == dbCreature && IS_OBJECT_FLOATING(si) == 0) {
				//^2FCF:2588
				if ((QUERY_CREATURE_AI_SPEC_FLAGS(si) & 0x0001) != 0 && _1c9a_06bd(si, di, 255) != NULL) {
					//^2FCF:25A5
					bp24 = 1;
				}
				else {
					//^2FCF:25AA
					bp22 = 1;
				}
			}
			//^2FCF:25B2
			if (bp12 == dbText && bp0e == 0xffff && place == FCT_PLACE_ON && ss == 0) { // if (bp12 == dbText && bp0e == 0xffff && place != FCT_REMOVE_OFF && ss == 0) {
				//^2FCF:25CA
				Text *bp18 = GET_ADDRESS_OF_RECORD2(si);
				//^2FCF:25D7
				if (bp18->TextMode() != 0 || bp18->TextVisibility() == 0)
					//^2FCF:25F0
					continue;
				//^2FCF:25F2
				Bit8u bp0106[200];
				QUERY_MESSAGE_TEXT(bp0106, si, 1);
				//^2FCF:2603
				DISPLAY_HINT_TEXT(COLOR_WHITE, bp0106);
				//^2FCF:2613
				continue;
			}
			//^2FCF:2615
			if (bp12 > 4 && bp12 < 14) {
				//^2FCF:2621
				bp20 = 1;
				//^2FCF:2626
				bp24 |= (GET_DISTINCTIVE_ITEMTYPE(si) == di) ? 1 : 0;
				//^2FCF:263B
				bp26 |= (GET_DISTINCTIVE_ITEMTYPE(si) != di) ? 1 : 0;
			}
			//^2FCF:2650
		}
	}
	else {
		for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^2FCF:2663
			if (si.Dir() == bp1e && si.DBType() > dbCreature) {
				//^2FCF:267A
				bp20 = 1;
				//^2FCF:267F
				bp24 |= (GET_DISTINCTIVE_ITEMTYPE(si) == di) ? 1 : 0;
				//^2FCF:2694
				bp26 |= (GET_DISTINCTIVE_ITEMTYPE(si) != di) ? 1 : 0;
			}
			//^2FCF:26B2
		}
	}
	//^2FCF:26B7
	if (place == FCT_PLACE_ON && bp0e != 0xffff) { // if (place != FCT_REMOVE_OFF && bp0e != 0xffff) {
		//^2FCF:26C3
		if (bp1c == NULL) {
			//^2FCF:26CB
			APPEND_RECORD_TO(recordLink, NULL, xpos, ypos);
		}
		else {
			//^2FCF:26D7
			APPEND_RECORD_TO(recordLink, bp1c, -1, 0);
		}
	}
	//^2FCF:26EC
	for (si = GET_TILE_RECORD_LINK(xpos, ypos); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^2FCF:26FC
		if (bp1e != 0xffff	// SPX: FIX: changed to "!=" instead of "==" => bp1e = direction on wall (and 0xffff on ground...) so it must not be 0xffff
			&& IS_REBIRTH_ALTAR(si) != 0
			&& QUERY_CLS1_FROM_RECORD(recordLink) == GDAT_CATEGORY_MISCELLANEOUS
			&& QUERY_CLS2_FROM_RECORD(recordLink) == 0) {	// Misc 0 = someone's bones
			//^2FCF:2730
			__int16 bp2e = ADD_ITEM_CHARGE(recordLink, 0);
			//^2FCF:273F
			if (bp2e < 0 || bp2e >= glbChampionsCount)
				//^2FCF:274E
				break;
			//^2FCF:2751
			Timer bp3c;
			bp3c.SetMap(glbCurrentMapIndex);
			bp3c.SetTick(glbGameTick + 1);
			//^2FCF:2774
			bp3c.TimerType(ttyResurrect);
			bp3c.actor = (Bit8u)bp2e;
			bp3c.Xcoord((Bit8u)xpos);
			bp3c.Ycoord((Bit8u)ypos);
			bp3c.Value2(bp1e);
			bp3c.ActionType(2);
			//^2FCF:2794
			QUEUE_TIMER(&bp3c);
			//^2FCF:27A0
			break;
		}
		//^2FCF:27A3
		Bit16u bp12 = si.DBType();
		//^2FCF:27AE
		if (bp12 == dbActuator) {
			//^2FCF:27B6
			Actuator *bp04 = GET_ADDRESS_OF_ACTU(si);
			//^2FCF:27C3
			if (bp04->ActuatorType() == 0)
				//^2FCF:27D1
				continue;
			//^2FCF:27D4
			Bit16u bp14 = bp04->ActuatorData();
			Bit16u bp10 = place;
			//^2FCF:27EA
			Bit16u bp3e;
			if (bp1e == 0xffff) {
				//^2FCF:27F3
				switch (bp04->ActuatorType()) {
					default:
						//^2FCF:2801
						continue;
					case 1: // 0x01: Activator, trap floor
						//^2FCF:280B
						if (ss != 0)
							//^2FCF:2811
							continue;
						//^2FCF:2814
						if (bp20 != 0)
							//^2FCF:281A
							continue;
						//^2FCF:281D
						if (bp22 == 0)
							//^2FCF:2823
							goto _29a8;
						//^2FCF:2826
						continue;
					case 2: // 0x02: -
						//^2FCF:2829
						if (bp0e > 4)
							//^2FCF:282F
							continue;
						//^2FCF:2832
						if (ss != 0)
							//^2FCF:2838
							continue;
						//^2FCF:283B
						if (bp22 == 0)
							//^2FCF:2841
							goto _29a8;
						//^2FCF:2844
						continue;
					case 3: // 0x03: Activator, trap floor
						//^2FCF:2847
						if (bp0e != 0xffff)
							//^2FCF:284D
							continue;
						//^2FCF:2850
						if (glbChampionsCount == 0)
							//^2FCF:2857
							continue;
						//^2FCF:285A
						if (bp14 == 0) {
							//^2FCF:2860
							if (ss == 0)
								//^2FCF:2866
								goto _29a8;
							//^2FCF:2869
							continue;
						}
						//^2FCF:286C
						if (place == FCT_REMOVE_OFF) {
							//^2FCF:2872
							bp10 = 0;
							//^2FCF:2877
							goto _29a8;
						}
						//^2FCF:287A
						bp10 = (glbPlayerDir +1 == bp14) ? 1 : 0;
						//^2FCF:288D
						goto _29a8;
					case 4: // 0x04: Activator, trap floor
						//^2FCF:2890
						if (bp14 != di)
							//^2FCF:2895
							continue;
						//^2FCF:2898
						if (bp24 == 0)
							//^2FCF:289E
							goto _29a8;
						//^2FCF:28A1
						continue;
					case 5: // 0x05: -
					case 6: // 0x06: -
						//^2FCF:2D72
						continue;
					case 7: // 0x07: Activator, trap floor
						//^2FCF:28A4
						if (bp0e > 4)
							//^2FCF:28AA
							continue;
						//^2FCF:28AD
						if (bp0e == 0xffff)
							//^2FCF:28B3
							continue;
						//^2FCF:28B6
						if (bp22 == 0)
							//^2FCF:28BC
							continue;
						//^2FCF:28BF
						continue;
					case 8: // 0x08: Activator, trap floor
						//^2FCF:28C2
						if (bp0e != 0xffff)
							//^2FCF:28C8
							continue;
						//^2FCF:28CB
						bp10 = _2fcf_16ff(bp14);
						//^2FCF:28D6
						goto _29a8;
				}
			}
			//^2FCF:28D9
			if (si.Dir() != bp1e)
				//^2FCF:28E3
				continue;
			//^2FCF:28E6
			bp3e = bp04->ActuatorType();
			//^2FCF:28F3
			switch (bp3e) {
				case ACTUATOR_TYPE_KEY_HOLE: // &H1A -> Activator, key hole
					{
						//^2FCF:2952
						if (bp24 != 0)
							//^2FCF:2958
							continue;
						//^2FCF:295B
						if (bp04->OnceOnlyActuator() == place)
							//^2FCF:296D
							continue;
						//^2FCF:2970
						if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, GET_WALL_DECORATION_OF_ACTUATOR(bp04), dtWordValue, 0x0e) != di)
							//^2FCF:2990
							continue;
						//^2FCF:2993
						bp04->OnceOnlyActuator(place);
						//^2FCF:29A8
_29a8:
						bp10 = bp10 ^ bp04->RevertEffect();
						//^2FCF:29BD
						Bit16u bp28 = bp04->ActionType();
						//^2FCF:29CA
						if (bp28 == 3) {
							//^2FCF:29CF
							bp28 = (bp10 != 0) ? 0 : 1;
						}
						else {
							//^2FCF:29E1
							if (bp10 == 0)
								//^2FCF:29E7
								continue;
						}
						//^2FCF:29EA
						if (bp04->SoundEffect() != 0) {
							//^2FCF:29FB
							QUEUE_NOISE_GEN2(
								(bp1e == 0xffff) ? GDAT_CATEGORY_FLOOR_GFX : GDAT_CATEGORY_WALL_GFX,
//									(bp1e == 0xffff) ? 0x0a : 0x09,
								(bp1e == 0xffff)
									? GET_FLOOR_DECORATION_OF_ACTUATOR(bp04)
									: GET_WALL_DECORATION_OF_ACTUATOR(bp04),
								SOUND_STD_ACTIVATION,
								0xfe,
								xpos,
								ypos,
								0x01,
								0x8c,
								0x80
								);
						}
						//^2FCF:2A47
						INVOKE_ACTUATOR(bp04, bp28, 0);
						//^2FCF:2A59
						continue;
					}
				case ACTUATOR_TYPE_X29: // &H29 -> -
					{
						//^2FCF:290C
						if (bp20 == 0)
							//^2FCF:2912
							goto _29a8;
						//^2FCF:2915
						continue;
					}
				case ACTUATOR_TYPE_ALCOVE_ITEM_TRAP: // &H2A -> Activator, alcove item trap
					{
						//^2FCF:2918
						if (bp24 != 0)
							//^2FCF:291E
							continue;
						//^2FCF:2921
						if (bp04->ActuatorData() == di)
							//^2FCF:2930
							goto _29a8;
						//^2FCF:2932
						continue;
					}
				case ACTUATOR_TYPE_X2B: // &H2B -> -
					{
						//^2FCF:2935
						if (bp26 != 0)
							//^2FCF:293B
							continue;
						//^2FCF:293E
						if (bp04->ActuatorData() != di)
							//^2FCF:294D
							goto _29a8;
						//^2FCF:294F
						continue;
					}
			}
			//^2FCF:2905
			continue;
		}
		//^2FCF:2A5C
		if (bp12 == dbText) {
			//^2FCF:2A65
			Text *bp18 = GET_ADDRESS_OF_RECORD2(si);
			//^2FCF:2A72
			if (bp18->TextMode() == 1) { }
			//^2FCF:2A81
			if (bp1e == 0xffff) {
				//^2FCF:2A8A
				// SPX: That part is called when an animated wall (even simple actuator) loops animation
				if (bp18->SimpleTextExtUsage() != 9) { // 0x09 -> ?
					//^2FCF:2AA2
					if (bp18->SimpleTextExtUsage() == 10) { // 0x0a -> Marsh
						//^2FCF:2AA7
						//^2FCF:2B5B
						if (bp0e != 0xffff)
							//^2FCF:2B61
							continue;
						//^2FCF:2B64
						if (place == FCT_PLACE_ON) // if (place != FCT_REMOVE_OFF)
							//^2FCF:2B6A
							continue;
						//^2FCF:2B6D
						if (glbChampionsCount == 0)
							//^2FCF:2B74
							continue;
						//^2FCF:2B77
						Bit16u bp32 = 0;
						Bit16u bp30 = 0;
						//^2FCF:2B81
						for (; bp30 < glbChampionsCount; bp30++) {
							//^2FCF:2B83
							if (glbChampionSquad[bp30].curHP() != 0) {
								//^2FCF:2B94
								bp32 = bp32 + GET_PLAYER_WEIGHT(bp30) / MAX_LOAD(&glbChampionSquad[bp30]);
							}
							//^2FCF:2BC3
						}
						//^2FCF:2BCF
						bp32 = min_value(90, (bp32 * 10) + ((bp18->TextVisibility() != 0) ? 50 : 25));
						//^2FCF:2BFE
						// SPX: When the party is bogged down
						if (ss == 0 && RAND16(100) < bp32) {
							//^2FCF:2C17
							Timer bp3c;
							bp3c.SetTick(glbGameTick);
							bp3c.SetMap(glbCurrentMapIndex);
							//^2FCF:2C34
							bp3c.TimerType(tty5D);
							bp3c.actor = 0;
							bp3c.b6_0_4((Bit8u)xpos);
							bp3c.w6_5_9(ypos);
							bp3c.Value2((Bit8u)glbPlayerMap);
							bp3c.w6_a_b(glbPlayerDir);
							//^2FCF:2C70
							QUEUE_TIMER(&bp3c);
							//^2FCF:2C7C
							bp30 = RAND02();
							//^2FCF:2C84
							if (glbChampionSquad[bp30].curHP() == 0) {
								//^2FCF:2C92
								bp30 = glbChampionLeader;
							}
							//^2FCF:2C98
							QUEUE_NOISE_GEN2(
								GDAT_CATEGORY_CHAMPIONS,
								glbChampionSquad[bp30].HeroType(),
								SOUND_CHAMPION_GETHIT,
								0xfe,
								glbPlayerPosX,
								glbPlayerPosY,
								0x01,
								0x69,
								0xc8
								);
							//^2FCF:2CC6
							continue;
						}
						//^2FCF:2CC9
						QUEUE_NOISE_GEN1(
							GDAT_CATEGORY_FLOOR_GFX,
							((Bit8u)bp18->TextIndex()) & 0xff,
							SOUND_STD_ACTIVATION,
							0x8c,
							0x80,
							glbPlayerPosX,
							glbPlayerPosY,
							0x01
							);
						//^2FCF:2CF6
						continue;
					}
					//^2FCF:2AAA
					continue;
				}
				//^2FCF:2AAD
				if (bp0e != 0xffff) {
					//^2FCF:2AB3
					continue;
				}
				//^2FCF:2AB6
				if (ss != 0) {
					//^2FCF:2ABC
					continue;
				}
				//^2FCF:2ABF
				if (glbChampionsCount == 0) {
					//^2FCF:2AC6
					continue;
				}
				//^2FCF:2AC9
				if (RAND16(100) >= (bp18->TextIndex() & 0x00ff)) {
					//^2FCF:2AE7
					continue;
				}
				//^2FCF:2AEA
				Bit16u bp10 = (bp18->TextVisibility() != place) ? 1 : 0;
				//^2FCF:2B00
				INVOKE_MESSAGE(
					xpos,
					ypos,
					0,
					(bp10 != 0) ? 0 : 1,
					glbGameTick +1
					);
				//^2FCF:2B2C
				INVOKE_MESSAGE(
					xpos,
					ypos,
					0,
					(bp10 != 0) ? 1 : 0,
					glbGameTick +5
					);
				//^2FCF:2B58
				continue;
			}
			//^2FCF:2CF8
			if (si.Dir() != bp1e)
				//^2FCF:2D00
				continue;
			//^2FCF:2D02
			if (bp18->SimpleTextExtUsage() != 4 && bp18->SimpleTextExtUsage() != 8)
				//^2FCF:2D1F
				continue;
			//^2FCF:2D21
			if (bp24 != 0)
				//^2FCF:2D25
				continue;
			//^2FCF:2D27
			if (bp18->TextVisibility() == place)
				//^2FCF:2D34
				continue;
			//^2FCF:2D36
			//if (QUERY_GDAT_ENTRY_DATA_INDEX(0x09, ((Bit8u)bp18->TextIndex()) & 0xff, dtWordValue, 0x0e) != di)
			if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, ((Bit8u)bp18->TextIndex()) & 0xff, dtWordValue, GDAT_WALL_ORNATE__IS_ITEM_TRIGGERED) != di)
				//^2FCF:2D56
				continue;
			//^2FCF:2D58
			bp18->TextVisibility(place);
			//^2FCF:2D6A
			continue;
		}
		//^2FCF:2D6C
		if (bp12 >= dbCreature)
			//^2FCF:2D70
			break;
		//^2FCF:2D72
	}

	//^2FCF:2D83
	return;
}

//^1C9A:156A
void SkWinCore::DELETE_CREATURE_RECORD(__int16 xpos, __int16 ypos, Bit16u dropMode, Bit16u tt)	// ss = dropMode
{
	SkD((DLV_DBM, "DBM: DELETE_CREATURE_RECORD(%2d,%2d,%04X,%04X)\n"
		, (Bitu)xpos, (Bitu)ypos, (Bitu)dropMode, (Bitu)tt));

	//^1C9A:156A
	//^1C9A:1570
	ObjectID si = GET_CREATURE_AT(xpos, ypos);
	//^1C9A:157E
	if (si == OBJECT_NULL)
		//^1C9A:1583
		return;
	//^1C9A:1586
	Creature *bp04 = GET_ADDRESS_OF_RECORD4(si);
	//^1C9A:1593
	AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType());
	//^1C9A:15A7
	if (bp08->IsStaticObject() == 0) {
		//^1C9A:15B4
		Bit16u bp10 = QUERY_GDAT_CREATURE_WORD_VALUE(bp04->CreatureType(), 0x01);
		//^1C9A:15C8
		Bit16u di = _4976_3752[bp10];
		//^1C9A:15D0
		if ((di & 0x0004) == 0) {
			//^1C9A:15D6
			Creature *bp0c = bp04;
			//^1C9A:15E5
			Bit16u bp0e = glbCurrentMapIndex;
			//^1C9A:15EB
			CHANGE_CURRENT_MAP_TO(bp0c->TriggerMap());
			//^1C9A:15FF
			INVOKE_MESSAGE(bp0c->TriggerX(), bp0c->TriggerY(), 0, 0, glbGameTick +1);
			//^1C9A:162E
			CHANGE_CURRENT_MAP_TO(bp0e);
		}
	}
	//^1C9A:1637
	MOVE_RECORD_TO(si, xpos, ypos, -4, 0);
	//^1C9A:164A
	DROP_CREATURE_POSSESSION(si, xpos, ypos, dropMode, tt);
	//^1C9A:165E
	_1c9a_0247(si);
	//^1C9A:1664
	DEALLOC_RECORD(si);
	//^1C9A:166B
	return;
}

//^1C9A:1374
// DROP_CREATURE_POSSESSION(ObjectID recordLink, __int16 xx, __int16 yy, Bit16u ss, __int16 tt)
// dropMode = 0 => GEN + POSSESS / dropMode = 2 => NOTHING
void SkWinCore::DROP_CREATURE_POSSESSION(ObjectID recordLink, __int16 xx, __int16 yy, Bit16u dropMode, __int16 tt)
{
	//^1C9A:1374
	//^1C9A:137A
	if (dropMode == CREATURE_NO_DROP)	// dropMode == 2
		return;
	//^1C9A:1383
	Creature *bp04 = GET_ADDRESS_OF_RECORDX4(recordLink);
	//^1C9A:1392
	ObjectID si;
	Bit16u di;
	if (dropMode == CREATURE_GENERATED_DROPS) {	// dropMode == 0
		//^1C9A:139B
		for (Bit16u bp0a = CREATURE_STAT_DROP_FIRST; bp0a <= CREATURE_STAT_DROP_LAST; bp0a++) { // for (Bit16u bp0a = 10; bp0a <= 20; bp0a++) {
			//^1C9A:13A3
			Bit16u bp06 = QUERY_GDAT_CREATURE_WORD_VALUE(bp04->CreatureType(), (Bit8u)bp0a);
			//^1C9A:13B9
			if (bp06 == 0)
				//^1C9A:13BF
				continue;

			// bp0c -> battle prize: base item count. 1 or 2 items.
			// bp0e -> battle prize: additional random item count. from 0 to 6 items.

            //^1C9A:13C2
			Bit16u bp0c = (bp06 & 15) + 1;
			//^1C9A:13C9
			Bit16u bp0e = (bp06 & 0x0070) >> 4;
			//^1C9A:13D5
			if (bp0e != 0) {
				//^1C9A:13D9
				bp0c = bp0c + RAND16(bp0e +1);
			}
			//^1C9A:13E9
			bp06 >>= 7;
			//^1C9A:13ED
			while (bp0c-- != 0) {
				//^1C9A:13F0
				si = ALLOC_NEW_DBITEM(bp06);
				//^1C9A:13FB
				if (si == OBJECT_NULL)
					//^1C9A:1400
					break;
				//^1C9A:1403
				if (xx == glbPlayerPosX && yy == glbPlayerPosY) {
					//^1C9A:1415
					di = (glbPlayerDir + RAND01()) & 3;
				}
				else {
					//^1C9A:1428
					di = RAND02();
				}
				//^1C9A:142F
				MOVE_RECORD_TO(ObjectID(si, di), -1, 0, xx, yy);
				//^1C9A:144F
				if (tt >= 0) {
					//^1C9A:1455
					QUEUE_NOISE_GEN2(
						QUERY_CLS1_FROM_RECORD(si),
						QUERY_CLS2_FROM_RECORD(si),
						SOUND_STD_KNOCK,
                        0xfe,
						xx,
						yy,
						tt,
						0x003a,
						0x0080
						);
				}
				//^1C9A:1481
			}
			//^1C9A:148E
		}
	}
	//^1C9A:149A
	si = bp04->GetPossessionObject();
	//^1C9A:14A3
	if (si == OBJECT_END_MARKER)
		//^1C9A:14A8
		return;

	ObjectID bp08;
	do {
		//^1C9A:14AB
		bp08 = GET_NEXT_RECORD_LINK(si);
		//^1C9A:14B5
		if ((QUERY_CREATURE_AI_SPEC_FLAGS(recordLink) & 0x0001) == 0) {
			//^1C9A:14C3
			if (xx == glbPlayerPosX && yy == glbPlayerPosY) {
				//^1C9A:14D5
				di = (glbPlayerDir + RAND01()) & 3;
			}
			else {
				//^1C9A:14E8
				di = RAND02();
			}
			//^1C9A:14EF
			si.Dir(di);
		}
		//^1C9A:14FE
		if (si.DBType() == dbMissile) {
			//^1C9A:150B
			DEALLOC_RECORD(si);
		}
		else {
			//^1C9A:1514
			MOVE_RECORD_TO(si, -1, 0, xx, yy);

			SkD((DLV_TWEET, "Tweet: %s (a#%03d, x:%d, y:%d, map:%d) have left %s by death! \n"
				, static_cast<LPCSTR>(getRecordNameOf(recordLink))
				, recordLink.DBIndex()
				, xx
				, yy
				, glbCurrentMapIndex
				, static_cast<LPCSTR>(getRecordNameOf(si))
				));

			//^1C9A:1527
			if (tt >= 0) {
				//^1C9A:152D
				QUEUE_NOISE_GEN2(
					QUERY_CLS1_FROM_RECORD(si),
					QUERY_CLS2_FROM_RECORD(si),
					SOUND_STD_KNOCK,
					0xfe,
					xx,
					yy,
					tt,
					0x3a,
					0x80
					);
			}
		}
		//^1C9A:1559
		si = bp08;
		//^1C9A:155E
	} while (si != OBJECT_END_MARKER);

	//^1C9A:1566
	return;
}

//^2FCF:00B2
ObjectID SkWinCore::ROTATE_RECORD_BY_TELEPORTER(Teleporter *ref, ObjectID recordLink)
{
	//^2FCF:00B2
	//^2FCF:00B7
	ObjectID cx = recordLink;
	//^2FCF:00BA
	Bit16u si = _4976_581e;
	//^2FCF:00BE
	Bit16u di = ref->Rotation();
	//^2FCF:00CD
	if (ref->RotationType() != 0) {
		//^2FCF:00DB
		si = di;
	}
	else {
		//^2FCF:00DF
		si = (si + di) & 3;
		//^2FCF:00E8
		cx.Dir(cx.Dir() + di);
	}
	//^2FCF:00FF
	_4976_581e = si;
	//^2FCF:0103
	return cx;
}

//^2FCF:0009
void SkWinCore::ROTATE_CREATURE(ObjectID recordLink, Bit16u rotationType, Bit16u rotation)
{
	SkD((DLV_DBM, "DBM: ROTATE_CREATURE(%04X,%d,%d)\n"
		, (Bitu)recordLink.w, (Bitu)rotationType, (Bitu)rotation));

	//^2FCF:0009
	//^2FCF:000F
	Creature *creature = GET_ADDRESS_OF_RECORD4(recordLink);	//*bp08
	//^2FCF:001E
	Bit16u di = creature->b15_0_1();
	//^2FCF:002A
	Bit16u si;
	if (rotationType != 0) {
		//^2FCF:0030
		si = rotation;
	}
	else {
		//^2FCF:0035
		si = (di + rotation) & 3;
	}
	//^2FCF:003F
	Bit16u bp0a = (si - di) & 3;
	//^2FCF:0049
	creature->b15_0_1(si);
	//^2FCF:005A
	if ((QUERY_CREATURE_AI_SPEC_FLAGS(recordLink) & 0x0001) != 0) {
		//^2FCF:0068
		ObjectID *bp04 = &creature->possession;
		//^2FCF:0076
		while (*bp04 != OBJECT_END_MARKER) {
			//^2FCF:0078
			bp04->Dir(bp04->Dir() + bp0a);
			//^2FCF:0096
			bp04 = &(GET_ADDRESS_OF_RECORD(*bp04)->w0);
			//^2FCF:00A5
		}
	}
	//^2FCF:00AE
	return;
}

//^2C1D:01DD
void SkWinCore::ROTATE_SQUAD(Bit16u dir)
{
	//^2C1D:01DD
	//^2C1D:01E3
	Bit16u di = dir;
	//^2C1D:01E6
	if (di != glbPlayerDir) {
		//^2C1D:01EC
		__int16 dx = di - glbPlayerDir;
		//^2C1D:01F4
		if (dx < 0)
			//^2C1D:01F8
			dx += 4;
		//^2C1D:01FB
		Champion *bp04 = glbChampionSquad;
		//^2C1D:0203
		for (Bit16u si=0; si < glbChampionsCount; bp04++, si++) {
			//^2C1D:0207
			bp04->playerPos(bp04->playerPos() + (Bit8u)dx);
			//^2C1D:0216
			bp04->playerDir(bp04->playerDir() + (Bit8u)dx);
			//^2C1D:0222
		}
		//^2C1D:022E
		glbPlayerDir = di;
		//^2C1D:0232
		if (_4976_4c08 != 0) {
			//^2C1D:0239
			_4976_4c2c = _4976_4c10 = (_4976_4c10 + dx) & 3;
		}
		else {
			//^2C1D:0246
			_4976_4c2c = glbPlayerDir;
		}
	}
	//^2C1D:024C
	return;
}

//^2FCF:0434
// TODO related to teleporter and falling into pits
Bit16u SkWinCore::_2fcf_0434(ObjectID recordLink, __int16 xpos, __int16 ypos, __int16 xx, __int16 yy, Bit16u zz)
{
	//^2FCF:0434
	//^2FCF:043A
	ObjectID si = recordLink;
	_4976_5822 = 0;
	Bit16u bp14 = 0; // 1 if telefragged?
	Bit16u bp12 = 0;
	Bit16u bp20 = glbCurrentMapIndex; // curmap
	Bit16u di = glbCurrentMapIndex; // curmap
	//^2FCF:0452
	Bit16u bp28;
	Bit16u bp1e;
	Bit16u bp26;
	Bit16u bp24; // teleporter scope
	if (si == OBJECT_NULL) {
		//^2FCF:0457
		if (_4976_4ddc != 0) {
			//^2FCF:045E
			_4976_4ddc = 0;
			_29ee_000f();
		}
		//^2FCF:0469
		glbPlayerPosX = xx;
		glbPlayerPosY = yy;
		bp24 = 2;
		//^2FCF:047A
		bp26 = (glbChampionInventory == 0 && glbIsPlayerSleeping == 0) ? 1 : 0;
		bp1e = 0xffff;
		bp28 = 0;
	}
	else {
		//^2FCF:049E
		bp28 = IS_OBJECT_FLOATING(si);
		bp1e = si.DBType();
		bp24 = 3;
		//^2FCF:04B7
		if (bp1e == dbCreature) {
			//^2FCF:04BD
			bp24 = (QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0x1e) != 0) ? 2 : 1;
		}
		//^2FCF:04D9
		else if (bp1e == dbMissile) {
			//^2FCF:04DF
			Missile *bp04 = GET_ADDRESS_OF_RECORD(si)->castToMissile();
			//^2FCF:04EC
			_4976_581e = glbTimersTable[bp04->TimerIndex()].Direction();
		}
		//^2FCF:050B
		bp26 = 0;
	}
	//^2FCF:0510
	for (Bit16u bp1a = 50; bp1a != 0; --bp1a) {
		//^2FCF:0518
		Bit16u bp16 = glbCurrentTileMap[xx][yy];
		//^2FCF:0532
		Bit16u bp18 = bp16 >> 5;	
		//^2FCF:053A
		if (bp18 == ttTeleporter) {
			//^2FCF:0542
			if ((bp16 & 0x0008) == 0)
				//^2FCF:0549
				break;
			//^2FCF:054C
			Teleporter *bp04 = GET_ADDRESS_OF_TILE_RECORD((Bit8u)xx, (Bit8u)yy)->castToTeleporter();
			//^2FCF:055F
			if (bp04->Scope() == scopeCreatures && bp1e != dbCreature)
				//^2FCF:0577
				break;
			//^2FCF:057A
			if (bp24 != 3) {
				//^2FCF:0580
				if ((bp24 & bp04->Scope()) == 0)
					//^2FCF:0592
					break;
			}
			//^2FCF:0595
			bp14 = (bp04->DestinationX() == xx && bp04->DestinationY() == yy && bp04->DestinationMap() == di) ? 1 : 0;
			//^2FCF:05C8
			xx = bp04->DestinationX();
			yy = bp04->DestinationY();
			_4976_5822 = bp04->Sound();
			di = bp04->DestinationMap();
			//^2FCF:05F8
			CHANGE_CURRENT_MAP_TO(di);
			//^2FCF:05FF
			if (si == OBJECT_NULL) {
				//^2FCF:0604
				glbPlayerPosX = xx;
				glbPlayerPosY = yy;
				//^2FCF:0610
				if (bp04->Sound() != 0) {
					//^2FCF:0621
					// SPX: TODO More in the spirit, it should call the 0x18 (teleporter) category instead of 0x03 (messages),
					// and use the index of teleporter (is it possible?)
					//if (!SkCodeParam::bUseDM2ExtendedMode)
						QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES,0x00,SOUND_STD_TELEPORT_MESSAGE,0x61,0x80,glbPlayerPosX,glbPlayerPosY,-1);
					//else
					//	QUEUE_NOISE_GEN1(GDAT_CATEGORY_TELEPORTERS,0x00,SOUND_STD_TELEPORT,0x61,0x80,glbPlayerPosX,glbPlayerPosY,-1);
				}
				//^2FCF:063F
				if (bp20 == di) {
					//^2FCF:0644
					bp26 &= _4976_5bee[0];
				}
				//^2FCF:064C
				ROTATE_SQUAD((bp04->Rotation() + ((bp04->RotationType() != 0) ? 0 : glbPlayerDir)) & 3);
			}
			//^2FCF:0680
			else if (bp1e == dbCreature && zz != 00) {
				//^2FCF:068C
				if (bp04->Sound() != 0) {
					//^2FCF:069D
					QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES,0x00,SOUND_STD_TELEPORT_MESSAGE,0x61,0x80,xx,yy,0x01);
				}
				//^2FCF:06B9
				ROTATE_CREATURE(si, bp04->RotationType(), bp04->Rotation());
			}
			//^2FCF:06DC
			else if (bp1e == dbMissile) {
				//^2FCF:06E2
				si = ROTATE_RECORD_BY_TELEPORTER(bp04, si);
			}
			//^2FCF:06F4
			else if (bp04->RotationType() == 0 && xpos != -2) {
				//^2FCF:070B
				si.Dir(si.Dir() + bp04->Rotation());
			}
			//^2FCF:072D
			if (bp14 == 0)
				//^2FCF:0733
				continue;
			//^2FCF:0736
			break;
		}
		//^2FCF:0739
		// SPX: Add special switchable paramater to not fall into pits
		if (bp18 == ttPit && bp28 == 0 && (bp16 & 8) != 0 && (bp16 & 1) == 0 && !SkCodeParam::bWalkOverPits) {
			//^2FCF:075F
			// SPX: Retrieving 1 (only for VOID set) tells to do special treatment when falling into a pit
			Bit16u bp2a = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, dunMapLocalHeader->MapGraphicsStyle(), dtWordValue, GDAT_GFXSET_VOID_RANDOM_FALL);
			//^2FCF:077F
			if (bp2a != 0 && bp1e == dbCreature) {
				//^2FCF:078B
				Creature *bp10 = GET_ADDRESS_OF_RECORD(si)->castToCreature();
				//^2FCF:0798
				xx = bp10->TriggerX();
				yy = bp10->TriggerY();
				di = bp10->TriggerMap();
				//^2FCF:07BE
				CHANGE_CURRENT_MAP_TO(di);
				//^2FCF:07C5
				continue;
			}
			//^2FCF:07C8
			if (bp26 != 0 && bp2a == 0 && _4976_5824 == 0) {
				//^2FCF:07DB
				bp26 = _4976_5bee[0];
				//^2FCF:07E3
				if (bp12 != 0) {
					//^2FCF:07E9
					LOAD_LOCALLEVEL_GRAPHICS_TABLE(di);
					//^2FCF:07F0
					LOAD_LOCALLEVEL_DYN();
				}
				//^2FCF:07F5
				DISPLAY_VIEWPORT(glbPlayerDir, xx, yy);
				//^2FCF:0807
				CHANGE_VIEWPORT_TO_INVENTORY(1);
			}
			//^2FCF:080F
			if (bp2a != 0) {
				//^2FCF:0818
				Bit16u bp2e = 0;
				//^2FCF:081D
				ObjectID bp2c = GET_TILE_RECORD_LINK(xx, yy);
				//^2FCF:082A
				for (; bp2c != OBJECT_END_MARKER && ((bp1e = bp2c.DBType()) <= dbActuator); bp2c = GET_NEXT_RECORD_LINK(bp2c)) {
					//^2FCF:082C
					if (bp1e == dbText) {
						//^2FCF:0832
						Text *bp0c = GET_ADDRESS_OF_RECORD(bp2c)->castToText();
						//^2FCF:0841
						if (bp0c->TextMode() == 1) {
							//^2FCF:0852
							if (bp0c->SimpleTextExtUsage() == 0x0c) {
								//^2FCF:0867
								bp2e = bp0c->TextIndex() & 0xff;
								//^2FCF:0877
								break;
							}
						}
					}
					//^2FCF:0879
				}
				//^2FCF:089C
				// SPX: 1) Counts how many "special markers" for valid destinations when falling from VOID.
				Bit16u bp30 = SEARCH_DUNGEON_FOR_SPECIAL_MARKER(SDFSM_CMD_COUNT_MARKERS, 0x0000, bp2e, &xx, &yy);
				SkD((DLV_FSM, "Found %d special markers.\n", bp30));
				//^2FCF:08B8
				// SPX: 2) Search one of this "special markers" with a random on the count
				di = SEARCH_DUNGEON_FOR_SPECIAL_MARKER(SDFSM_CMD_FIND_MAP_OFFVOID, RAND16(bp30), bp2e, &xx, &yy);
			}
			else {
				//^2FCF:08DC
				di = LOCATE_OTHER_LEVEL(di, 1, &xx, &yy, NULL);
			}
			//^2FCF:08FA
			CHANGE_CURRENT_MAP_TO(di);
			//^2FCF:0901
			if (si == OBJECT_NULL) {
				//^2FCF:0909
				glbPlayerPosX = xx;
				glbPlayerPosY = yy;
				//^2FCF:0915
				if (glbChampionsCount > 0) {
					//^2FCF:091F
					Champion *bp08;
					if (_4976_5824 != 0) {
						//^2FCF:0926
						bp26 = (_4976_5bee[0] != 0 && glbChampionInventory == 0 && glbIsPlayerSleeping == 0) ? 1 : 0;
						//^2FCF:0945
						bp08 = glbChampionSquad;
						//^2FCF:094D
						for (bp18=0; bp18 < glbChampionsCount; bp08++, bp18++) {
							//^2FCF:0954
							if (bp08->curHP() != 0) {
								//^2FCF:095E
								ADJUST_STAMINA(
									bp18,
									((GET_PLAYER_WEIGHT(bp18) * 25) / MAX_LOAD(bp08)) + 1
									);
							}
							//^2FCF:098D
						}
					}
					else {
						//^2FCF:09A1
						bp08 = glbChampionSquad;
						//^2FCF:09A9
						for (bp18 = 0; (bp18 < glbChampionsCount); bp08++, bp18++) {
							//^2FCF:09B0
							if (bp08->curHP() != 0) {
								//^2FCF:09BA
								WOUND_PLAYER(
									bp18, 
									min_value(bp08->maxHP() >> 2, 17) + RAND02(),
									0x0030,
									0x0002
									);
								//^2FCF:09E9
								// SPX: Noise when falling a pit
								QUEUE_NOISE_GEN2(
									GDAT_CATEGORY_CHAMPIONS,
									bp08->HeroType(),
									SOUND_CHAMPION_SCREAM,
									0xfe,
									glbPlayerPosX,
									glbPlayerPosY,
									0xffff,
									0x00be,
									0x00ff
									);
							}
							//^2FCF:0A12
						}
					}
				}
				//^2FCF:0A23
				_4976_5824 = 0;
				//^2FCF:0A29
				continue;
			}
			//^2FCF:0A2C
			if (bp1e != dbCreature)
				//^2FCF:0A32
				continue;
			//^2FCF:0A35
			if (zz == 0)
				//^2FCF:0A3B
				continue;
			//^2FCF:0A3E
			if (xpos >= 0) {
				//^2FCF:0A44
				CHANGE_CURRENT_MAP_TO(bp20);
				//^2FCF:0A4D
				ATTACK_CREATURE(
					si,
					xpos,
					ypos,
					0x0000,
					0x0000,
					0x0014
					);
			}
			//^2FCF:0A62
			CHANGE_CURRENT_MAP_TO(di);
			//^2FCF:0A69
			continue;
		}
		//^2FCF:0A6C
		if (bp18 != ttStairs || si == OBJECT_NULL || bp1e == 14 || bp1e == 4)
			//^2FCF:0A8C
			break;
		//^2FCF:0A8F
		if ((bp16 & 0x0004) == 0) {
			//^2FCF:0A96
			di = LOCATE_OTHER_LEVEL(di, 1, &xx, &yy, NULL);
			//^2FCF:0AB1
			CHANGE_CURRENT_MAP_TO(di);
		}
		//^2FCF:0AB8
		Bit16u bp22 = _0cee_06dc(xx, yy);
		//^2FCF:0AC8
		xx += glbXAxisDelta[bp22];
		//^2FCF:0AD4
		yy += glbYAxisDelta[bp22];
		//^2FCF:0AE0
		bp22 = (bp22 +2 ) & 3;
		//^2FCF:0AEB
		Bit16u bp1c = si.Dir();
		//^2FCF:0AF3
		bp1c = ((((bp1c - bp22 + 1) & 2) >> 1) + bp22) & 3;
		//^2FCF:0B05
		si.Dir(bp1c);

		//^2FCF:0B12
	}
	//^2FCF:0B1F
	_4976_5826 = xx;
	_4976_5828 = yy;
	_4976_581c = di;
	//^2FCF:0B2F
	_4976_5820 = si.Dir();
	//^2FCF:0B37
	if (bp12 != 0 && zz != 0 && si != OBJECT_NULL) {
		//^2FCF:0B48
		// SPX: Sound when an item hit an obstacle
		QUEUE_NOISE_GEN2(
			QUERY_CLS1_FROM_RECORD(si),
			QUERY_CLS2_FROM_RECORD(si),
			SOUND_STD_KNOCK,
			0xfe,
			xx,
			yy,
			0x0001,
			0x003a,
			0x0080
			);
	}
	//^2FCF:0B73
	CHANGE_CURRENT_MAP_TO(bp20);
	//^2FCF:0B7C
	_482b_05bf(1);
	//^2FCF:0B84
	return bp28;
}

//^1C9A:03CF
// TODO related creature size ? b35
ObjectID SkWinCore::_1c9a_03cf(__int16 *xx, __int16 *yy, Bit16u dir)
{
	//^1C9A:03CF
	//^1C9A:03D5
	__int16 bp0c = *xx;
	__int16 di = *yy;
	Bit16u bp10;
	Bit16u bp12;
	//^1C9A:03E4
	_098d_000f(
		bp0c, 
		di, 
		(dir == 255) ? 12 : (_4976_014c[RCJ(4,dir)]),
		&bp10,
		&bp12
		);
	//^1C9A:0410
	__int16 bp0e = 4;
	//^1C9A:0415
	for (__int16 si=0; si <= bp0e; si++) {
		//^1C9A:041A
		ObjectID bp06 = GET_CREATURE_AT(bp0c, di);
		//^1C9A:0427
		if (bp06 != OBJECT_NULL) {
			//^1C9A:042F
			Creature *bp04 = GET_ADDRESS_OF_RECORD(bp06)->castToCreature();
			//^1C9A:043E
			__int16 bp08 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType())->b35;
			//^1C9A:0458
			Bit16u bp14;
			Bit16u bp16;
			_098d_000f(
				bp0c,
				di,
				QUERY_CREATURE_5x5_POS(
					bp04,
					_4976_392c[RCJ(4,bp04->b15_0_1())]
					),
				&bp14,
				&bp16
				);
			//^1C9A:048F
			bp14 -= bp10;
			bp16 -= bp12;
			__int16 bp0a = (bp14 * bp14) + (bp16 * bp16);
			//^1C9A:04AE
			if (_4976_3924[RCJ(4,bp08)] > bp0a) {
				//^1C9A:04BC
				*xx = bp0c;
				*yy = di;
				//^1C9A:04CB
				return bp06;
			}
		}
		//^1C9A:04D0
		if (dir == 255) {
#if UseAltic
			//^1C9A:04D7
			bp0c = *xx + _4976_38f4[8 +si].w0;
			//^1C9A:04EE
			di = *yy + _4976_38f4[8 +si].w2;
#else
			//^1C9A:04D7
			bp0c = *xx + _4976_3914[RCJ(4,si)].w0;
			//^1C9A:04EE
			di = *yy + _4976_3914[RCJ(4,si)].w2;
#endif
		}
		else {
			//^1C9A:0504
			bp0c = *xx + _4976_38f4[RCJ(12,(dir << 1) + si)].w0;
			//^1C9A:0523
			di = *yy + _4976_38f4[RCJ(12,(dir << 1) + si)].w2;
		}
		//^1C9A:0541
	}
	//^1C9A:054A
	return OBJECT_NULL;
}

//^0CD5:0078
__int16 SkWinCore::ABS16(__int16 val)
{
	//^0CD5:0078
	//^0CD5:007C
	__int16 si = val;
	//^0CD5:007F
	if (si < 0) {
		//^0CD5:0083
		return -si;
	}
	//^0CD5:0089
	return si;
}

//^075F:1B61
Bit16u SkWinCore::CALC_VECTOR_DIR(__int16 x1, __int16 y1, __int16 x2, __int16 y2)
{
	// calc normal vector of: v2 - v1. v2=(x2,y2), v1=(x1,y1)
	//
	// return: 0 if v2 is at north from v1
	//         1 if v2 is at east from v1
	//         2 if v2 is at south from v1
	//         3 if v2 is at west from v1

	//^075F:1B61
	//^075F:1B66
	__int16 di = x2;
	__int16 si = y2;
	x1 -= di;
	di = ABS16(x1);
	//^075F:1B7B
	y1 -= si;
	si = ABS16(y1);
	//^075F:1B8B
	if (di == si) {
		//^075F:1B90
		if (RAND01() != 0) {
			//^075F:1B99
			di++;
		}
		else {
			//^075F:1B9C
			si++;
		}
	}
	//^075F:1B9D
	if (di < si) {
		//^075F:1BA1
		if (y1 > 0)
			//^075F:1BA7
			return 0;

		//^075F:1BAB
		return 2;
	}
	//^075F:1BB0
	if (x1 > 0) {
		//^075F:1BB6
		return 3;
	}
	//^075F:1BBB
	return 1;
}

//^075F:1B32
Bit16u SkWinCore::CALC_SQUARE_DISTANCE(__int16 x1, __int16 y1, __int16 x2, __int16 y2)
{
	// CSBwinSimilarity: TAG00f4c8,DistanceBetweenPoints

	//^075F:1B32
	//^075F:1B37
	__int16 di = x1;
	__int16 si = y1;
	//^075F:1B3D
	di -= x2;
	si -= y2;

	return ((di < 0) ? (-di) : di) + ((si < 0) ? (-si) : si);
}

//^4937:005C
// TODO: creature animation related ?
Bit16u SkWinCore::_4937_005c(Bit16u xx, Bit16u *yy)
{
	//^4937:005C
	//^4937:0061
	Bit16u si;
	if ((*yy & 0x4000) != 0) {
		//^4937:006B
		si = 0;
	}
	//^4937:006F
	else if ((*yy & 0x8000) != 0) {
		//^4937:0079
		Bit16u di;
		if ((*yy & 0x1000) != 0) {
			//^4937:0080
			*yy &= 0xe03f;
			di = 0;
		}
		else {
			//^4937:0089
			di = (*yy & 0x0fc0) >> 6;
		}
		//^4937:0097
		// SPX: TODO / I got this fall under divide by zero when replacing static AI table
		// by a new table. I don't understand why this happens, then I use some fix
		if (SkCodeParam::bUseFixedMode)
		{
			if ( (*yy & 0x003F) == 0)
				*yy = 1;
		}
		// SPX: What is this 0x3F (63) value? is it related to number of AI ??
		si = (glbGameTick + di) % (*yy & 0x003f);
	}
	else {
		//^4937:00B8
		si = *yy & 0x003f;
	}
	//^4937:00C3
	return xx + si;
}

//^4937:0036
// TODO: creature animation related, get some sequence
CreatureAnimationFrame* SkWinCore::_4937_0036(Bit16u xx, Bit16u *yy)
{
	//^4937:0036
	//^4937:0039
	return &tlbCreaturesAnimationSequences[_4937_005c(xx, yy)];
}

//^1C9A:198E
//SPX: _1c9a_198e renamed APPLY_CREATURE_POISON_RESISTANCE
Bit16u SkWinCore::APPLY_CREATURE_POISON_RESISTANCE(ObjectID recordLink, Bit16u iPoisonDamage)
{
	//CSBWin:Code11f52.cpp/TAG00bbbe/DeterminePoisonDamage
	//^1C9A:198E
	//^1C9A:1992
	if (iPoisonDamage != 0) {
		//^1C9A:1998
		Bit16u iPoisonResistance = QUERY_CREATURE_AI_SPEC_FROM_RECORD(recordLink)->GetPoisonResistance(); // si
		//^1C9A:19B1
		if (iPoisonResistance == 15) { // 15 == immune
			//^1C9A:19B6
			return 0;
		}
		//^1C9A:19BA
		return ((iPoisonDamage + RAND02()) << 3) / (iPoisonResistance + 2);
	}
	//^1C9A:19B6
	return 0;
}

void SkWinCore::PROCESS_QUEUED_DEALLOC_RECORD() {
	// kkdf2: ext for skwinspx
	while (!vecDelayDeallocRecords.empty()) {
		ObjectID recordLink = vecDelayDeallocRecords.top();
		DEALLOC_RECORD(recordLink);
		vecDelayDeallocRecords.pop();
	}
}

void SkWinCore::QUEUE_DEALLOC_RECORD(ObjectID recordLink) {
	// kkdf2: ext for skwinspx: it prevents you from watching many asserts when you put coin into your money box!
	vecDelayDeallocRecords.push(recordLink);
}

//^0CEE:1585
void SkWinCore::DEALLOC_RECORD(ObjectID recordLink)
{
	// it is a unused record if next object is FFFF.

	//^0CEE:1585
	//^0CEE:1588
	SkD((DLV_DBM,"DBM: DEALLOC_RECORD(%04X)\n", (Bitu)recordLink.w));
	GET_ADDRESS_OF_RECORD(recordLink)->w0 = OBJECT_NULL;
}

//^075F:06BD
// TODO: related to missile/item attack strength ?
Bit16u SkWinCore::_075f_06bd(Missile *ref, ObjectID recordLink) //#DS=4976?
{
	//^075F:06BD
	//^075F:06C3
	glbPoisonAttackDamage = 0;
	_4976_4b7a = 3;
	//^075F:06CF
	Bit16u di = ref->EnergyRemaining();
	//^075F:06DA
	Bit16u iAttackDamage = 0; // si
	if (recordLink.DBType() != dbCloud) {
		//^075F:06EB
		iAttackDamage = QUERY_GDAT_DBSPEC_WORD_VALUE(recordLink, GDAT_ITEM_WEAPON_THROW_STRENGTH);	// 0x09
		//^075F:06F9
		if (iAttackDamage != 0) {
			//^075F:06FD
			iAttackDamage += (di >> 1);
			//^075F:0703
			Bit16u bp02 = ref->b5_4_7() +3;
			//^075F:0715
			iAttackDamage = (bp02 * bp02 * iAttackDamage) >> 7;
			//^075F:071F
			_4976_4b7a = 4;
			//^075F:0725
			glbPoisonAttackDamage = QUERY_GDAT_DBSPEC_WORD_VALUE(recordLink, GDAT_ITEM_STATS_POISONOUS);	// 0x0D
			//^075F:0734
			if (glbPoisonAttackDamage != 0) {
				//^075F:0738
				if ((RAND() & 0x007f) > di) {
					//^075F:0744
					glbPoisonAttackDamage -= RAND16((glbPoisonAttackDamage >> 1) + 1);
				}
			}
		}
		//^075F:0755
		iAttackDamage += RAND02();
		//^075F:075C
		iAttackDamage += QUERY_ITEM_WEIGHT(recordLink);
		//^075F:0767
		if ((RAND() & 0x01ff) < ref->EnergyRemaining2()) {
			//^075F:077C
			iAttackDamage <<= 1;
		}
	}
	else {
		//^075F:0780
		// TODO: May check CSBWin for comparison
		if (recordLink == OBJECT_EFFECT_POISON_BLOB) {	// oFF81
			//^075F:0786
			iAttackDamage = RAND() & 0x000f;
			//^075F:0790
			glbPoisonAttackDamage = iAttackDamage + 10;
			//^075F:0796
			iAttackDamage += RAND() & 0x001f;
		}
		else {
			//^075F:07A2
			// SPX: TODO may need to reorganize this block
			if (recordLink >= OBJECT_EFFECT_DISPELL) {	// oFF83
				//^075F:07A8
				_4976_4b7a = 5;
				//^075F:07AE
				if (recordLink == OBJECT_EFFECT_POISON_BOLT) {	// oFF86
					//^075F:07B4
					glbPoisonAttackDamage = di >> 1;
					//^075F:07BB
					return (di >> 4) + 1;
				}
				//^075F:07C4
				return 0;
			}
			//^075F:07C9
			_4976_4b7a = 1;
			//^075F:07CF
			iAttackDamage = (RAND() & 0x000f) + (RAND() & 0x000f) + 10;
			//^075F:07E8
			if (recordLink == OBJECT_EFFECT_LIGHTNING) {	// oFF82
				//^075F:07EE
				_4976_4b7a = 7;
				//^075F:07F4
				iAttackDamage >>= 4;
				iAttackDamage += di;
			}
		}
	}
	//^075F:07F9
	iAttackDamage = ((iAttackDamage + di) >> 4) + 1;
	//^075F:0803
	iAttackDamage += RAND16((iAttackDamage >> 1) + 1) + RAND02();
	//^075F:0818
	iAttackDamage = max_value(iAttackDamage, iAttackDamage - 32 - ((ref->EnergyRemaining2() >> 3) << 1));
	//^075F:083A
	iAttackDamage = min_value(iAttackDamage, di << 1);
	//^075F:0847
	return iAttackDamage;
}

//^1C9A:0958
// TODO: get some info of creature anim ?
Bit16u SkWinCore::_1c9a_0958(ObjectID recordLink)
{
	//^1C9A:0958
	//^1C9A:095C
	Creature *creature = GET_ADDRESS_OF_RECORD(recordLink)->castToCreature();	//*bp04
	//^1C9A:096B
	sk1c9a02c3 *bp08 = _1c9a_02c3(creature, QUERY_CREATURE_AI_SPEC_FROM_TYPE(creature->CreatureType()));
	//^1C9A:098E
	CreatureAnimationFrame *bp0c = _4937_0036(bp08->w0, &bp08->w2);
	//^1C9A:09AB
	return (bp0c->w0 & 0x4000) >> 14;
}

//^0CD5:0118
// SPX: Random over 1 bits => range 0 to 1
Bit16u SkWinCore::_RAND01()
{
	// CSBwinSimilarity: TAG001050,STRandomBool

	//^0CD5:0118
	//^0CD5:011B
	glbRandomSeed = glbRandomSeed * 0xbb40e62d + 11;
	//^0CD5:013B
	return (glbRandomSeed >> 8) & 1;
	//^0CD5:0146
}

//^0CEE:328C
// SPX: _0cee_328c renamed GET_DOOR_STAT_0X10
Bit16u SkWinCore::GET_DOOR_STAT_0X10(Bit8u iDoorType) // Bit8u cls2
{
	//^0CEE:328C
	//^0CEE:328F
	// TODO what is 10 ??
	return QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorType, dtWordValue, GDAT_DOOR_X10); // 0x10
}

//^0CEE:322D
Bit8u SkWinCore::GET_GRAPHICS_FOR_DOOR(Door *ref)
{
	//^0CEE:322D
	//^0CEE:3230
	if (ref->DoorType() == 0) {
		//^0CEE:323E
		if (dunMapLocalHeader->b2_7_7() == 0)
			//^0CEE:3271
			return 0xff;
		//^0CEE:3254
		return dunMapLocalHeader->DoorType0();
	}
	else {
		//^0CEE:3259
		if (dunMapLocalHeader->b3_0_0() == 0)
			//^0CEE:3271
			return 0xff;
		//^0CEE:3268
		return dunMapLocalHeader->DoorType1();
	}
}

//^075F:0AF9
// SPX: Something to do when an item (missile) hit an obstacle
Bit16u SkWinCore::_075f_0af9(__int16 u16tileType, __int16 xpos, __int16 ypos, Bit16u dir, ObjectID rlMissile)
{
	//^075F:0AF9
	//^075F:0AFF
	Bit16u bp1c = 0;
	Bit16u bp2a = 0;
	//^075F:0B09
	Missile *bp08 = GET_ADDRESS_OF_RECORDE(rlMissile);
	//^075F:0B18
	ObjectID si = bp08->GetMissileObject();
	//^075F:0B21
	Bit16u bp2c = si.DBType();
	//^075F:0B2A
	Bit16u bp28;
	ObjectID bp1e;
	ObjectID bp20;
	tileTypeIndex tileType = UtilConvertU16ToTile(u16tileType);	// SPX added for safe conversion

	if (bp2c == dbPotion) {
		//^075F:0B2F
		Potion *bp04 = GET_ADDRESS_OF_RECORD(si)->castToPotion();
		//^075F:0B3C
		U8	potionType = 0;
		potionType = bp04->PotionType();

// SPX: STANDARD BEHAVIOUR, HARD CODED POTION BOMB TYPE
		if (!SkCodeParam::bUseDM2ExtendedMode)
		{
			switch (potionType)
			{
				case POTION_TYPE_VEN_BOMB: // 0x03 -> {VEN} BOMB
					//^075F:0B52
					bp20 = OBJECT_EFFECT_POISON_CLOUD;
					//^075F:0B57
					//^075F:0B5E
					bp2a = 1;
					//^075F:0B63
					bp28 = bp04->PotionPower();
					//^075F:0B70
					bp1e = si;
					break;
				case POTION_TYPE_FUL_BOMB: // 0x13 -> {FUL} BOMB
					//^075F:0B59
					bp20 = OBJECT_EFFECT_FIREBALL;
					//^075F:0B5E
					bp2a = 1;
					//^075F:0B63
					bp28 = bp04->PotionPower();
					//^075F:0B70
					bp1e = si;
					break;
			}
		}
// SPX: CUSTOM BEHAVIOUR more flexible
		else if (SkCodeParam::bUseDM2ExtendedMode)
		{
			// SPX: New way, retrieve a coded value
			bp20 = QUERY_GDAT_POTION_SPELL_TYPE_FROM_RECORD(si);
			// The first spell start at 0x80 to differenciate from 0x00 which is equals to no value
			if (bp20 != 0)
			{
				bp2a = 1;	// will explode
				bp20 = bp20 + 0xFF00;
				// Some control over
				bp20 = BETWEEN_VALUE(0xFF80, bp20, 0xFFFF);											
				bp28 = bp04->PotionPower();
				bp1e = si;
			}
			else
				bp2a = 0;	// won't explode
		}
// SPX: End of standard/custom block
	}
	//^075F:0B73
//		Bit16u bp26 = (bp2c == dbCloud && si != oFF81 && si != oFF86) ? 1 : 0;
	Bit16u bp26 = (bp2c == dbCloud && si != OBJECT_EFFECT_POISON_BLOB && si != OBJECT_EFFECT_POISON_BOLT) ? 1 : 0;
	//^075F:0B8D
	ObjectID *bp10 = NULL;
	Bit16u bp36 = 0;
	//^075F:0B9C
	__int16 bp22;
	__int16 bp24;
	if (xpos <= 255) {
		//^075F:0BA3
		bp22 = xpos;
		bp24 = ypos;
	}
	else {
		//^075F:0BB1
		bp22 = (xpos >> 8) -1;
		bp24 =  ypos >> 8;
		//^075F:0BC4
		xpos &= 255;
		ypos &= 255;
	}
	//^075F:0BCE
	__int16 bp30 = bp22;
	__int16 bp38 = bp22;
	__int16 bp32 = bp24;
	__int16 bp3a = bp24;
	//^075F:0BE0
	Bit16u bp16;
	switch (tileType) {
		case  ttWall:	// WALL
			{
				//^075F:0BF5
				Bit16u di = glbTimersTable[bp08->TimerIndex()].Direction();
				//^075F:0C13
				bp38 += glbXAxisDelta[di];
				//^075F:0C1E
				bp3a += glbYAxisDelta[di];
				//^075F:0C29

				SkD((DLV_TWEET, "Tweet: %s (x:%d, y:%d, map:%d) attacks the wall! \n"
					, static_cast<LPCSTR>(getRecordNameOf(rlMissile))
					, bp38 - glbXAxisDelta[di]
					, bp3a - glbYAxisDelta[di]
					, glbCurrentMapIndex
					));

				if (ATTACK_WALL(bp38, bp3a, bp22, bp24, di, rlMissile) == 0)
					break;
				//^075F:0C47
				return 1;
			}
		case  ttDoor:	// DOOR
			{
				//^075F:0C4A
				__int16 bp12 = glbCurrentTileMap[xpos][ypos] & 0x07;
				//^075F:0C66
				Door *door = GET_ADDRESS_OF_TILE_RECORD((Bit8u)xpos, (Bit8u)ypos)->castToDoor();	//*bp1a
				//^075F:0C79
				if (bp12 != 5 && (si == OBJECT_EFFECT_ZO_SPELL || si == OBJECT_EFFECT_ZO_2)) {	// (si == oFF84 || si == oFF8D
					//^075F:0C89
					if (door->Button() == 0 && door->Bit13C() == 0) {
						//^075F:0C9A
						break;
					}
					//^075F:0CAB
					INVOKE_MESSAGE(
						xpos,
						ypos,
						0,
						(si == OBJECT_EFFECT_ZO_SPELL) ? 2 : 0,
						glbGameTick +1
						);
					//^075F:0CD8
					break;
				}
				//^075F:0CDB
				if (bp12 == 5 || bp12 <= 1)
					//^075F:0CDF
					//^075F:0CE5
					//^075F:0D42
					return 0;

				//^075F:0CE7
				if (GET_DOOR_STAT_0X10(GET_GRAPHICS_FOR_DOOR(door)) != 0) {
					//^075F:0CFF
					if (bp2c == dbCloud) { // bp2c == 15
						//^075F:0D05
						// SPX: that would say only FIREBALL and LIGHTNING will pass
						if (((si >= OBJECT_EFFECT_DISPELL) ? 1 : 0) != 0) {	// (si >= oFF83)
							//^075F:0D42
							return 0;
						}
					}
					//^075F:0D13
					if (((bp08->EnergyRemaining2() < (RAND() & 0x007f)) && (QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0) & 2) != 0) ? 1 : 0) {
						//^075F:0D42
						return 0;
					}
				}
				//^075F:0D47
				Bit16u bp16 = _075f_06bd(bp08, si) +1;
				//^075F:0D59
				ATTACK_DOOR(xpos, ypos, bp16 + RAND16(bp16), 0, 0);
				//^075F:0D7A
				break;
			}
		case ttTeleporter://-3:	// TELEPORTER
		case ttTrickWall://-2:	// TRICKWALL
			{
				//^075F:0D7D
				__int16 bp12 = GET_PLAYER_AT_POSITION(dir);
				//^075F:0D89
				if (bp12 < 0) {
					//^075F:0D8D
					if (tileType == ttTeleporter) {
						//^075F:0D93
						goto _0e37;
					}
					//^075F:0D96
					//^075F:0D42
					return 0;
				}
				//^075F:0D98
				bp36 = 1;
				//^075F:0D9D
				bp16 = _075f_06bd(bp08, si);
				//^075F:0DAE
				if (bp16 != 0) {
					//^075F:0DB2
					if ((((glbChampionSquad[bp12].playerDir() == (glbTimersTable[bp08->TimerIndex()].Direction() +2)) ? 1 : 0) & 3) != 0) {
						//^075F:0DF2
						_4976_4b7a |= 0x8000;
					}
					//^075F:0DF8
					if (WOUND_PLAYER(bp12, bp16, 0, _4976_4b7a) != 0 && glbPoisonAttackDamage != 0 && RAND01() != 0) {
						//^075F:0E20
						PROCESS_POISON(bp12, glbPoisonAttackDamage);
					}
				}
				//^075F:0E2E
				if (tileType == ttTrickWall) {
					//^075F:0E34
					break;
				}

				goto _0e37;
			}
		case ttMapExit://-1:	// EXTERN TILE
			{
				//^075F:0E37
_0e37:
				bp38 = xpos;
				bp3a = ypos;
				//^075F:0E43
				ObjectID bp2e = _1c9a_03cf(&bp38, &bp3a, dir);
				//^075F:0E5B
				if (bp2e == OBJECT_NULL) {
					//^075F:0E60
					if (tileType == ttTeleporter)
						//^075F:0E66
						break;
					//^075F:0E69
					//^075F:0D42
					return 0;
				}
				//^075F:0E6C
				if (_1c9a_0958(bp2e) != 0) {
					//^075F:0E79
					if (tileType == ttTeleporter)
						//^075F:0E7F
						break;
					//^075F:0E82
					//^075F:0D42
					return 0;
				}
				//^075F:0E85
				Creature *bp04 = GET_ADDRESS_OF_RECORD(bp2e)->castToCreature();
				//^075F:0E94
				AIDefinition *bp0c = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType());
				//^075F:0EA8
				if (bp0c->w0_5_5() != 0 && si != OBJECT_EFFECT_DISPELL) {	// oFF83
					//^075F:0EB7
					if (tileType == ttTeleporter)
						//^075F:0EBD
						break;
					//^075F:0EC0
					//^075F:0D42
					return 0;
				}
				//^075F:0EC3
				if (bp0c->IsStaticObject() == 0) {
					//^075F:0ECD
					if (bp0c->Weight != 255) {
						//^075F:0ED4
						goto _0f82;
					}
					else {
						//^075F:0ED7
						goto _0f11;
					}
				}
				//^075F:0ED9
				if ((bp0c->w30 & 0x0100) != 0 && si < OBJECT_EFFECT_FIREBALL) {	// oFF80
					//^075F:0EE7
					//^075F:0EFA
					if (tileType == ttTeleporter)
						//^075F:0F00
						break;
					//^075F:0F03
					//^075F:0D42
					return 0;
				}
				//^075F:0EE9
				if (bp0c->w0_6_7() > 1) {
					//^075F:0EFA
					if (tileType == ttTeleporter)
						//^075F:0F00
						break;
					//^075F:0F03
					//^075F:0D42
					return 0;
				}
				//^075F:0F06
				// SPX: This is turning the direction of the missile (for reflectors certainly ..)
				if ((bp0c->w30 & AI_W30_FLAGS__TURN_MISSILE) == 0) {	// 0x0800
					//^075F:0F11
_0f11:
					Bit16u di = glbTimersTable[bp08->TimerIndex()].Direction();	// get direction
					//^075F:0F2F
					di = (di +2) &3;
					//^075F:0F36
					bp30 += glbXAxisDelta[di];
					//^075F:0F41
					bp32 += glbYAxisDelta[di];
					//^075F:0F4C
					Bit16u bp34 = rlMissile.Dir();
					//^075F:0F55
					if ((di & 1) == (bp34 & 1)) {
						//^075F:0F65
						bp34--;
					}
					else {
						//^075F:0F6A
						bp34++;
					}
					//^075F:0F6D
					rlMissile.Dir(bp34);
				}
				//^075F:0F82
_0f82:
				bp16 = (_075f_06bd(bp08, si) << 6) / bp0c->ArmorClass;
				//^075F:0FA7
				if (bp16 != 0) {
					//^075F:0FAB
					ATTACK_CREATURE(
						bp2e,
						bp38,
						bp3a,
						0x200d,
						0x0064,
						((bp0c->w24 & 0x1000) != 0 && _4976_4b7a != 1) ? 0 : (bp16 + APPLY_CREATURE_POISON_RESISTANCE(bp2e, glbPoisonAttackDamage))
						);
					//^075F:0FED
					if (bp26 == 0 && bp0c->AbsorbsMissile() != 0) {	// if not a grey cloud and w0_9_9 = 1
						//^075F:0FFD
						// si is the item thrown
						if ((QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0) & ITEM_FLAG_40) != 0) {	// 0x0040
							//^075F:100C
							bp10 = &bp04->possession;	// bp04 is the creature
						}
					}
				}
				//^075F:101A
				if (bp2a == 0 && bp2c != 5) {
					//^075F:1026
					if (false
						|| bp2c != 15
						|| si == OBJECT_EFFECT_ZO_SPELL
						|| (si >= OBJECT_EFFECT_PUSH && si <= OBJECT_EFFECT_REFLECTOR)	// (si >= oFF89 && si <= oFF8E)
					) {
						//^075F:1039
						//^075F:1064
						bp36 = 1;
						break;
					}
				}
				//^075F:103B
				ATTACK_CREATURE(
					bp2e,
					bp38,
					bp3a,
					2,
					(bp16 < 5 && si != OBJECT_EFFECT_POISON_CLOUD) ? 30 : 95,
					0
					);

				break;
			}
		case  ttFloor:	// FLOOR
		case  ttPit:	// PIT
		case  ttStairs:	// STAIRS
			//^075F:1069
			break;
	}
	//^075F:1069
	if (tileType == ttTeleporter && bp36 == 0) {
		//^075F:0D42
		return 0;
	}
	//^075F:1078
	if (bp26 == 0 && bp2a == 0 && si != OBJECT_EFFECT_POISON_BOLT)
		//^075F:1089
		goto _113b;

	//^075F:108C
	Bit16u bp14;
	if (bp2a != 0) {
		//^075F:1092
		bp14 = bp28;
		DEALLOC_RECORD(bp1e);
		//^075F:10A1
		bp08->SetMissileObject(si = bp20);
	}
	else {
		//^075F:10AF
		bp14 = bp08->EnergyRemaining();
		//^075F:10BB
		if (si == OBJECT_EFFECT_POISON_BOLT) {
			//^075F:10C0
			bp14 >>= 2;
			//^075F:10C4
			if (bp14 == 0)
				//^075F:10C9
				goto _113b;
		}
		//^075F:10CB
		if (si == OBJECT_EFFECT_LIGHTNING) {
			//^075F:10D0
			bp14 >>= 1;
			if (bp14 == 0)
				//^075F:10D8
				goto _113b;
		}
	}
	//^075F:10DA
	Bit16u di;
	if (si == OBJECT_EFFECT_PUSH || si == OBJECT_EFFECT_PULL) {
		//^075F:10E8
		di = glbTimersTable[bp08->TimerIndex()].Direction();
		//^075F:1106
		bp1c = bp08->EnergyRemaining();
	}
	//^075F:1112
	CREATE_CLOUD(
		si,
		bp14,
		bp22,
		bp24,
		(si == OBJECT_EFFECT_POISON_CLOUD || si == OBJECT_EFFECT_ZO_SPELL || si == OBJECT_EFFECT_ZO_2) ? 255 : dir
		);
	//^075F:113B
_113b:
	CUT_RECORD_FROM(rlMissile, NULL, bp22, bp24);
	//^075F:1150
	// SPX: I think this actually attach the missile to another object, like creature possession (= absorb)
	DELETE_MISSILE_RECORD(rlMissile, bp10, bp30, bp32);
	//^075F:1166
	if (bp1c != 0) {
		//^075F:116C
		_12b4_0d75(
			xpos,
			ypos,
			(si == OBJECT_EFFECT_PUSH) ? (di) : ((di+2) &3),
			max_value(min_value(bp1c, 0xfe), 0x28)
			);
	}
	//^075F:11A3
	return 1;
}

//^2FCF:0234
void SkWinCore::_2fcf_0234(__int16 xposFrom, __int16 yposFrom, __int16 xposTo, __int16 yposTo)
{
	//^2FCF:0234
	//^2FCF:023A
	Bit16u bp04 = 0;
	//^2FCF:023F
	Bit8u bp10[4];
	ZERO_MEMORY(&bp10, 4);
	//^2FCF:0250
	Bit16u bp02;
	for (bp02=0; bp02 < 4; bp02++) {
		//^2FCF:0257
		if (GET_PLAYER_AT_POSITION(bp02) >= 0) {
			//^2FCF:0264
			bp10[bp02] = bp02 +1;
		}
		//^2FCF:0274
	}
	//^2FCF:027D
	Bit8u bp0c[4];
	if (xposTo >= 0 && CALC_SQUARE_DISTANCE(xposFrom, yposFrom, xposTo, yposTo) == 1) {
		//^2FCF:02A2
		bp02 = CALC_VECTOR_DIR(xposFrom, yposFrom, xposTo, yposTo);
		//^2FCF:02B9
		Bit16u di = (bp02 +1) & 3;
		//^2FCF:02BF
		ZERO_MEMORY(&bp0c, 4);
		//^2FCF:02D0
		if ((bp0c[(bp02 +3) &3] = bp10[bp02]) != 0) {
			//^2FCF:02F3
			bp04 = 1;
		}
		//^2FCF:02F8
		if ((bp0c[(di +1) &3] = bp10[di]) != 0) {
			//^2FCF:030E
			bp04 = 1;
		}
		//^2FCF:0313
		if (bp10[bp02] == 0) {
			//^2FCF:0324
			bp10[bp02] = bp10[((bp02 +3) &3)];
		}
		//^2FCF:0341
		if (bp10[di] == 0) {
			//^2FCF:034A
			bp10[di] = bp10[(di +1) &3];
		}
	}
	//^2FCF:035C
	__int16 bp06 = xposFrom;
	__int16 bp08 = yposFrom;

	//^2FCF:0368
	while (true) {
		//^2FCF:0368
_0368:
		ObjectID si = GET_TILE_RECORD_LINK(bp06, bp08);
		//^2FCF:0375
		for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^2FCF:0377
			if (si.DBType() == dbMissile) {
				//^2FCF:0384
				if (glbTimersTable[GET_ADDRESS_OF_RECORDE(si)->TimerIndex()].TimerType() != tty1D) {
					//^2FCF:03A5
					bp02 = bp10[si.Dir()];
					//^2FCF:03B7
					if (bp02 != 0) {
						//^2FCF:03BB
						if (_075f_0af9(-3, xposFrom, yposFrom, bp02, si) != 0) {
							//^2FCF:03D2
							_075f_056c(si);
							//^2FCF:03D9
							goto _0368;
						}
					}
				}
			}
			//^2FCF:03DB
		}
		//^2FCF:03E9
		if (bp04 == 0) {
			//^2FCF:03ED
			break;
		}
		//^2FCF:03EF
		xposFrom |= ((bp06 = xposTo) +1) << 8;
		//^2FCF:0401
		yposFrom |= ((bp08 = yposTo)) << 8;
		//^2FCF:0412
		COPY_MEMORY(bp0c, bp10, 4);
		//^2FCF:0428
		bp04 = 0;
		//^2FCF:042D
		continue;
	}
	//^2FCF:0430
	return;
}

//^2FCF:013C
void SkWinCore::SET_MINION_RECENT_OPEN_DOOR_LOCATION(ObjectID recordLink, __int16 xpos, __int16 ypos, Bit16u curmap, Bit16u ww)
{
	//^2FCF:013C
	//^2FCF:0141
	ObjectID si = GET_ADDRESS_OF_RECORD(recordLink)->castToCreature()->possession;
	//^2FCF:0152
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^2FCF:0154
		if (si.DBType() == dbMissile) {
			//^2FCF:0161
			Missile *bp04 = GET_ADDRESS_OF_RECORD(si)->castToMissile();
			//^2FCF:016E
			bp04->SetX(xpos);
			bp04->SetY(ypos);
			bp04->SetMap(curmap);
			bp04->b6_0_0(ww);
		}
		//^2FCF:01B4
	}
	//^2FCF:01C2
	return;
}

//^1C9A:0DB0
void SkWinCore::RELEASE_CREATURE_TIMER(ObjectID recordLink)
{
	//^1C9A:0DB0
	//^1C9A:0DB5
	if (recordLink.DBType() == dbCreature) {
		//^1C9A:0DC3
		Bit8u bp01 = GET_ADDRESS_OF_RECORD(recordLink)->castToCreature()->b5_0_7();
		//^1C9A:0DD7
		if (bp01 != 0xff) {
			//^1C9A:0DDD
			__int16 si = glbTabCreaturesInfo[bp01].TimerIndex();
			//^1C9A:0DF0
			if (si >= 0) {
				//^1C9A:0DF4
				DELETE_TIMER(si);
				//^1C9A:0DFB
				glbTabCreaturesInfo[bp01].TimerIndex(0xffff);
			}
		}
	}
	//^1C9A:0E11
	return;
}

//^0CD5:00FE
//SPX : Random over 16 bits, using cap (modulo) value: range 0 to max, or 0 to 32768 in positive number
Bit16u SkWinCore::_RAND16(Bit16u maxcnt)
{
	// CSBwinSimilarity: STRandom

	//^0CD5:00FE
	//^0CD5:0101
	if (maxcnt == 0)
		//^0CD5:0107
		return 0;
	//^0CD5:010B
	return RAND() % maxcnt;
	//^0CD5:0117
}

//^0CEE:2E1E
// SPX: _0cee_2e1e renamed GET_CREATURE_WEIGHT
Bit16u SkWinCore::GET_CREATURE_WEIGHT(ObjectID recordLink)
{
	//^0CEE:2E1E
	//^0CEE:2E21
	return QUERY_CREATURE_AI_SPEC_FROM_RECORD(recordLink)->Weight;
}

//^1C9A:0FCB
// TODO : release creature ?
void SkWinCore::_1c9a_0fcb(Bit16u xx)
{
	//^1C9A:0FCB
	//^1C9A:0FD1
	Bit16u di = xx;
	//^1C9A:0FD4
	if (di <= glbCreaturesCount) {
		//^1C9A:0FDA
		CreatureInfoData *bp04 = &glbTabCreaturesInfo[di];
		//^1C9A:1004
		ObjectID si(0, dbCreature, bp04->CreatureIndex());
		//^1C9A:100F
		Creature *bp08 = GET_ADDRESS_OF_RECORD(si)->castToCreature();
		//^1C9A:101C
		RELEASE_CREATURE_TIMER(si);
		//^1C9A:1022
		_4976_1a68--;
		//^1C9A:1026
		bp08->b5_0_7(0xff);
		bp04->CreatureIndex(-1);
	}
	//^1C9A:1036
}

//^0CEE:00CD
void SkWinCore::LOAD_LOCALLEVEL_GRAPHICS_TABLE(Bit16u curmap) //#DS=4976?
{
	//^0CEE:00CD
	//^0CEE:00D3
	CHANGE_CURRENT_MAP_TO(glbPlayerMap = curmap);
	//^0CEE:00DF
	Bit8u *bp04 = (glbMapCreaturesTypeNumber = &glbCurrentTileMap[glbCurrentMapWidth -1][glbCurrentMapHeight]);
	//^0CEE:0107
	Bit16u si = dunMapLocalHeader->WallGraphics();
	//^0CEE:0114
	COPY_MEMORY(
		bp04 += dunMapLocalHeader->CreaturesTypes(), 
		_4976_4dc2,
		si
		);
	//^0CEE:0137
	Bit16u di = dunMapLocalHeader->FloorGraphics();
	//^0CEE:0144
	COPY_MEMORY(
		bp04 += si,
		_4976_4cba,
		di
		);
	//^0CEE:015D
	COPY_MEMORY(
		bp04 += di,
		glbMapDoorOrnatesList,
		dunMapLocalHeader->DoorDecorationGraphics()
		);
	//^0CEE:0180
	return;
}

//^1C9A:0397
ObjectID SkWinCore::GET_CREATURE_AT(__int16 xpos, __int16 ypos)
{
	// find a creature at (xpos,ypos).
	//
	// return OBJECT_NULL if no creature found.

	//^1C9A:0397
	//^1C9A:039B
	ObjectID si = GET_TILE_RECORD_LINK(xpos, ypos);
	//^1C9A:03A8
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^1C9A:03AA
		if (si.DBType() == dbCreature)
			//^1C9A:03B7
			return si;
		//^1C9A:03BB
	}
	//^1C9A:03C9
	return OBJECT_NULL;
}


//^0CEE:2E53
Bit16u SkWinCore::IS_CREATURE_ALLOWED_ON_LEVEL(ObjectID rlCreature, Bit16u curmap)
{
	//^0CEE:2E53
	//^0CEE:2E59
	if ((QUERY_CREATURE_AI_SPEC_FLAGS(rlCreature) & 0x4000) != 0) {
		//^0CEE:2E66
		return 1;
	}
	//^0CEE:2E6C
	Bit8u bp09 = QUERY_CLS2_FROM_RECORD(rlCreature);
	//^0CEE:2E77
	Map_definitions *bp08 = &dunMapsHeaders[curmap];
	//^0CEE:2E8D
	Bit8u *bp04 = &glbMapTileValue[curmap][bp08->RawColumn()][bp08->RawRow() +1];
	//^0CEE:2ECE
	__int16 si = bp08->CreaturesTypes();
	//^0CEE:2EDD
	for (; si > 0; --si) {
		//^0CEE:2EDF
		if (*(bp04++) == bp09)
			return 1;
		//^0CEE:2EF0
	}
	//^0CEE:2EF5
	return 0;
	//^0CEE:2EF7
}

//^2FCF:0DD5
Bit16u SkWinCore::MOVE_RECORD_TO(ObjectID rlWhatYouMove, __int16 xposFrom, __int16 yposFrom, __int16 xposTo, __int16 yposTo) //#DS=4976?
{
	SkD((DLV_DBM, "DBM: MOVE_RECORD_TO(%04X,%2d,%2d,%2d,%2d)\n"
		, (Bitu)rlWhatYouMove.w, (Bitu)xposFrom, (Bitu)yposFrom, (Bitu)xposTo, (Bitu)yposTo));

	// CSBwinSimilarity: TAG011f52,MoveObject

	// in CSBwin, similar to TAG011f52,MoveObject
	// place battle prize?

	// place an object to tile. or take an object from tile. the target can be floor/wall/alcove/creature/missile.
	// you can move creatures/missiles too.
	//
	// rlWhatYouMove: an object what you wanna move. this also includes new tile position.
	//
	// a) player [takes] an object at [creature]
	//    xposFrom=xx, yposFrom=yy, xposTo=[-1], yposTo=[-1]
	// b) player [takes] an object at [alcove/floor]
	//    xposFrom=xx, yposFrom=yy, xposTo=[-1], yposTo=[ 0]
	//
	// c) player [places] an object to [creature]
	//    xposFrom=[-1], yposFrom=[-1], xposTo=xx, yposTo=yy
	// d) player [places] an object to [alcove/floor]
    //    xposFrom=[-1], yposFrom=[ 0], xposTo=xx, yposTo=yy
	//
	// e) if player surely moves (not called if run to wall)
	//    xposFrom=[old xpos], yposFrom=[old ypos], xposTo=[new xpos], yposTo=[new ypos], rlWhatYouMove=0xFFFF
	//
	// f) if an item in missile drops
	//    xposFrom=[-2], yposFrom=[ 0], xposTo=[xpos], yposTo=[ypos], rlWhatYouMove=[an flying item such as gold coin]
	// g) if an item injects to creature
	//    xposFrom=[xpos], yposFrom=[ypos], xposTo=[-2], yposTo=[ 0], rlWhatYouMove=[an flying item such as gold coin]
	//
	// h) to generate creature,
	//    xposFrom=[-4], yposFrom=[ 0], xposTo=[xpos], yposTo=[ypos], rlWhatYouMove=[creature]
	// i) to kill creature,
	//    xposFrom=[xpos], yposFrom=[ypos], xposTo=[-4], yposTo=[ 0], rlWhatYouMove=[creature]

	// return 0 if move success
	// return non 0 if move failed

	ATLASSERT(rlWhatYouMove.DBType() != dbDoor); // you would not move this kind of object
	ATLASSERT(rlWhatYouMove.DBType() != dbTeleporter); // you would not move this kind of object
	ATLASSERT(rlWhatYouMove.DBType() != dbText); // you would not move this kind of object
	ATLASSERT(rlWhatYouMove.DBType() != dbActuator); // you would not move this kind of object

	//^2FCF:0DD5
	//^2FCF:0DDB
	ObjectID si = rlWhatYouMove;
	_4976_5822 = 0;
	Bit16u bp10 = 0;
	Bit16u bp12 = 0;
	Bit16u bp08 = glbCurrentMapIndex; // current mapno
	Bit16u bp0c = glbPlayerDir; // current player dir
	Bit16u bp1a = 0;
	//^2FCF:0DFA
	Bit16u bp0a;
	Bit16u bp0e;
	GenericRecord *bp04;
	ObjectID bp1c;
	if (si == OBJECT_NULL) {
		//^2FCF:0DFF
		glbDoLightCheck = 1;
		bp0a = 0xffff;
		//^2FCF:0E0A
		if (xposFrom >= 0) {
			//^2FCF:0E10
			_2fcf_0234(xposFrom, yposFrom, xposTo, yposTo);
		}
	}
	else {
		//^2FCF:0E25
		bp0a = si.DBType();
		//^2FCF:0E30
		if (bp0a == dbCreature) {
			//^2FCF:0E35
			bp04 = GET_ADDRESS_OF_RECORD(si);
		}
		//^2FCF:0E42
		bp0e = si.Dir();
	}
	//^2FCF:0E4A
	Bit16u bp1e = 0; // defaulting to 0
	Bit16u di = 0; // defaulting to 0
	if (xposTo >= 0) {
		//^2FCF:0E53
		bp10 = _2fcf_0434(si, xposFrom, yposFrom, xposTo, yposTo, 1);
		//^2FCF:0E6C
		if (si != OBJECT_NULL) {
			//^2FCF:0E71
			if (QUERY_GDAT_DBSPEC_WORD_VALUE(si, 0xf8) != 0) {
				//^2FCF:0E80
				if (bp08 == glbPlayerMap || _4976_581c == glbPlayerMap) {
					//^2FCF:0E92
					glbDoLightCheck = 1;
				}
			}
			//^2FCF:0E98
			si.Dir(_4976_5820);
		}
		//^2FCF:0EA8
		xposTo = _4976_5826;
		yposTo = _4976_5828;
		bp1e = _4976_581e;
		di = _4976_581c;
		//^2FCF:0EBF
		CHANGE_CURRENT_MAP_TO(di);
		//^2FCF:0EC6
		// SPX: Moved the 2nd condition checking if creature is allowed on target level into a variable.
		// This allows to break the limitation of "creatures list" for any map and also allows any creature to be summoned from custom spells
		// The original logic was " if (bp0a == dbCreature && IS_CREATURE_ALLOWED_ON_LEVEL(si, di) == 0) "
		U8 bCreatureAllowedOnLevel = 1;
		if (bp0a == dbCreature)
		{
			if (!SkCodeParam::bUseDM2ExtendedMode)
				bCreatureAllowedOnLevel = IS_CREATURE_ALLOWED_ON_LEVEL(si, di);

			if (bCreatureAllowedOnLevel == 0) {
				//^2FCF:0ED9
				DROP_CREATURE_POSSESSION(si, xposTo, yposTo, CREATURE_GENERATED_DROPS, 1);	// (si, xposTo, yposTo, 0, 1)
				//^2FCF:0EEC
				CHANGE_CURRENT_MAP_TO(bp08);
				//^2FCF:0EF5
				if (xposFrom >= 0) {
					//^2FCF:0EFB
					DELETE_CREATURE_RECORD(xposFrom, yposFrom, CREATURE_NO_DROP, 0xffff);	// (xposFrom, yposFrom, 2, 0xffff)
				}
				//^2FCF:0F0D
				return 1;
			}
		}
		//^2FCF:0F13
		bp12 = (di == bp08 && xposTo == xposFrom && yposTo == yposFrom) ? 1 : 0;
		//^2FCF:0F32
		if (bp12 != 0) {
			//^2FCF:0F38
			if (si == 0xffff) {
				//^2FCF:0F3D
				if (glbPlayerDir == bp0c) {
					//^2FCF:0F45
					goto _1562;
				}
			}
			else {
				//^2FCF:0F48
				if (_4976_5820 == bp0e && bp0a != dbMissile) {
					//^2FCF:0F56
					goto _1562;
				}
			}
		}
		else {
			//^2FCF:0F59
			if (di != bp08) {
				//^2FCF:0F5E
				if (si == 0xffff && glbPlayerMap != bp08) {
					//^2FCF:0F6B
					LOAD_LOCALLEVEL_GRAPHICS_TABLE(bp08);
				}
				else {
					//^2FCF:0F75
					CHANGE_CURRENT_MAP_TO(bp08);
				}
			}
		}
	}
	//^2FCF:0F7E
	if (xposFrom >= 0) {
		//^2FCF:0F87
		if (si == OBJECT_NULL) {
			//^2FCF:0F8C
			PLACE_OR_REMOVE_OBJECT_IN_ROOM(xposFrom, yposFrom, -1, bp12, FCT_REMOVE_OFF, 0);
		}
		else {
			//^2FCF:0FA6
			if (bp10 != 0) {
				//^2FCF:0FAC
				CUT_RECORD_FROM(si, NULL, xposFrom, yposFrom);
			}
			else {
				//^2FCF:0FC1
				PLACE_OR_REMOVE_OBJECT_IN_ROOM(
					xposFrom, 
					yposFrom, 
					si, 
					(glbCurrentMapIndex == glbMap_4c28 && glbCurrentMapIndex == glbSomePosX_4c2e && glbCurrentMapIndex == glbSomePosY_4c30) ? 1 : 0,
					FCT_REMOVE_OFF,
					(xposTo < 0 && yposTo < 0) ? 1 : 0 
					);
			}
			//^2FCF:1009
			if (bp0a == dbCreature && xposTo < -1) {
				//^2FCF:1015
				Bit16u bp06 = bp04->castToCreature()->b5_0_7();
				//^2FCF:1021
				if (bp06 != 255) {
					//^2FCF:1026
					_1c9a_0fcb(bp06);
				}
			}
		}
	}
	//^2FCF:102F
	__int16 bp16, bp18;
	if (xposTo < 0) {
		//^2FCF:1035
		goto _1562;
	}
	else {
		//^2FCF:1038
		if (si == OBJECT_NULL) {
			//^2FCF:1040
			CHANGE_CURRENT_MAP_TO(di);
			//^2FCF:1047
			_2fcf_0b8b(xposTo, yposTo, di);
			//^2FCF:1055
			si = GET_CREATURE_AT(glbPlayerPosX, glbPlayerPosY);
			//^2FCF:1066
			if (si != OBJECT_NULL) {
				//^2FCF:106E
				Bit16u bp20 = QUERY_CREATURE_AI_SPEC_FLAGS(si);
				//^2FCF:1078
				if ((bp20 & CREATURE_AI_FLAG_8000) == 0) {
					//^2FCF:1080
					if ((bp20 & CREATURE_AI_FLAG_0001) != 0 && GET_CREATURE_WEIGHT(si) == 255) {
						//^2FCF:1093
						if (TRY_PUSH_OBJECT_TO(0xffff, xposTo, yposTo, &bp16, &bp18) != 0) {
							//^2FCF:10B3
							LOAD_LOCALLEVEL_GRAPHICS_TABLE(di);
							//^2FCF:10BA
							glbMapToLoad = di;
							//^2FCF:10BE
							MOVE_RECORD_TO(0xffff, -1, 0, bp16, bp18);
							//^2FCF:10D1
							LOAD_LOCALLEVEL_GRAPHICS_TABLE(bp08);
							//^2FCF:10DA
							if (glbMapToLoad == bp08) {
								//^2FCF:10E5
								glbMapToLoad = 0xffff;
								//^2FCF:10EB
								goto _1183;
							}
							else {
								//^2FCF:10E2
								goto _1562;
							}
						}
						else {
							//^2FCF:10B0
							goto _1151;
						}
					}
					//^2FCF:10EE
					if (TRY_PUSH_OBJECT_TO(si, xposTo, yposTo, &bp16, &bp18) != 0) {
						//^2FCF:110A
						bp1a = GET_PARTY_SPECIAL_FORCE() >> 2;
						//^2FCF:1115
						bp1a += RAND16((bp1a >> 1) +1);
						//^2FCF:1127
						ATTACK_CREATURE(si, xposTo, yposTo, 0x2000, 0x0000, bp1a);
						//^2FCF:113E
						MOVE_RECORD_TO(si, xposTo, yposTo, bp16, bp18);
						//^2FCF:114F
						goto _1183;
					}
					//^2FCF:1108
					goto _1151;
				}
			}
			//^2FCF:106B
			goto _1183;
		}
		//^2FCF:103D
		goto _11a3;
	}

	//^2FCF:1151
_1151:
	RELEASE_CREATURE_TIMER(si);
	//^2FCF:1158
	if (MOVE_RECORD_TO(si, glbPlayerPosX, glbPlayerPosY, -3, 0) == 0) {
		//^2FCF:1170
		_2fcf_01c5(si, glbPlayerPosX, glbPlayerPosY, di, 0);
	}

	//^2FCF:1183
_1183:
	if (di == bp08) {
		//^2FCF:1188
		//^2FCF:1199
		//^2FCF:155A
		PLACE_OR_REMOVE_OBJECT_IN_ROOM(glbPlayerPosX, glbPlayerPosY, 0xffff, bp12, FCT_PLACE_ON, 0);
	}
	else {
		//^2FCF:119C
		glbMapToLoad = di;
		//^2FCF:11A0
	}
	goto _1562;

	//^2FCF:11A3
_11a3:
	if (bp0a == dbCreature) {
		//^2FCF:11AC
		CHANGE_CURRENT_MAP_TO(di);
		//^2FCF:11B3
		Bit16u bp06 = bp04->castToCreature()->b5_0_7();
		//^2FCF:11BF
		if (di == glbMap_4c28 && xposTo == glbSomePosX_4c2e && yposTo == glbSomePosY_4c30) {
			//^2FCF:11E0
			if ((QUERY_CREATURE_AI_SPEC_FLAGS(si) & 0x8000) == 0) {
				//^2FCF:11EC
				if (TRY_PUSH_OBJECT_TO(0xffff, xposTo, yposTo, &bp16, &bp18) != 0) {
					//^2FCF:120C
					bp1a = (GET_CREATURE_WEIGHT(si) >> 3) + RAND16(10);
					//^2FCF:1225
					ATTACK_PARTY(bp1a, 4, 2);
					//^2FCF:1234
					// SPX: Bumping sound
					QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, 0xfe, SOUND_CHAMPION_BUMP, 0xfe, xposTo, yposTo, 1, 100, 200);
					//^2FCF:1254
					MOVE_RECORD_TO(0xffff, xposTo, yposTo, bp16, bp18);
				}
				else {
					//^2FCF:1209
					goto _13a5;
				}
			}
		}
		//^2FCF:1269
		bp1c = GET_CREATURE_AT(xposTo, yposTo);
		//^2FCF:1279
		Bit16u bp22;
		if (bp1c != OBJECT_NULL) {
			//^2FCF:1281
			bp22 = GET_CREATURE_WEIGHT(si);
			//^2FCF:128B
			Bit16u bp20 = QUERY_CREATURE_AI_SPEC_FLAGS(bp1c);
			//^2FCF:1297
			if (QUERY_CREATURE_AI_SPEC_FLAGS(si) != 0 && bp22 == 255) {
				//^2FCF:12AA
				if ((bp20 & 0x0001) != 0) {
					//^2FCF:12B1
					if (GET_CREATURE_WEIGHT(bp1c) == 255) {
						//^2FCF:12BF
						goto _13a5;
					}
				}
				//^2FCF:12C2
				if (TRY_PUSH_OBJECT_TO(bp1c, xposTo, yposTo, &bp16, &bp18) == 0) {
					//^2FCF:12E0
					RELEASE_CREATURE_TIMER(si);
					//^2FCF:12E7
					_2fcf_01c5(si, xposTo, yposTo, di, 0);
					//^2FCF:12F5
					goto _1562;
				}
				else {
					//^2FCF:12DE
					goto _1359;
				}
			}
			//^2FCF:12F8
			if ((bp20 & 1) != 0 && GET_CREATURE_WEIGHT(bp1c) == 255) {
				//^2FCF:130D
				if (TRY_PUSH_OBJECT_TO(si, xposTo, yposTo, &bp16, &bp18) == 0)
					//^2FCF:1327
					goto _13a5;
				//^2FCF:1329
				MOVE_RECORD_TO(si, -1, 0, bp16, bp18);
				//^2FCF:1338
				goto _1562;
			}
			else {
				//^2FCF:133B
				if (TRY_PUSH_OBJECT_TO(bp1c, xposTo, yposTo, &bp16, &bp18) == 0)
					//^2FCF:1357
					goto _13a5;

				goto _1359;
			}
		}
		else {
			//^2FCF:127E
			goto _13ce;
		}

		//^2FCF:1359
_1359:
		{
			bp1a = bp22 >> 2;
			//^2FCF:1362
			bp1a += RAND16((bp1a >> 1) +1);
			//^2FCF:1374
			ATTACK_CREATURE(bp1c, xposTo, yposTo, 0x2000, 0, bp1a);
			//^2FCF:138D
			MOVE_RECORD_TO(bp1c, xposTo, yposTo, bp16, bp18);
			//^2FCF:13A3
			goto _13ce;
		}

		//^2FCF:13A5
_13a5:
		{
			if (bp06 != 255) {
				//^2FCF:13AC
				_1c9a_0fcb(bp06);
			}
			//^2FCF:13B5
			_2fcf_01c5(si, xposTo, yposTo, di, _4976_5822);
			//^2FCF:13CB
			return 2;
		}

		//^2FCF:13CE
_13ce:
		{
			if (bp10 != 0) {
				//^2FCF:13D4
				APPEND_RECORD_TO(si, NULL, xposTo, yposTo);
			}
			else {
				//^2FCF:13E9
				PLACE_OR_REMOVE_OBJECT_IN_ROOM(xposTo, yposTo, si, 0, FCT_PLACE_ON, 0);
			}
			//^2FCF:13FE
			SET_MINION_RECENT_OPEN_DOOR_LOCATION(si, xposTo, yposTo, di, 0);
			//^2FCF:140F
			if (bp06 == 255) {
				//^2FCF:1416
				if ((QUERY_CREATURE_AI_SPEC_FLAGS(si) & 1) == 0) {
					//^2FCF:1425
					ALLOC_CAII_TO_CREATURE(si, xposTo, yposTo);
					//^2FCF:1434
				}
			}
			else {
				//^2FCF:1437
				bp06 = glbTabCreaturesInfo[bp06].TimerIndex();
				//^2FCF:144C
				if (bp06 != 0xffff) {
					//^2FCF:1454
					glbTimersTable[bp06].Xcoord((Bit8u)xposTo);
					//^2FCF:1466
					glbTimersTable[bp06].Ycoord((Bit8u)yposTo);
					//^2FCF:147B
					glbTimersTable[bp06].SetMap(di);
					//^2FCF:14C3
				}
			}
			goto _1562;
		}
	}
	else {
		//^2FCF:14C6
		CHANGE_CURRENT_MAP_TO(di);
		//^2FCF:14CD
		if (bp0a == dbCloud) {
			//^2FCF:14D3
			APPEND_RECORD_TO(si, NULL, xposTo, yposTo);
			//^2FCF:14E6
		}
		else {
			//^2FCF:14E8
			Bit16u bp14 = (xposFrom < 0 && yposFrom < 0) ? 1 : 0;
			//^2FCF:14FE
			if (bp14 == 0 && di != bp08) {
				//^2FCF:1507
				bp1c = GET_CREATURE_AT(xposTo, yposTo);
				//^2FCF:1517
				if (bp1c != OBJECT_NULL) {
					//^2FCF:151C
					bp14 = QUERY_CREATURE_AI_SPEC_FLAGS(bp1c) & 1;
				}
			}
			//^2FCF:152B
			PLACE_OR_REMOVE_OBJECT_IN_ROOM(
				xposTo, 
				yposTo, 
				si, 
				(glbCurrentMapIndex == glbMap_4c28 && xposTo == glbSomePosX_4c2e && yposTo == glbSomePosY_4c30) ? 1 : 0,
				FCT_PLACE_ON,
				bp14
				);
		}
	}
	//^2FCF:1562
_1562:
	_4976_581e = bp1e;
	_4976_5826 = xposTo;
	_4976_5828 = yposTo;
	_4976_581c = di;
	//^2FCF:1578
	CHANGE_CURRENT_MAP_TO(bp08);
	//^2FCF:1581
	return 0;
	//^2FCF:1583
}

//^075F:056C
// SPX: Ran into this one after being hit by a poison ball from Dru Tan
// TODO: Delete missile ?
void SkWinCore::_075f_056c(ObjectID rl)
{
	//^075F:056C
	ENTER(0);
	//^075F:056F
	if (rl.DBType() == dbMissile) {
		DELETE_TIMER(GET_ADDRESS_OF_RECORDE(rl)->TimerIndex());
	}
	//^075F:0594
	return;
}

//^075F:0596
void SkWinCore::DELETE_MISSILE_RECORD(ObjectID rlMissile, ObjectID *prlDropTo, __int16 xposDropTo, __int16 yposDropTo)
{
	SkD((DLV_DBM,"DBM: DELETE_MISSILE_RECORD(%04X,%p(%04X),%2d,%2d)\n"
		, (Bitu)rlMissile.w
		, prlDropTo
		, (prlDropTo != NULL) ? (Bitu)prlDropTo->w : 0
		, (Bitu)xposDropTo
		, (Bitu)yposDropTo));

	//^075F:0596
	//^075F:059C
	ObjectID si = rlMissile;
	//^075F:059F
	Missile *bp04 = GET_ADDRESS_OF_RECORDE(si);
	//^075F:05AF
	ObjectID di = bp04->GetMissileObject();
	//^075F:05B5
	if (di.DBType() != dbCloud) {
		//^075F:05C3
		if (prlDropTo != NULL) {
			//^075F:05CB
			APPEND_RECORD_TO(di, prlDropTo, -1, 0);
		}
		else {
			//^075F:05DE
			ObjectID bp06 = GET_CREATURE_AT(xposDropTo, yposDropTo);
			//^075F:05EE
			if (bp06 != OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp06) & 0x0001) != 0) {
				//^075F:0602
				Bit16u bp08 = si.Dir();
				//^075F:060A
				if ((QUERY_CREATURE_AI_SPEC_FROM_RECORD(bp06)->w30 & 15) == 1) {
					//^075F:0623
					bp08 = glbTimersTable[bp04->TimerIndex()].Direction();
					//^075F:063F
				}
				else {
					//^075F:0641
					bp08 = si.Dir();
				}
				//^075F:0649
				MOVE_RECORD_TO(ObjectID(di, bp08), -2, -1, xposDropTo, yposDropTo);

				SkD((DLV_TWEET, "Tweet: %s (a#%03d, x:%d, y:%d, map:%d) have acquired %s! \n"
					, static_cast<LPCSTR>(getRecordNameOf(bp06))
					, bp06.DBIndex()
					, xposDropTo
					, yposDropTo
					, glbCurrentMapIndex
					, static_cast<LPCSTR>(getRecordNameOf(di))
					));
			}
			else {
				//^075F:0667
				MOVE_RECORD_TO(ObjectID(di, si.Dir()), -2, 0, xposDropTo, yposDropTo);

				SkD((DLV_TWEET, "Tweet: %s (x:%d, y:%d, map:%d) have falled down! \n"
					, static_cast<LPCSTR>(getRecordNameOf(di))
					, xposDropTo
					, yposDropTo
					, glbCurrentMapIndex
					));
			}
		}
		//^075F:0687
		QUEUE_NOISE_GEN2(
			QUERY_CLS1_FROM_RECORD(si),
			QUERY_CLS2_FROM_RECORD(si),
			SOUND_STD_KNOCK,
			0xfe,
			xposDropTo,
			yposDropTo,
			0x01,
			0x3a,
			0x80
			);
	}
	//^075F:06B2
	DEALLOC_RECORD(si);
	//^075F:06B9
	return;
}

//^0CEE:0EC8
ObjectID SkWinCore::RECYCLE_A_RECORD_FROM_THE_WORLD(Bit16u itemdb, Bit8u itemtype)
{
	SkD((DLV_DBM, "DBM: RECYCLE_A_RECORD_FROM_THE_WORLD(%04X,%3u)\n"
		, (Bitu)itemdb, (Bitu)itemtype));

	// searches almost unused record from the dungeon,
	// then detach it from the dungeon,
	// then recycle the record as unused one.
	//
	// itemdb: itemdb of a record which you want to recycle.
	// itemtype: searches for any recyclable itemtype if itemtype is 0xff.
	//
	// return-val: 0xffff if there is no recyclable ones.

	//^0CEE:0EC8
	//^0CEE:0ECE
	if (itemdb == dbCloud) {
		//^0CEE:0ED4
		return OBJECT_NULL;
	}
	//^0CEE:0EDA
	Bit16u bp1a = glbCurrentMapIndex;
	//^0CEE:0EE0
	Bit16u di = (_4976_4c08 != 0) ? _4976_4c12 : 0xffff;
	//^0CEE:0EF1
	Bit16u bp26 = 0;
	//^0CEE:0EF6
	Bit16u bp0e;
	Bit16u bp18;
	bp0e = bp18 = _4976_4c42[itemdb];
	//^0CEE:0F05
	if (bp0e == glbPlayerMap || bp0e == di) {
		//^0CEE:0F13
		if (di != 0xffff) {
			do {
				//^0CEE:0F18
				if (dunHeader->nMaps <= (++bp0e)) {
					//^0CEE:0F2C
					bp0e = 0;
				}
				//^0CEE:0F31
				if (bp0e == bp18) {
					//^0CEE:0F39
					bp0e = di;
					di = 0xffff;
				}
				//^0CEE:0F3F
			} while (bp0e == di || bp0e == glbPlayerMap);
		}
		else {
			do {
				//^0CEE:0F4F
				if (dunHeader->nMaps <= (++bp0e)) {
					//^0CEE:0F63
					bp0e = 0;
				}
				//^0CEE:0F68
			} while (bp0e == glbPlayerMap);
			//^0CEE:0F71
			if (bp0e == bp18) {
				//^0CEE:0F76
				bp0e = glbPlayerMap;
			}
		}
	}
	//^0CEE:0F7C
	bp18 = bp0e;
	Bit16u bp20 = 0;

	while (true) {
		//^0CEE:0F87
        Bit16u bp14 = dunMapsHeaders[bp0e].RawColumn();
		//^0CEE:0FA0
		Bit16u bp16 = dunMapsHeaders[bp0e].RawRow();
		//^0CEE:0FB9
		Bit8u *bp04 = *glbMapTileValue[bp0e];
		//^0CEE:0FD5
		Bit16u *bp0c = &dunGroundStacks[dunMapTilesObjectIndexPerColumn[dunMapColumnsSumArray[bp0e]]];
		//^0CEE:1000
		for (Bit16u bp10=0; bp10 <= bp14; bp10++) {
			//^0CEE:1008
			for (Bit16u bp12=0; bp12 <= bp16; bp12++) {
				//^0CEE:1010
				if ((*(bp04++) & 0x10) != 0) {
					//^0CEE:1024
					Bit8u bp27 = 0xff;
					//^0CEE:1028
					ObjectID si = *(bp0c++);
					//^0CEE:1032
					Bit16u bp24 = ((bp0e == glbPlayerMap) && (bp10 - glbPlayerPosX + 5 <= 10) && (bp12 - glbPlayerPosY + 5 <= 10)) ? 1 : 0;
					ObjectID bp22;

					// bp10: x-pos of GC(garbage-collector) cursor
					// bp12: y-pos of GC cursor
					// bp24: 1 if player is near from GC cursor. 0 if far

					while (true) {
						//^0CEE:1063
						Bit16u bp1c = si.DBType();
						//^0CEE:106E
						if (bp1c == dbActuator) {
							//^0CEE:1073
							Actuator *bp08 = GET_ADDRESS_OF_RECORD(si)->castToActuator();
							//^0CEE:107F
							Bit16u bp1e = bp08->ActuatorType();
							//^0CEE:108C
							if (bp1e >= 0x2c || _4976_0c5e[bp1e] == 0) {	// >= 0x2C
								//^0CEE:109E
								if (bp26 != 0 && bp24 != 0 && bp1e == ACTUATOR_FLOOR_TYPE__SHOP) {	// 0x30
									//^0CEE:10B9
									bp24 = 0;
									//^0CEE:10BE
									bp1e = bp08->ActuatorData();
									//^0CEE:10CE
									if (GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(bp1e) == itemdb) {
										//^0CEE:10DD
										bp27 = GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(bp1e);
									}
								}
								goto _1314;
							}
							goto _1324;
						}
						//^0CEE:10EC
						else if (bp1c == dbText) {
							//^0CEE:10F2
							Text *bp08 = GET_ADDRESS_OF_RECORD(si)->castToText();
							//^0CEE:10FE
							if (bp08->TextMode() != 1) {
								//^0CEE:110F
								goto _1314;
							}
							//^0CEE:1112
							if (bp08->SimpleTextExtUsage() != 4) {
								//^0CEE:1127
								goto _1314;
							}
							//^0CEE:112A
							goto _1324;
						}
						//^0CEE:112D
						else if (bp1c > dbActuator && bp24 != 0) {
							goto _1314;
						}
						//^0CEE:113C
						else if (bp1c == itemdb) {
							//^0CEE:1147
							GenericRecord *bp08 = GET_ADDRESS_OF_RECORD(si);
							//^0CEE:1153
							switch (itemdb) {
								case dbCreature:	// 4
									{
										Creature *_bp08 = bp08->castToCreature();

										//^0CEE:1168
										//^0CEE:116B
										if (_bp08->b15_2_2() != 0)
											goto _1314;
										//^0CEE:117C
										if (_bp08->possession != OBJECT_END_MARKER)	// 0xFFFE
											goto _1314;
										//^0CEE:1186
										if (itemtype != 0xff) {
											//^0CEE:118C
											if (_bp08->CreatureType() != itemtype)
												goto _1314;
										}
										//^0CEE:119B
										CHANGE_CURRENT_MAP_TO(bp0e);
										//^0CEE:11A3
										DELETE_CREATURE_RECORD(bp10, bp12, CREATURE_DROP_POSSESSION_ONLY, 0xffff);	// (bp10, bp12, 1, 0xffff)
										//^0CEE:11B5
										break;
									}
								case dbMissile:		//14
									{
										Missile *_bp08 = bp08->castToMissile();

										//^0CEE:11B8
										if (itemtype != 0xff) {
											//^0CEE:11BE
											if (QUERY_CLS2_FROM_RECORD(_bp08->w2) != itemtype)
												goto _1314;
										}
										//^0CEE:11D3
										_075f_056c(si);
										//^0CEE:11DA
										CUT_RECORD_FROM(si, NULL, bp10, bp12);
										//^0CEE:11EC
										DELETE_MISSILE_RECORD(si, NULL, bp10, bp12);
										//^0CEE:11FC
										break;
									}
								case dbCloth:		// 6
									{
										Cloth *_bp08 = bp08->castToCloth();

										//^0CEE:11FF
										if (_bp08->Important() != 0)
											goto _1314;
										//^0CEE:1213
										//^0CEE:121A
										//^0CEE:1263
										Bit16u bp1e = _bp08->ItemType();
										//^0CEE:1269
										if (bp1e == bp27)
											goto _1314;
										//^0CEE:1278
										if (itemtype != 0xff && itemtype != bp1e)
											goto _1314;
										//^0CEE:1289
										CHANGE_CURRENT_MAP_TO(bp0e);
										//^0CEE:1291
										MOVE_RECORD_TO(si, bp10, bp12, -1, (bp20 != 0) ? -1 : 0);
										//^0CEE:12B0
										break;
									}
								case dbWeapon:		// 5
									{
										Weapon *_bp08 = bp08->castToWeapon();

										//^0CEE:121C
										if (_bp08->Important() != 0)
											goto _1314;
										//^0CEE:1230
										//^0CEE:1213
										//^0CEE:121A
										//^0CEE:1263
										Bit16u bp1e = _bp08->ItemType();
										//^0CEE:1269
										if (bp1e == bp27)
											goto _1314;
										//^0CEE:1278
										if (itemtype != 0xff && itemtype != bp1e)
											goto _1314;
										//^0CEE:1289
										CHANGE_CURRENT_MAP_TO(bp0e);
										//^0CEE:1291
										MOVE_RECORD_TO(si, bp10, bp12, -1, (bp20 != 0) ? -1 : 0);
										//^0CEE:12B0
										break;
									}
								case dbPotion:		// 8
									{
										Potion *_bp08 = bp08->castToPotion();

										//^0CEE:1248
										if (_bp08->VisiblePower() != 0)
											goto _1314;
										//^0CEE:125C
										Bit16u bp1e = _bp08->PotionType();
										//^0CEE:1269
										if (bp1e == bp27)
											goto _1314;
										//^0CEE:1278
										if (itemtype != 0xff && itemtype != bp1e)
											goto _1314;
										//^0CEE:1289
										CHANGE_CURRENT_MAP_TO(bp0e);
										//^0CEE:1291
										MOVE_RECORD_TO(si, bp10, bp12, -1, (bp20 != 0) ? -1 : 0);
										//^0CEE:12B0
										break;
									}
								case dbMiscellaneous_item:	//10
									{
										Miscellaneous_item *_bp08 = bp08->castToMisc();

										//^0CEE:1232
										if (_bp08->Important() != 0)
											goto _1314;
										//^0CEE:1246
										//^0CEE:1213
										//^0CEE:121A
										//^0CEE:1263
										Bit16u bp1e = _bp08->ItemType();
										//^0CEE:1269
										if (bp1e == bp27)
											goto _1314;
										//^0CEE:1278
										if (itemtype != 0xff && itemtype != bp1e)
											goto _1314;
										//^0CEE:1289
										CHANGE_CURRENT_MAP_TO(bp0e);
										//^0CEE:1291
										MOVE_RECORD_TO(si, bp10, bp12, -1, (bp20 != 0) ? -1 : 0);
										//^0CEE:12B0
										break;
									}
								case dbScroll:		// 7
								case dbContainer:	// 9
								case db11:			//11
								case db12:			//12
								case db13:			//13
									//^0CEE:12B0
									break;
							}
							//^0CEE:12B0
							CHANGE_CURRENT_MAP_TO(bp1a);
							//^0CEE:12B8
							_4976_4c42[itemdb] = (Bit8u)bp0e;
							//^0CEE:12C2v
							return si.GetAsNorth();
						}
						//^0CEE:12CA
						else if (bp1c == dbCreature && itemdb != dbMissile) {
							//^0CEE:12D6
							Creature *bp08 = GET_ADDRESS_OF_RECORD(si)->castToCreature();
							//^0CEE:12E2
							if (bp08->possession == OBJECT_END_MARKER) {
								//^0CEE:12EA
								goto _1314;
							}
							//^0CEE:12EC
							if (QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp08->CreatureType())->IsStaticObject() == 0) {
								//^0CEE:1300
								goto _1314;
							}
							//^0CEE:1302
							bp20 = 1;
							bp22 = si;
							//^0CEE:130A
							si = bp08->possession;
							//^0CEE:1311
							continue;
						}
						else {
							goto _1314;
						}

						//^0CEE:1314
_1314:
						si = GET_NEXT_RECORD_LINK(si);
						//^0CEE:131C
						if (si != OBJECT_END_MARKER)
							continue;
						//^0CEE:1324
_1324:
						if (bp20 == 0)
							break;
						//^0CEE:132A
						si = bp22;
						bp20 = 0;
						goto _1314;
					}
				}
				//^0CEE:1334
			}
			//^0CEE:1342
		}
		//^0CEE:1350
		if (bp0e == glbPlayerMap || dunHeader->nMaps <= 1) {
			//^0CEE:1364
			if (bp26 != 0) {
				//^0CEE:136A
				_4976_4c42[itemdb] = (Bit8u)bp0e;
				//^0CEE:1374
				//^0CEE:0ED4
				return OBJECT_NULL;
			}
			//^0CEE:1377
			bp26 = 1;
			//^0CEE:137C
			continue;
		}
		//^0CEE:137F
		if (di != 0xffff) {
			do {
				//^0CEE:1384
				if (dunHeader->nMaps <= (++bp0e)) {
					//^0CEE:1398
					bp0e = 0;
				}
				//^0CEE:139D
				if (bp0e == bp18) {
					//^0CEE:13A5
					bp0e = di;
					di = 0xffff;
				}
				//^0CEE:13AB
			} while (bp0e == di || bp0e == glbPlayerMap);
			//^0CEE:13B9
			continue;
		}
		do {
			//^0CEE:13BC
			if (dunHeader->nMaps <= (++bp0e)) {
				//^0CEE:13D0
				bp0e = 0;
			}
			//^0CEE:13D5
		} while (bp0e == glbPlayerMap);
		//^0CEE:13DE
		if (bp0e != bp18)
			continue;
		//^0CEE:13E6
		bp0e = glbPlayerMap;
	}
}

//^0CEE:1409
ObjectID SkWinCore::ALLOC_NEW_RECORD(Bit16u db)
{
	SkD((DLV_DBM, "DBM: ALLOC_NEW_RECORD(%2d)\n", (Bitu)db));

	//^0CEE:1409
	Bit16u si = db;
	ObjectID di = OBJECT_NULL;
	Bit16u bp08 = dunHeader->nRecords[(si & 0x7fff)];
	//^0CEE:1429
	if (si == 0x800a) { // 0x8000 is for bone?
		//^0CEE:142F
		si = 0x000a;
	}
	else {
		//^0CEE:1434
		if (si == 0x000a) {
			//^0CEE:1439
			bp08 -= 3;
		}
	}
	//^0CEE:143D
	Bit16u bp06 = bp08;
	Bit16u bp0a = glbItemSizePerDB[si];
	Bit8u *bp04 = glbDBObjectData[si];

	while (true) {
		//^0CEE:145F
		if (reinterpret_cast<GenericRecord *>(bp04)->w0 == OBJECT_NULL) {
			//^0CEE:1468
			di = ObjectID(0, si, bp08 - bp06);
		}
		else {
			//^0CEE:1479
			if (bp06-- != 0) {
				//^0CEE:147E
				bp04 += (bp0a >> 1) << 1;
				continue;
			}
			else {
				//^0CEE:148A
				di = RECYCLE_A_RECORD_FROM_THE_WORLD(si, 0xFF);
				//^0CEE:1496
				if (di == OBJECT_NULL) {
					//^0CEE:149B
					//^0CEE:14D5
					return OBJECT_NULL;
				}
				//^0CEE:14A0
				bp04 = reinterpret_cast<Bit8u *>(GET_ADDRESS_OF_RECORD(di));
			}
		}
		//^0CEE:14AC
		ZERO_MEMORY(bp04, bp0a);
		//^0CEE:14C0
		reinterpret_cast<GenericRecord *>(bp04)->w0 = OBJECT_END_MARKER;
		//^0CEE:14C8
		if (si == dbContainer) {
			//^0CEE:14CD
			reinterpret_cast<Container *>(bp04)->w2 = OBJECT_END_MARKER;
		}
		//^0CEE:14D3
		return di;
	}
}

//^069A:035B
X16 SkWinCore::_069a_035b(X16 xx)
{
	//^069A:035B
	ENTER(0);
	//^069A:035E
	if (xx == 0xffff)
		return 0xffff;
	//^069A:036B
	if ((_4976_00e3[RCJ(5, U8(xx))] & 8) != 0)
		return U8(xx) -32;
	//^069A:0381
	return U8(xx);
}
//^069A:0406
X16 SkWinCore::_sk_setjmp(jmp_buf xx)
{
	return setjmp(xx);
}

//^01B0:20EF
// TODO: random seed ?
i16 SkWinCore::_01b0_20ef()
{
	// Query random seed?
	// AH=sec.
	// AL=milli sec.

	time_t t;
	t = time(&t);
	return U8(localtime(&t)->tm_sec) << 8;
}

//^069A:038D
void (SkWinCore::*SkWinCore::_crt_getvect(U16 interruptno))() {
#if UseAltic
	return _sys_getvect(interruptno);
#else
#error	Unc
#endif
}

//^00EB:0BC4
void SkWinCore::_00eb_0bc4() //#DS=04BF
{
	//^00EB:0BC4
	ENTER(0);
	//^00EB:0BC8
	LOADDS(0x0C48);
	_04bf_0e34 = reinterpret_cast<U8 *>(__vram);
	U16 si = 1;
	do {
		//^00EB:0BDD
		if (si < 0xfa00) {
			//^00EB:0BE3
			IBMIO_FILL_SCREEN_LINE(si, 0, 1);
		}
		//^00EB:0BEF
		si = ((si & 1) != 0) ? ((si >> 1) ^ 0xb400) : (si >> 1);
		//^00EB:0C02
	} while (si != 1);
	//^00EB:0C09
	IBMIO_FILL_SCREEN_LINE(0, 0, 1);
	//^00EB:0C17
	return;
}

//^01B0:2B1B
// TODO : that one does nothing ?!
X16 SkWinCore::_01b0_2b1b()
{
	//^01B0:2B1B
	ENTER(0);
	//^01B0:2B1E
	return 0;
}

//^01B0:0E80
X16 SkWinCore::_01b0_0e80(void (SkWinCore::*pfn)()) //#DS=04BF
{
	//^01B0:0E80
	ENTER(0);
	//^01B0:0E83
	LOADDS(0x3083);
	_04bf_18ae = pfn;
	_04bf_0284 = 1;

	SkD((DLV_DBG_TICK, "Tick step value = %03d\n", 1));
	//^01B0:0EA0
	return 1;
}

//^4726:03B2
// TODO: related to some init ?
void SkWinCore::_4726_03b2()
{
	//^4726:03B2
	ENTER(0);
	//^4726:03B5
#if UseAltic
	_4976_5e90 = _4976_5e98 = _4976_5e88 = _4976_5e8c = 0;
#else
	_4976_5e90 = _crt_getvect(0xfe);
	_4976_5e98 = _4976_5e90;
	_4976_5e88 = _crt_getvect(0xff);
	_4976_5e8c = _4976_5e88;
#endif
	//^4726:03F1
	glbRandomSeed = _01b0_20ef() CALL_IBMIO * 0x7AE3;
#if UseAltic
	glbRandomSeed = 12345;
#endif
	_00eb_0bc4();
	IBMIO_SELECT_PALETTE_SET(0);
	_01b0_2b1b();
	glbTickStepValue = _01b0_0e80(&SkWinCore::_4726_0383);
	//^4726:0446
	return;
}

//^069A:0309
U32 SkWinCore::_crt_farcoreleft() { // TODO: Unr
	Unr(); return 0;
}

//^069A:0387
U32 SkWinCore::_crt_coreleft() { // TODO: Unr
	Unr(); return 0;
}

//^069A:0470
i16 SkWinCore::_crt_setblock(U16 segx, U16 newsize) { // TODO: Unr
	Unr(); return 0;
}

//^069A:01DD
U16 SkWinCore::_crt_normalize(U8 *cp) { // TODO: Unr
	Unr(); return 0;
}

//^069A:029C
U8 *SkWinCore::_crt_brk(U32 addr) { // TODO: Unr
	Unr(); return NULL;
}

//^069A:0607
U8 *SkWinCore::_crt_CreateHeap(U16 ax) { // TODO: Unr
	Unr(); return NULL;
}

//^069A:06CE
U8 *SkWinCore::_crt_farmalloc(U32 size) { // TODO: Unr
	Unr(); return NULL;
}

//^3E74:04D8
void SkWinCore::INIT_FREE_POOL(sk5d00 *ref, i32 size, U16 poolflag)
{
	//^3E74:04D8
	ENTER(0);
	//^3E74:04DB
	EMS_MAP_BANK_TO_MEMORY();
	ref->pv0 = _4976_5d00;
	ref->dw4 = size -sizeof(sk5d00);
	ref->w16 = poolflag;
	if (ref->Is4EMS()) {
		//^3E74:0523
		_4976_5d20 = CONVERT_PHYS_TO_SHELF_FORM(reinterpret_cast<U8 *>(ref));
		ref->dw8 = ref->dw4 +0x00200000 +sizeof(sk5d00);
	}
	else {
		//^3E74:0551
		ref->dw8 = reinterpret_cast<U32ptr>(PTR_PADD(ref,ref->dw4 +sizeof(sk5d00)));
	}
	//^3E74:057C
	ref->dw12 = ref->dw4;
	_4976_5d00 = ref;
	//^3E74:059C
	return;
}
//^3E74:059E
sk5d00 *SkWinCore::_3e74_059e(X16 xx)
{
	//^3E74:059E
	ENTER(12);
	//^3E74:05A3
	X16 si = xx;
	sk5d00 *bp08 = NULL;
	U32 bp0c = 0;
	sk5d00 *bp04 = _4976_5d00;
	if (bp04 == NULL) {
		return NULL;
	}
	//^3E74:05DD
	EMS_MAP_BANK_TO_MEMORY();
	do {
		//^3E74:05EB
		if (bp04->w18 != 0)
			continue;
		if ((bp04->w16 & si) != si)
			continue;
		if ((bp04->w16 & 0x800) != (si & 0x800))
			continue;
		if (bp04->dw4 <= bp0c)
			continue;
		//^3E74:0624
		bp08 = bp04;
		bp0c = bp08->dw4;
		//^3E74:0641
	} while ((bp04 = bp04->pv0) != NULL);
	//^3E74:0660
	if (bp08 != NULL) {
		//^3E74:0671
		bp08->w18 = 1;
	}
	//^3E74:067A
	return bp08;
}

//^3E74:1175
U16 SkWinCore::ADD_MEM_TO_FREE_POOL(sk5d00 *pool, i32 size, X16 poolflag)
{
	//^3E74:1175
	ENTER(4);
	//^3E74:1179
	if (pool != NULL) {
		//^3E74:118A
		size &= 0xfffffffe;
		if (size < 32) {
			//^3E74:11A2
			return 0;
		}
		//^3E74:11A7
		INIT_FREE_POOL(pool, size, poolflag);
		return 1;
	}
	//^3E74:11C0
	_4976_5c7a = 1;
	sk5d00 *bp04 = _3e74_059e(0x7f8);	// 0x7f8 = 2040
	if (bp04 == NULL) {
		//^3E74:11DF
		RAISE_SYSERR(SYSTEM_ERROR__CANT_ADD_MEM);
	}
	//^3E74:11E7
	_4976_5cb2 = _4976_5ce6 = reinterpret_cast<mement *>(&bp04[+1]);
	_4976_5cf0 = _4976_5cf4 = PTR_PADD(bp04,+bp04->dw4 +sizeof(sk5d00));
	glbFreeRAMMemPool = bp04->dw4;
	_4976_5cee = bp04->w16;
	//^3E74:124C
	bp04 = _3e74_059e(0xc00);
	if (bp04 != NULL || (bp04 = _3e74_059e(0x400)) != NULL) {
		//^3E74:127E
		_4976_5d6e = bp04->w16;
		if ((_4976_5d6e & 0x800) != 0) {
			//^3E74:1290
			_4976_5d5a = tiamat::From_cems(bp04->dw4 +sizeof(sk5d00));
		}
		else {
			//^3E74:12A7
			_4976_5d5a = ptr2t(PTR_PADD(bp04,+bp04->dw4 +sizeof(sk5d00)));
		}
		//^3E74:12CE
		glbFreeEMSMemPool = bp04->dw4;
	}
	//^3E74:12E0
	_4976_5d04 = ALLOC_MEMORY_RAM(TEMP_BUFF_SIZE, afUseUpper, 0x280);
	_4976_5d94 = NULL;
	_4976_5d90 = NULL;
	_4976_5c8c = NULL;
	_4976_5d70 = NULL;
	_4976_5d5e = NULL;
	_4976_5d2a = -1;
	//^3E74:132B
	return 1;
}
//^4726:0055
U32 SkWinCore::EMS_ALLOC_POOL(U8 **buff)
{
#if UseAltic
	_4976_5ea0 = cems;
	_4976_5eac = shelf_memory::From_cems(sizeof(cems) -0x8000);
	return sizeof(cems) -0x8000;
#else
	ATLASSERT(false);
	return 0;
#endif
//!	//^4726:0055
//!	ENTER(4);
//!	//^4726:0059
//!	_4976_5ea4 = 0;
//!	WRITE_UI16(buff,+0,0);
//!	WRITE_UI16(buff,+2,0);
//!	if (_4726_000d() == 0)
//!		return 0;
//!	//^4726:0078
//!	__asm mov ah,0x42
//!	__asm int 0x67
//!	if (ah == 0) {
//!		U16 bp02 = bx;
//!		__asm mov ah,0x43
//!		__asm int 0x67
//!		if (ah == 0) {
//!			//^4726:008D
//!			_4976_5ea4 = dx;
//!			__asm mov ah,0x41
//!			__asm int 0x67
//!			U16 bp04 = bx;
//!			WRITE_UI16(buff,+0,0);
//!			WRITE_UI16(buff,+2,bp04);
//!			EMS_MAP_BANK_TO_MEMORY();
//!			if (bp02 >= 0x10) {
//!				//^4726:00BB
//!				_4976_4968 = 1;
//!				_4976_5eac = shelf_memory::FromPg(bp02).Subtract(0x8000);
//!				return _4976_5eac;
//!			}
//!			//^4726:00DF
//!			return bp02 << 14;
//!		}
//!	}
//!	//^4726:00ED
//!	return 0;
}

//^4726:02F7
void SkWinCore::_4726_02f7()
{
	//^4726:02F7
	ENTER(0);
	//^4726:02FA
#if UseAltic
	_4976_5e9c = sizeof(cram);
	_4976_5e94 = cram;
#else
	_4976_5e9c = _crt_coreleft();
	_4976_5e94 = _crt_farmalloc(_4976_5e9c);
#endif
	if (_4976_5e94 == NULL) {
		//^4726:0320
		__terminate(0);
	}
	//^4726:0328
	ATLVERIFY(ADD_MEM_TO_FREE_POOL(reinterpret_cast<sk5d00 *>(_4976_5e94), _4976_5e9c, 0x7f8));
	_4976_5ea6 = EMS_ALLOC_POOL(&_4976_5ea0);
	ATLVERIFY(ADD_MEM_TO_FREE_POOL(reinterpret_cast<sk5d00 *>(_4976_5ea0), _4976_5ea6, 0xc00));
	ATLVERIFY(ADD_MEM_TO_FREE_POOL(NULL, NULL, 0));
	//^4726:0381
	return;
}

//^01B0:1FFC
X16 SkWinCore::_01b0_1ffc(X16 xx)
{
#if UseAltic
	return 1;
#else
	// TODO: ioctl
	ATLASSERT(false);
	return 1;
#endif
}

//^476D:02E0
X16 SkWinCore::_476d_02e0(X16 xx)
{
	//^476D:02E0
	ENTER(0);
	//^476D:02E3
	return _01b0_1ffc(xx) CALL_IBMIO;
}

//^01B0:20CA
void SkWinCore::_01b0_20ca(i16 drvno, U8 *str)
{
	//^01B0:20CA
	ENTER(0);
	//^01B0:20CD
	if (drvno >= 0 && drvno < 0x19) {
		//^01B0:20D9
		str[0] = U8(drvno) +0x40;
		str[1] = ':';
		str[2] = 0;
	}
	//^01B0:20ED
	return;
}

//^476D:04F4
void SkWinCore::_476d_04f4(i16 drvno, U8 *str)
{
	//^476D:04F4
	ENTER(0);
	//^476D:04F7
	_01b0_20ca(drvno, str);
	//^476D:050C
	return;
}

//^476D:018A
void SkWinCore::_476d_018a()
{
	//^476D:018A
	ENTER(0);
	//^476D:018D
	//^476D:01AE
	_4976_5eb2 = _getdrive();
	if (_476d_02e0(_4976_5eb2) == 1) {
		//^476D:01C1
		glbDriveNumber = _4976_5eb2;
		_4976_499e = 1;
		_4976_5ebc = _4976_5eb2;
		_4976_49a0 = 1;
		_4976_5eb4 = 1;
		_4976_5eb0 = 1;
	}
	else {
		//^476D:01E2
		_4976_5eb6 = _4976_5eb2;
		glbDriveNumber = _4976_5eb4 = _4976_5eb2 ^ 3;
		if (glbDriveNumber == 1) {
			//^476D:01FB
			if (_476d_02e0(2) != 0 && _476d_02e0(1) == _476d_02e0(2)) {
				//^476D:021D
				_4976_5ebc = 2;
				_4976_5eb0 = 0;
			}
			else {
				//^476D:022B
				_4976_5ebc = _4976_5eb2;
				_4976_5eb0 = 1;
			}
		}
		//^476D:0239
		else if (glbDriveNumber == 2) {
			if (_476d_02e0(1) != 0 && _476d_02e0(1) == _476d_02e0(2)) {
				//^476D:0262
				_4976_5ebc = 1;
				_4976_5eb0 = 0;
			}
			else {
				//^476D:0270
				_4976_5ebc = _4976_5eb2;
				_4976_5eb0 = 1;
			}
		}
		else {
			//^476D:027E
			_4976_5ebc = _4976_5eb2;
			_4976_5eb0 = 1;
		}
	}
	//^476D:028A
	if (_4976_499e != 0) {
		_476d_04f4(1, _4976_4980);
	}
	else {
		_476d_04f4(glbDriveNumber, _4976_4980);
	}
	//^476D:02A9
	_476d_04f4(_4976_5ebc, _4976_4984);
	//SPX: 0x40 = 'A'-1
	strDirLetter[0] = glbDriveNumber + 0x40;
	strDirLetter2[0] = _4976_5ebc +0x40;
	//^476D:02C9
	return;
}
//^2636:03D4
void SkWinCore::_2636_03d4()
{
	//^2636:03D4
	ENTER(0);
	//^2636:03D8
	_4976_52f8 = 0;
	i16 si = 0;
	for (; si < 2; si++) {
		//^2636:03E2
		_4976_52ea[si] = ALLOC_MEMORY_RAM(0x80, afUseUpper, 0x400);
	}
	//^2636:0407
	return;
}

//^476D:0020
//U32 GET_FILE_POS_6(i16 handle);

//^476D:003C
U32 SkWinCore::GET_FILE_SIZE(i16 handle) {
	return fset.fileGetSize(handle);
}

//^3E74:0004
U16 SkWinCore::SWAPW(U16 xx)
{
	//^3E74:0004
	ENTER(0);
	//^3E74:0007
	return (xx << 8) + (xx >> 8);
}
//^3E74:16ED
U32 SkWinCore::QUERY_GDAT_ENTRY_VALUE(U16 entryIndex, U16 entryPos)
{
	ATLASSERT(entryPos < 7);

	//^3E74:16ED
	ENTER(8);
	//^3E74:16F3
	X16 di = entryPos;
	U8 *bp04 = PTR_PADD(PTR_PADD(_4976_5d38,U32(entryIndex) * _4976_5d3e),_4976_5d42[di]);
	i16 si = _4976_5d50[di];
	U32 bp08 = 0;
	while (si-- > 0) {
		//^3E74:1746
		bp08 = (bp08 << 8) + i16(*bp04);
		bp04++;
	}
	//^3E74:1782
	return bp08;
}

//^3E74:216A
void SkWinCore::LOAD_GDAT_ENTRIES()
{
	//^3E74:216A
	ENTER(12);
	//^3E74:2170
	X16 di;
	for (di = 0; di < glbGDatNumberOfRawEntries; di++) {
		//^3E74:2175
		if (QUERY_GDAT_ENTRY_VALUE(di, EPcls6) != 0xff)
			continue;
		U8 bp05 = QUERY_GDAT_ENTRY_VALUE(di, EPcls3);
		if (bp05 == 0xb || bp05 == 0xc)
			continue;
		//^3E74:21A3
		X16 si = QUERY_GDAT_ENTRY_VALUE(di, EPdata);
		if (glbShelfMemoryTable[si].Present())
			continue;
		//^3E74:21CC
		U16 bp08;
		if (QUERY_GDAT_ENTRY_VALUE(di, EPcls1) != 1) {
			//^3E74:21DC
			shelf_memory bp0c = ALLOC_MEMORY_EMS((bp08 = QUERY_GDAT_RAW_DATA_LENGTH(si)) +2, afUseUpper, 0xc00) +2;
			U8 *bp04 = REALIZE_GRAPHICS_DATA_MEMORY(bp0c);
			//^3E74:2214
			WRITE_UI16(bp04,-2,bp08);
//LOGX(("LOAD_GDAT_RAW_DATA call from LOAD_GDAT_ENTRIES (1)"));
			LOAD_GDAT_RAW_DATA(si, glbShelfMemoryTable[si] = bp0c);
			EMS_MAP_BANK_TO_MEMORY();

			SkD((DLV_GLD, "GLD: Load Raw#%4d at EMS(%08X)\n", (Bitu)si, (Bitu)bp0c.val));
		}
		else {
			//^3E74:225B
			U8 *bp04 = ALLOC_MEMORY_RAM((bp08 = QUERY_GDAT_RAW_DATA_LENGTH(si)) +2, afUseUpper, 0x400);
			WRITE_UI16(bp04,+0,bp08);
//LOGX(("LOAD_GDAT_RAW_DATA call from LOAD_GDAT_ENTRIES (2)"));
			LOAD_GDAT_RAW_DATA(si, glbShelfMemoryTable[si] = CONVERT_PHYS_TO_SHELF_FORM(bp04 +2));

			SkD((DLV_GLD, "GLD: Load Raw#%4d at RAM(%08X)\n", (Bitu)si, bp04));
		}
		//^3E74:22C1
	}
	//^3E74:22CB
	return;
}
//^3E74:2162
X16 SkWinCore::_3e74_2162(U16 xx)
{
	//^3E74:2162
	ENTER(0);
	//^3E74:2165
	return 1;
}

X16 SkWinCore::LANG_FILTER(U16 entryIndex)
{
	U8 cls1 = U8(QUERY_GDAT_ENTRY_VALUE(entryIndex, EPcls1)); // Main category
	U8 cls2 = U8(QUERY_GDAT_ENTRY_VALUE(entryIndex, EPcls2)); // Sub category
	U8 cls3 = U8(QUERY_GDAT_ENTRY_VALUE(entryIndex, EPcls3)); // Entry kind
	U8 cls4 = U8(QUERY_GDAT_ENTRY_VALUE(entryIndex, EPcls4)); // Entry no
	U8 cls5 = U8(QUERY_GDAT_ENTRY_VALUE(entryIndex, EPcls5)); // Optional 1

	if (cls3 == fmtText) {

		if (cls5 == s_textLangSel[cls1][cls2][cls4]) {
			// already elected
			return 1;
		}

		if (cls5 == 0x00 || cls5 == 0xF0) {
			// language independent text
			if (s_textLangSel[cls1][cls2][cls4] == 0xFF) {
				s_textLangSel[cls1][cls2][cls4] = cls5;
				return 1;
			}
		}

		if (cls5 == skwin.GetLang()) {
			// elected language
			if (s_textLangSel[cls1][cls2][cls4] == 0xFF) {
				s_textLangSel[cls1][cls2][cls4] = cls5;
				return 1;
			}
			if (SkCodeParam::bUseMultilanguageExtended 
				&& cls1 == GDAT_CATEGORY_CHAMPIONS) {
				s_textLangSel[cls1][cls2][cls4] = cls5;
				return 0;	// don't return 1 or it will crash because the standard text is already here with cls5 = 0x00
			}
		}
		return 0; // never pass for other language.
	}

	// SPX: manages also localized images only for char interface
#if DM2_EXTENDED_MODE == 1
	if (SkCodeParam::bUseMultilanguageExtended) {
		if (cls3 == fmtImage && (cls1 == GDAT_CATEGORY_INTERFACE_CHARSHEET || cls1 == GDAT_CATEGORY_TITLE)) {
			U8 iLangSelect = (cls5 & 0xF0);	// Do not take variation 0x08 into account

			if (iLangSelect == s_imageLangSel[cls1][cls2][cls4]) {
				return 1;
			}

			if (iLangSelect == 0x00 || iLangSelect == 0xF0) {
				if (s_imageLangSel[cls1][cls2][cls4] == 0xFF) {
					s_imageLangSel[cls1][cls2][cls4] = iLangSelect;
					return 1;
				}
			}

			if (iLangSelect == skwin.GetLang()) {
				// If corresponding language, always prioritary
					s_imageLangSel[cls1][cls2][cls4] = iLangSelect;
					return 1;
			}
		return 0;
		}
	}
#endif // DM2_EXTENDED_MODE
	
	return 1; // always pass for non text entry.
}

//^3E74:1D5F
// SPX: With help from Kentaro to enable more memory when loading GDAT (specially to go over 0x1C categories)
void SkWinCore::BUILD_GDAT_ENTRY_DATA(GDATEntries *ref, X16 (SkWinCore::*pfnIfLoad)(U16 xx), U8 *zz)
{
	//^3E74:1D5F
	ENTER(14);
	//^3E74:1D65
	// SPX: Original value was 0x3a0, so 0x1D max categories
	const int buffSize = (GDAT_CATEGORY_LIMIT+1) * 16 * 2;
	U16 *bp04 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(buffSize, afUseLower|afZeroMem, 0x400));
	ref->w12 = 0;
	ref->w16 = 0;
	U16 si;
	U8 bp0a;
	for (si = 0; si < glbGDatNumberOfRawEntries; si++) {
		//^3E74:1D91
		if ((this->*pfnIfLoad)(si) == 0)
			continue;
		//^3E74:1D9D
		bp0a = U8(QUERY_GDAT_ENTRY_VALUE(si, EPcls1));
		U8 bp09 = U8(QUERY_GDAT_ENTRY_VALUE(si, EPcls3));
		if (bp0a > GDAT_CATEGORY_LIMIT || bp09 > 0xe)
			continue;
		//^3E74:1DC1
		ref->w16++;
		if (ref->w12 < bp0a) {
			//^3E74:1DD3
			ref->w12 = bp0a;
		}
		//^3E74:1DDC
		bp04[(bp0a << 4) + (bp09)]++;
		if (bp04[(bp0a << 4) +15] <= bp09) {
			//^3E74:1E11
			bp04[(bp0a << 4) +15] = bp09 +1;
		}
		//^3E74:1E2C
	}
	//^3E74:1E36
	X16 bp0c = 0;
	for (bp0a = 0; ref->w12 >= bp0a; bp0a++) {
		//^3E74:1E41
		bp0c += bp04[(bp0a << 4) +15];
		//^3E74:1E59
	}
	//^3E74:1E6A
	ref->w14 = bp0c;
	ref->w18 = 0;
	ref->w20 = 0;
	U16 di;
	for (di = 0; di < 7; di++) {
		//^3E74:1E81
		if (di <= 4) {
			//^3E74:1E86
			ref->b36[di] = _4976_483f[RCJ(5,di)];
			ref->w18 += _4976_483f[RCJ(5,di)];
			ref->w22[di] = 0xffff;
			if (_4976_483f[RCJ(5,di)] > 0) {
				//^3E74:1EAA
				ref->w20++;
			}
			continue;
		}
		//^3E74:1EB3
		if (zz[di] != 0) {
			ref->w22[di] = ref->w18;
			ref->b36[di] = _4976_5d50[RCJ(7,di)];
			ref->w18 += _4976_5d50[RCJ(7,di)];
			ref->w20++;
		}
		//^3E74:1EE2
	}
	//^3E74:1EE8
	ref->pw0 = reinterpret_cast<X16 *>(ALLOC_MEMORY_RAM((ref->w12 +2) << 1, afUseUpper, 0x400));
	ref->pw4 = reinterpret_cast<X16 *>(ALLOC_MEMORY_RAM((ref->w14 +1) << 1, afUseUpper, 0x400));
	ref->pv8 = reinterpret_cast<RawEntry *>(ALLOC_MEMORY_RAM(U32(ref->w16) << 2, afUseUpper, 0x400));
	bp0c = 0;
	si = 0;
	U8 bp09;
	for (bp0a = 0; ref->w12 >= bp0a; bp0a++) {
		//^3E74:1F66
		ref->pw0[bp0a] = bp0c;
		di = bp04[(bp0a << 4) +15];
		for (bp09 = 0; bp09 < di; bp0c++, bp09++) {
			//^3E74:1F96
			ref->pw4[bp0c] = si;
			si += bp04[(bp0a << 4) +bp09];
			//^3E74:1FC6
		}
		//^3E74:1FCF
	}
	//^3E74:1FE0
	ref->pw0[ref->w12 +1] = bp0c;
	//^3E74:1FFC
	ref->pw4[ref->w14] = ref->w16;
	//^3E74:2021
	ZERO_MEMORY(bp04, buffSize);	// Original buffsize = 0x3a0
	ZERO_MEMORY(ref->pv8, U32(ref->w16) << 2);
	//^3E74:2059
	X16 bp0e;
	for (si = 0; si < glbGDatNumberOfRawEntries; si++) {
		//^3E74:205E
		if ((this->*pfnIfLoad)(si) == 0)
			continue;
		//^3E74:206A
		bp0a = QUERY_GDAT_ENTRY_VALUE(si, EPcls1);
		bp09 = QUERY_GDAT_ENTRY_VALUE(si, EPcls3);
		if (bp0a > GDAT_CATEGORY_LIMIT || bp09 > 0xe)
			continue;
		//^3E74:2094
		di = bp04[(bp0a << 4) +bp09]++;
		RawEntry *bp08 = &ref->pv8[ref->pw4[ref->pw0[bp0a] +bp09] +di];
		bp08->cls2 = QUERY_GDAT_ENTRY_VALUE(si, EPcls2);
		bp08->cls4 = QUERY_GDAT_ENTRY_VALUE(si, EPcls4);
		bp08->data = QUERY_GDAT_ENTRY_VALUE(si, EPdata);
		bp0e = QUERY_GDAT_ENTRY_VALUE(si, EPcls6);
		if (bp0e == 1) {
			//^3E74:2140
			bp08->data |= 0x8000;
		}
		//^3E74:2149
	}
	//^3E74:2153
	DEALLOC_LOWER_MEMORY(buffSize);		// Original buffsize = 0x3a0
	//^3E74:215E
	return;
}

//^3E74:22CF
void SkWinCore::LOAD_ENT1()
{
	//^3E74:22CF
	ENTER(8);
	//^3E74:22D5
	U32 bp08 = _4976_5d7a;
	_4976_5d38 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(bp08, afUseLower, 0x400));
//LOGX(("LOAD_GDAT_RAW_DATA call from LOAD_ENT1"));
	LOAD_GDAT_RAW_DATA(0, CONVERT_PHYS_TO_SHELF_FORM(reinterpret_cast<U8 *>(_4976_5d38)));
	U16 si = *_4976_5d38;
	if (si != 0x8001 && SWAPW(si) != 0x8001) {
		RAISE_SYSERR(SYSTEM_ERROR__INVALID_ENT1);
	}
	//^3E74:2334
	glbGDatNumberOfRawEntries = _4976_5d38[1];
	_4976_5d40 = _4976_5d38[2];
	if (si != 0x8001) {
		//^3E74:2350
		glbGDatNumberOfRawEntries = SWAPW(glbGDatNumberOfRawEntries);
		_4976_5d40 = SWAPW(_4976_5d40);
	}
	//^3E74:2368
	U8 (*bp04)[2] = (U8 (*)[2])PTR_PADD(_4976_5d38,+6);
	FILL_U16(_4976_5d42, 7, -1, 2);
	_4976_5d3e = 0;
	for (si = 0; si < _4976_5d40; si++) {
		//^3E74:239B
		i16 di;
		for (di = 0; di < 7; di++) {
			//^3E74:239F
			if (bp04[si][0] == _4976_4813[RCJ(7,di)]) {
				_4976_5d50[RCJ(7,di)] = bp04[si][1];
				_4976_5d42[di] = _4976_5d3e;
				break;
			}
			//^3E74:23CF
		}
		//^3E74:23D5
		_4976_5d3e += bp04[si][1];
		//^3E74:23E8
	}
	//^3E74:23EF
	_4976_5d38 = reinterpret_cast<U16 *>(bp04[_4976_5d40]);
	LOAD_GDAT_ENTRIES();
// SPX: add here a localized image table as for texts to be able to support multilanguage interface
#if DM2_EXTENDED_MODE == 1
	memset(s_imageLangSel, 0xFF, sizeof(s_imageLangSel));
#endif
	memset(s_textLangSel, 0xFF, sizeof(s_textLangSel));
	//BUILD_GDAT_ENTRY_DATA(&glbGDatEntries, &SkWinCore::_3e74_2162, _4976_4844);
	BUILD_GDAT_ENTRY_DATA(&glbGDatEntries, &SkWinCore::LANG_FILTER, _4976_4844);
	DEALLOC_LOWER_MEMORY(bp08);
	_4976_5d38 = NULL;
	//^3E74:2435
	return;
}
//^3E74:24B8
void SkWinCore::_3e74_24b8()
{
	//^3E74:24B8
	ENTER(38);
	//^3E74:24BE
	U16 si;
	for (si = 0; si < 2; si++) {
		//^3E74:24C3
		if (si > 0 && _4976_5d58 == 0)
			break;
		//^3E74:24D1
		SkEntIter bp26;
		bp26.w0 = 1;
		bp26.w22 = 0;
		bp26.x2.x2.cls1(0xff);
		bp26.x2.x2.cls2(0xff);
		bp26.x2.x2.cls3(fmtSound);
		bp26.x2.x2.cls4(0xff);
		X16 di;
		X16 *bp04;
		if (si > 0) {
			//^3E74:24EF
			bp04 = reinterpret_cast<X16 *>(ALLOC_MEMORY_RAM(_4976_5d58 << 1, afDefault, 0x400));
			di = 0;
		}
		while (QUERY_NEXT_GDAT_ENTRY(&bp26)) {
			//^3E74:250D
			U16 bp08 = bp26.pv14->data;
			if (si == 0) {
				//^3E74:251B
				_4976_5d58++;
				U16 bp06 = QUERY_GDAT_RAW_DATA_LENGTH(bp08);
				if (bp06 > _4976_5c7c)
					//^3E74:2530
					_4976_5c7c = bp06;
				continue;
			}
			//^3E74:2535
			X16 bp0a;
			for (bp0a = 0; bp0a < di; bp0a++) {
				//^3E74:253C
				if (bp04[bp0a] == bp08)
					goto _256a;
				//^3E74:254E
			}
			//^3E74:2556
			bp04[di] = bp08;
			//^3E74:2565
			di++;
			_4976_5cae++;
			//^3E74:256A
_256a:
			continue;
		}
		//^3E74:2579
		if (si > 0) {
			DEALLOC_UPPER_MEMORY(_4976_5d58 << 1);
		}
		//^3E74:258B
	}
	//^3E74:2594
	return;
}

// SPX: Add function to detail important GDAT values, in order to compare to other SkWin versions
void SkWinCore::DEBUG_DISPLAY_GDAT_MAIN_INFO()
{
	unsigned int iItemIndex = 0;
	LOGX(("DEBUG_DISPLAY_GDAT_MAIN_INFO"));
	LOGX(("#Items: %04d", glbGDatNumberOfData));
	for (iItemIndex = 0; iItemIndex < glbGDatNumberOfData; iItemIndex++) 
	{
		LOGX(("ShelfMemTab: %04d => Val = %08X [%d] (%05d)", iItemIndex, glbShelfMemoryTable[iItemIndex].val, glbShelfMemoryTable[iItemIndex].Absent(), (glbShelfMemoryTable[iItemIndex].val & 0x7FFFFFF) ));
	}
	// Max of each category
	unsigned int iCategoryIndex = 0;
	for (iCategoryIndex = 0; iCategoryIndex < 26; iCategoryIndex++) 
	{
		unsigned int iMaxItemsForCategory = 0;
		iMaxItemsForCategory = _3e74_2439(iCategoryIndex, 0x0B);
		LOGX(("Category: %02d => # %03d", iCategoryIndex, iMaxItemsForCategory ));
	}
	LOGX(("============================"));

}

#define MIN(a,b) ( (a < b) ? a : b )

void SkWinCore::DEBUG_DUMP_ULP()
{
	unsigned int iItemNumber = 0;
LOGX(("============================\n"));
LOGX(("ULP >> "));
	for (iItemNumber = 0; iItemNumber < glbGDatNumberOfData; iItemNumber++)
	{
		char sInfoPointer[8];
		char sData[128];
		U32 val = 0;
		memset(sInfoPointer, 0, 8);
		memset(sData, 0, 128);
		//shelf_memory *glbShelfMemoryTable
		//u_lp* p = dm2_ulp.getadr(iItemNumber);
		shelf_memory* p = &glbShelfMemoryTable[iItemNumber];
		val = glbShelfMemoryTable[iItemNumber].val;
		//shelf_memory();
		if (p != NULL && (void*) p < (void*) 0x70000000)	// assume else it is not valid
		{
			Bit8u* xDataPointer = NULL;
			unsigned int iLength = 0;
			iLength = QUERY_GDAT_RAW_DATA_LENGTH(iItemNumber);
			iLength= iLength & 0x7FFFFFFF;

			
			if (val & 0x80000000) // not a direct pointer
			{
				unsigned int iMemOffset = val & 0x7FFFFFFF;
				sprintf(sInfoPointer, "(np)");
			}
			else
			{
				xDataPointer = REALIZE_GRAPHICS_DATA_MEMORY(glbShelfMemoryTable[iItemNumber]);
			}
			if (xDataPointer != NULL) // we have a valid data pointer
			{
				unsigned int iMaxBytesToDisplay = MIN(16, iLength);
				unsigned char* pData;
				char* sWriteData = (char*) sData;

				pData = (unsigned char*) xDataPointer;
				for (unsigned int iByte = 0; iByte < iMaxBytesToDisplay; iByte++)
				{
					sprintf(sWriteData, "%02X ", pData[iByte]);
					pData++;
					sWriteData+=3;
				}

			}
			
			
			LOGX(("u_lp #%04d: %08x || x32 = %08x %4s -> len = %05d (%04X) || i8* = %08X  || Data = %s", iItemNumber, p, val, sInfoPointer, iLength, iLength, xDataPointer, sData)); 
				
		}
		else
			LOGX(("p %04d: %08x ", iItemNumber, p));
	}
LOGX(("============================\n"));
}



const char* SkWinCore::DEBUG_SKLOADENT(U8* xSkLoadEnt)
{
	static char xStaticDebugLoadEnt[32];
	unsigned int iCls1Category = 0;
	unsigned int iCls2 = 0;
	unsigned int iCls3 = 0;
	unsigned int iCls4 = 0;
	memset(xStaticDebugLoadEnt, 0, 32);

	iCls1Category = xSkLoadEnt[2];
	iCls2 = xSkLoadEnt[3];
	iCls3 = xSkLoadEnt[4];
	iCls4 = xSkLoadEnt[5];


	sprintf(xStaticDebugLoadEnt, "%02X-%02X-%02X-%02X", iCls1Category, iCls2, iCls3, iCls4);
	return xStaticDebugLoadEnt;
}



const char* SkWinCore::DEBUG_SKGDATENT(SkEntIter* xSkGDATEnt)
{
	static char xStaticDebugGDATEnt[128];
	char sLoadEntFrom[32];
	char sLoadEntTo[32];
	unsigned int iValue32 = 0;
	unsigned char* xRawPointer = NULL;

	memset(sLoadEntFrom, 0, 32);
	memset(sLoadEntTo, 0, 32);
	memset(xStaticDebugGDATEnt, 0, 128);

	iValue32 = xSkGDATEnt->w0;
	xRawPointer = (unsigned char*) xSkGDATEnt->pv14;
	sprintf(sLoadEntFrom, "%s", DEBUG_SKLOADENT((U8*)&xSkGDATEnt->x2));
	sprintf(sLoadEntTo, "%s", DEBUG_SKLOADENT((U8*)&xSkGDATEnt->x8));

	sprintf(xStaticDebugGDATEnt, "%s to %s -=- x32 = %08x / pRaw = %08x", sLoadEntFrom, sLoadEntTo, iValue32, xRawPointer);
	return xStaticDebugGDATEnt;

}

//^3E74:2641
void SkWinCore::READ_GRAPHICS_STRUCTURE()
{
	//^3E74:2641
	ENTER(12);
	//^3E74:2647
	_4976_5d10 = 0;
	GRAPHICS_DATA_OPEN();
	skfh4 bp0c;
	if (READ_FILE(glbFileHandleGraphics1, 4, &bp0c) == 0)	// Read the first 4 bytes of GDAT, which hold GDAT signature + nb of data items
		goto _28d2;
	if ((bp0c.w0 & 0x8000) == 0)
		goto _28d2;
	//^3E74:2677
	glbGDATVersion = bp0c.w0 & 0x7fff;
	glbGDatNumberOfData = bp0c.w2;
	U16 *bp04;
	X32 bp08;
	if (glbGDATVersion != 4 && glbGDATVersion != 5 && glbGDATVersion != 2)
		goto _28d2;
	//^3E74:269E
	glbShelfMemoryTable = reinterpret_cast<shelf_memory *>(ALLOC_MEMORY_RAM(sizeof(shelf_memory) * U32(glbGDatNumberOfData), afUseUpper, 0x400));
	_4976_5c82 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(U32(glbGDatNumberOfData) << 1, afUseUpper, 0x400));
	FILL_U16(reinterpret_cast<i16 *>(_4976_5c82), glbGDatNumberOfData, -1, 2);
	bp08 = U32(glbGDatNumberOfData) << 1;	// nb items * 2 = nb of bytes for all item sizes
	bp04 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(bp08, afDefault, 0x400));
	_4976_5d6a = bp08 +4;	// nb items sizes + (magic number + nb items) = offset of first raw data which must be the ENT1
	if (glbGDATVersion < 3) {
		if (READ_FILE(glbFileHandleGraphics1, bp08, bp04) == 0)
			goto _28d2;
		//^3E74:2755
		_4976_5d7a = *bp04;
		_4976_5d6a += _4976_5d7a;
	}
	else {
		//^3E74:2775
		if (READ_FILE(glbFileHandleGraphics1, 4, &_4976_5d7a) == 0)	// Read the next 4 bytes of GDAT which hold the size for the first item entry which must be the ENT1 item
			goto _28d2;
		//^3E74:2790
		_4976_5d6a += _4976_5d7a +2;	// there _4976_5d6a gets the offset of the second item after ENT1 item
		if (READ_FILE(glbFileHandleGraphics1, bp08 -2, &bp04[1]) == 0)	// here read the size table before the ENT1 item (except the first item already read, which is exceptionnally on 4 bytes; all others are on 2 bytes max)
			goto _28d2;
	}
	//^3E74:27CF
	bp04[0] = 0;
	_4976_5caa = _4976_5d6a;
	U16 si;
	for (si = 0; si < glbGDatNumberOfData; bp04++, si++) {
		//^3E74:27E9
		_4976_5caa += *bp04;
		glbShelfMemoryTable[si] = shelf_memory::FromSizeOnUnloaded(*bp04);
		//printf("Shelf memory %05d: size = %06d\n", si, glbShelfMemoryTable[si].val & 0x7fff);
		//^3E74:2813
	}
	//^3E74:281E
	_4976_5cea = GET_FILE_SIZE(glbFileHandleGraphics1);
	if (_4976_5cea < _4976_5caa) {
		//^3E74:283D
		_4976_5ca8 = 1;
		_4976_5c9c = 1;
	}
	//^3E74:2846
	DEALLOC_UPPER_MEMORY(bp08);
	LOAD_ENT1();
	if (glbGDATVersion >= 2 && glbGDATVersion != 4 && QUERY_GDAT_ENTRY_DATA_INDEX(0x0, 0x0, dt08, 0x0) != 0xffff) {
		//^3E74:2878
        _4976_5d0c = reinterpret_cast<sk5d0c *>(ALLOC_MEMORY_RAM(
			_4976_5d78 = QUERY_GDAT_ENTRY_DATA_LENGTH(0x0, 0x0, dt08, 0x0),
			afUseUpper, 0x400));
		LOAD_GDAT_ENTRY_DATA_TO(0x0, 0x0, dt08, 0x0, reinterpret_cast<U8 *>(_4976_5d0c));
		_4976_5d78 = _4976_5d78 / 4;
	}

//DEBUG_DISPLAY_GDAT_MAIN_INFO();

	//^3E74:28C6
	_4976_5cb0 = 1;
	_3e74_24b8();
	//^3E74:28D0
	return;
	//^3E74:28D2
_28d2:
	RAISE_SYSERR(SYSTEM_ERROR__INVALID_GRAPHICS_STRUCTURE);
	//^3E74:28DA
	return;
}

//^01B0:1ED2
X16 SkWinCore::IS_SCARD_PRESENT() //#DS=04BF
{
	//^01B0:1ED2
	ENTER(0);
	//^01B0:1ED5
	LOADDS(0x3083);
	return (glbSoundCardType != 0) ? 1 : 0;
}

//^01B0:1BE8
// SPX: _01b0_1be8 renamed _RELOAD_SOUND_BUFFER
X16 SkWinCore::_RELOAD_SOUND_BUFFER(U8 *buff, X16 buffSize, X16 playbackRate) //#DS=04BF
{
	//^01B0:1BE8
	ENTER(0);
	//^01B0:1BEC
	LOADDS(0x3083);
	if (buff == NULL) {
		//^01B0:1C03
		_01b0_18d3(0);
		sndSoundInBuffer = 0;
	}
	else if (buffSize != 0) {
		//^01B0:1C1C
		sndSoundBufferSize = buffSize;
		sndSoundBuffer = buff;
		sndSoundPlaybackFrequency = playbackRate;
		U16 si;
		for (si = 0; si < buffSize; si++) {
			//^01B0:1C39
			sndSoundBuffer[si] = 0;
			//^01B0:1C51
		}
		//^01B0:1C57
        sndSoundToPlayBuffer = buff;
		sndSoundToPlayBufferSize = buffSize;
		if (glbSoundCardType == 3 || glbSoundCardType == 5 || glbSoundCardType == ScardSBlaster)
			//^01B0:1C80
			sndSoundInBuffer = 1;
	}
	//^01B0:1C86
	return sndSoundInBuffer;
}

//^47EB:0003
void SkWinCore::_47eb_0003()
{
	//^47EB:0003
	ENTER(0);
	//^47EB:0006
	_4976_4838 = X8(_01b0_2b1b() CALL_IBMIO);
	if (IS_SCARD_PRESENT() CALL_IBMIO != 0) {
		//^47EB:001F
		_RELOAD_SOUND_BUFFER(
			ALLOC_MEMORY_RAM(_4976_5c7c, afUseUpper, 0x400),
			_4976_5c7c, PLAYBACK_FREQUENCY
			) CALL_IBMIO;
	}
	//^47EB:0046
	return;
}

//^482B:0004
void SkWinCore::_482b_0004()
{
	//^482B:0004
	ENTER(4);
	//^482B:0008
	_4976_5f0a = reinterpret_cast<sk5f0a *>(ALLOC_MEMORY_RAM(_4976_5cae << 4, afUseUpper, 0x400));
	_4976_5f06 = reinterpret_cast<sk5f06 *>(ALLOC_MEMORY_RAM(_4976_5d58 * 7, afUseUpper, 0x400));
	_4976_5f02 = reinterpret_cast<SoundStructure *>(ALLOC_MEMORY_RAM(0xf0, afUseUpper, 0x400));
	U32 bp04;
	glbSoundList = reinterpret_cast<SoundEntryInfo *>(ALLOC_MEMORY_RAM(bp04 = 0x60, afUseUpper, 0x400));
	ZERO_MEMORY(glbSoundList, bp04);
	_4976_5efe = reinterpret_cast<SoundStructure *>(ALLOC_MEMORY_RAM(0x48, afUseUpper, 0x400));
	_47eb_0003();
	//^482B:00BD
	return;
}
//^32CB:0008
// SPX: _32cb_0008 renamed LOAD_GDAT_INTERFACE_00_0A
void SkWinCore::LOAD_GDAT_INTERFACE_00_0A()
{
	//^32CB:0008
	ENTER(4);
	//^32CB:000C
	U32 bp04;
	// SPX: This points to a 1652 bytes file .. seems to have struct of 14 bytes => 118 records.
	_4976_5a98 = reinterpret_cast<U8 (*)[14]>(ALLOC_MEMORY_RAM(bp04 = QUERY_GDAT_ENTRY_DATA_LENGTH(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dt07, 0xa), afUseUpper, 0x400));
	LOAD_GDAT_ENTRY_DATA_TO(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dt07, 0xa, reinterpret_cast<U8 *>(_4976_5a98));
	//^32CB:0052
	return;
}
//^0B36:020E
// SPX: _0b36_020e renamed LOAD_GDAT_INTERFACE_00_02
void SkWinCore::LOAD_GDAT_INTERFACE_00_02()
{
	//^0B36:020E
	ENTER(6);
	//^0B36:0214
	U8 *bp04 = ALLOC_MEMORY_RAM(QUERY_GDAT_ENTRY_DATA_LENGTH(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dt07, 0x2), afUseUpper, 0x400);
	LOAD_GDAT_ENTRY_DATA_TO(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dt07, 0x2, bp04);
	X8 bp05 = *bp04++;
	_4976_4bde = reinterpret_cast<sk4bde *>(ALLOC_MEMORY_RAM(bp05 * 9UL, afUseUpper, 0x400));
	i16 si;
	for (si = 0; bp05 > si; bp04++, si++) {
		//^0B36:0282
		_4976_4bde[si].b0 = *bp04;
		//^0B36:029A
	}
	//^0B36:02A7
	for (si = 0; bp05 > si; si++) {
		//^0B36:02AB
		_4976_4bde[si].pv1 = bp04;
		bp04 += _4976_4bde[si].b0;
		//^0B36:02DB
	}
	//^0B36:02E5
	for (si = 0; bp05 > si; si++) {
		//^0B36:02E9
		_4976_4bde[si].pv5 = bp04;
		bp04 += _4976_4bde[si].b0;
		//^0B36:0319
	}
	//^0B36:0323
	_4976_4be2 = reinterpret_cast<sk4be2 *>(bp04);
	//^0B36:0330
	return;
}
//^4937:0320
// SPX: _4937_0320 renamed LOAD_GDAT_INTERFACE_00_00
// This function loads one item which contains 3 data tables. These tables are about creature animations.
// The 1st table contains animation sequences, with associated sounds.
//	Each animation begins with a special bits telling the start of a new animation.
// The 2nd table describe all possible action animations for a creature behaviour.
//	Each action animation points to an animation sequence.
//	Each creature behaviour is finished by a special record using end marker.
// The 3rd table contains a list of pointers which start to a creature behaviour description.
void SkWinCore::LOAD_GDAT_INTERFACE_00_00()
{
	//^4937:0320
	ENTER(8);
	//^4937:0324
	U8 *bp04 = ALLOC_MEMORY_RAM(
		QUERY_GDAT_ENTRY_DATA_LENGTH(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dt06, 0x0),
		afUseUpper, 0x400);
	LOAD_GDAT_ENTRY_DATA_TO(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dt06, 0x0, bp04);
	//^4937:0360
	X32 bp08 = READ_UI32(bp04,+0);	// Read first DWORD of data, which is length of the first part : 0xC24 = 3108 = 6*518
	bp04 += 4;
	tlbCreaturesAnimationSequences = reinterpret_cast<CreatureAnimationFrame *>(bp04);	// This points to the first part
	bp04 += bp08;
	//^4937:0387
	bp08 = READ_UI32(bp04,+0);	// 0x760 = 1888 = 4*472
	bp04 += 4;
	tlbCreaturesActionsGroupSets = reinterpret_cast<CreatureCommandAnimation *>(bp04);	// This points to the second part
	bp04 += bp08;
	//^4937:03AE
	bp08 = READ_UI32(bp04,+0);	// 0x54 = 84 = 2*42
	bp04 += 4;
	tlbCreaturesActionsGroupOffsets = reinterpret_cast<U16 *>(bp04);		// This points to the third part
	//^4937:03CF
	return;
}
//^38C8:00C8
void SkWinCore::_38c8_00c8()
{
	//^38C8:00C8
	ENTER(0);
	//^38C8:00CB
	_4976_4c16 = _4726_02ac();
	if (_4976_4c16 == NULL) {
		//^38C8:00DB
		_4976_4c16 = ALLOC_PICT_BUFF(_4976_00f6, _4976_00f8, afUseUpper, 8);
	}
	//^38C8:00F6
	_4976_5ca0 = 0xB798;
	//^38C8:0102
	return;
}

//^3929:0CA8
void SkWinCore::KANJI_FONT_LOAD(X8 cls2)
{
	//^3929:0CA8
	ENTER(660);
	//^3929:0CAE
	X16 bp0e = 0;
	X16 bp10 = 0x20;
	X16 si = 0xef;
	skxxxf bp0294[64];
	skxxxf *bp08 = bp0294;
	U8 bp0b;
	U8 *bp04;
	for (bp0b = 0; (bp04 = QUERY_GDAT_ENTRY_DATA_BUFF(GDAT_CATEGORY_JAPANESE_FONT, cls2, dtImage, bp0b)) != NULL; ) {
		//^3929:0CCC
		X16 bp0a = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_JAPANESE_FONT, cls2, dtWordValue, bp0b);
		if (bp0a != 0) {
			//^3929:0CE7
			bp0e = bp0a >> 8;
			bp10 = U8(bp0a);
		}
		//^3929:0CF5
		bp0a = QUERY_GDAT_PICT_OFFSET(0x1c, cls2, bp0b);
		bp08->b0 = X8(bp0e);
		bp08->b1 = X8(bp10);
		bp08->w6 = i8(bp0a >> 8);
		bp08->w2 = i16(READ_UI16(bp04,+0) & 0x3ff) / bp08->w6;
		bp08->w8 = i8(bp0a);
		bp08->w4 = i16(READ_UI16(bp04,+2) & 0x3ff) / bp08->w8;
		bp0b++;
		if (bp0b >= 0x40)
			continue;
		//^3929:0D69
		bp10 += bp08->w2 * bp08->w4;
		if (bp10 > si) {
			//^3929:0D7E
			if (bp0e == 0) {
				//^3929:0D84
				bp0e = 0xef;
				si = 0xff;
			}
			//^3929:0D8C
			bp0e++;
			bp10 = 0x20;
		}
		bp08++;
		//^3929:0D98
	}
	//^3929:0DB9
	_4976_5bf8[cls2] = bp0b;
	U32 bp14 = bp0b * 10;
	COPY_MEMORY(
		bp0294, 
		_4976_5bfa[cls2] = reinterpret_cast<skxxxf *>(ALLOC_MEMORY_RAM(bp14, afUseUpper, 0x400)),
		bp14
		);
	//^3929:0E12
	return;
}
//^470A:0003
// TODO: this does nothing ?!
void SkWinCore::_470a_0003()
{
	//^470A:0003
	ENTER(0);
	//^470A:0006
	//^470A:0006
	return;
}

//^3929:0E16
void SkWinCore::_3929_0e16()
{
	//^3929:0E16
	ENTER(8);
	//^3929:0E1B
	_3929_07e1(0, 0);
	_4976_5c08 = ALLOC_PICT_BUFF(_4976_013e, _4976_0140, afUseUpper, 8);
	_4976_5c0e = ALLOC_MEMORY_RAM(0x300, afUseUpper, 0x400);
	LOAD_GDAT_ENTRY_DATA_TO(0x1, 0x0, dt07, 0x0, _4976_5c0e);
	U16 si;
	for (si = 0; si < 1; si++) {
		//^3929:0E75
		_4976_5c02[si] = 0xffffffff;
		//^3929:0E86
	}
	//^3929:0E8C
	SRECT bp08;
	QUERY_EXPANDED_RECT(15, &bp08); // 00 00|B4 00|40 01|14 00 (0,180,320,20)
	_4976_5c12 = (bp08.cy - (_4976_013a - _4976_0134)) >> 1;
	KANJI_FONT_LOAD(1);
	_470a_0003();
	_4976_4750 = 1;
	//^3929:0EBF
	return;
}
//^2405:0009
void SkWinCore::_2405_0009()
{
	//^2405:0009
	ENTER(0);
	//^2405:000C
	glbLeaderHandPossession.pb2 = ALLOC_PICT_BUFF(_4976_0106, _4976_0108, afUseUpper, 4);
	//^2405:0027
	return;
}

//^01B0:08B6
void SkWinCore::_01b0_08b6(U16 (SkWinCore::*pfn)(U16 xx, U16 yy, i16 zz)) //#DS=04BF
{
	//^01B0:08B6
	ENTER(0);
	//^01B0:08B9
	LOADDS(0x3083);
	_04bf_179e = pfn;
	_04bf_03c6 = 1;
	//^01B0:08D6
	return;
}

//^443C:0380
void SkWinCore::_443c_0380()
{
	//^443C:0380
	ENTER(0);
	//^443C:0383
	IBMIO_SET_CURSOR_PATTERN(0, _4976_4862, 0, 0, 12, 16, 4, glbPaletteT16, 12) CALL_IBMIO;
	IBMIO_SET_CURSOR_PATTERN(1, _4976_48c2, 0, 0, 16, 16, 4, glbPaletteT16, 12) CALL_IBMIO;
	_01b0_0c70(0);
	_01b0_08b6(&SkWinCore::FIRE_MOUSE_EVENT_RECEIVER);
	//^443C:03F2
	return;
}

//^443C:067A
void SkWinCore::_443c_067a(sk0cea *ref)
{
	//^443C:067A
	ENTER(0);
	//^443C:067D
	if (ref->b3_6_6() == 0) {
		//^443C:068C
		ref->b3_6_6(1);
		ref->pv6(reinterpret_cast<skxxx7 *>(ALLOC_MEMORY_RAM(sizeof(skxxx7), afUseUpper, 0x200)));
	}
	//^443C:06AD
	return;
}

//^1031:07D6
void SkWinCore::_1031_07d6()
{
	//^1031:07D6
	ENTER(194);
	//^1031:07DB
	X16 si = 0;
	i16 bp02;
	X16 bp0084[61];
	X16 bp00a8[18];
	X8 bp00c2[26];
	for (bp02 = 0; bp02 < 0x101; bp02++) {	// 257
		//^1031:07E4
		if ((_4976_0d9e[bp02].w0 & 0x8000) != 0) {
			//^1031:07F6
			bp0084[RCJ(61,si)] = bp02;
			si++;
		}
		//^1031:0807
	}
	//^1031:0811
	si = 0;
	for (bp02 = 0; bp02 < 0x74; bp02++) {	// 116
		//^1031:081A
		if ((_4976_13a4[bp02].w0 & 0x8000) != 0) {
			bp00a8[RCJ(18,si)] = bp02;
			si++;
		}
		//^1031:0839
	}
	//^1031:0842
	si = 0;
	for (bp02 = 0; bp02 < 0x51; bp02++) {	// 81
		//^1031:084B
		if ((_4976_169c[bp02] & 0x80) != 0) {
			bp00c2[RCJ(26,si)] = X8(bp02);
			si++;
		}
		//^1031:085D
	}
	//^1031:0866
	for (bp02 = 0; bp02 < 0x4a; bp02++) {	// 74
		//^1031:086D
		sk1891 *bp06 = &_4976_1574[bp02];
		if ((bp06->b0 & 0x80) != 0) {
			//^1031:0885
			bp06->w2 = bp00c2[RCJ(26,bp06->w2)];
		}
		//^1031:089B
	}
	//^1031:08A4
	for (bp02 = 0; bp02 < 0xa; bp02++) {	// 10
		//^1031:08AB
		sk1891 *bp06 = &_4976_1891[bp02];
		if ((bp06->b0 & 0x80) != 0) {
			bp06->w2 = bp00c2[RCJ(26,bp06->w2)];
		}
		//^1031:08D9
	}
	//^1031:08E2
	for (bp02 = 0; bp02 < 0x3c; bp02++) {	// 60
		//^1031:08E9
		sk16ed *bp0a = &_4976_16ed[bp02];
		if (bp0a->w2 != 0xffff) {
			//^1031:0904
			bp0a->w2 = bp0084[RCJ(61,bp0a->w2)];
		}
		//^1031:091A
		if (bp0a->w4 != 0xffff) {
			//^1031:0924
			bp0a->w4 = bp00a8[RCJ(18,bp0a->w4)];
		}
		//^1031:093A
	}
	//^1031:0943
	for (bp02 = 0; bp02 < 0x12; bp02++) {	// 18
		//^1031:094A
		_443c_067a(&_4976_0ce0[1 +bp02]);
		//^1031:095E
	}
	//^1031:0967
	return;
}
//^3E74:2439
U8 SkWinCore::_3e74_2439(X8 cls1, X8 cls4)
{
	//^3E74:2439
	ENTER(0);
	//^3E74:243D
	if (cls1 > U8(glbGDatEntries.w12))
		return 0;
	//^3E74:244C
	X16 si = glbGDatEntries.pw0[cls1];
	if (glbGDatEntries.pw0[cls1 +1] -si <= cls4)
		return 0;
	//^3E74:247A
	return glbGDatEntries.pv8[U32(glbGDatEntries.pw4[cls4 +si +1]) -1].cls2;
}

//^2481:0002
void SkWinCore::_2481_0002()
{
	//^2481:0002
	ENTER(0);
	//^2481:0005
	FIRE_SELECT_PALETTE_SET(0);
	if (_4976_3d2c != 0) {
		//^2481:0014
		FIRE_BLIT_PICTURE(
			glbImageMenuScreen, _4976_4964, ALLOC_TEMP_ORIGIN_RECT(glbScreenWidth, glbScreenHeight),
			0, 0, glbScreenWidth, glbScreenWidth, -1, 0, 8, 8, NULL);
	}
	else {
		//^2481:0057
		DRAW_GAMELOAD_DIALOGUE_TO_SCREEN(glbImageMenuScreen, 2, -1, _4976_52ba);
	}
	//^2481:0073
	FIRE_SELECT_PALETTE_SET(1);
	//^2481:007B
	return;
}
//^3E74:0A77
void SkWinCore::_3e74_0a77(U8 *ref)
{
	//^3E74:0A77
	ENTER(0);
	//^3E74:0A7A
	if (_4976_5d76 != 0)
		return;
	//^3E74:0A81
	if (READ_UI16(ref,-6+4) == 0) {
		//^3E74:0A9D
		DEALLOC_UPPER_MEMORY(READ_UI32(ref,-6));
	}
	else {
		//^3E74:0ABF
		DEALLOC_LOWER_MEMORY(READ_UI32(ref,-6));
	}
	//^3E74:0AE1
	return;
}

//^2481:007D
// SPX: Main loop, display title&menu screen
// _2481_007d renamed SHOW_MENU_SCREEN
void SkWinCore::SHOW_MENU_SCREEN()
{
	//^2481:007D
	ENTER(0);
	//^2481:0080
	glbImageCreditScreen = QUERY_GDAT_IMAGE_ENTRY_BUFF(GDAT_CATEGORY_TITLE, 0x0, 0x1);		// Credit screen (tombstone)
	if (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_TITLE, 0x0, dt07, 0x4) != 0xffff)	// 64000 bytes raw data for menu screen ?
	{
		//^2481:00AA
		_4976_3d2c = 1;
		glbImageMenuScreen = QUERY_GDAT_ENTRY_DATA_PTR(GDAT_CATEGORY_TITLE, 0x0, dt07, 4);
	}
	else {
		//^2481:00C9
		glbImageMenuScreen = QUERY_GDAT_IMAGE_ENTRY_BUFF(GDAT_CATEGORY_TITLE, 0x0, 0x4);
		_4976_52ba = glbImageMenuScreen +((READ_UI16(glbImageMenuScreen,-6) == 4)
			? (((READ_UI16(glbImageMenuScreen,-4) +1) & 0xfffe) >> 1)
			: (  READ_UI16(glbImageMenuScreen,-4)     & 0xffff)
			) * READ_UI16(glbImageMenuScreen,-2);
	}
	//^2481:0116
	_4976_52b6 = glbImageCreditScreen +((READ_UI16(glbImageCreditScreen,-6) == 4)
		? (((READ_UI16(glbImageCreditScreen,-4) +1) & 0xfffe) >> 1)
		: (  READ_UI16(glbImageCreditScreen,-4)     & 0xffff)
		) * READ_UI16(glbImageCreditScreen,-2)
		;
	GRAPHICS_DATA_CLOSE();
	_1031_0541(0);
	//^2481:015B
	do {
		_2481_0002();
		FIRE_SHOW_MOUSE_CURSOR();
		_1031_098e();
		glbSpecialScreen = 0x63;
		goto _0180;
		//^2481:0171
_0171:
		_1031_0d36(0x20, _476d_050e());
_0180:
		do {
			MessageLoop(true); // main menu

			//^2481:0180
			if (_476d_05a9() != 0)
				goto _0171;
			MAIN_LOOP();
			//^2481:018E
		} while (glbSpecialScreen == 0x63);
		//^2481:0195
	} while (glbSpecialScreen == 0xda);
	//^2481:019D
	FIRE_HIDE_MOUSE_CURSOR();
	if (_4976_3d2c != 0) {
		//^2481:01A9
		_3e74_0a77(glbImageMenuScreen);
	}
	else {
		//^2481:01B8
		FREE_PICT_ENTRY(glbImageMenuScreen);
	}
	//^2481:01C5
	FREE_PICT_ENTRY(glbImageCreditScreen);
	//^2481:01D6
	return;
}
//^1C9A:3C30
// SPX: _1c9a_3c30 Something related to loading creatures ?
void SkWinCore::__LOAD_CREATURE_FROM_DUNGEON()
{
	//^1C9A:3C30
	ENTER(4);
	//^1C9A:3C35
	glbCreaturesCount = 0;
	Creature *bp04 = reinterpret_cast<Creature *>(static_cast<U8 *>(glbDBObjectData[dbCreature]));
	X16 si = dunHeader->nRecords[DB_CATEGORY_CREATURE];
	for (; si-- != 0; bp04++) {
		//^1C9A:3C52
		if (bp04->w0 != OBJECT_NULL
			&& QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType())->IsStaticObject() == 0)
			//^1C9A:3C71
			glbCreaturesCount++;
		//^1C9A:3C75
	}
	//^1C9A:3C80
	glbCreaturesCount = min_value(glbCreaturesCount +0x4b, dunHeader->nRecords[DB_CATEGORY_CREATURE]);
	glbTabCreaturesInfo = reinterpret_cast<CreatureInfoData *>(ALLOC_MEMORY_RAM(glbCreaturesCount * sizeof(CreatureInfoData), afUseUpper, 0x400));
	//^1C9A:3CBF
	return;
}

//^3E74:07B2
void SkWinCore::_3e74_07b2()
{
	//^3E74:07B2
	ENTER(4);
	//^3E74:07B6
	sk5d00 *bp04 = _4976_5d00;
	EMS_MAP_BANK_TO_MEMORY();
	//^3E74:07D1
	while (bp04 != NULL) {
		//^3E74:07D3
		if (bp04->w18 == 0) {
			bp04->dw20 = bp04->dw8;
			bp04->dw24 = bp04->dw12;
		}
		//^3E74:07FD
		bp04 = bp04->pv0;
		//^3E74:080D
	}
	//^3E74:081E
	return;
}

//^3E74:0820
void SkWinCore::_3e74_0820()
{
	//^3E74:0820
	ENTER(4);
	//^3E74:0824
	sk5d00 *bp04 = _4976_5d00;
	EMS_MAP_BANK_TO_MEMORY();
	//^3E74:083F
	while (bp04 != NULL) {
		//^3E74:0841
		if (bp04->w18 == 0) {
			//^3E74:084B
			bp04->dw8 = bp04->dw20;
			bp04->dw12 = bp04->dw24;
		}
		//^3E74:086B
		bp04 = bp04->pv0;
	}
	//^3E74:088C
	return;
}
//^38C8:0109
X16 SkWinCore::_38c8_0109(X8 **buff, X32 *xx, X16 *yy)
{
	//^38C8:0109
	ENTER(6);
	//^38C8:010D
	X8 *bp04 = *buff;
	X8 bp05 = 0;
	//^38C8:0121
	while (bp05 < 4) {
		//^38C8:0123
		_4976_5bee[bp05] = 0; bp05++;
	}
	//^38C8:0138
	*xx = 0;
	*yy = 0;
	if (_4976_474e != 0) {
		//^38C8:0158
		_4976_474e = 0;
		_4976_5bf4 = 0;
		_4976_5be8 = 0;
		//^38C8:016A
		while ((bp05 = *(bp04++)) != 0xff) {
			//^38C8:016C
			if (bp05 == 0xfe)
				//^38C8:0172
				_4976_5bf4++;
		}
		//^38C8:0186
		bp04 = *buff;
	}
	while ((bp05 = *(bp04++)) != 0xfe) {
		//^38C8:0198
		if (bp05 == 0xff)
			//^38C8:019E
			return 0;
		//^38C8:01A3
		if (bp05 == 0xfd) {
			//^38C8:01A9
#if UseAltic
			ATLASSERT(false);
			*xx = 0;
#else
			*xx = U32(bp04) << 10;
#endif
			bp04++;
			continue;
		}
		//^38C8:01C6
		if (bp05 == 0xfc) {
			//^38C8:01CC
#if UseAltic
			ATLASSERT(false);
			*yy = 0;
#else
			*yy = U16(bp04) << 4;
#endif
			bp04++;
			continue;
		}
		//^38C8:01E2
		_4976_5bee[bp05] = 1;
		//^38C8:01EE
	}
	//^38C8:01FE
	_4976_5be8++;
	*buff = bp04;
	if (*bp04 != 0xff)
		//^38C8:021B
		return 1;
	//^38C8:0220
	return 0;
}
//^38C8:0104
void SkWinCore::_38c8_0104()
{
	//^38C8:0104
	ENTER(0);
	//^38C8:0107
	return;
}
//^3E74:2EC7
void SkWinCore::INIT_CPXHEAP(sk5d12 *ref, tiamat poolBuff, U32 poolSize, U16 poolflag)
{
	//^3E74:2EC7
	ENTER(0);
	//^3E74:2ECA
	ref->t0 = (poolBuff);
	ref->t4 = (poolBuff);
	ref->t8 = (poolBuff);
	//^3E74:2EEE
	if (poolBuff.IsntZero()) {
		//^3E74:2EF9
		if ((poolflag & 0x800) != 0) {
			//^3E74:2F00
			ref->t4 = (poolBuff -poolSize); // integer subtraction.
		}
		else {
			//^3E74:2F19
			ref->t4 = (poolBuff -poolSize); // pointer subtraction.
		}
	}
	//^3E74:2F35
	ref->w12 = poolflag;
	//^3E74:2F3F
	return;
}
//^38C8:0224
X16 SkWinCore::_38c8_0224(X16 xx, i32 yy)
{
	//^38C8:0224
	ENTER(6);
	//^38C8:022A
	X16 bp06 = glbPlayerMap;
	_4976_5c8a = 1;
	i32 bp04 = i32(0x7fffffff);
	i16 si;
	i16 di;
	for (si = 0; dunHeader->nMaps; si++) {
		//^38C8:0245
		if ((si & 3) == 0) {
			//^38C8:024B
			DRAW_DIALOGUE_PROGRESS((i32(dunHeader->nMaps * (_4976_5be8 -1) +si +1) * 500) / i32(dunHeader->nMaps * _4976_5bf4));
		}
		//^38C8:0293
		LOAD_NEWMAP(U8(si));
		//^38C8:029A
		if (_4976_5d62 < 0) {
			//^38C8:02AA
			if (_4976_5d62 < bp04) {
				//^38C8:02BD
				bp04 = _4976_5d62;
				di = si;
			}
		}
		//^38C8:02CC
		if (_4976_5d26 -yy < bp04) {
			//^38C8:02E5
			bp04 = _4976_5d26 -yy;
			di = si;
		}
		//^38C8:02FA
		if ((bp04 < 0 && xx == 0) || _4976_5bee != 0)
			break;
		//^38C8:0315
	}
	//^38C8:0327
	if (bp04 > _4976_4742) {
		//^38C8:033B
		_4976_4742 = bp04;
		_4976_4746 = di;
	}
	//^38C8:034C
	if (xx != 0) {
		//^38C8:0352
		if (bp04 < 0) {
			//^38C8:0360
			_4976_4742 = bp04;
			_4976_4746 = di;
			_0aaf_0067(_0aaf_02f8(2, 0));
			SK_PREPARE_EXIT();
		}
	}
	//^38C8:0388
	_4976_5c8a = 0;
	glbPlayerMap = bp06;
	if (bp04 >= 0)
		return 1;
	//^38C8:03A7
	return 0;
}

//^3E74:1330
// SPX _3e74_1330 renamed ALLOC_CPX_SETUP
void SkWinCore::ALLOC_CPX_SETUP(X8 *xx)
{
	//^3E74:1330
	ENTER(26);
	//^3E74:1335
	U8 *bp08 = t2ptr(_4976_5d5a);
	X32 bp10 = glbFreeEMSMemPool;
	U8 *bp0c = _4976_5cf4;
	X32 bp14 = glbFreeRAMMemPool;
	mement *bp04 = _4976_5ce6;
	_3e74_07b2();
	X32 bp18;
	X16 si;
	do {
		//^3E74:137A
		_4976_5d5a = ptr2t(bp08);
		glbFreeEMSMemPool = bp10;
		_4976_5cf4 = bp0c;
		glbFreeRAMMemPool = bp14;
		_4976_5ce6 = bp04;
		_3e74_0820();
		X16 bp1a;
		si = _38c8_0109(&xx, &bp18, &bp1a);
		_38c8_0104();
		if (i32(bp1a +0x100) > 0xffff) {
			//^3E74:13F3
			glbNumberOfMements = 0xffff;
		}
		else {
			//^3E74:13FB
			glbNumberOfMements = bp1a +0x100;
		}
		//^3E74:1404
		tlbMementsPointers = reinterpret_cast<mement **>(ALLOC_MEMORY_RAM(glbNumberOfMements << 2, afZeroMem|afUseUpper, 0x400));
		_4976_5d24 = 0x80;
		_4976_5d08 = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(_4976_5d24 << 1, afUseUpper, 0x400));
		FILL_U16(reinterpret_cast<i16 *>(_4976_5d08), _4976_5d24, -1, 2);
		_4976_5c7e = reinterpret_cast<U16 *>(ALLOC_MEMORY_RAM(_4976_5d24 << 1, afUseUpper, 0x400));
		_4976_5c86 = reinterpret_cast<U32 *>(ALLOC_MEMORY_RAM(_4976_5d24 << 2, afZeroMem|afUseUpper, 0x400));
		_4976_5ce2 = _4976_5cf4 - _4976_00ec;
		INIT_CPXHEAP(&_4976_5d12, ptr2t(_4976_5ce2), 0, _4976_5cee);
		if (glbFreeEMSMemPool < 12) {
			//^3E74:14E7
			INIT_CPXHEAP(&_4976_5d7e, ptr2t(NULL), 0, _4976_5d6e);
		}
		else {
			//^3E74:14F5
			INIT_CPXHEAP(&_4976_5d7e, _4976_5d5a, glbFreeEMSMemPool, _4976_5d6e);
		}
		//^3E74:1515
		if (!SkCodeParam::bUsePowerDebug)	// SPX: I don't get the meaning of this, overriding MEM left value with a low one?
			// then in certain condition it will raise error 40 complaining of no MEM left while there is ...
			glbFreeRAMMemPool = _4976_00ec;
		_4976_5cf8 = tiamat::Size(ptr2t(_4976_5ce2), ptr2t(reinterpret_cast<U8 *>(_4976_5ce6)));
		//^3E74:153C
	} while (_38c8_0224(!si, bp18) == 0);
	//^3E74:1559
	_4976_5d76 = 1;
	//^3E74:155F
	return;
}

//^00EB:05C7
// SPX: _00eb_05c7 renamed SET_GRAPHICS_RGB_PALETTE
X16 SkWinCore::SET_GRAPHICS_RGB_PALETTE(U8 (*pal)[4], X16 yy) //#DS=04BF
{
	//^00EB:05C7
	ENTER(0);
	//^00EB:05CB
	LOADDS(0x0C48);
	i16 si;
	for (si = 0; si < 0x100; si++) {
		//^00EB:05D5
		glbPaletteRGB[si][0] = pal[si][1] >> 2;
		//^00EB:05F7
		glbPaletteRGB[si][1] = pal[si][2] >> 2;
		//^00EB:0619
		glbPaletteRGB[si][2] = pal[si][3] >> 2;
		//^00EB:063B
	}
	//^00EB:0642
	if (glbUpdatePalette == 1)
		//^00EB:0649
		IBMIO_UPDATE_PALETTE_SET();
	//^00EB:064E
	return 1;
}

//^44C8:1BAF
// SPX: _44c8_1baf renamed SET_RGB_PALETTE_FROM_DATA
void SkWinCore::SET_RGB_PALETTE_FROM_DATA(U8 *pal)
{
	//^44C8:1BAF
	ENTER(0);
	//^44C8:1BB2
	glbPaletteIRGBLoaded = SET_GRAPHICS_RGB_PALETTE(reinterpret_cast<U8 (*)[4]>(pal), 0);
	//^44C8:1BC8
	return;
}

//^38C8:04AA
// SPX: _38c8_04aa renamed INIT
void SkWinCore::INIT()
{
	//^38C8:04AA
	ENTER(4);
	//^38C8:04AF
	_4726_02f7();
	_4976_474a = 1;
	_4976_474c = 1;
	_476d_018a();
	_2636_03d4();
	READ_GRAPHICS_STRUCTURE();
	_482b_0004();
	LOAD_GDAT_INTERFACE_00_0A();
	U8 *bp04 = ALLOC_MEMORY_RAM(0x400, afUseLower, 1024);
//DEBUG_DUMP_ULP();
	LOAD_GDAT_ENTRY_DATA_TO(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dtPalIRGB, 0xFE, bp04);	// C01=I00=EFE=T009 palette IRGB (0x1, 0x0, dt09, 0xFE, bp04)
	SET_RGB_PALETTE_FROM_DATA(bp04);
	DEALLOC_LOWER_MEMORY(0x400);
	LOAD_GDAT_INTERFACE_00_02();
	//glbPaletteT16 = QUERY_GDAT_ENTRY_DATA_PTR(0x1, 0x0, dt0d, 0xfe);
	glbPaletteT16 = QUERY_GDAT_ENTRY_DATA_PTR(GDAT_CATEGORY_INTERFACE_GENERAL, 0x0, dtPalette16, 0xFE);
	_098d_1208();

	// SPX: Added extended load here (requires the GDAT to be initialized, but must be before dungeon loading)
	EXTENDED_LOAD_AI_DEFINITION();

	LOAD_GDAT_INTERFACE_00_00();
	_38c8_00c8();
	_3929_0e16();
	glbTextEntryEncoded = QUERY_GDAT_ENTRY_DATA_INDEX(0x0, 0x0, dtWordValue, 0) & 8;	// Value is 0B ..
	_2405_0009();
	_443c_0380();
	_4976_4748 = 1;
	_1031_07d6();
	glbCreaturesMaxCount = _3e74_2439(0xf, 0xb);
	X16 si = (glbCreaturesMaxCount +1) * 3;
	glbSomeCreatureTable = ALLOC_MEMORY_RAM(si, afUseUpper, 1024);
	FILL_STR(glbSomeCreatureTable, si, 0xff, 1);
	//^38C8:05C1
	while (SHOW_MENU_SCREEN(), GAME_LOAD() != 1) {
		//^38C8:05C3
		GRAPHICS_DATA_OPEN();
	}
	//^38C8:05D7
	GRAPHICS_DATA_OPEN();
	__LOAD_CREATURE_FROM_DUNGEON();
	ALLOC_CPX_SETUP(_4976_4736);
	__INIT_GAME_38c8_03ad();
	GRAPHICS_DATA_CLOSE();
	if (glbSpecialScreen != 0) {
		//^38C8:05FC
		MOVE_RECORD_TO(OBJECT_NULL, -1, 0, glbPlayerPosX, glbPlayerPosY);
	}
	//^38C8:0612
	FIRE_SHOW_MOUSE_CURSOR();
	_1031_098e();
	//^38C8:061C
	return;
}

//^3A15:0763
// SPX: _3a15_0763 renamed IS_TIMER_TO_PROCEED
X16 SkWinCore::IS_TIMER_TO_PROCEED()
{
	//^3A15:0763
	ENTER(0);
	//^3A15:0766
	if (_4976_4762 >= 0) {
		_3a15_0486(_4976_4762);
	}
	if (glbTimersCount != 0) {
		if (glbTimersTable[*glbTimerNextEntries].GetTick() <= glbGameTick)
			return 1;
	}
	//^3A15:07B0
	return 0;
}

//^3A15:072F
// SPX: _3a15_072f renamed GET_AND_DELETE_NEXT_TIMER
void SkWinCore::GET_AND_DELETE_NEXT_TIMER(Timer *ref)
{
	//^3A15:072F
	ENTER(0);
	//^3A15:0733
	X16 si;
	*ref = glbTimersTable[si = *glbTimerNextEntries];
	DELETE_TIMER(si);
	//^3A15:0760
	return;
}

//^1C9A:17C7
X16 SkWinCore::_1c9a_17c7(U8 xx, U8 yy, U8 zz)
{
	// SPX: I hit this one with undefined AI table
	//^1C9A:17C7
	ENTER(0);
	//^1C9A:17CC
	U16 di = xx;
	U16 si = yy;
	if (true
		&& glbCreatureMap == zz 
		&& glbIsPlayerSleeping == 0 
		&& glbChampionInventory == 0 
		&& ABS16(glbCreaturePosX -di) != ABS16(glbCreaturePosY -si)
		&& CALC_VECTOR_DIR(glbCreaturePosX, glbCreaturePosY, di, si) == glbCreatureDir
		&& ABS16(glbCreaturePosX -di) <= 2
		&& ABS16(glbCreaturePosY -si) <= 2
	) {
		//^1C9A:1841
		return 1;
	}
	//^1C9A:1846
	return 0;
	//^1C9A:1848
}

//^1C9A:184C
X16 SkWinCore::WOUND_CREATURE(i16 damage)
{
	SkD((DLV_DBM, "DBM: WOUND_CREATURE(%3d) C:%p\n"
		, (Bitu)damage, glbCurrentThinkingCreatureRec));

	//^1C9A:184C
	ENTER(12);
	//^1C9A:1852
	Creature *bp04 = glbCurrentThinkingCreatureRec;
	AIDefinition *bp08 = glbAIDef;
	X16 di = 0;

	if (glbCurrentMapIndex == glbPlayerMap)
	SkD((DLV_TWEET, "Tweet: %s (a#%03d, x:%d, y:%d, map:%d) took %d damage! (hp:%d ac:%d) \n"
		, static_cast<LPCSTR>(getRecordNameOf(glbCurrentThinkingCreatureID))
		, glbCurrentThinkingCreatureID.DBIndex()
		, glbCreatureTimer.XcoordB() // really? x
		, glbCreatureTimer.YcoordB() // really? y
		, glbCurrentMapIndex
		, damage
		, bp04->HP1()
		, bp08->ArmorClass
		));

	// If the creature has max defense, then take no damage
	if (bp08->ArmorClass == AI_DEF_ARMOR_MAX)
		return di;
	X16 si = 0;	// SPX : added default value to 0
	if (bp08->IsStaticObject() == 0) {
		//^1C9A:1882
		X16 bp0a = QUERY_GDAT_CREATURE_WORD_VALUE(bp04->CreatureType(), 1);
		si = _4976_3752[bp0a];
		if ((si & 4) == 0) {
			//^1C9A:18A5
			X16 bp0c = glbCurrentMapIndex;
			CHANGE_CURRENT_MAP_TO(bp04->TriggerMap());
			INVOKE_MESSAGE(bp04->TriggerX(), bp04->TriggerY(), 0, 1, glbGameTick +1);
			CHANGE_CURRENT_MAP_TO(bp0c);
		}
	}
	//^1C9A:18F9
	if (bp04->HP1() > U16(damage)) {
		bp04->HP1(bp04->HP1() - damage);
		return di;
	}
	// SPX : we get here if creature has not enough HP to survive damage done
	//^1C9A:190E
	bp04->HP1(1);
	if (bp08->IsStaticObject() == 0) {
		if ((si & 0x800) != 0) {
			//^1C9A:1927
			if (_1c9a_17c7(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), glbSomeMap_4976_4ee7) == 0)
				return di;
		}
		//^1C9A:1944
		if ((si & 0x800) != 0)
			_4976_4dfe = 0x18;
		//^1C9A:1950
		_13e4_0360(glbCurrentThinkingCreatureID, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), 0x13, 1);
	}
	else {
		//^1C9A:196E
		di = 1;
		DELETE_CREATURE_RECORD(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), CREATURE_GENERATED_DROPS, 1);
	}
	//^1C9A:1988
	return di;
}

//^14CD:062E
// returns a type of tile ?
X8 SkWinCore::_14cd_062e()
{
	//^14CD:062E
	ENTER(2);
	//^14CD:0632
	U8 cl = 0;
	i8 bp01 = glbCurrentThinkingCreatureData->x;
	i8 bp02 = glbCurrentThinkingCreatureData->y;
	if (glbCurrentThinkingCreatureData->x != -1) {
		if (((cl = (_4976_3672[RCJ(56,bp01)][bp02].b5() & 0xe0)) & 0x60) == 0x40) {
			if (glbSomeMap_4976_4ee7 != glbCreatureMap) {
				cl = 0;
			}
		}
	}
	//^14CD:0680
	return cl;
}

//^14CD:0067
i16 SkWinCore::SELECT_CREATURE_4EFE(const sk4efe *ref)
{
	// _4976_37fc[xx][yy], select yy.

	//^14CD:0067
	ENTER(16);
	//^14CD:006D
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData; // bp04
	Creature *xCreature = glbCurrentThinkingCreatureRec; // bp08
	X16 si = xCreature->w10;
	X16 bp0e = RAND();
	if (glbSomeMap_4976_4ee7 == glbCreatureMap) {
		si &= 0x7fff;
	}
	//^14CD:00A7
	else if ((bp0e & (xCreatureInfo->x != xactrNeedReset) ? 0x70 : 0x30) == 0) {
		//^14CD:00BE
		si |= 0x8000;
		si &= 0xbfff;
	}
	//^14CD:00C6
	if ((si & 0x8000) == 0) {
		if ((bp0e & (((si & 8) != 0) ? 0x380 : 0xf80)) == 0)
			si ^= 0x4000;
	}
	//^14CD:00E3
	if ((bp0e / (0x10 - glbAIDef->w22_4_7())) == 0)
		si &= 0xffdf;
	//^14CD:0105
	if ((_4976_3752[_4976_4efa] & 0x400) != 0)
		si |= 0x2000;
	else if ((bp0e & 0x38) == 0)
		si &= 0xdfff;
	//^14CD:0124
	if ((bp0e & 0x3000) == 0)
		si &= 0xffef;
	if ((bp0e & 0x3) == 0)
		si &= 0xffbf;
	if ((bp0e & 0x8008) == 0)
		si &= 0xefff;
	//^14CD:0145
	X16 di = 2;
	if ((_4976_3752[_4976_4efa] & 2) == 0) {
		//^14CD:0156
		di = di * ((((glbCurrentThinkingCreatureID.DBIndex() & 3) +1) << 1) -1);
	}
	//^14CD:0168
	if (RAND16(di) == 0) {
		//^14CD:0173
		if (U32((xCreature->w6 * 100) / i16(max_value(1, glbAIDef->BaseHP))) < 0x19)
			si |= 8;
		else	
			si &= 0xfff7;
	}
	//^14CD:01B6
	xCreature->w10 = si;
	X16 bp10 = 0xffff;
	di = 0xffff;
	X16 bp0c = 0;
	X16 bp0a;
	for (; (bp0a = ref->w0) != 0; bp0c++, ref++) {
		//^14CD:01CC
		if ((bp0a & 0xc000) == 0xc000) {
			if (GET_GLOB_VAR(bp0a & 0x3fff) == 0)
				continue;
			break;
		}
		//^14CD:01EA
		if (bp10 == 0xffff && (bp0a & si) != 0) {
			//^14CD:01F5
			bp10 = bp0c;
		}
		//^14CD:01FB
		if (di == 0xffff && (bp0a & si) == bp0a)
			di = bp0c;
		//^14CD:020D
		if (bp0a == si)
			break;
		//^14CD:0212
	}
	//^14CD:0226
	if (bp0a == 0 && (di != 0xffff || bp10 != 0xffff)) {
		bp0c = (di == 0xffff) ? bp10 : di;
	}
	//^14CD:0246
	if (xCreatureInfo->b22 != bp0c) {
		_4976_514e.b1 = 0;
		xCreatureInfo->x = xactrNeedReset;
		xCreatureInfo->y = 0;
		_4976_514e.b3 = 0xff;
	}
	//^14CD:0267
	return xCreatureInfo->b22 = U8(bp0c);
}

//^14CD:0009
void SkWinCore::SELECT_CREATURE_37FC()
{
	//^14CD:0009
	ENTER(0);
	//^14CD:000C
	if (_4976_4efa == 0xffff) {
		//^14CD:0013
		_4976_4efa = QUERY_GDAT_CREATURE_WORD_VALUE(glbCurrentThinkingCreatureRec->CreatureType(), 1);
	}
	_4976_4efc = SELECT_CREATURE_4EFE(_4976_37fc[RCJ(CREATURE_AI_TAB_SIZE,_4976_4efa)]);
	_4976_4efe = &_4976_37fc[RCJ(CREATURE_AI_TAB_SIZE,_4976_4efa)][_4976_4efc];
	//^14CD:0065
	SkD((DLV_CAI, "CAI: (i) a#%03d 37fc[%2d,%3d] \n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bitu)_4976_4efa, (Bitu)_4976_4efc
		));

	return;
}

//^1C9A:37BE
// SPX: Retrieve current creature Walk Path ?
// SPX: _1c9a_37be renamed __SET_CURRENT_THINKING_CREATURE_WALK_PATH
void SkWinCore::__SET_CURRENT_THINKING_CREATURE_WALK_PATH()
{
	//^1C9A:37BE
	ENTER(2);
	//^1C9A:37C2
	glbMemWalkPath = NULL;
	if (glbCurrentThinkingCreatureData == NULL || _4976_514e.b0 == 0)
		return;
	U16 bp02;
	if (_3e74_5673(glbCurrentThinkingCreatureID.DBIndex()|0x28000000, &bp02, 0) == 0) {
		//^1C9A:3800
		_4976_514e.b1 = 0;
		_4976_514e.b0 = 0;
	}
	else {
		//^1C9A:380A
		glbMemWalkPath = reinterpret_cast<WalkPath *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp02));
	}
	//^1C9A:381A
	return;
}

//^1C9A:381C
// SPX: _1c9a_381c renamed CREATURE_THINK_381c
i16 SkWinCore::CREATURE_THINK_381c()
{
	//^1C9A:381C
	ENTER(4);
	//^1C9A:3821
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData; // bp04
	X16 si = 0;
	__SET_CURRENT_THINKING_CREATURE_WALK_PATH();
	if (_4976_514e.b0 != 0) {
		//^1C9A:383B
		si = _4976_514e.b1;
		if (si != 0) {
			xCreatureInfo->b27 = glbMemWalkPath[_4976_514e.b0 -si].getDir();
			return si;
		}
	}
	//^1C9A:3864
	if (glbSomeMap_4976_4ee7 == _4976_514e.w8.GetMap()) {
		if (glbCreatureTimer.XcoordB() == _4976_514e.w8.GetX()) {
			if (glbCreatureTimer.YcoordB() == _4976_514e.w8.GetY()) {
				_4976_514e.w8 = Ax3::Invalid;
			}
		}
	}
	//^1C9A:38A3
	return si;
}

//^3E74:5788
U8 *SkWinCore::_3e74_5788(U16 xx, i32 yy)
{
	//^3E74:5788
	ENTER(0);
	//^3E74:578B
	_4976_5c90 = 1;
	FREE_INDEXED_MEMENT(xx|0x8000);
	_4976_5c90 = 0;
	return ALLOC_CPXHEAP_MEM(xx, yy);
}

//^14CD:0276
void SkWinCore::_14cd_0276(skxxx9 *ref)
{
	//^14CD:0276
	ENTER(14);
	//^14CD:027B
	i16 si = max_value(0, ref->b6);
	_4976_514e.b1 = _4976_514e.b0 = U8(si);
	_4976_514e.w8 = ref->w4;
	_4976_514e.b3 = ref->b7;
	_4976_514e.w4 = ref->w8;
	_4976_514e.w6 = ref->w10;
	_4976_514e.b2 = ref->b17;
	_4976_514e.pv10 = ref->pv18();
	U8 *bp04 = NULL;
	if (si > 0) {
		//^14CD:02DB
		U16 bp0e;
		i32 bp0c = _3e74_5673(glbCurrentThinkingCreatureID.DBIndex()|0x28000000, &bp0e, 1);
		i32 bp08 = si << 1;
		if (bp0c < bp08) {
			//^14CD:0315
			bp04 = (bp0c != 0)
				? _3e74_5788(bp0e, bp08)
				: ALLOC_CPXHEAP_MEM(bp0e, bp08);
			_3e74_585a(bp0e, 1);
		}
		else {
			//^14CD:0352
			bp04 = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp0e));
		}
		//^14CD:0361
		ATLASSERT(bp08 < sizeof(glbCreatureWalkPath));
		COPY_MEMORY(&glbCreatureWalkPath, bp04, bp08);
	}
	//^14CD:0379
	glbMemWalkPath = reinterpret_cast<WalkPath *>(bp04);
	//^14CD:0386
	return;
}

//^14CD:0F0A
void SkWinCore::_14cd_0f0a(U8 func, U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:0F0A
	ENTER(0);
	//^14CD:0F0D
	func &= 31;
	_4976_4ef6 = 0xffff;
	(this->*_4976_38a4[RCJ(17,func)])(xx, yy, ss);
	//^14CD:0F3A
	return;
}

//^14CD:0F3C
void SkWinCore::_14cd_0f3c(i8 aa, sk1bf9 *ss, sk1bf9 *tt, X8 ww, i8 vv, Ax3 uu, U8 xx, U8 yy)
{
	SkD((DLV_CAI, "CAI: (e) Append #%d (%02X,x,x,%02X,%02X,(%2d,%2d,%2d),%04X,%02X) \n"
		, (Bitu)_4976_4fd8->b18()
		, (Bitu)(U8)aa, (Bitu)ww, (Bitu)vv, (Bitu)uu.GetX(), (Bitu)uu.GetY(), (Bitu)uu.GetMap(), (Bitu)xx, (Bitu)yy
		));

	//^14CD:0F3C
	ENTER(6);
	//^14CD:0F40
	if (tt == NULL)
		return;
	if (ss == 0)
		return;
	if (i8(_4976_4fd8->b18()) >= 0x10)
		return;
	//^14CD:0F60
	i8 bp05 = tt->b8;
	if (glbSomeMap_4976_4ee7 != glbCreatureMap && bp05 > 0 && glbAIDef->w0_e_e() == 0) {
		//^14CD:0F86
		bp05 >>= 2;
		vv >>= 2;
	}
	//^14CD:0F8E
	vv = (i8)BETWEEN_VALUE(-1, vv +127, bp05);
	if (vv < 0)
		return;
	skxxx9 *bp04 = &_4976_4fee[RCJ(16,_4976_4fd8->b18())];
	_4976_4fd8->b18(_4976_4fd8->b18() +1);
	bp04->b14 = xx;
	bp04->b15 = yy;
	bp04->w12 = uu;
	bp04->b0 = vv;
	//^14CD:0FE2
	bp04->b1 = tt->b9;
	bp04->b7 = aa;
	bp04->w8 = tt->w4;
	bp04->w10 = tt->w6 & _4976_4ef6;
	bp04->b17 = ww;
	bp04->pv18(ss);
	//^14CD:102C
	return;
}

//^14CD:18CC
void SkWinCore::_14cd_18cc(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:18CC
	ENTER(0);
	//^14CD:18CF
	_14cd_0f3c(0, ss, _4976_1bcf, 0, 0, Ax3::Invalid, yy, xx);
	//^14CD:18F0
	return;
}

//^1C9A:0732
ObjectID SkWinCore::CREATURE_CAN_HANDLE_ITEM_IN(i16 flags, ObjectID rlFindFrom, i8 dir)
{
	// find an item (which creature can handle for holding/selling/buying) from the rlFindFrom.

	// return OBJECT_END_MARKER if he can't.
	// return id if he can handle one of them.

	//^1C9A:0732
	ENTER(0);
	//^1C9A:0737
	ObjectID si;
	for (si = rlFindFrom; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^1C9A:073C
		X16 di = si.DBType();
		if ((di > dbCreature && di < dbMissile) || di == dbContainer) {
			//^1C9A:0755
			if (dir == -1 || si.Dir() == dir) {
				//^1C9A:0769
				if (CREATURE_CAN_HANDLE_IT(si, flags) != 0)
					break;
			}
		}
		//^1C9A:0777
	}	
	//^1C9A:0785
	return si;
}

//^2C1D:09D9
U16 SkWinCore::_2c1d_09d9()
{
	//^2C1D:09D9
	ENTER(4);
	//^2C1D:09DF
	X32 bp04 = 0;
	U16 di;
	for (di = 0; di < glbChampionsCount; di++) {
		//^2C1D:09ED
		U16 si;
		for (si = 0; si < SKILL_MAJOR_COUNT; si++) {	// (si = 0; si <= 3; si++) 
			//^2C1D:09F1
			bp04 += glbChampionSquad[di].skills[si];
			//^2C1D:0A0F
		}
		//^2C1D:0A15
	}
	//^2C1D:0A1C
	X16 si;
	for (si = 1; bp04 >= 0x200; ) {
		//^2C1D:0A21
		bp04 = bp04 >> 1;
		si++;
		//^2C1D:0A32
	}
	//^2C1D:0A41
	return si;
}

//^14CD:1316
// SPX: _14cd_1316 renamed CREATURE_THINK_1316
X16 SkWinCore::CREATURE_THINK_1316(U8 xx, X16 yy, U8 zz)
{
	//^14CD:1316
	ENTER(28);
	//^14CD:131C
	Creature *xCreature = glbCurrentThinkingCreatureRec;	// bp04
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData;	// bp08

	SkD((DLV_CAI, "CAI: (CREATURE_THINK_1316) a#%03d P(%3d,%3d,x,%d)\n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex()
		, (Bitu)(U8)xx, (Bitu)(U8)yy, (Bitu)zz
		));

	if ((xx & 0x40) != 0) {
		if (xCreatureInfo->x == zz) {
			//^14CD:1348
			return 1;
		}
		//^14CD:134E
		xx &= 0xbf;
	}
	//^14CD:1356
	X16 bp0c = xx & 0x80;
	xx &= 0x7f;
	X16 bp0a = 0;
	i16 si;
	i16 bp10;
	ObjectID di;
	U8 *bp18;
	U16 *bp1c;
	X16 bp0e;
	i16 bp12;
	i16 bp14;
	switch (xx) {
		case 1://^1380
			//^14CD:1380
			if (glbSomeMap_4976_4ee7 != glbCreatureMap)
				break;
			if (CALC_VECTOR_DIR(glbCreaturePosX, glbCreaturePosY, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB()) != glbCreatureDir)
				break;
			goto _1470;
		case 2://^13B6
			//^14CD:13B6
			bp0a = (glbSomeMap_4976_4ee7 == glbCreatureMap && glbCreatureTimer.XcoordB() == glbCreaturePosX && glbCreatureTimer.YcoordB() == glbCreaturePosY) ? 1 : 0;
			break;
		case 3://^13E4
			//^14CD:13E4
_13e4:
			if (CREATURE_CAN_HANDLE_ITEM_IN(yy, xCreature->GetPossessionObject(), -1) == OBJECT_END_MARKER)
				break;
			goto _1470;
		case 4://^1403
			//^14CD:1403
			bp0a = _4976_4f03;
			break;
		case 5://^1409
		case 13://^1409
			//^14CD:1409
			if (xCreature->TriggerMap() != glbSomeMap_4976_4ee7 || xCreature->TriggerX() != glbCreatureTimer.XcoordB() || xCreature->TriggerY() != glbCreatureTimer.YcoordB())
				break;
			//^14CD:144E
			if (xx != 0xd)
				goto _1470;
			goto _13e4;

		case 16://^1456
			//^14CD:1456
			if (xCreature->TriggerMap() != glbSomeMap_4976_4ee7)
				break;
			goto _1470;

		case 0://^1470
			//^14CD:1470
_1470:
			bp0a = 1;
			break;
		case 6://^1478
			//^14CD:1478
			if ((xCreature->w10 & (1 << yy)) == 0)
				break;
			//^14CD:148C
			goto _1470;

		case 7://^148E
			//^14CD:148E
			if (glbSomeMap_4976_4ee7 != glbCreatureMap)
				break;
			goto _1470;

		case 8://^149E
			//^14CD:149E
			for (si = 0; si < 4; si++) {
				//^14CD:14A2
				bp10 = GET_PLAYER_AT_POSITION(si);
				if (bp10 == -1)
					continue;
				di = glbChampionSquad[bp10].Possess(1);
				if (di != OBJECT_NULL) {
					//^14CD:14C6
					if (CREATURE_CAN_HANDLE_IT(di, 0xb) != 0)
						goto _1470;
				}
				//^14CD:14D4
				di = glbChampionSquad[bp10].Possess(0);
				if (di != OBJECT_NULL) {
					//^14CD:14E9
					if (CREATURE_CAN_HANDLE_IT(di, 0xb) != 0)
						goto _1470;
				}
				//^14CD:14FA
			}
			//^14CD:1500
			break;
		case 9://^1503
			//^14CD:1503
			if (_2c1d_09d9() < yy)
				break;
			//^14CD:1510
			goto _1470;

		case 10://^1513
			//^14CD:1513
			if (glbSomeMap_4976_4ee7 != glbCreatureMap)
				break;
			//^14CD:1521
			if (glbSomeMap_4976_4ee7 == glbCreatureMap && glbCreatureTimer.XcoordB() == glbCreaturePosX && glbCreatureTimer.YcoordB() == glbCreaturePosY)
				break;
			//^14CD:1545
			if (ABS16(glbCreatureTimer.XcoordB() - glbCreaturePosX) + ABS16(glbCreatureTimer.YcoordB() - glbCreaturePosY) > 1)
				break;
			//^14CD:1571
			si = CALC_VECTOR_DIR(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), glbCreaturePosX, glbCreaturePosY);
			bp10 = GET_TILE_VALUE(glbCreaturePosX + glbXAxisDelta[si], glbCreaturePosY + glbYAxisDelta[si]);
			if ((bp10 >> 5) != ttPit)
				break;
			//^14CD:15BD
			if ((bp10 & 8) == 0 || (bp10 & 1) != 0)
				break;
			goto _1470;

		case 11://^15D4
			//^14CD:15D4
			bp10 = (xCreature->b15_0_1() +2)&3;
			if ((_4976_4ef0 & 0x20) == 0)
				break;
			//^14CD:15F1
			if ((GET_TILE_VALUE(glbCreatureTimer.XcoordB() + glbXAxisDelta[bp10], glbCreatureTimer.YcoordB() + glbYAxisDelta[bp10]) >> 5) != ttDoor)
				break;
			//^14CD:1622
			if (_19f0_0d10(1, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), -1, -1, bp10) == 0)
				break;
			goto _1470;
			break;
		case 12://^1649
			//^14CD:1649
			if (glbSomeMap_4976_4ee7 != glbCreatureMap)
				break;
			//^14CD:1657
			di = GET_CREATURE_AT(glbCreatureTimerGetX + glbXAxisDelta[xCreature->b15_0_1()], glbCreatureTimerGetY + glbYAxisDelta[xCreature->b15_0_1()]);
			if (di == OBJECT_NULL)
				break;
			//^14CD:1696
			if (QUERY_CREATURE_AI_SPEC_FROM_TYPE(GET_ADDRESS_OF_RECORD4(di)->CreatureType())->IsStaticObject() == 0)
				break;
			//^14CD:16BA
			for (si = 0; si < 4; si++) {
				//^14CD:16BF
				bp12 = glbCreaturePosX + glbXAxisDelta[si];
				bp14 = glbCreaturePosY + glbYAxisDelta[si];
				bp10 = GET_TILE_VALUE(bp12, bp14);
				if ((bp10 >> 5) != 0 || (bp10 & 0x10) == 0)
					continue;
				//^14CD:16FA
				for (di = GET_TILE_RECORD_LINK(bp12, bp14); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
					//^14CD:1709
					bp10 = di.DBType();
					if (bp10 == dbActuator) {
						//^14CD:1719
						if (GET_ADDRESS_OF_ACTU(di)->ActuatorType() == ACTUATOR_TYPE_SHOP_PANEL) { // 0x3f: Shop panel
							goto _1470;
						}
					}
					//^14CD:1733
					if (bp10 > dbActuator)
						break;
					//^14CD:1739
				}
				//^14CD:1747
			}
			//^14CD:1750
			break;
		case 14://^1753
			//^14CD:1753
			if ((xCreature->w6 * 100) / glbAIDef->BaseHP > i16(yy))
				break;
			//^14CD:1792
			goto _1470;
		case 15://^1795
			//^14CD:1795
			bp0e = si = 0;
			bp18 = glbCurrentTileMap[0];
			bp1c = &dunGroundStacks[_4976_4c52[0]];
			for (bp12 = 0; bp12 < glbCurrentMapWidth; bp12++) {
				//^14CD:17CD
				for (bp14 = 0; bp14 < glbCurrentMapHeight; bp14++) {
					//^14CD:17D4
					if ((*(bp18++) & 0x10) == 0)
						continue;
					di = *(bp1c++);
					do {
						//^14CD:17EA
						if (di.DBType() == dbCreature) {
							//^14CD:17F7
							bp10 = GET_ADDRESS_OF_RECORD4(di)->CreatureType();
							if (bp10 == yy) {
								//^14CD:1810
								si++;
							}
							// 0x34 -> 'GUARD MINION'; 0x31 -> 'ATTACK MINION'
							else if (bp10 == CREATURE_GOOD_GUARD_MINION || bp10 == CREATURE_GOOD_ATTACK_MINION) {
								//^14CD:181F
								bp0e++;
							}
							break;
						}
						//^14CD:1824
					} while ((di = GET_NEXT_RECORD_LINK(di)) != OBJECT_END_MARKER);
					//^14CD:1832
				}
				//^14CD:183E
			}
			//^14CD:184A
			if (min_value(4, bp0e +1) <= si)
				break;
			goto _1470;

		case 17://^185F
			//^14CD:185F
			_19f0_045a(glbCreatureTimerGetX, glbCreatureTimerGetY);
			if ((_4976_521c & 0x10) == 0)
				break;
			if (_1c9a_1b16(yy, xCreature->w8) != 0)
				break;
			goto _1470;
	}
	//^14CD:1891
	return (bp0c != 0) ? !bp0a : bp0a;
}

//^14CD:18F2
void SkWinCore::_14cd_18f2(i8 xx, U8 yy, sk1bf9 *ss, X8 ww, Ax3 vv)
{
	//^14CD:18F2
	ENTER(14);
	//^14CD:18F7
	if (ss == 0)
		return;
	X16 si = (xx < 0) ? 1 : 0;
	if (si != 0) {
		xx = -xx;
	}
	//^14CD:191D
	do {
		if (ss->b12 == xx) {
			//^14CD:1929
			if (CREATURE_THINK_1316(ss->b1, ss->w2, yy) != 0) {
				//^14CD:1944
				sk1bf9 bp0e = *ss;
				if (si != 0)
					bp0e.b8 = bp0e.b9 = 0;
				//^14CD:1963
				_14cd_0f3c(ss->b0, ss, &bp0e, xx, ww, vv, yy, xx);
			}
		}
		//^14CD:1990
	} while ((ss++)->b13 != 0);
	//^14CD:19A1
	return;
}

//^14CD:19A4
void SkWinCore::_14cd_19a4(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:19A4
	ENTER(0);
	//^14CD:19A7
	_14cd_18f2(xx, yy, ss, 0, Ax3::Invalid);
	//^14CD:19C0
	return;
}

//^14CD:102E
X16 SkWinCore::_14cd_102e(X16 ww, ObjectID rl, i8 dir, X16 alsoPossession, X16 alsoContainer)
{
	//^14CD:102E
	ENTER(2);
	//^14CD:1034
	ObjectID di = rl;
	X16 si = 0;
	for (; di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
		//^14CD:103C
		i16 bp02 = di.DBType();
		if ((alsoPossession != 0 && bp02 == dbCreature) || (alsoContainer != 0 && IS_CONTAINER_CHEST(di) != 0)) {
			//^14CD:1066
			si += _14cd_102e(ww, GET_ADDRESS_OF_RECORD4(di)->GetPossessionObject(), dir, alsoPossession, alsoContainer);
		}
		//^14CD:108B
		if (bp02 <= dbCreature || bp02 >= dbMissile)
			continue;
		//^14CD:1097
		if (dir == -1 || di.Dir() == dir) {
			//^14CD:10AB
			if (CREATURE_CAN_HANDLE_IT(di, ww) != 0)
				//^14CD:10BA
				si++;
		}
		//^14CD:10BB
	}
	//^14CD:10CC
	return si;
}

//^14CD:10D2
sk4f04 *SkWinCore::_14cd_10d2(sk1bf9 *ss, i8 ww)
{
	//^14CD:10D2
	ENTER(30);
	//^14CD:10D8
	X16 bp18 = 0;
	X16 bp1a = 0;
	X16 bp1c = 0;
	X16 bp1e = 0;
	if (_4976_4f02 != 0) {
		//^14CD:10F3
		ZERO_MEMORY(_4976_4f04, sizeof(_4976_4f04)); // 128
		_4976_4f02 = 0;
	}
	//^14CD:1109
	sk4f04 *bp04 = _4976_4f04;
	sk4f04 *bp08 = _4976_4f04;
	i16 si;
	for (si = 0; si < 4; si++, bp08++) {
		//^14CD:111E
		if (bp08->pv0 == 0) {
			//^14CD:112A
			bp04 = bp08;
			continue;
		}
		//^14CD:1138
		if (bp08->pv0 != ss || bp08->b4 != ww)
			continue;
		//^14CD:1156
		return bp08;
		//^14CD:115F
	}
	//^14CD:1169
	bp04->pv0 = ss;
	bp04->b4 = ww;
	skxxxg *bp0c = bp04->x8;
	skxxxg *bp10 = bp04->x8;
	skxxxg *bp14 = bp04->x8;
	bp04->b7 = 0;
	bp04->b6 = 0;
	bp04->b5 = 0;
	si = 0;
	X16 di;
	X16 bp16;
	//^14CD:11AC
	if (si <= 5) {
		do {
			//^14CD:11B4
			if (ss->b12 == ww) {
				//^14CD:11C4
				di = ss->w4;
				if (di != 0xffff && ss->b0 != 8) {
					//^14CD:11DE
					if (ss->b10 != 0xff) {
						//^14CD:11E5
						while (bp10 < bp0c) {
							//^14CD:11E7
							bp10->b1 = U8(bp18) -U8(bp1c);
							++bp10;
						}
						//^14CD:1200
						bp18 = ss->b10;
						bp04->b6 += U8(bp18);
						bp1c = 0;
					}
					//^14CD:121E
					if (ss->b11 != 0xff) {
						//^14CD:1228
						while (bp14 < bp0c) {
							//^14CD:122A
							bp14->b2 = U8(bp1a) -U8(bp1e);
							++bp14;
						}
						//^14CD:1243
						bp1a = ss->b11;
						bp04->b7 += U8(bp1a);
						bp1e = 0;
					}
					//^14CD:1261
					bp16 = _14cd_102e(di, glbCurrentThinkingCreatureRec->GetPossessionObject(), -1, 0, 1);
					bp0c->b0 = U8(bp16);
					bp04->b5 += U8(bp16);
					bp04->b6 -= U8(min_value(bp16, bp18 -bp1c));
					bp04->b7 -= U8(min_value(bp16, bp1a -bp1e));
					bp1c = min_value(bp18, bp1c +bp16);
					bp1e = min_value(bp1a, bp1e +bp16);
				}
				//^14CD:12F6
				++bp0c;
				si++;
			}
			//^14CD:12FB
			//^14CD:1302
		} while ((ss++)->b13 != 0);
	}
	//^14CD:130C
	return bp04;
}

//^14CD:19C2
void SkWinCore::_14cd_19c2(U8 xx, U8 yy, sk1bf9 *ss, i8 vv, i8 ww)
{
	//^14CD:19C2
	ENTER(6);
	//^14CD:19C6
    if (ss == NULL || _4976_4f03 == 0)
		return;
	//^14CD:19D6
	sk4f04 *bp04 = _14cd_10d2(ss, ww);
	if (bp04->b5 <= 0 || bp04->b6 != 0)
		//^14CD:19FF
		_4976_4ef6 &= 0xfff7;
	//^14CD:1A05
	if (glbAIAttacksSpells == 0)
		return;
	//^14CD:1A0C
	X16 bp06 = 0;
	if (xx != 0)
		//^14CD:1A17
		vv = -vv;
	//^14CD:1A1F
	_14cd_18f2(vv, yy, ss, U8(bp06), Ax3::Invalid);
	//^14CD:1A3A
	return;
}

//^14CD:1A3C
void SkWinCore::_14cd_1a3c(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1A3C
	ENTER(0);
	//^14CD:1A3F
	_14cd_19c2(xx, yy, ss, 2, 1);
	//^14CD:1A58
	return;
}
//^14CD:1A5A
void SkWinCore::_14cd_1a5a(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1A5A
	ENTER(0);
	//^14CD:1A5D
	_14cd_19c2(xx, yy, ss, 4, 3);
	//^14CD:1A76
	return;
}
//^14CD:1A78
void SkWinCore::_14cd_1a78(U8 xx, U8 yy, sk1bf9 *ss, X8 ww)
{
	//^14CD:1A78
	ENTER(24);
	//^14CD:1A7C
	if (ss == NULL)
		return;
	//^14CD:1A87
	sk4f04 *bp04 = _14cd_10d2(ss, ww);
	//^14CD:1A9F
	if (bp04->b7 == 0)
		return;
	//^14CD:1AAC
	skxxxg *bp08 = bp04->x8;
	do {
		//^14CD:1ABB
		if (ss->b12 == ww) {
			//^14CD:1ACA
			if (ss->w4 != 0xffff && CREATURE_THINK_1316(ss->b1, ss->w2, yy) != 0) {
				//^14CD:1AEE
				X16 bp0a = min_value(ss->b8, bp08->b0);
				sk1bf9 bp18 = *ss;
				if (xx != 0) {
					//^14CD:1B24
					bp18.b8 = 0;
					bp18.b9 = 0;
					bp0a = 0;
				}
				//^14CD:1B31
				_14cd_0f3c(ss->b0, ss, &bp18, ww, i8(bp0a), Ax3::Invalid, yy, xx);
			}
			//^14CD:1B5D
			++bp08;
		}
		//^14CD:1B61
	} while ((ss++)->b13 != 0);
	//^14CD:1B72
	return;
}

//^14CD:1B74
void SkWinCore::_14cd_1b74(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1B74
	ENTER(0);
	//^14CD:1B77
	_14cd_1a78(xx, yy, ss, 1);
	//^14CD:1B8E
	return;
}

//^14CD:1B90
void SkWinCore::_14cd_1b90(U8 xx, U8 yy, sk1bf9 *ss) 
{
	//^14CD:1B90
	ENTER(0);
	//^14CD:1B93
	_14cd_1a78(xx, yy, ss, 3);
	//^14CD:1BAA
	return;
}

//^14CD:1C27
void SkWinCore::_14cd_1c27(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1C27
	ENTER(0);
	//^14CD:1C2A
	_14cd_1bac(xx, yy, ss, 2, 1);
	//^14CD:1C43
	return;
}

//^14CD:1BAC
void SkWinCore::_14cd_1bac(U8 xx, U8 yy, sk1bf9 *ss, X8 vv, X8 ww)
{
	//^14CD:1BAC
	ENTER(4);
	//^14CD:1BB0
    if (ss == NULL || _4976_4f03 == 0)
		return;
	//^14CD:1BC0
	sk4f04 *bp04 = _14cd_10d2(ss, ww);
	if ((glbAIAttacksSpells & 8) != 0 && (bp04->b5 < 0 || bp04->b6 != 0))
		_4976_4ef6 &= 0xfff7;
	//^14CD:1BF7
	if (glbAIAttacksSpells == 0)
		return;
	if (xx != 0)
		//^14CD:1C04
		vv = -vv;
	//^14CD:1C0C
	_14cd_18f2(vv, yy, ss, 0, Ax3::Invalid);
	//^14CD:1C25
	return;
}
//^14CD:1C45
void SkWinCore::_14cd_1c45(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1C45
	ENTER(0);
	//^14CD:1C48
	_14cd_1bac(xx, yy, ss, 4, 3);
	//^14CD:1C61
	return;
}
//^14CD:1C63
void SkWinCore::_14cd_1c63(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1C63
	ENTER(0);
	//^14CD:1C66
	_14cd_18f2(5, yy, ss, 0, (_4976_5151 == 13) ? _4976_5156 : Ax3::Invalid);
	//^14CD:1C8B
	return;
}
//^14CD:1C8D
void SkWinCore::_14cd_1c8d(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1C8D
	ENTER(0);
	//^14CD:1C90
	if (xx != 0 && glbCurrentThinkingCreatureRec->TriggerX() == glbCreatureTimerGetX && glbCurrentThinkingCreatureRec->TriggerY() == glbCreatureTimerGetY && glbCurrentThinkingCreatureRec->TriggerMap() == glbSomeMap_4976_4ee7)
		return;
	//^14CD:1CD3
	_14cd_18f2(6, yy, ss, 0, Ax3::Invalid);
	//^14CD:1CEA
	return;
}
//^14CD:1CEC
void SkWinCore::_14cd_1cec(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1CEC
	ENTER(4);
	//^14CD:1CF0
	Missile *bp04 = GET_MISSILE_REF_OF_MINION(glbCurrentThinkingCreatureID, OBJECT_NULL);
	if (bp04 == NULL || bp04->GetMissileObject().DBType() != dbContainer)
		return;
	//^14CD:1D19
	_14cd_18f2(7, yy, ss, 0, GET_ADDRESS_OF_RECORD9(bp04->GetMissileObject())->GetDest());
	//^14CD:1D40
	return;
}
//^14CD:1D42
void SkWinCore::_14cd_1d42(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1D42
	ENTER(0);
	//^14CD:1D45
	_14cd_18f2(0x12, yy, ss, 0, (_4976_5151 == 5) ? _4976_5156 : Ax3::Invalid);
	//^14CD:1D6A
	return;
}

//^14CD:1D6C
void SkWinCore::_14cd_1d6c(U8 xx, U8 yy, sk1bf9 *ss, i8 ww)
{
	//^14CD:1D6C
	ENTER(14);
	//^14CD:1D72
	if (ss == NULL)
		return;
	do {
		//^14CD:1D7D
		X16 di = ss->w4;
		X16 si = ss->w6;
		if (ss->b12 == ww) {
			//^14CD:1D94
			if (di == 0xffff || (si != 0 && si == 1) || CREATURE_CAN_HANDLE_ITEM_IN(di, glbCurrentThinkingCreatureRec->possession, -1) != OBJECT_END_MARKER) {
				//^14CD:1DBB
				if (CREATURE_THINK_1316(ss->b1, ss->w2, yy) != 0) {
					//^14CD:1DD6
					sk1bf9 bp0e = *ss;
					if (xx != 0) {
						//^14CD:1DEF
						bp0e.b8 = 0;
						bp0e.b9 = 0;
					}
					//^14CD:1DF7
					_14cd_0f3c(ss->b0, ss, &bp0e, ww, 0, Ax3::Invalid, yy, xx);
				}
			}
		}
		//^14CD:1E21
	} while ((ss++)->b13 != 0);
	//^14CD:1E32
	return;
}

//^14CD:1E36
void SkWinCore::_14cd_1e36(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1E36
	ENTER(0);
	//^14CD:1E39
	_14cd_1d6c(xx, yy, ss, 15);
	//^14CD:1E50
	return;
}

//^14CD:1E52
void SkWinCore::_14cd_1e52(U8 xx, U8 yy, sk1bf9 *ss) { // TODO: Unr
	Unr();
}

//^32CB:00BF
U16 SkWinCore::IS_MAP_INSIDE(U16 mapno)
{
	//^32CB:00BF
	ENTER(0);
	//^32CB:00C2
	return !(QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_GRAPHICSSET, dunMapsHeaders[mapno].MapGraphicsStyle(), dtWordValue, GDAT_GFXSET_SCENE_FLAGS) & 0x20);

	// MapGraphicsStyle = [0x65]
	// 00=0018 ;Void
	// 01=0028 ;Outside
	// 02=000B ;Cave
	// 03=000B ;Stone corridor
	// 04=0028 ;Skullkeep rooftop
	// 05=0028 ;Myst zone

	// SPX: 0x020 would mean to use 'outdoor sky' (in weather category) ?
}

//^14CD:1E6E
void SkWinCore::_14cd_1e6e(U8 xx, U8 yy, sk1bf9 *ss)
{
	// SPX: this one seems to be called by bats? for each tile.
	//^14CD:1E6E
	ENTER(0);
	//^14CD:1E71
	if (IS_MAP_INSIDE(glbSomeMap_4976_4ee7) == 0) {
		//^14CD:1E93
		glbCurrentThinkingCreatureRec->w10_7_7(0);
		//^14CD:1E9D
		return;
	}
	//^14CD:1E81
	if (xx != 0) {
		//^14CD:1EB5
		if ((RAND() & 0x1F) == 0) {
			//^14CD:1EBF
			glbCurrentThinkingCreatureRec->w10_7_7(0);
		}
		//^14CD:1EC9
		_14cd_0f3c(0, ss, _4976_1bcf, 0, 0, Ax3::Invalid, yy, xx);
	}
	else {
		//^14CD:1E8B
		if (glbCurrentThinkingCreatureRec->w10_7_7() != 0) {
			//^14CD:1E91
			//^14CD:1E93
			glbCurrentThinkingCreatureRec->w10_7_7(0);
			//^14CD:1E9D
			return;
		}
		//^14CD:1E9F
		if ((RAND() & 0x3F) == 0) {
			//^14CD:1EA9
			glbCurrentThinkingCreatureRec->w10_7_7(1);
			//^14CD:1EC9
			_14cd_0f3c(0, ss, _4976_1bcf, 0, 0, Ax3::Invalid, yy, xx);
		}
	}
	//^14CD:1EEA
}

//^14CD:1EEC
void SkWinCore::_14cd_1eec(U8 xx, U8 yy, sk1bf9 *ss, X8 ww)
{
	//^14CD:1EEC
	ENTER(14);
	//^14CD:1EF0
	if (ss == NULL)
		return;
	do {
		//^14CD:1EFB
		if (ss->b12 == ww) {
			//^14CD:1F07
			if (CREATURE_THINK_1316(ss->b1, ss->w2, yy) != 0) {
				//^14CD:1F22
				sk1bf9 bp0e = *ss;
				bp0e.w6 = glbCurrentThinkingCreatureRec->w8;
				if (xx != 0)
					bp0e.b8 = bp0e.b9 = 0;
				//^14CD:1F4E
				_14cd_0f3c(ss->b0, ss, &bp0e, ww, 0, Ax3::Invalid, yy, xx);
			}
		}
		//^14CD:1F78
	} while ((ss++)->b13 != 0);
	//^14CD:1F89
	return;
}

//^14CD:1FA7
void SkWinCore::_14cd_1fa7(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1FA7
	ENTER(2);
	//^14CD:1FAB
	Ax3 bp02;
	bp02.SetX(glbCreaturePosX);
	bp02.SetY(glbCreaturePosY);
	bp02.SetMap(glbCreatureMap);
	_14cd_18f2(0x16, yy, ss, 0, bp02);
	//^14CD:1FF1
	return;
}

//^14CD:1F8B
void SkWinCore::_14cd_1f8b(U8 xx, U8 yy, sk1bf9 *ss)
{
	//^14CD:1F8B
	ENTER(0);
	//^14CD:1F8E
	_14cd_1eec(xx, yy, ss, 0x15);
	//^14CD:1FA5
	return;
}

//^1C9A:38A8
X16 SkWinCore::_1c9a_38a8()
{
	//^1C9A:38A8
	ENTER(22);
	//^1C9A:38AE
	CreatureInfoData *bp08 = glbCurrentThinkingCreatureData;
	X16 di = 0;
	__SET_CURRENT_THINKING_CREATURE_WALK_PATH();
	X16 si = 0;
	while (true) {
		//^1C9A:38C3
		if (_4976_4fd8->b18() > si) {
			//^1C9A:38CE
			if (_4976_4fee[RCJ(16,si)].b7 != _4976_5151 || _4976_4fee[RCJ(16,si)].w8 != _4976_5152) {
				//^1C9A:38F4
				si++;
				continue;
			}
			else {
				//^1C9A:38F7
				if (si != 0) {
					//^1C9A:38FB
					MOVE_MEMORY(&_4976_4fee[RCJ(16,si)], _4976_4fee, sizeof(skxxx9));
				}
				//^1C9A:3917
				_4976_4fee->b0 = 0;
				X16 bp14 = glbCurrentMapIndex;
				_1c9a_0648(_4976_5156.GetMap());
				WalkPath bp16;
				X16 bp10;
				X16 bp0e;
				if (FIND_WALK_PATH(bp0e = _4976_5156.GetX(), bp10 = _4976_5156.GetY(), 2, 0, 1, _4976_4fee, &bp16) == 0 && _4976_4fee[0].b6 == 0) {
					//^1C9A:396F
					X16 bp0a = glbCreatureTimerGetX;
					X16 bp0c = glbCreatureTimerGetY;
					si = _4976_514e.b1;
					if (si == 0) {
						//^1C9A:398A
						di = (bp0a == bp0e && bp0c == bp10 && glbCurrentMapIndex == bp14) ? 1 : 0;
					}
					else {
						//^1C9A:39AE
						_1c9a_0648(bp14);
						i16 bp12 = 5;
						__SET_CURRENT_THINKING_CREATURE_WALK_PATH();
						//^1C9A:39BF
						while (true) {
							WalkPath *bp04 = &glbMemWalkPath[_4976_514e.b0 -si];
							if (true
								&& CREATURE_GO_THERE(_4976_4fd8->b17, bp0a, bp0c, -1, -1, bp04->getDir()) != 0
								&& bp04->getY() == glbCreatureSomeY
								&& bp04->getMapCross() == ((glbCreatureSomeZMap != glbCurrentMapIndex) ? 1 : 0) 
							) {
								//^1C9A:3A3D
								_1c9a_0648(glbCreatureSomeZMap);
								bp0a = glbCreatureSomeX;
								bp0c = glbCreatureSomeY;
								if (--si > 0 && --bp12 > 0)
									continue;
								//^1C9A:3A5D
								di = 1;
							}
							break;
						}
					}
				}
				//^1C9A:3A60
				_1c9a_0648(bp14);
			}
		}
		//^1C9A:3A68
		return di;
	}
}

//^14CD:0389
// SPX: _14cd_0389 renamed CREATURE_THINK_0389
X8 SkWinCore::CREATURE_THINK_0389()
{
	//^14CD:0389
	ENTER(10);
	//^14CD:038E
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData; // bp08
	X16 si = 0;
	i8 bp09;
	i8 bp0a;
	if (_4976_514e.b0 != 0 && _4976_514e.b1 != 0 && _4976_514e.b3 != 0xff) {
		//^14CD:03BB
		_4976_4fd8->b18(0);
		if (xCreatureInfo->x != -1) {
			//^14CD:03CA
			bp09 = xCreatureInfo->x;
			bp0a = xCreatureInfo->y;
			sk3672 *bp04 = _4976_3672[RCJ(56,bp09)];
			_14cd_0f0a(bp04[bp0a].b5(), bp04[bp0a].b6(), bp09, _4976_514e.pv10);
		}
		//^14CD:0429
		if (_4976_4fd8->b18() == 0) {
			si = 0;
		}
		else {
			si = _1c9a_38a8();
			if (si != 0) {
				xCreatureInfo->w24 = _4976_4fee[0].w2;
			}
		}
	}
	//^14CD:0449
	return (si != 0) ? bp09 : 0xff;
}

//^14CD:0550
void SkWinCore::_14cd_0550(skxxxh *ref, i8 xx, i8 yy, X16 ww)
{
	//^14CD:0550
	ENTER(8);
	//^14CD:0556
	X16 bp08 = 0;

	// SPX: ref may be null when using IMG9; let's skip this ...
	if (SkCodeParam::bUseFixedMode && ref == NULL)
		return;

	//^14CD:055B
	do {
		i8 bp05 = ref->b0;
		X16 si;

		//^14CD:0564
		SkD((DLV_CAI, "CAI: (B) a#%03d H(%3d,%3d,x,%d) _ %02X %02X %04X \n"
			, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bitu)ref->b0, (Bitu)ref->b1, (Bitu)ref->b6
			, (Bitu)(U8)xx, (Bitu)(U8)yy, (Bitu)ww
			));

		if (bp05 != xx) {
			//^14CD:0569
			if (_4976_5162 != 0)
				continue;
			//^14CD:0573
			i16 di = ref->b1; // Typ@i8
			if (di != 0) {
				//^14CD:0581
				if (di > 0) {
					//^14CD:0585
					if (RAND16(di) != 0)
						continue;
				}
				else {
					//^14CD:0593
					if (RAND16(-di) == 0)
						continue;
				}
			}
			//^14CD:05A2
			si = 0;
		}
		else {
			//^14CD:05A6
			bp08 = (ww != 0 || _4976_5162 != 0) ? 1 : 0;
			si = yy;
		}
		//^14CD:05C3
		sk3672 *bp04 = _4976_3672[RCJ(56,bp05)];

		//^14CD:05DA
		//SkD((DLV_CAI, "CAI: b-- a#%03d 3672[%3d,%3d] (%3d,%2d,%2d,%3d,%3d,%2d,%2d)\n"
		//	, (Bitu)glbCurrentThinkingCreatureData->w0, (Bitu)bp05, (Bitu)si
		//	, (Bits)(i8)bp04[si].b0_[0], (Bits)(i8)bp04[si].b0_[1], (Bits)(i8)bp04[si].b0_[2], (Bits)(i8)bp04[si].b0_[3]
		//	, (Bits)(i8)bp04[si].b0_[4], (Bits)    bp04[si].b0_[5], (Bits)    bp04[si].b0_[6]
		//	));

		_14cd_0f0a(bp04[si].b5(), bp04[si].b6(), bp05, ref->pv2);

		//SkD((DLV_CAI, "CAI: --b a#%03d r %d\n"
		//	, (Bitu)glbCurrentThinkingCreatureData->w0, (Bitu)_4976_5162
		//	));
		//^14CD:0613
	} while (bp08 == 0 && (ref++)->b6 != 0);

	//^14CD:062A
	return;
}
//^14CD:0457
void SkWinCore::_14cd_0457()
{
	//^14CD:0457
	ENTER(10);
	//^14CD:045D
	i16 bp0a = _4976_4fd8->b18();
	if (bp0a == 0)
		return;
	//^14CD:046B
	skxxx9 *bp04 = _4976_4fee;
	i16 di = _4976_514e.b0;
	for (; bp0a > 0; bp0a--, bp04++) {
		//^14CD:047C
		i16 si = bp04->b0;
		if (si <= 0)
			continue;
		bp04->b0 = i8(min_value(si >> 1, di -2));
		//^14CD:04A1
	}
	//^14CD:04AE
	bp0a = _4976_4fd8->b18();
	bp04 = _4976_4fee;
	for (di = 0; di < bp0a; di++, bp04++) {
		//^14CD:04C1
		if (bp04->b0 >= 0)
			continue;
		//^14CD:04CA
		i16 si = di +1;
		skxxx9 *bp08 = bp04 +1;
		for (; bp0a < bp0a; si++, bp08++) {
			//^14CD:04E0
			if (bp08->b0 >= 0)
				break;
			//^14CD:04E9
		}
		//^14CD:04F3
		if (si >= bp0a) {
			//^14CD:04F8
			bp0a = di +1;
			continue;
		}
		//^14CD:0500
		MOVE_MEMORY(bp08, bp04, (bp0a -si) * sizeof(skxxx9));
		bp0a -= si -di;
		//^14CD:0528
	}
	//^14CD:0532
	if (_4976_4fd8[bp0a].b0 < 0)
		bp0a--;
	//^14CD:0546
	_4976_4fd8->b18(i8(bp0a));
	//^14CD:054C
	return;
}

//^14CD:0684
i8 SkWinCore::SELECT_CREATURE_3672()
{
	//^14CD:0684
	ENTER(14);
	//^14CD:068A
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData; // bp08
	X16 si = (CREATURE_THINK_0389() != 0xff) ? 1 : 0;
	X8 bp0a = 0xff;
	if ((_4976_3752[_4976_4efa] & 1) != 0 || si == 0 || RAND02() == 0) {
		//^14CD:06CA
		_4976_4fd8->b18(0);
		_4976_5162 = _14cd_062e();
		i8 bp09 = xCreatureInfo->x;
		i8 bp0d = xCreatureInfo->y;
		_14cd_0550(_4976_4efe->pv2, bp09, bp0d, si);
		if (si != 0)
			_14cd_0457();
		if (_4976_4fd8->b18() != 0) {
			//^14CD:0712
			X16 di = ((glbCurrentThinkingCreatureRec->w10 & 0x2048) != 0) ? _4976_5163 : 0;
			if (glbCurrentThinkingCreatureRec->w10_c_c() != 0)
				di |= 0x20;
			//^14CD:0739
			ATLASSERT(_4976_4fd8->b18() < 16);
			U16 bp0c = FIND_WALK_PATH(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), di, 0, _4976_4fd8->b18(), _4976_4fee, glbCreatureWalkPath);
			_4976_4fd8->b19(U8(bp0c));
			if (bp0c != 0xffff) {
				//^14CD:0769
				skxxx9 *bp04 = &_4976_4fee[RCJ(16,bp0c)];
				bp0a = bp04->b14;
				xCreatureInfo->w24 = bp04->w2;
				_14cd_0276(bp04);
			}
			//^14CD:079D
			else if (_4976_5162 != 0) {
				return -3;
			}
		}
	}
	//^14CD:07A8
	if (bp0a != 0xff || si == 0) {
		//^14CD:07B2
		if (bp0a == 0xff) {
			bp0a = 0x11;
			_4976_514e.b1 = 0;
			_4976_514e.b3 = 0xff;
		}
		else {
			//^14CD:07C8
			if (xCreatureInfo->x != -1) {
				//^14CD:07D2
				i8 bp09 = xCreatureInfo->x;
				i8 bp0d = xCreatureInfo->y;
				if (bp09 == bp0a) {
					//^14CD:07E8
					bp0a = 0xff;
				}
				else {
					//^14CD:07EE
					xCreatureInfo->x = xactrNeedReset;
					xCreatureInfo->y = 0;
				}
			}
		}
	}
	//^14CD:07FB
	return bp0a;
}
//^14CD:0815
i8 SkWinCore::DECIDE_NEXT_XACT()
{
	//^14CD:0815
	ENTER(8);
	//^14CD:0819
	i8 bp05 = glbCurrentThinkingCreatureData->x;
	i8 cl = glbCurrentThinkingCreatureData->y;
	sk3672 *bp04 = _4976_3672[RCJ(56,bp05)];
	i8 bp07;
	for (; (bp07 = bp04[cl].b0()) < 0; cl++) {
		SkD((DLV_CAI, "CAI: ( ) a#%03d 3672[%3d,%3d] (%3d,%2d,%2d,%3d,%3d,%2d,%2d)\n"
			, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bitu)bp05, (Bitu)cl
			, (Bits)(i8)bp04[cl].b0_[0], (Bits)(i8)bp04[cl].b0_[1], (Bits)(i8)bp04[cl].b0_[2], (Bits)(i8)bp04[cl].b0_[3]
			, (Bits)(i8)bp04[cl].b0_[4], (Bits)    bp04[cl].b0_[5], (Bits)    bp04[cl].b0_[6]
			));

		//^14CD:0843
		if (bp07 != -10)
			continue;
		//^14CD:0849
		i8 bp06 = bp04[cl].b1();
		if (bp06 < 0 || bp06 >= 2)
			continue;
		//^14CD:0867
		glbCurrentThinkingCreatureData[bp06].w14 = bp04[cl].b2();
		//^14CD:088B
	}

	SkD((DLV_CAI, "CAI: (!) a#%03d 3672[%3d,%3d] (%3d,%2d,%2d,%3d,%3d,%2d,%2d)\n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bitu)bp05, (Bitu)cl
		, (Bits)(i8)bp04[cl].b0_[0], (Bits)(i8)bp04[cl].b0_[1], (Bits)(i8)bp04[cl].b0_[2], (Bits)(i8)bp04[cl].b0_[3]
		, (Bits)(i8)bp04[cl].b0_[4], (Bits)    bp04[cl].b0_[5], (Bits)    bp04[cl].b0_[6]
		));

	//^14CD:08A4
	glbCurrentThinkingCreatureData->x = bp05;
	glbCurrentThinkingCreatureData->y = cl;
	bp07 = bp04[cl].b0();
	if (bp07 == 86)
		printf("break");
	_4976_4ee8 = bp04[cl].b3();
    _4976_4eea = bp04[cl].b4();		
	//^14CD:08F0
	return bp07;
}
//^14CD:226D
// SPX: _14cd_226d renamed PROCEED_XACT_56
X8 SkWinCore::PROCEED_XACT_56()
{
	//^14CD:226D
	ENTER(0);
	//^14CD:2270
	return (CREATURE_GO_THERE(128, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, -1, glbCurrentThinkingCreatureRec->b15_0_1()) != 0)
		? xactrAgain 
		: xactrYes;
}
//^14CD:22A3
// SPX: _14cd_22a3 renamed PROCEED_XACT_57
void SkWinCore::PROCEED_XACT_57()
{
	//^14CD:22A3
	ENTER(0);
	//^14CD:22A8
	i16 di = (RAND01() != 0) ? 1 : -1;
	X16 si = glbCurrentThinkingCreatureRec->b15_0_1();
	if (CREATURE_GO_THERE(128, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, -1, (si +di)&3) != 0)
		return;
	//^14CD:22ED
	if (CREATURE_GO_THERE(128, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, -1, (si -di)&3) != 0)
		return;
	//^14CD:2319
	_19f0_0559((si +di)&3);
	//^14CD:2327
	return;
}
//^14CD:232B
// SPX : _14cd_232b renamed PROCEED_XACT_59_76
X8 SkWinCore::PROCEED_XACT_59_76()
{
	//^14CD:232B
	ENTER(0);
	//^14CD:232F
	X16 si = _4976_4ee8;
	if (si == 0xffff)
		si = _4976_5152;
	//^14CD:233D
	if (_4976_4eea != 0 && CREATURE_CAN_HANDLE_ITEM_IN(si, glbCurrentThinkingCreatureRec->possession, -1) != OBJECT_END_MARKER)
		return xactrYes;
	//^14CD:2361
	_19f0_2165(128, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCurrentThinkingCreatureData->w24.GetX(), glbCurrentThinkingCreatureData->w24.GetY(), -1, si);
	//^14CD:2392
	return _4976_4ee5;
}

//^14CD:2B9A
ObjectID SkWinCore::FIND_TILE_ACTUATOR(X16 xx, X16 yy, i8 dir, X16 actuatorType)
{
	//^14CD:2B9A
	ENTER(6);
	//^14CD:2BA0
	ObjectID si = GET_TILE_RECORD_LINK(xx, yy);
	X16 di = 0;
	for (; si != OBJECT_END_MARKER; si  = GET_NEXT_RECORD_LINK(si)) {
		//^14CD:2BB3
		i16 bp06 = si.DBType();
		if (bp06 > dbActuator)
			break;
		//^14CD:2BC3
		if (bp06 != dbActuator || dir != -1) {
			//^14CD:2BCF
			if (si.Dir() != U8(dir))
				continue;
		}
		//^14CD:2BDD
		Actuator *bp04 = GET_ADDRESS_OF_ACTU(si);
		di = (bp04->ActuatorType() == actuatorType) ? 1 : 0;
		if (di != 0)
			break;
		//^14CD:2C06
	}
	//^14CD:2C14
	return (di != 0) ? si : OBJECT_NULL;
}

//^14CD:2C23
// SPX : _14cd_2c23 renamed PROCEED_XACT_62
X8 SkWinCore::PROCEED_XACT_62()
{
	//^14CD:2C23
	ENTER(16);
	//^14CD:2C29
	X16 bp0e = 0;
	X16 bp02 = _4976_4ef2;
	if ((bp02 & 0x77) == 0)
		//^14CD:2C39
		return xactrNo;
	//^14CD:2C3E
	if (_4976_4eea == 1 && CREATURE_CAN_HANDLE_ITEM_IN(16, glbCurrentThinkingCreatureRec->possession, -1) != OBJECT_END_MARKER)
		return xactrYes;
	//^14CD:2C62
	X16 bp04;
	X16 bp06;
	if (_4976_4ee8 != 0) {
		//^14CD:2C69
		bp04 = glbCreatureTimerGetX;
		bp06 = glbCreatureTimerGetY;
	}
	else {
		//^14CD:2C78
		bp04 = glbCurrentThinkingCreatureData->w24.GetX();
		bp06 = glbCurrentThinkingCreatureData->w24.GetY();
	}
	//^14CD:2C93
	ObjectID si = FIND_TILE_ACTUATOR(bp04, bp06, -1, 0x30);
	if (si == OBJECT_NULL)
		return xactrNo;
	//^14CD:2CAE
	Actuator *bp0a = GET_ADDRESS_OF_ACTU(si);
	X16 bp0c = bp0a->ActuatorData();
	if (_4976_4eea == 2) {
		//^14CD:2CD2
		ObjectID bp10 = GET_CREATURE_AT(glbCreatureTimerGetX + glbXAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()], glbCreatureTimerGetY + glbYAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()]);
		if (bp10 != OBJECT_NULL) {
			//^14CD:2D11
			if (_1c9a_06bd(bp10, bp0c, (glbCurrentThinkingCreatureRec->b15_0_1() +2)&3) == NULL)
				return xactrNo;
			return xactrYes;
		}
	}
	//^14CD:2D3B
	si = GET_WALL_TILE_ANYITEM_RECORD(bp04, bp06);
	//^14CD:2D48
	while (si != OBJECT_END_MARKER && si.DBType() < dbWeapon)
		//^14CD:2D4A
		si = GET_NEXT_RECORD_LINK(si);
	//^14CD:2D65
	if (si != OBJECT_END_MARKER) {
		//^14CD:2D6D
		if (GET_DISTINCTIVE_ITEMTYPE(si) == bp0c) {
			//^14CD:2D79
			bp0e = 1;
		}
		else {
			//^14CD:2D81
			ObjectID di = si;
			//^14CD:2D83
			while (si != OBJECT_END_MARKER && si.DBType() <= dbMiscellaneous_item && GET_DISTINCTIVE_ITEMTYPE(si) != bp0c)
				//^14CD:2D85
				si = GET_NEXT_RECORD_LINK(si);
			//^14CD:2DAC
			if (si != OBJECT_END_MARKER) {
				//^14CD:2DB1
				bp0e = 1;
				//^14CD:2DB6
				while (di != OBJECT_END_MARKER && di.DBType() <= dbMiscellaneous_item && GET_DISTINCTIVE_ITEMTYPE(di) != bp0c) {
					//^14CD:2DB8
					si = GET_NEXT_RECORD_LINK(di);
					CUT_RECORD_FROM(di, NULL, bp04, bp06);
					APPEND_RECORD_TO(di, NULL, bp04, bp06);
					di = si;
				}
			}
		}
	}
	//^14CD:2E07
	if (bp0e == 0) {
		//^14CD:2E0D
		if (glbCurrentThinkingCreatureData->w14-- <= 0) {
			//^14CD:2E1D
			glbCurrentThinkingCreatureData->w14 = 3;
			glbCurrentThinkingCreatureData->Command = ccm1E;
			return xactrNo;
		}
		else {
			//^14CD:2E2B
			glbCurrentThinkingCreatureData->Command = ccm1D;
			return xactrNo;
		}
		//^14CD:2E37
		return xactrNo;
	}
	//^14CD:2E3A
	_4976_4ef2 &= 0x77;
	_19f0_2165(128, glbCreatureTimerGetX, glbCreatureTimerGetY, bp04, bp06, -1, 0x10);
	_4976_4ef2 = bp02;
	//^14CD:2E67
	return _4976_4ee5;
}
//^14CD:25B8
// SPX: _14cd_25b8 renamed PROCEED_XACT_63
X8 SkWinCore::PROCEED_XACT_63()
{
	// find an item around the creature. 
	// merchant uses this.

	// sk3672.b3 _4976_4ee8 = item pool. check CREATURE_CAN_HANDLE_ITEM_IN
	// sk3672.b4 _4976_4ee9 = dir. -1 for any dir. 
	//                              0 for front?
	//               33             1 for right side?
	//  MERCHANT   0-**-2  YOU      2 for opposite side,?
	//             0-**-2           3 for left side?
	//               11  TABLE

	//^14CD:25B8
	ENTER(6);
	//^14CD:25BE
	X8 bp04 = xactrNo;
	X16 bp06 = _4976_4ee8;
	if (bp06 == 0xffff)
		return bp04;
	//^14CD:25D0
	X16 di = glbCreatureTimerGetX;
	X16 si = glbCreatureTimerGetY;
	X8 bp03 = X8(_4976_4eea);
	if (bp03 != 0xff) {
		//^14CD:25E8
		bp03 = (glbCurrentThinkingCreatureRec->b15_0_1() +bp03 +2)&3;
	}
	//^14CD:25FD
	di += glbXAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()];
	si += glbYAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()];
	ObjectID bp02 = GET_CREATURE_AT(di, si);
	if (bp02 != OBJECT_NULL && CREATURE_CAN_HANDLE_ITEM_IN(bp06, GET_ADDRESS_OF_RECORD4(bp02)->GetPossessionObject(), bp03) != OBJECT_END_MARKER)
		//^14CD:2657
		bp04 = xactrYes;
	//^14CD:265B
	return bp04;
}
//^14CD:240E
// SPX: _14cd_240e renamed PROCEED_XACT_64
X8 SkWinCore::PROCEED_XACT_64()
{
	//^14CD:240E
	ENTER(0);
	//^14CD:2413
	X16 di;
	if (glbCurrentThinkingCreatureRec->possession == OBJECT_END_MARKER || ((di = _4976_4ef2) & 8) == 0)
		//^14CD:2428
		return xactrNo;
	//^14CD:242C
	X16 si = _4976_4ee8;
	if (si == 0xffff)
		si = 0x3f;
	//^14CD:2439
	if (CREATURE_CAN_HANDLE_ITEM_IN(si, glbCurrentThinkingCreatureRec->possession, -1) == OBJECT_END_MARKER)
		return xactrNo;
	//^14CD:2454
	_4976_4ef2 &= 8;
	_19f0_2165(0x81, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, -1, glbCurrentThinkingCreatureRec->b15_0_1(), si);
	_4976_4ef2 = di;
	//^14CD:2486
	return _4976_4ee5;
}
//^14CD:2E6E
// SPX: _14cd_2e6e renamed PROCEED_XACT_65
X8 SkWinCore::PROCEED_XACT_65()
{
	//^14CD:2E6E
	ENTER(6);
	//^14CD:2E74
	glbCurrentThinkingCreatureData->w12 = Ax3::Invalid;
	X16 si = glbCurrentThinkingCreatureRec->b15_0_1();
	X16 bp02 = glbCreatureTimerGetX + (glbXAxisDelta[si] << 1);
	X16 di = glbCreatureTimerGetY + (glbYAxisDelta[si] << 1);
	ObjectID bp04 = GET_CREATURE_AT(bp02, di);
	X8 bp05;
	if ((bp04 != OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp04) & 1) == 0) || (glbCurrentMapIndex == glbCreatureMap && bp02 == glbCreaturePosX && di == glbCreaturePosY)) {
		//^14CD:2EED
		bp05 = xactrYes;
	}
	else {
		//^14CD:2EF3
		glbCurrentThinkingCreatureData->Command = ccm1D;
		bp05 = xactrAgain;
	}
	//^14CD:2F00
	return bp05;
}
//^14CD:2662
X16 SkWinCore::_14cd_2662(i8 dir)
{
	//^14CD:2662
	ENTER(6);
	//^14CD:2668
	ObjectID si = OBJECT_END_MARKER;
	X16 bp04 = glbCreatureTimerGetX;
	X16 bp06 = glbCreatureTimerGetY;
	if (dir != -1) {
		//^14CD:2681
		dir = (glbCurrentThinkingCreatureRec->b15_0_1() +dir +2)&3;
	}
	//^14CD:2696
	bp04 += glbXAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()];
	bp06 += glbYAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()];
	ObjectID bp02 = GET_CREATURE_AT(bp04, bp06);
	if (bp02 != OBJECT_NULL) {
		//^14CD:26D5
		for (si = GET_ADDRESS_OF_RECORD4(bp02)->GetPossessionObject(); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
			//^14CD:26E8
			i16 di = si.DBType();
			if ((di <= dbCreature || di >= dbMissile) && di != dbContainer)
				continue;
			//^14CD:2701
			if (dir != -1 && si.Dir() != dir)
				continue;
			//^14CD:2715
			if (CREATURE_CAN_HANDLE_IT(si, 16) != 0)
				continue;
			//^14CD:2723
			if (CREATURE_CAN_HANDLE_IT(si, 7) == 0)
				break;
			//^14CD:2731
		}
	}
	//^14CD:273F
	return (si != OBJECT_END_MARKER) ? 1 : 0;
}

//^14CD:274F
// SPX: _14cd_274f renamed PROCEED_XACT_66
X8 SkWinCore::PROCEED_XACT_66()
{
	//^14CD:274F
	ENTER(2);
	//^14CD:2754
	X8 bp01;
	if (_14cd_2662(2) != 0) {
		//^14CD:275F
		bp01 = xactrAgain;
		if (glbCurrentThinkingCreatureData->w14-- <= 5) {
			//^14CD:2774
			glbCurrentThinkingCreatureData->w14 = 9;
			glbCurrentThinkingCreatureData->Command = ccm1F;
		}
		else {
			//^14CD:2782
			glbCurrentThinkingCreatureData->Command = ccm1D;
		}
	}
	else {
		//^14CD:278D
		X16 si = _4976_4ee8;
		_4976_4ee8 = 16;
		_4976_4eea = 2;
		if (PROCEED_XACT_63() == 0xfe || (si != 0 && (_4976_4ee8 = 7) != 0 && PROCEED_XACT_63() == 0xfe)) {
			//^14CD:27BD
			bp01 = xactrYes;
		}
		//^14CD:27C3
		else if (glbCurrentThinkingCreatureData->w14-- <= 0) {
			//^14CD:27D3
			glbCurrentThinkingCreatureData->w14 = 5;
			bp01 = xactrNo;
			glbCurrentThinkingCreatureData->Command = ccm1E;
		}
		else {
			//^14CD:27E4
			if (glbCurrentThinkingCreatureData->w14 > 5)
				glbCurrentThinkingCreatureData->w14 -= 5;
			//^14CD:27F4
			bp01 = xactrNo;
			glbCurrentThinkingCreatureData->Command = ccm1D;
		}
	}
	//^14CD:2801
	return bp01;
}
//^14CD:2807
U16 SkWinCore::_14cd_2807(ObjectID *ref, skxxxi *pv)
{
	//^14CD:2807
	ENTER(0);
	//^14CD:280A
	if (CREATURE_CAN_HANDLE_IT(*ref, pv->w2) != 0) {
		//^14CD:2822
		if (pv->w0 == -1)
			pv->w0 = 0;
		pv->w0 += _48ae_05ae(
			GET_DISTINCTIVE_ITEMTYPE(*ref), 
			glbCurrentThinkingCreatureRec->CreatureType(), 
			glbCurrentThinkingCreatureRec->w8, pv->w4, pv->w6, 
			(pv->w8 != 0) ? ADD_ITEM_CHARGE(*ref, 0) : 0xffff);
	}
	//^14CD:2882
	return 0;
}

//^14CD:2886
i16 SkWinCore::_14cd_2886(ObjectID *ref, X16 xx, i8 dir, X16 ss, X16 tt, X16 ww)
{
	//^14CD:2886
	ENTER(14);
	//^14CD:288A
	skxxxi bp0e;
	bp0e.w0 = -1;
	bp0e.w2 = xx;
	bp0e.w4 = ss;
	bp0e.w6 = tt;
	bp0e.w8 = ww;
	ObjectID *bp04;
	OVERSEE_RECORD(ref, dir, &bp04, (pfnOversee_t)&SkWinCore::_14cd_2807, &bp0e, 0, 1);
	//^14CD:28CD
	return bp0e.w0;
}

//^14CD:28D2
// SPX: _14cd_28d2 renamed PROCEED_XACT_67
X8 SkWinCore::PROCEED_XACT_67()
{
	//^14CD:28D2
	ENTER(40);
	//^14CD:28D8
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	X8 bp0f = xactrNo;
	X16 bp0c = glbCurrentThinkingCreatureRec->b15_0_1();
	if (_14cd_2662(2) != 0) {
		//^14CD:2902
		if (--bp04->w14 <= 6) {
			//^14CD:2912
			bp04->w14 = RAND02() +9;
			bp04->Command = ccm1F;
		}
		else {
			//^14CD:2929
			bp04->Command = ccm1D;
		}
		//^14CD:2934
	}
	else {
		//^14CD:2937
		ObjectID bp0a = GET_CREATURE_AT(glbCreatureTimerGetX + glbXAxisDelta[bp0c], glbCreatureTimerGetY + glbYAxisDelta[bp0c]);
		if (bp0a != OBJECT_NULL) {
			//^14CD:2967
			bp04->Command = ccm1D;
			ObjectID *bp08 = &GET_ADDRESS_OF_RECORD4(bp0a)->possession;
			i16 si = _14cd_2886(bp08, 16, U8(bp0c), 0, 0, 0);
			i16 bp0e = _14cd_2886(bp08, 7, U8(bp0c), 0, 0, 0);
			if (bp0e != -1) {
				//^14CD:29BD
				si = (si == -1) ? bp0e : (si +bp0e);
			}

			do {
				//^14CD:29CB
				if (si == -1) {
					//^14CD:29D0
					bp04->w16 = 0;
				}
				else {
					//^14CD:29DC
					i16 di = _14cd_2886(bp08, 0x10, (bp0c +2)&3, 1, 1, 0);
					U8 bp28[22];
					i16 bp12;
					X16 bp16 = di = _48ae_0767(di, 0x12, bp28, &bp12, 1);
					bp0e = bp04->w16;
					bp04->w16 = si;
					if (di > 16) {
						//^14CD:2A2A
						di = i16(di - (i32(di) * RAND16(0x10)) / 100);
					}
					//^14CD:2A50
					X16 bp14 = (100 * si) / di;
					if (si != bp0e && U16(si) < U16(di)) {
						//^14CD:2A7C
						if (bp0e != 0xffff && si <= bp0e) {
							//^14CD:2A87
							if (RAND02() == 0 || ((RAND()&7) +0x4c) < bp14) {
								//^14CD:2AA0
								bp04->w12 = Ax3::Frm(0);
								if ((((RAND16(max_value(1, 100 -bp14)) < 5) ? 1 : 0) ^ (!RAND02())) != 0) {
									//^14CD:2ADC
									bp04->Command = ccm20;
								}
								else {
									//^14CD:2AE6
									bp04->Command = ccm1B;
								}
							}
						}
						else {
							//^14CD:2AF0
							bp04->Command = ccm1D;
						}
					}
					//^14CD:2AFB
					else if (U16(si) >= U16(di)) {
						//^14CD:2AFF
						bp04->w14 = min_value(si, bp16);
						bp04->Command = ccm1C;
						bp0f = xactrYes;
						//^14CD:2B1A
						break;
					}
					//^14CD:2B1C
					else if (bp04->w14-- <= 0) {
						if (true
							//^14CD:2B2B
							&& i16(bp14) > 0x4c
							//^14CD:2B31
							&& ((((RAND16(max_value(1, 100 -bp14)) < 5U) ? 1 : 0) ^ (!RAND02())) != 0)
						) {
							//^14CD:2B64
							bp04->Command = ccm20;
							//^14CD:2B6C
							break;
						}
						else {
							//^14CD:2B6E
							bp04->Command = ccm1B;
							//^14CD:2B76
							break;
						}
					}
					else {
						//^14CD:2B78
						if (bp04->w14 > 6) {
							//^14CD:2B82
							bp04->w14 -= 4;
						}
						//^14CD:2B87
						bp04->Command = ccm1D;
					}
					//^14CD:2B8F
					bp0f = xactrAgain;
				}
			} while (false);
		}
	}
	//^14CD:2B93
	return bp0f;
}
//^14CD:2F07
// SPX: _14cd_2f07 renamed PROCEED_XACT_68
X8 SkWinCore::PROCEED_XACT_68()
{
	//^14CD:2F07
	ENTER(34);
	//^14CD:2F0D
	X8 bp0d = xactrNo;
	X16 bp06 = glbCurrentThinkingCreatureRec->b15_0_1();
	if (_14cd_2662((_4976_4ee8 +2)&3) != 0) {
		//^14CD:2F30
		bp0d = xactrNo;
		glbCurrentThinkingCreatureData->Command = ccm1F;
	}
	else {
		//^14CD:2F40
		ObjectID bp0c = GET_CREATURE_AT(glbCreatureTimerGetX + glbXAxisDelta[bp06], glbCreatureTimerGetY +glbYAxisDelta[bp06]);
		if (bp0c != OBJECT_NULL) {
			//^14CD:2F70
			ObjectID *bp04 = &GET_ADDRESS_OF_RECORD4(bp0c)->possession;
			bp06 = (bp06 + _4976_4ee8)&3;
			i16 di = _14cd_2886(bp04, 0x10, (bp06 +2)&3, 1, 1, 0);
			U8 bp22[18];
			i16 bp10;
			di = _48ae_0767(di, 0x12, bp22, &bp10, 1);
			i16 bp08 = _14cd_2886(bp04, 7, (bp06 +2)&3, 0, 0, 0);
			if (bp08 != -1)
				//^14CD:2FEC
				di += bp08;
			else
				//^14CD:2FF1
				bp08 = 0;
			//^14CD:2FF6
			i16 si = _14cd_2886(bp04, 0x10, i8(bp06), 0, 0, 0);
			i16 bp0a = _14cd_2886(bp04, 7, i8(bp06), 0, 0, 0);
			if (si == -1)
				si = 0;
			//^14CD:3034
			if (bp0a != -1)
				si += bp0a;
			//^14CD:303D
			if (U16(glbCurrentThinkingCreatureData->w14 +bp08) > U16(si)) {
				glbCurrentThinkingCreatureData->Command = ccm1B;
			}
			else {
				//^14CD:3053
				if (glbCurrentThinkingCreatureData->w16 != si) {
					//^14CD:305D
					glbCurrentThinkingCreatureData->Command = ccm1C;
					glbCurrentThinkingCreatureData->w16 = si;
				}
				//^14CD:3066
				glbCurrentThinkingCreatureData->w12 = Ax3::Frm(max_value(0, si -di));
				bp0d = xactrYes;
			}
		}
	}
	//^14CD:3080
	return bp0d;
}
//^14CD:2398
// SPX: _14cd_2398 renamed PROCEED_XACT_69
void SkWinCore::PROCEED_XACT_69()
{
	//^14CD:2398
	ENTER(4);
	//^14CD:239D
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	X16 si = glbCurrentThinkingCreatureRec->b15_0_1();
	bp04->w24.SetX((glbCreatureTimerGetX + glbXAxisDelta[si])&31);
	bp04->w24.SetY((glbCreatureTimerGetY + glbYAxisDelta[si])&31);
	bp04->b29 = U8(_4976_4ee8);
	bp04->Command = (bp04->b29 == 1) ? ccm16 : ccm15;
	//^14CD:240B
	return;
}
//^1C9A:078B
void SkWinCore::_1c9a_078b(ObjectID *ref, X16 xx, i8 dir)
{
	//^1C9A:078B
	ENTER(12);
	//^1C9A:0791
	ObjectID bp02 = *ref;
	ObjectID bp04;
	for (ObjectID si = bp02; (si = bp02) != OBJECT_END_MARKER; ) {
		//^1C9A:079D
		bp02 = GET_NEXT_RECORD_LINK(si);
		i16 bp06 = si.DBType();
		if ((bp06 <= dbCreature || bp06 >= dbMissile) && bp06 != dbContainer)
			continue;
		//^1C9A:07C7
		if (dir != -1 && si.Dir() != U8(dir))
			continue;
		//^1C9A:07DE
		X16 bp0c = CREATURE_CAN_HANDLE_IT(si, xx);
		if (bp06 == dbContainer) {
			//^1C9A:07F4
			if (IS_CONTAINER_MONEYBOX(si) != 0 && bp0c == 0)
				continue;
			//^1C9A:0808
			Container *bp0a = GET_ADDRESS_OF_RECORD9(si);
			_1c9a_078b(&bp0a->w2, xx, -1);
			if (bp0c == 0)
				continue;
			//^1C9A:0831
			bp04 = bp0a->GetContainedObject();
			ObjectID di;
			//^1C9A:083B
			while ((di = bp04) != OBJECT_END_MARKER) {
				//^1C9A:083D
				bp04 = GET_NEXT_RECORD_LINK(di);
				CUT_RECORD_FROM(di, &bp0a->w2, -1, 0);
				di.Dir(U8(dir));
				APPEND_RECORD_TO(di, ref, -1, 0);
				//^1C9A:0882
			}
		}
		//^1C9A:088C
		if (bp0c != 0) {
			CUT_RECORD_FROM(si, ref, -1, 0);
			DEALLOC_RECORD(si);
		}
		//^1C9A:08AC
	}
	//^1C9A:08B9
	return;
}

//^14CD:3087
// SPX: _14cd_3087 renamed PROCEED_XACT_71
X8 SkWinCore::PROCEED_XACT_71()
{
	//^14CD:3087
	ENTER(4);
	//^14CD:308C
	ObjectID *bp04 = &glbCurrentThinkingCreatureRec->possession;
	X16 si = _4976_4eea;
	if (si != 0xfffe && (si != 0xffff || ((si = _4976_5154) != 0xffff)) && *bp04 != OBJECT_END_MARKER) {
		//^14CD:30BD
		_1c9a_078b(bp04, si, -1);
	}
	//^14CD:30CF
	if (*bp04 == OBJECT_END_MARKER)
		//^14CD:30D8
		return xactrNo;
	//^14CD:30DC
	si = _4976_4ee8;
	if (si == 0xffff && (si = _4976_5152) == 0xffff)
		//^14CD:30F0
		return xactrYes;
	//^14CD:30F4
	if (CREATURE_CAN_HANDLE_ITEM_IN(si, *bp04, -1) == OBJECT_END_MARKER)
		return xactrNo;
	//^14CD:310D
	_19f0_2165(0x81, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, si);
	//^14CD:3133
	return _4976_4ee5;
}
//^14CD:3139
// SPX: _14cd_3139 renamed PROCEED_XACT_73
X8 SkWinCore::PROCEED_XACT_73()
{
	//^14CD:3139
	ENTER(16);
	//^14CD:313F
	Creature *bp08 = glbCurrentThinkingCreatureRec;
	X16 si = _4976_4eea;
	X16 bp10;
	X16 bp0a;
	X16 bp0c;
	X16 di;
	X8 bp0d;
	sk1bf9 *bp04;
	switch (si) {
		case 0://^3162
		case 1://^3162
		case 2://^3162
		case 16://^3162
		case 17://^3162
		case 18://^3162
			//^14CD:3162
			bp10 = si&16;
			si &= 15;
			bp0a = 1 << _4976_4ee8;
			bp0c = ((bp0a & bp08->w10) == bp0a) ? 1 : 0;
			di = bp08->w10;
			if (si == 0) {
				//^14CD:319B
				bp08->w10 &= ~bp0a;
			}
			//^14CD:31A6
			else if (si == 1) {
				//^14CD:31AB
				bp08->w10 |= bp0a;
			}
			//^14CD:31B5
			if (bp10 == 0 && bp08->w10 != di)
				//^14CD:31C4
				glbCurrentThinkingCreatureData->Command = ccm33;
			//^14CD:31CD
			if (bp0c != 0)
				return xactrYes;
			//^14CD:31D6
			return 0xfd;
		case 3://^31DB
		case 4://^31DB
			//^14CD:31DB
			bp0d = (si == 3) ? 0x13 : 0x14;
			di = bp08->w10;
			bp04 = _4976_514e.pv10;
			if (bp04 == NULL)
				break;
			do {
				//^14CD:3203
				if (bp04->b12 == bp0d) {
					//^14CD:320F
					if (bp04->w4 == 0) {
						//^14CD:3216
						bp08->w10 |= 1 << bp04->b6_0_f();
					}
					//^14CD:3228
					else if (bp04->w4 == 1) {
						//^14CD:3232
						bp08->w10 &= ~(1 << bp04->b6_0_f());
					}
				}
				//^14CD:3244
			} while ((bp04++)->b13 != 0);
			//^14CD:3252
			if (bp08->w10 != di)
				//^14CD:325B
				glbCurrentThinkingCreatureData->Command = ccm33;
			//^14CD:3264
			if (bp08->w10 != di)
				//^14CD:326D
				return xactrYes;
			//^14CD:3272
			return 0xfd;
		case 5://^3278
		case 6://^3278
		case 7://^3278
		case 8://^3278
		case 9://^3278
		case 10://^3278
		case 11://^3278
		case 12://^3278
		case 13://^3278
		case 14://^3278
		case 15://^3278
			break;
	}
	//^14CD:3278
	return xactrNo;
}
//^14CD:32A4
// SPX: _14cd_32a4 renamed PROCEED_XACT_74
i8 SkWinCore::PROCEED_XACT_74()
{
	//^14CD:32A4
	ENTER(6);
	//^14CD:32AA
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	X16 si = glbAIDef->w22_c_f();
	X16 bp06 = (si != 0 && (RAND()&15) < ((glbCurrentThinkingCreatureRec->w10_d_d() != 0) ? (si >> 2) : si)) ? 1 : 0;
	//^14CD:32F5
	if (CREATURE_THINK_381c() == 0) {
		//^14CD:3301
		if (bp04->w24.GetX() == glbCreatureTimerGetX && bp04->w24.GetY() == glbCreatureTimerGetY && bp04->w24.GetMap() == glbCurrentMapIndex)
			//^14CD:3339
			return xactrYes;
		//^14CD:333E
		si = CALC_VECTOR_DIR(glbCreatureTimerGetX, glbCreatureTimerGetY, bp04->w24.GetX(), bp04->w24.GetY());
		if (glbCurrentThinkingCreatureRec->b15_0_1() == si)
			return xactrYes;
		//^14CD:337B
		if (bp06 != 0 && RAND01() != 0) {
			//^14CD:338A
_338a:
			bp04->Command = ccmNeutral;
			//^14CD:3392
			return xactrAgain;
		}
		//^14CD:3396
		_19f0_0559(si);
	}
	else {
		//^14CD:339F
		if (bp06 != 0)
			goto _338a;
		X16 di = 0x80;
		if (glbCurrentThinkingCreatureRec->w10_c_c() != 0)
			di |= 0x20;
		//^14CD:33B8
		CREATURE_GO_THERE(di, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, -1, bp04->b27);
	}
	//^14CD:33DA
	return _4976_4ee5;
}
//^14CD:2162
// SPX: _14cd_2162 renamed PROCEED_XACT_75
X8 SkWinCore::PROCEED_XACT_75()
{
	//^14CD:2162
	ENTER(10);
	//^14CD:2168
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	sk4f04 *bp08 = _14cd_10d2(_4976_514e.pv10, _4976_5150);
	X8 bp09 = _4976_5151;
	X16 si;
	if (bp09 == 8) {
		//^14CD:2199
		si = 2;
	}
	//^14CD:219E
	else if (bp09 == 9) {
		//^14CD:21A4
		si = 3;
	}
	else {
		//^14CD:21A9
		si = 0;
	}
	//^14CD:21AB
	bp04->ItemToThrow = U8(_4976_5152);
	X16 di = glbAIAttacksSpells;
	if ((di & 8) != 0 && (bp08->b5 > 0 || bp08->b6 != 0))
		//^14CD:21D0
		glbAIAttacksSpells &= 0xfff7;
	//^14CD:21D6
	glbAIAttacksSpells &= _4976_5154;
	_19f0_0891(si |0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, bp04->w24.GetX(), bp04->w24.GetY(), 0xffff);
	glbAIAttacksSpells = di;
	//^14CD:2213
	return _4976_4ee5;
}
//^14CD:33E1
// SPX: _14cd_33e1 renamed PROCEED_XACT_77
X8 SkWinCore::PROCEED_XACT_77()
{
	//^14CD:33E1
	ENTER(4);
	//^14CD:33E5
	_4976_4fd8->b18(0);
	sk1bf9 *bp04 = _4976_514e.pv10;
	if (bp04 != NULL) {
		do {
			//^14CD:33FB
			if (bp04->b12 == 0x11 && bp04->w4 != 0xffff) {
				//^14CD:340C
				_14cd_0f3c(0x14, bp04, bp04, 0x11, 0, Ax3::Invalid, (U8)0xffff, 0);
			}
			//^14CD:342B
		} while ((bp04++)->b13 != 0);
		//^14CD:3439
		if (_4976_4fd8->b18() != 0) {
			//^14CD:3440
			ATLASSERT(_4976_4fd8->b18() < 16);
			_4976_4fd8->b19(U8(FIND_WALK_PATH(glbCreatureTimerGetX, glbCreatureTimerGetY, 3, 0, _4976_4fd8->b18(), _4976_4fee, glbCreatureWalkPath)));
			if (_4976_4fd8->b19() != 0xff)
				//^14CD:346C
				return xactrYes;
		}
	}
	//^14CD:3470
	return xactrNo;
}
//^14CD:3474
// SPX: _14cd_3474 renamed PROCEED_XACT_78
X8 SkWinCore::PROCEED_XACT_78()
{
	//^14CD:3474
	ENTER(0);
	//^14CD:3478
	_4976_4ee5 = xactrNo;
	if (glbCurrentMapIndex == glbCreatureMap) {
		//^14CD:3486
		X16 si = CALC_VECTOR_DIR(glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreaturePosX, glbCreaturePosY);
		if ((_0cee_04e5(si, 1, 0, glbCreatureTimerGetX, glbCreatureTimerGetY) >> 5) != 0) {
			//^14CD:34C6
			_19f0_0559(si);
		}
	}
	//^14CD:34CD
	return _4976_4ee5;
}
//^14CD:221A
// SPX: _14cd_221a renamed PROCEED_XACT_79
void SkWinCore::PROCEED_XACT_79()
{
	//^14CD:221A
	ENTER(8);
	//^14CD:221E
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	X16 bp06 = RAND01();
	X16 bp08 = RAND02();
	bp04->ItemToThrow = i8(0x82);
	bp04->Command = (bp06 != 0) ? ccmCastSpell2 : ccmCastSpell1;
	bp04->b27 = U8(bp08);
	bp04->b28 = U8(bp06)&3;
	bp04->b32 = 0;
	//^14CD:226B
	return;
}
//^14CD:34D3
// SPX: _14cd_34d3 renamed PROCEED_XACT_80
X8 SkWinCore::PROCEED_XACT_80()
{
	//^14CD:34D3
	ENTER(2);
	//^14CD:34D9
	X16 di = _4976_4ee8;
	X16 bp02 = (di == 0) ? 0 : 6;
	X16 si = _4976_4eec;
	_4976_4eec |= 0x1800;
	CREATURE_GO_THERE(bp02|0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, -1, (di + glbCurrentThinkingCreatureRec->b15_0_1()) & 3);
	_4976_4eec = si;
	//^14CD:352E
	return _4976_4ee5;
}

//^14CD:3535
// SPX: _14cd_3535 renamed PROCEED_XACT_81
X8 SkWinCore::PROCEED_XACT_81()
{
	//^14CD:3535
	ENTER(4);
	//^14CD:3539
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	_19f0_2813(_4976_5154|0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, bp04->w24.GetX(), bp04->w24.GetY(), -1, _4976_5152);
	return _4976_4ee5;
	//^14CD:3580
}

//^14CD:3582
X16 SkWinCore::EXCHANGE_MONEYBOX(X16 onlyTest, ObjectID rlWallet) 
{
	// return 0 if no exchange is useful
	// return 1 if any exchange is useful

	//^14CD:3582
	ENTER(46);
	//^14CD:3588
	X16 bp06 = 0;
	i16 moneyQuantityPerType[MONEY_ITEM_MAX];
	COUNT_BY_COIN_TYPES(rlWallet, moneyQuantityPerType);
	i16 moneyAmount = 0;
	i16 si = 0;
	for (; si < glbCountMoneyItems; si++) {
		//^14CD:35A5
		moneyAmount += glbMoneyItemsValueTable[si] * moneyQuantityPerType[si];
		//^14CD:35BD
	}
	//^14CD:35C4
	i16 bp2e[MONEY_ITEM_MAX];
	ZERO_MEMORY(bp2e, sizeof(bp2e));
	si = glbCountMoneyItems -1;
	i16 bp02;
	ObjectID bp04;
	for (; si >= 0 && moneyAmount > 0; si--) {
		//^14CD:35EC
		while ((bp02 = glbMoneyItemsValueTable[si]) <= moneyAmount) {
			//^14CD:35DD
			bp2e[si]++;
			moneyAmount -= bp02;
			//^14CD:35EC
		}
		//^14CD:35FB
		bp06 |= (moneyQuantityPerType[si] != bp2e[si]) ? 1 : 0;
		if (bp06 != 0 && onlyTest == 1)
			return 1;
	}
	//^14CD:3633
	if (bp06 == 0 || onlyTest == 1) {
		//^14CD:363F
		return bp06;
	}
	//^14CD:3644
	for (si = 0; si < glbCountMoneyItems; si++) {
		//^14CD:3648
		while ((bp04 = TAKE_COIN_FROM_WALLET(rlWallet, si)) != OBJECT_NULL) {
			//^14CD:3648
			DEALLOC_RECORD(bp04);
			//^14CD:3651
		}
		//^14CD:3665
	}
	//^14CD:366B
	for (si = 0; si < glbCountMoneyItems; si++) {
		//^14CD:366F
		while (bp2e[si]-- != 0) {
			//^14CD:366F
			bp04 = ALLOC_NEW_DBITEM(glbMoneyItemsIDTable[si]);
			//^14CD:3680
			if (bp04 != OBJECT_NULL) {
				//^14CD:3685
				ADD_COIN_TO_WALLET(rlWallet, bp04);
			}
			//^14CD:3692
		}
		//^14CD:36A6
	}
	//^14CD:36AC
	return 1;
}

//^0CEE:2821
X16 SkWinCore::ADD_COIN_TO_WALLET(ObjectID rlMoneyBox, ObjectID rlCoin)
{
	//^0CEE:2821
	ENTER(12);
	//^0CEE:2827
	ObjectID di = rlCoin;
	if (IS_CONTAINER_MONEYBOX(rlMoneyBox) == 0)
		//^0CEE:2836
		return 0;
	if (IS_MISCITEM_CURRENCY(di) == 0)
		return 0;
	//^0CEE:2847
	Miscellaneous_item *bp08 = GET_ADDRESS_OF_RECORDA(di);
	Container *bp0c = GET_ADDRESS_OF_RECORD9(rlMoneyBox);
	ObjectID si = bp0c->GetContainedObject();
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^0CEE:286B
		if (si.DBType() == dbMiscellaneous_item) {
			//^0CEE:2878
			Miscellaneous_item *bp04 = GET_ADDRESS_OF_RECORDA(si);
			if (bp04->ItemType() != bp08->ItemType())
				continue;
			if (bp04->Charge() >= 0x3f)
				continue;
			bp04->Charge(bp04->Charge() +1);
			QUEUE_DEALLOC_RECORD(di); // this causes many assertion prompts!
			break;
		}
		//^0CEE:28C9
		return 0;
		//^0CEE:28CC
	}
	//^0CEE:28D9
	if (si != OBJECT_END_MARKER)
		return 1;
	//^0CEE:28DE
	APPEND_RECORD_TO(di, &bp0c->w2, -1, 0);
	//^0CEE:28FB
	return 1;
}
//^14CD:36B3
// SPX: _14cd_36b3 renamed PROCEED_XACT_82
X8 SkWinCore::PROCEED_XACT_82()
{
	//^14CD:36B3
	ENTER(36);
	//^14CD:36B9
	X8 bp09 = xactrNo;
	ObjectID bp12 = OBJECT_NULL;
	X16 bp0e = glbCurrentThinkingCreatureRec->b15_0_1();
	ObjectID bp0c = GET_CREATURE_AT(glbCreatureTimerGetX + glbXAxisDelta[bp0e], glbCreatureTimerGetY + glbYAxisDelta[bp0e]);
	ObjectID si;
	//^14CD:36F5
	if (bp0c != OBJECT_NULL) {
		//^14CD:3700
		glbCurrentThinkingCreatureData->Command = ccm1D;
		Creature *bp04 = GET_ADDRESS_OF_RECORD4(bp0c);
		//^14CD:3718
		if (_4976_4ee8 == 0) {
			//^14CD:3722
			ObjectID bp12 = CREATURE_CAN_HANDLE_ITEM_IN(0x3e, GET_ADDRESS_OF_RECORD4(bp0c)->GetPossessionObject(), (glbCurrentThinkingCreatureRec->b15_0_1() +2)&3);
			if (bp12 == OBJECT_END_MARKER)
				bp12 = OBJECT_NULL;
			//^14CD:375A
			i16 di = _14cd_2886(&bp04->possession, 0x10, (bp0e +2)&3, 0, 1, 1);
			if ((di != 0 && di == -1) || bp12 == -1) {
				//^14CD:378E
				glbCurrentThinkingCreatureData->w16 = max_value(0, di);
				bp09 = xactrYes;
			}
		}
		else {
			//^14CD:37A7
			i16 *bp08;
			if (_4976_4ee8 == 1) {
				//^14CD:37AE
				bp08 = &glbCurrentThinkingCreatureData->w16;
			}
			else if (_4976_4ee8 == 2) {
				//^14CD:37C1
				bp08 = &glbCurrentThinkingCreatureData->w14;
			}
			else {
				//^14CD:37CD
				bp08 = reinterpret_cast<i16 *>(&glbCurrentThinkingCreatureData->w12);
			}
			//^14CD:37DD
			for (si = glbCurrentThinkingCreatureRec->possession; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
				//^14CD:37E7
				if (IS_CONTAINER_MONEYBOX(si) != 0) {
					//^14CD:37F2
					bp12 = si;
					EXCHANGE_MONEYBOX(0, bp12);
				}
				//^14CD:3800
			}
			//^14CD:380E
			_4976_4ee8 = 0x47;
			if (*bp08 <= 0) {
				//^14CD:381D
				bp09 = PROCEED_XACT_64();
				if (bp09 != xactrAgain)
					//^14CD:382B
					bp09 = xactrYes;
			}
			else {
				//^14CD:3832
				i16 bp10;
				U8 bp24[18];
				_48ae_0767(*bp08, 0x12, bp24, &bp10, 0);
				*bp08 = -1;
				if (bp10 <= 0) {
					//^14CD:385C
					bp09 = xactrYes;
				}
				else {
					//^14CD:3862
					i16 di = bp10 -1;
					do {
						//^14CD:3868
						si = ALLOC_NEW_DBITEM(glbMoneyItemsIDTable[bp24[di]]);
						if (si == OBJECT_NULL)
							break;
						//^14CD:3882
						if (bp12 != OBJECT_NULL) {
							//^14CD:3888
							ADD_COIN_TO_WALLET(bp12, si);
						}
						else {
							//^14CD:3895
							APPEND_RECORD_TO(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
						}
						//^14CD:38AC
					} while (di-- != 0);
					//^14CD:38B3
					PROCEED_XACT_64();
					bp09 = xactrAgain;
				}
			}
		}
	}
	//^14CD:38BB
	return bp09;
}

//^14CD:38C2
// SPX: _14cd_38c2 renamed PROCEED_XACT_83
i8 SkWinCore::PROCEED_XACT_83()
{
	//^14CD:38C2
	ENTER(2);
	//^14CD:38C6
	i8 bp01 = xactrYes;
	if (glbCurrentThinkingCreatureRec->w10_7_7() == 0 && _4976_4ee8 == 0) {
		//^14CD:38DD
		bp01 = xactrNo;
	}
	else {
		//^14CD:38E3
		glbCurrentThinkingCreatureData->Command = BETWEEN_VALUE(0, _4976_4ee8, 2) +0x23;
		//^14CD:38FD
		if (glbCurrentThinkingCreatureRec->w10_7_7() != 0 && _4976_4ee8 == 1) {
			//^14CD:3910
			bp01 = xactrAgain;
		}
	}
	//^14CD:3914
	return bp01;
	//^14CD:3917
}

//^14CD:3919
// SPX: somewhat used to discard consumed or unimportant item?
// SPX: _14cd_3919 renamed PROCEED_XACT_84
X8 SkWinCore::PROCEED_XACT_84()
{
	//^14CD:3919
	ENTER(6);
	//^14CD:391F
	X8 bp05 = xactrNo;
	ObjectID si = glbCurrentThinkingCreatureRec->GetPossessionObject();
	if (si == OBJECT_END_MARKER)
		return bp05;
	//^14CD:3933
	GenericRecord *_bp04 = GET_ADDRESS_OF_RECORD(si);
	X16 di;
	switch (si.DBType()) {
	case dbCloth://^3958
		{
			//^14CD:3958
			Cloth *bp04 = _bp04->castToCloth();
			di = !bp04->Important();
			break;
		}
	case dbWeapon://^396E
		{
			//^14CD:396E
			Weapon *bp04 = _bp04->castToWeapon();
			di = !bp04->Important();
			break;
		}
	case dbMiscellaneous_item://^3970
		{
			//^14CD:3970
			Miscellaneous_item *bp04 = _bp04->castToMisc();
			di = (bp04->Important() != 0 || QUERY_GDAT_FOOD_VALUE_FROM_RECORD(si) != 0) ? 1 : 0;
			break;
		}
	case dbPotion://^3995
		{
			//^14CD:3995
			Potion *bp04 = _bp04->castToPotion();
			di = !bp04->VisiblePower();
			break;
		}
	case dbScroll://^399E
	case dbContainer://^399E
	default:
		{
			//^14CD:399E
			di = 0;
			break;
		}
	}
	//^14CD:39A0
	if (di != 0) {
		//^14CD:39A4
		CUT_RECORD_FROM(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
		DEALLOC_RECORD(si);
		glbCurrentThinkingCreatureData->Command = ccmNeutral;
		bp05 = xactrYes;
	}
	else {
		//^14CD:39D1
		_19f0_2165(0x81, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, 6);
	}
	//^14CD:39F8
	return bp05;
}
//^14CD:3A0B
// SPX: _14cd_3a0b renamed PROCEED_XACT_85
i8 SkWinCore::PROCEED_XACT_85()
{
	//^14CD:3A0B
	ENTER(6);
	//^14CD:3A11
	ObjectID si = GET_TILE_RECORD_LINK(glbCreatureTimerGetX, glbCreatureTimerGetY);
	U16 di = 0; // defaulting to 0
	for (; si != OBJECT_END_MARKER && (di = si.DBType()) <= dbActuator; si = GET_NEXT_RECORD_LINK(si)) {
		//^14CD:3A26
		if (di == dbText) {
			//^14CD:3A2B
			Text *bp04 = GET_ADDRESS_OF_RECORD2(si);
			if (bp04->TextMode() == 1) {
				U16 bp06 = bp04->TextIndex();
				if (bp04->SimpleTextExtUsage() == 1) {
					//^14CD:3A61
					glbCurrentThinkingCreatureData->ItemToThrow = i8(bp06 & 0xff);
					glbCurrentThinkingCreatureData->Command = ccmTransform;
					return xactrYes;
				}
			}
		}
		//^14CD:3A77
	}
	//^14CD:3A94
	_13e4_0360(glbCurrentThinkingCreatureID, glbCreatureTimerGetX, glbCreatureTimerGetY, 0x13, 1);
	glbCurrentThinkingCreatureData->Command = ccm33;
	return xactrNo;
	//^14CD:3ABB
}
//^14CD:3ABF
// SPX: _14cd_3abf renamed PROCEED_XACT_86
X8 SkWinCore::PROCEED_XACT_86() 
{
	//^14CD:3ABF
	ENTER(4);
	//^14CD:3AC3
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	bp04->b32 = _4976_514e.b4();
	bp04->ItemToThrow = _4976_514e.b6();
	bp04->Command = U8(_4976_4ee8) + ccmExplode;
	//^14CD:3AEA
	return xactrYes;
}
//^14CD:3AEE
// SPX: _14cd_3aee renamed PROCEED_XACT_72_87_88
void SkWinCore::PROCEED_XACT_72_87_88()
{
	//^14CD:3AEE
	ENTER(0);
	//^14CD:3AF1
	U8 dl = U8(_4976_4ee8);
	if (dl == U8(ccmInv))
		dl = U8(_4976_5152);
	//^14CD:3AFF
	glbCurrentThinkingCreatureData->Command = dl;
	//^14CD:3B09
	return;
}
//^14CD:3B0B
// SPX: Hit this one in front of Rocky
// SPX: _14cd_3b0b renamed PROCEED_XACT_89
X8 SkWinCore::PROCEED_XACT_89() 
{
	//^14CD:3B0B
	ENTER(0);
	//^14CD:3B0F
	X16 si = _4976_5154;
	//^14CD:3B13
	_19f0_0d10(si |0x80u, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCurrentThinkingCreatureData->w24.X, glbCurrentThinkingCreatureData->w24.Y, -1);
	//^14CD:3B46
	return _4976_4ee5;
	//^14CD:3B49
}
//^14CD:3B4C
// SPX: _14cd_3b4c renamed PROCEED_XACT_90
X8 SkWinCore::PROCEED_XACT_90()
{
	//^14CD:3B4C
	ENTER(2);
	//^14CD:3B50
	X8 bp01;
	return bp01 = ((RAND16(0x64) < _4976_4ee8) ? xactrYes : xactrNo);
}
//^14CD:3B69
// SPX: _14cd_3b69 renamed PROCEED_XACT_91
X8 SkWinCore::PROCEED_XACT_91()
{
	//^14CD:3B69
	ENTER(0);
	//^14CD:3B6C
	return (false
		|| CREATURE_CAN_HANDLE_ITEM_IN(_4976_4ee8, glbCurrentThinkingCreatureRec->GetPossessionObject(), -1) != OBJECT_END_MARKER
		|| CREATURE_CAN_HANDLE_ITEM_IN(_4976_4eea, glbCurrentThinkingCreatureRec->GetPossessionObject(), -1) != OBJECT_END_MARKER
		) ? xactrYes : xactrNo;
}
//^14CD:248D
// SPX: _14cd_248d renamed PROCEED_XACT_70
X8 SkWinCore::PROCEED_XACT_70()
{
	//^14CD:248D
	ENTER(8);
	//^14CD:2493
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	X8 bp05 = xactrNo;
	X16 bp08 = _4976_4ee8;
	if (bp08 == 0xffff)
		bp08 = 0x3f;
	//^14CD:24B4
	bp04->w24.SetX(glbCreatureTimer.b6_0_4());
	bp04->w24.SetY(glbCreatureTimer.b7_0_4());
	bp04->b28 = (glbCurrentThinkingCreatureRec->b15_0_1() +2)&3;
	bp04->ItemToThrow = bp08;
	bp04->w24.SetX(bp04->w24.GetX() + glbXAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()]);
	bp04->w24.SetY(bp04->w24.GetY() + glbYAxisDelta[glbCurrentThinkingCreatureRec->b15_0_1()]);
	ObjectID si = GET_CREATURE_AT(bp04->w24.GetX(), bp04->w24.GetY());
	if (si != OBJECT_NULL) {
		//^14CD:2578
		if (CREATURE_CAN_HANDLE_ITEM_IN(bp08, GET_ADDRESS_OF_RECORD4(si)->possession, bp04->b28) == OBJECT_END_MARKER) {
			bp05 = xactrYes;
		}
		else {
			bp04->Command = ccmTakeMerchandise;
			bp05 = xactrAgain;
		}
	}
	//^14CD:25B1
	return bp05;
}

//^14CD:1FF3
i8 SkWinCore::PROCEED_XACT(i8 xact)
{
	SkD((DLV_CAI, "CAI: S-- a#%03d PROCEED_XACT_%d\n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bitu)xact, (Bitu)xact
		));
	//^14CD:1FF3
	ENTER(2);
	//^14CD:1FF7
	i8 bp01 = -2;
	//printf("XACT = %d\n", xact);
	switch (xact) {
	case 56://^2013
		//^14CD:2013
		bp01 = PROCEED_XACT_56();
		break;
	case 57://^201B
		//^14CD:201B
		PROCEED_XACT_57();
		break;
	case 58://^2023
		//^14CD:2023
		glbCurrentThinkingCreatureData->Command = ccmDestroy;
		break;
	case 76://^202F
		//^14CD:202F
		_4976_4ee8 = 0xffff;
		_4976_4eea = 0;
		bp01 = PROCEED_XACT_59_76();
		break;
	case 59://^203B
		//^14CD:203B
		bp01 = PROCEED_XACT_59_76();
		break;
	case 60://^2043 // still. do nothing
		//^14CD:2043
		glbCurrentThinkingCreatureData->Command = ccmNeutral;
		break;
	case 62://^204F
		//^14CD:204F
		bp01 = PROCEED_XACT_62();
		break;
	case 63://^2057
		//^14CD:2057
		bp01 = PROCEED_XACT_63();
		break;
	case 64://^205F
		//^14CD:205F
		bp01 = PROCEED_XACT_64();
		break;
	case 65://^2067
		//^14CD:2067
		bp01 = PROCEED_XACT_65();
		break;
	case 66://^206F
		//^14CD:206F
		bp01 = PROCEED_XACT_66();
		break;
	case 67://^2077
		//^14CD:2077
		bp01 = PROCEED_XACT_67();
		break;
	case 68://^207F
		//^14CD:207F
		bp01 = PROCEED_XACT_68();
		break;
	case 69://^2087
		//^14CD:2087
		PROCEED_XACT_69();
		break;
	case 70://^208F
		//^14CD:208F
		bp01 = PROCEED_XACT_70();
		break;
	case 71://^2096
		//^14CD:2096
		bp01 = PROCEED_XACT_71();
		break;
	case 73://^209D
		//^14CD:209D
		bp01 = PROCEED_XACT_73();
		break;
	case 74://^20A4
		//^14CD:20A4
		bp01 = PROCEED_XACT_74();
		break;
	case 75://^20AB
		//^14CD:20AB
		bp01 = PROCEED_XACT_75();
		break;
	case 77://^20B2
		//^14CD:20B2
		bp01 = PROCEED_XACT_77();
		break;
	case 78://^20B9
		//^14CD:20B9
		bp01 = PROCEED_XACT_78();
		break;
	case 79://^20C0
		//^14CD:20C0
		PROCEED_XACT_79();
		break;
	case 80://^20C7
		//^14CD:20C7
		bp01 = PROCEED_XACT_80();
		break;
	case 81://^20CE
		//^14CD:20CE
		bp01 = PROCEED_XACT_81();
		break;
	case 82://^20D5
		//^14CD:20D5
		bp01 = PROCEED_XACT_82();
		break;
	case 83://^20DC
		//^14CD:20DC
		bp01 = PROCEED_XACT_83();
		break;
	case 84://^20E3
		//^14CD:20E3
		bp01 = PROCEED_XACT_84();
		break;
	case 85://^20EA
		//^14CD:20EA
		bp01 = PROCEED_XACT_85();
		break;
	case 86://^20F1
		//^14CD:20F1
		bp01 = PROCEED_XACT_86();
		break;
	case 72://^20F8
	case 87://^20F8
	case 88://^20F8
		//^14CD:20F8
		PROCEED_XACT_72_87_88();
		break;
	case 89://^20FF
		//^14CD:20FF
		bp01 = PROCEED_XACT_89();
		break;
	case 90://^2106
		//^14CD:2106
		bp01 = PROCEED_XACT_90();
		break;
	case 91://^210D
		//^14CD:210D
		bp01 = PROCEED_XACT_91();
		break;
	case 61://^2115
		break;
	}
	//^14CD:2115
	SkD((DLV_CAI, "CAI: --S a#%03d r %d   %s \n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bits)bp01, getXActrName((Bits)bp01)
		));

	return bp01;
}
//^14CD:08F5
// SPX: _14cd_08f5 renamed CREATURE_THINK_08F5
X16 SkWinCore::CREATURE_THINK_08F5(i8 xx)
{
	//^14CD:08F5
	ENTER(10);
	//^14CD:08FA
	i8 cl = xx;
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData;	 // bp08
	i8 bp09 = -1;
	X16 si = 0;
	bp09 = xCreatureInfo->x;
	i8 bp0a = xCreatureInfo->y;
	sk3672 *bp04 = _4976_3672[RCJ(56,bp09)];
	cl = (cl == xactrYes)
		? bp04[bp0a].b1()
		: bp04[bp0a].b2();
	if (cl == xactrYes || cl == xactrNo) {
		//^14CD:096F
		xCreatureInfo->x = xactrNeedReset;
		xCreatureInfo->y = 0;
		return si = 1;
	}
	//^14CD:0981
	if (cl <= xactrNext1 && cl >= xactrNext2) {
		//^14CD:098B
		if (cl != xactrRetry) {
			if (cl == xactrNext2) {
				//^14CD:0995
				bp0a += 2;
			}
			//^14CD:099F
			else if (cl == xactrNext1) {
				//^14CD:09A4
				bp0a += +1;
			}
			else {
				//^14CD:09A8
				bp0a += -1;
			}
			//^14CD:09B2
			si = 1;
		}
	}
	else {
		//^14CD:09B7
		si = (bp0a != cl) ? 1 : 0;
		bp0a = cl;
	}
	//^14CD:09CC
	xCreatureInfo->x = bp09;
	xCreatureInfo->y = bp0a;
	//^14CD:09DD
	return si;
}

//^14CD:09E2
// SPX: _14cd_09e2 renamed CREATURE_THINK_09E2
void SkWinCore::CREATURE_THINK_09E2()
{
	//^14CD:09E2
	ENTER(26);
	//^14CD:09E8
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData;	// bp08
	Creature *xCreature = glbCurrentThinkingCreatureRec;	// bp0c
	SELECT_CREATURE_37FC();
	X16 bp14 = _4976_3752[_4976_4efa];
	if ((bp14 & 0x40) != 0) {
		_4976_5163 = 0;
	}
	else if ((bp14 & 0x20) != 0) {
		_4976_5163 = 4;
	}
	else {
		_4976_5163 = 5;
	}
	//^14CD:0A2F
	if (_4976_4efe->pv2 == _4976_1d6c) {
		//^14CD:0A43
	_0a43:
		xCreatureInfo->Command = ccmNeutral;
		return;
	}
	//^14CD:0A4E
	if (_4976_4efe->pv2 == _4976_1d65) {
		i8 bp0e = RAND() & 7;
		if (bp0e > 3) {
			//^14CD:0A76
			goto _0a43;
		}
		//^14CD:0A78
		if (bp0e != 0) {
			//^14CD:0A81
			xCreatureInfo->b27 = xCreature->b15_0_1();
			xCreatureInfo->w24.SetX(glbCreatureTimer.XcoordB() + glbXAxisDelta[xCreature->b15_0_1()]);
			xCreatureInfo->w24.SetY(glbCreatureTimer.YcoordB() + glbYAxisDelta[xCreature->b15_0_1()]);
			U8 bp11 = GET_TILE_VALUE(xCreatureInfo->w24.GetX(), xCreatureInfo->w24.GetY()) >> 5;
			TELE_inf bp1a;
			if (bp11 == 0 || bp11 == 7 || (bp11 == 5 && GET_TELEPORTER_DETAIL(&bp1a, U8(xCreatureInfo->w24.GetX()), U8(xCreatureInfo->w24.GetY())) != 0 && IS_CREATURE_ALLOWED_ON_LEVEL(glbCurrentThinkingCreatureID, bp1a.b4) == 0)) {
				//^14CD:0B4E
				goto _0a43;
			}
			//^14CD:0B51
			xCreatureInfo->Command = ccm02;
			return;
		}
		//^14CD:0B5C
		_19f0_0559(U16(glbGameTick) & 3);
		return;
	}
	//^14CD:0B6C
	_13e4_01a3();
	_4976_520e = ALLOC_MEMORY_RAM(0x100, afDefault, 0x400);
	X16 si = !RAND02();
	i8 bp0d;
	if ((bp14 & 0x40) == 0) {
		//^14CD:0BA0
		if (CREATURE_GO_THERE(_4976_5163, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), -1) == 0) {
			//^14CD:0BCF
			if (false
				|| (_4976_5163 == 5 && _19f0_13aa(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB()) != 0) 
				|| _4976_4f03 == 0
				|| _19f0_0891(0, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), -1, -1, xCreature->b15_0_1()) == 0
				|| RAND16((glbAIDef->GetPoisonResistance() >> 2) +1) <= 1
			) {
				//^14CD:0C3E
				xCreature->w10_d_d(1);
				do {
					//^14CD:0C47
					if ((bp14 & 0x10) != 0) {
						//^14CD:0C4E
						if (((xCreature->w10_3_3() != 0 || si != 0) ? RAND01() : !RAND02()) != 0) {
							//^14CD:0C72
							if (_19f0_13aa(glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB()) != 0) {
								xCreatureInfo->x = xactrNeedReset;
								xCreatureInfo->y = 0;
								xCreatureInfo->Command = ccm55;
								goto _0eee;
							}
						}
					}
					//^14CD:0C9E
					X16 di = 4;
					U8 bp10 = (CREATURE_THINK_381c() > 0) 
						? xCreatureInfo->b27 
						: ((RAND01() != 0) 
							? ((xCreature->b15_0_1() +2) & 3) 
							: RAND02()
						);
					//^14CD:0CD4
					i8 bp0e = (RAND01() != 0) ? 1 : -1;
					for (; di-- != 0; bp10 = (bp10 +bp0e) & 3) {
						//^14CD:0CE8
						if (CREATURE_GO_THERE(((si != 0) ? 0 : _4976_5163)|0x80, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), -1,  -1, bp10) != 0) {
							//^14CD:0D1A
							xCreatureInfo->x = xactrNeedReset;
							xCreatureInfo->y = 0;
							goto _0eee;
						}
						//^14CD:0D2A
					}
					//^14CD:0D3C
				} while ((si++) == 0 && RAND01() != 0);
			}
		}
	}
	//^14CD:0D4F
	xCreatureInfo->Command = ccmInv;
	bp0d = SELECT_CREATURE_3672();
	X8 bp11;
	X8 bp12;
	i16 di;
	sk3672 *bp04;
	if (bp0d == -3) {
		if ((_4976_5162 & 0x80) == 0) {
			//^14CD:0D6F
			xCreatureInfo->Command = ccmNeutral;
		}
		else {
			//^14CD:0D7A
		    if (CREATURE_THINK_08F5(-3) != 0)
				_4976_514e.b1 = 0;
			//^14CD:0D8A
			xCreatureInfo->Command = ccm33;
		}
	}
	else {
		//^14CD:0D95
		i8 bp0e;
		if (bp0d >= 0 && bp0d < MAX3672) {
			//^14CD:0DA1
			SkD((DLV_CAI, "CAI: ( ) a#%03d 3672[xxx] <- %d\n"
				, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), bp0d
				));

			xCreatureInfo->x = bp0d; // new 3672[xxx]
			bp0e = 0;
			xCreatureInfo->y = 0;
		}
		else {
			ATLASSERT(xCreatureInfo->x >= 0);
			//^14CD:0DB6
			bp0d = xCreatureInfo->x;
			bp0e = xCreatureInfo->y;
		}
		//^14CD:0DC7
		bp04 = _4976_3672[RCJ(MAX3672,bp0d)];
		bp11 = bp04[bp0e].b5() & 0x1f;
		bp12 = bp04[bp0e].b6();
		di = 0;
		si = 0;
		do {
			//^14CD:0E0E
			bp0d = xCreatureInfo->x;
			bp0e = xCreatureInfo->y;
			sk3672 *bp04 = _4976_3672[RCJ(56,bp0d)];
			if (si != 0) {
				X8 bp10 = bp04[bp0e].b5() & 0x1f;
				if ((bp10 != bp11 || bp11 == 1) && (bp10 != 0) & (bp11 != 1 || bp10 != 1 || bp04[bp0e].b6() != bp12)) {
					//^14CD:0E85
					xCreatureInfo->Command = ccm33;
					break;
				}
			}
			//^14CD:0E8F
			i8 bp0f = DECIDE_NEXT_XACT();
			bp0d = PROCEED_XACT(bp0f);
			//^14CD:0EA0
			if (bp0d != xactrAgain) {
				si |= CREATURE_THINK_08F5(bp0d);
			}
			//^14CD:0EAC
			if (si != 0)
				_4976_514e.b1 = 0;
			if (di++ > 0x20)
				xCreatureInfo->Command = ccmNeutral;
			//^14CD:0EC5
			if (xCreatureInfo->Command == i8(ccmInv) && bp0d != xactrAgain && xCreatureInfo->x == xactrNeedReset)
				xCreatureInfo->Command = ccmNeutral;
			//^14CD:0EE1
		} while (xCreatureInfo->Command == i8(ccmInv));
	}
	//^14CD:0EEE
_0eee:
	_4976_520e = NULL;
	DEALLOC_UPPER_MEMORY(0x100);
	//^14CD:0F06
	return;
}
//^13E4:01A3
void SkWinCore::_13e4_01a3()
{
	//^13E4:01A3
	ENTER(14);
	//^13E4:01A9
	if (_4976_5161 != 0)
		return;
	//^13E4:01B3
	_4976_5161 = 1;
	AIDefinition *bp04 = glbAIDef;
	Creature *bp08 = glbCurrentThinkingCreatureRec;
	if (_4976_4efa == 0xffff) {
		//^13E4:01D9
		_4976_4efa = QUERY_GDAT_CREATURE_WORD_VALUE(bp08->CreatureType(), 1);
	}
	//^13E4:01ED
	_4976_4eec = bp04->w10;
	glbAIAttacksSpells = bp04->AttacksSpells;
	_4976_4ef0 = bp04->w16;
	_4976_4ef2 = bp04->w12;
	_4976_4ef4 = bp04->w18;
	if (_1c9a_08bd(bp08) != 0)
		_4976_4eec &= 0x7fff;
	//^13E4:022A
	_4976_4f02 = 1;
	ZERO_MEMORY(_4976_5164, sizeof(_4976_5164));
	_4976_520e = NULL;
	_4976_520c = 4;
	_4976_5162 = 0;
	_4976_4ef8 = QUERY_GDAT_CREATURE_WORD_VALUE(bp08->CreatureType(), 7);
	i16 si = (i8)((U8)glbGameTick - glbCurrentThinkingCreatureData->b4);
	if (si < 0)
		si += 0x100;
	//^13E4:0281
    X16 di = (15 -bp04->w22_0_3()) << 1;
	//^13E4:0294
	_4976_4f03 = (RAND16(di +1) + (((0x0147 | 0x0CD5) != 0) ? (di >> 2) : 0) <= (U16)si) ? 1 : 0;
	U16 bp0e;
	//^13E4:02C1
	if (_3e74_5673(glbCurrentThinkingCreatureID.DBIndex()|0x20000000, &bp0e, 0) == 0) {
		//^13E4:02E3
		ZERO_MEMORY(&_4976_514e, sizeof(sk514e));
		_4976_5151 = 0xff;
		_4976_5156 = Ax3::Invalid;
	}
	else {
		//^13E4:0300
		sk514e *bp0c = reinterpret_cast<sk514e *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp0e));
		COPY_MEMORY(bp0c, &_4976_514e, sizeof(sk514e));
	}
	//^13E4:0325
	return;
}
//^3A15:2CA8
void SkWinCore::ADVANCE_TILES_TIME(X16 xx, X16 yy)
{
	// call this if you modify tile's type.
	// c.g. convert floor to pit-fall. then it allows you to fall down if you are at the pit-fall.

	//^3A15:2CA8
	ENTER(12);
	//^3A15:2CAE
	if (glbCurrentMapIndex == glbMap_4c28 && xx == glbSomePosX_4c2e && yy == glbSomePosY_4c30) {
		//^3A15:2CC9
		MOVE_RECORD_TO(OBJECT_NULL, xx, yy, xx, yy);
	}
	//^3A15:2CDF
	ObjectID si = GET_CREATURE_AT(xx, yy);
	if (si != OBJECT_NULL) {
		MOVE_RECORD_TO(si, xx, yy, xx, yy);
	}
	//^3A15:2D08
	si = GET_WALL_TILE_ANYITEM_RECORD(xx, yy);
	ObjectID bp0a = si;
	X16 bp0c = 0;
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^3A15:2D21
		if (si.DBType() <= dbCreature)
			continue;
		bp0c++;
		//^3A15:2D31
	}
	//^3A15:2D3F
	for (; (si = bp0a) != OBJECT_END_MARKER && bp0c != 0; ) {
		//^3A15:2D42
		bp0a = GET_NEXT_RECORD_LINK(si);
		U16 di = si.DBType();
		if (di <= dbCreature)
			continue;
		//^3A15:2D5E
		bp0c--;
		MOVE_RECORD_TO(si, xx, yy, xx, yy);
		if (di == dbMissile) {
			//^3A15:2D7E
			Missile *bp08 = GET_ADDRESS_OF_RECORDE(si);
			Timer *bp04 = &glbTimersTable[bp08->TimerIndex()];
			bp04->w8_0_4(_4976_5826);
			bp04->w8_5_9(_4976_5828);
			bp04->w8_a_b(_4976_581e);
			bp04->id6(ObjectID(si, _4976_5820));
			bp04->SetMap(_4976_581c);
			continue;
		}
		//^3A15:2E21
		if (di == dbCloud) {
			//^3A15:2E26
			Timer *bp04 = glbTimersTable;

			// SPX: I had the case of infinite loop here because of non incrementation of di (nor bp04?)!!
			// the whole original block is commented then rewritten after
			/*
			for (di = 0; di < glbTimersActiveCount; ) {
				//^3A15:2E37
				if (bp04->TimerType() != ttyCloud || bp04->w8 != si)
					continue;
				bp04->XcoordB(U8(_4976_5826));
				bp04->YcoordB(U8(_4976_5828));
				bp04->id8(ObjectID(si, _4976_5820));
				bp04->SetMap(_4976_581c);
				//^3A15:2E95
			}*/
			// SPX: new block with supposition
			for (di = 0; di < glbTimersActiveCount; di++, bp04++) {
				//^3A15:2E37
				if (bp04->TimerType() != ttyCloud || bp04->w8 != si)
					continue;
				bp04->XcoordB(U8(_4976_5826));
				bp04->YcoordB(U8(_4976_5828));
				bp04->id8(ObjectID(si, _4976_5820));
				bp04->SetMap(_4976_581c);
				//^3A15:2E95
			}
			// SPX: end of new block
		}
		//^3A15:2EA0
	}
	//^3A15:2EB1
	return;
}
//^1887:000C
X16 SkWinCore::OPERATE_PIT_TELE_TILE(X16 xx, X16 yy, X16 ww)
{
	// this is for invisible walker? at the crypt and keep

	// ww: 0=activate, 1=deactivate, 2=toggle

	//^1887:000C
	ENTER(8);
	//^1887:0012
	X16 di = ww;
	X16 si = 0;
	U8 *bp04 = &glbCurrentTileMap[xx][yy];
	if ((*bp04 >> 5) == ttPit) {
		// pit bit3: 0=Closed, 1=Open

		//^1887:0042
		if ((*bp04 & 8) != 0)
			si = 1;
		//^1887:004B
		if (di == 2) {
			di = (si != 0) ? 1 : 0;
		}
		//^1887:005E
		if (di == 0) {
			//^1887:0062
_0062:
			si = !si;
			*bp04 |= 8; // open pit (you can fall down)
			ADVANCE_TILES_TIME(xx, yy);
		}
		else {
			//^1887:0081
			*bp04 &= 0xf7; // close pit (you cannot fall off)
		}
	}
	//^1887:008E
	else if ((*bp04 >> 5) == ttTeleporter) {
		// teleporter bit3: 0=closed, 1=open

		//^1887:009D
		Teleporter *bp08 = GET_ADDRESS_OF_TILE_RECORD(U8(xx), U8(yy))->castToTeleporter();
		if (bp08->b4_1_2() != 3) {
			//^1887:00C1
			if ((*bp04 & 8) != 0)
				si = 1;
			//^1887:00CD
			if (di == 2) {
				di = (si != 0) ? 1 : 0;
			}
			//^1887:00E0
			if (di == 0)
				goto _0062; // open teleporter (you can warp)
			//^1887:00E7
			*bp04 &= 0xf7; // close teleporter (you cannot warp)
		}
	}
	//^1887:00F2
	return si;
}

//^1887:00F8
U16 SkWinCore::CREATURE_WALK_NOW()
{
	// return 0 if walk is possible or have done
	// return 1 if keep to stay

	//^1887:00F8
	ENTER(4);
	//^1887:00FD
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	if (glbAIDef->PushWhenMoving() != 0) {
		//^1887:0115
		bp04->Command = ccmPushBack;
		bp04->b28 = 4;
		CREATURE_ATTACKS_PARTY();
	}
	//^1887:0127
	if (CREATURE_GO_THERE(bp04->b32|0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTempTargetX, glbCreatureTempTargetY, bp04->b27) != 0) {
		//^1887:015C
		//SPX: is b9 a special for pit/tele ghost?
		//X16 si = glbAIDef->b9 & 0x40;
		X16 si = glbAIDef->CanActivatePitTeleport();
		if (si != 0) {
			//^1887:016E
			OPERATE_PIT_TELE_TILE(glbCreatureTimerGetX, glbCreatureTimerGetY, 1);
		}
		//^1887:0183
		if (MOVE_RECORD_TO(glbCurrentThinkingCreatureID, glbCreatureTimerGetX, glbCreatureTimerGetY, bp04->w24.GetX(), bp04->w24.GetY()) != 0) {
			_4976_4ee6 = 1;
			return 0;
		}
		//^1887:01BC
		glbCreatureTimer.XcoordB((U8)_4976_5826);
		glbCreatureTimer.YcoordB((U8)_4976_5828);
		glbSomeMap_4976_4ee7 = (U8)_4976_581c;
		_1c9a_0648(glbSomeMap_4976_4ee7);
		if (si != 0) {
			//^1887:01DB
			OPERATE_PIT_TELE_TILE(glbCreatureTimerGetX, glbCreatureTimerGetY, 0);
		}
		//^1887:01F0
		if (_4976_514e.b1 > 0)
			//^1887:01F7
			_4976_514e.b1--;
		//^1887:01FB
		return 0;
	}
	//^1887:01FF
	return 1;
}
//^1887:0205
X16 SkWinCore::CREATURE_CCM03()
{
	//^1887:0205
	ENTER(0);
	//^1887:0209
	X16 si;
	switch (glbCurrentThinkingCreatureData->b31) {
		case 0: //^_021d
			//^1887:021D
			CREATURE_CCM06();
			si = 0;
			break;
		case 1: //^_0226
			//^1887:0226
			si = CREATURE_WALK_NOW();
	}
	//^1887:022C
	glbCurrentThinkingCreatureData->b31++;
	//^1887:0234
	return si;
}
//^1887:0239
// SPX: Creature jumps
X16 SkWinCore::CREATURE_JUMPS()
{
	//^1887:0239
	ENTER(6);
	//^1887:023E
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	X16 bp06;
	X16 si;
	switch (bp04->b31) {
		case 0: //^_0267
			//^1887:0267
			bp04->b31 = 1;
			bp06 = _4976_514e.b1;
			si = CREATURE_WALK_NOW();
			_4976_514e.b1 = U8(bp06);
			bp04->w24.SetX(bp04->w24.GetX() + glbXAxisDelta[bp04->b27]);
			bp04->w24.SetY(bp04->w24.GetY() + glbYAxisDelta[bp04->b27]);
			break;
		case 1: //^_02d9
			//^1887:02D9
			si = CREATURE_WALK_NOW();
			if (si != 0) {
				bp04->b31 = 2;
				break;
			}
			bp04->b31 = 3;
			break;
		case 2: //^_02f7
			//^1887:02F7
			si = 0;
			bp04->b31 = 3;
			// SPX: creature has to be moved on another tile?
			if (MOVE_RECORD_TO(glbCurrentThinkingCreatureID, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTimerGetX, glbCreatureTimerGetY) != 0)
				_4976_4ee6 = 1;
			//^1887:032E
			glbCreatureTimer.XcoordB(U8(_4976_5826));
			glbCreatureTimer.YcoordB(U8(_4976_5828));
			glbSomeMap_4976_4ee7 = U8(_4976_581c);
			_1c9a_0648(glbSomeMap_4976_4ee7);
			break;
	}
	//^1887:0349
	return si;
}
//^1887:05AA
void SkWinCore::CREATURE_CCM06()
{
	//^1887:05AA
	ENTER(0);
	//^1887:05AE
	i16 si = glbCurrentThinkingCreatureData->b29;
	if (((glbCurrentThinkingCreatureRec->b15_0_1() -si)&3) == 2) {
		si = ((RAND()&2) +si +1)&3;
	}
	//^1887:05DE
	glbCurrentThinkingCreatureRec->b15_0_1(si&3);
	//^1887:05F0
	return;
}
//^075F:1C74
i16 SkWinCore::CREATURE_ATTACKS_PLAYER(Creature *ref, U16 player)
{
	//^075F:1C74
	ENTER(16);
	//^075F:1C7A
	Champion *champion;	//*bp04
    if (player >= glbChampionsCount || (champion = &glbChampionSquad[player])->curHP() == 0)
		return 0;
	//^075F:1CA3
	i16 si = 0;
	X16 bp0e = dunMapLocalHeader->Difficulty() << 1;
	AIDefinition *AIdef = QUERY_CREATURE_AI_SPEC_FROM_TYPE(ref->CreatureType());	//*bp08
	X16 bp10 = AIdef->b28;
	ADJUST_SKILLS(player, SKILL_FIGHTER_PARRY, AIdef->w22_8_b());	// 7
	X16 di;
	if (glbGlobalSpellEffects.Invisibility != 0 && AIdef->w0_a_a() == 0) {
		//^075F:1D01
		di = 0x10;
	}
	else if (AIdef->w0_b_b() != 0) {
		//^075F:1D10
		di = 0;
	}
	else {
		//^075F:1D14
		di = glbLightLevel << 1;
	}
	//^075F:1D1B
	X16 bp0c = AIdef->Defense;
	if (bp10 == 9) {
		//^075F:1D2D
		bp0c = min_value(255, bp0c << 1);
	}
	else if (bp10 == 8) {
		//^075F:1D45
		bp0c = 255;
	}
	//^075F:1D4A
	if (false
		|| glbIsPlayerSleeping != 0
		|| bp0c == 255
		|| ((USE_DEXTERITY_ATTRIBUTE(player) < U16((RAND()&0x1f) +bp0c +bp0e +di -0x10) || RAND02() == 0) && USE_LUCK_ATTRIBUTE(champion, 0x3c) == 0)
	) {
		//^075F:1D9D
		di = RAND();
		U16 bp0a;
		if ((di & 0x70) != 0 && (bp0c = AIdef->w26) != 0) {
			//^075F:1DB7
			di &= 15;
			if (di == 0)
				di = 1;
			//^075F:1DC4
			for (bp0a = 0; bp0a < 3 && (bp0c&15) < di; ) {
				//^075F:1DCB
				bp0a++;
				bp0c >>= 4;
				//^075F:1DD2
			}
			//^075F:1DE2
			bp0a = _4976_00e3[RCJ(5, 1 +bp0a)];
		}
		else {
			//^075F:1DED
			bp0a = (di&1) +1;
		}
		//^075F:1DF6
		si = AIdef->AttackStrength +min_value(AIdef->AttackStrength, (RAND()&15) +bp0e);
		if (bp10 != 8) {
			//^075F:1E26
			si = si -(QUERY_PLAYER_SKILL_LV(player, SKILL_FIGHTER_PARRY, 1) << 1);
			if (si <= 1) {
				//^075F:1E44
				if (RAND01() != 0) {
					//^075F:1E4D
					si = 0;
					goto _1f21;
				}
				else {
					//^075F:1E52
					si = RAND02() +2;
				}
			}
		}
		//^075F:1E5B
		si >>= 1;
		si = RAND16(si) +RAND02() +si;
		si = si +RAND16(si);
		si >>= 2;
		si = RAND02() +si +1;
		if (RAND01() != 0) {
			//^075F:1E94
			si = si -(RAND16((si >> 1) +1) -1);
		}
		//^075F:1EA7
		si = WOUND_PLAYER(player, si, bp0a, bp10);
		if (si != 0) {
			//^075F:1EBF
			// SPX: Champion "oof" sound when hit
			// => it would be possible to have several oof sounds using a random
			QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, champion->HeroType(), SOUND_CHAMPION_GETHIT, 0xfe, glbPlayerPosX, glbPlayerPosY, 2, 0x69, 0xc8);
			di = AIdef->PoisonDamage;
			if (di != 0 && RAND01() != 0 && (di = _2c1d_0f2a(champion, abVit, di)) > 0) {
				//^075F:1F16
				PROCESS_POISON(player, di);
			}

#if DM2_EXTENDED_MODE == 1
			{
				U16 iPlagueDamage = 0;
				// Get plague damage from creature if any
				//iPlagueDamage = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_CREATURES, ref->CreatureType(), dtWordValueExt, GDAT_AI_PLAGUE_DAMAGE);
				iPlagueDamage = QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_CREATURES, ref->CreatureType(), dtWordValue, GDAT_AI_PLAGUE_DAMAGE);
				if (iPlagueDamage > 0 && iPlagueDamage < 255)
					PROCESS_PLAGUE(player, iPlagueDamage);
				
			}

#endif
		}
	}
	//^075F:1F21
_1f21:
	// SPX: damage(?) is done to champions so that they are forced to wake
	if (glbIsPlayerSleeping != 0)
		RESUME_FROM_WAKE();
	//^075F:1F2D
	return si;
}
//^1C9A:166F
// SPX: _1c9a_166f renamed CREATURE_ATTACKS_CREATURE
i16 SkWinCore::CREATURE_ATTACKS_CREATURE(X16 xx, X16 yy)
{
	//^1C9A:166F
	ENTER(14);
	//^1C9A:1675
	i16 si = 0;
	ObjectID di = GET_CREATURE_AT(xx, yy);
	if (di == OBJECT_NULL)
		return -1;
	//^1C9A:1690
	Creature *bp04 = GET_ADDRESS_OF_RECORD4(di);
	AIDefinition *bp0c = glbAIDef;
	AIDefinition *bp08 = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->CreatureType());
	//SPX: creature/object is undestructible, no attack can work
	if (bp08->Defense == 0xff)
		return 0;
	//^1C9A:16CB
	if (i16((RAND()&0x1f) +bp0c->Defense) < i16((RAND()&0x1f) +bp08->Defense) && RAND02() != 0)
		return si;
	//^1C9A:1703
	X16 bp0e = ((RAND()&0x1f) +bp08->ArmorClass) >> 3;
	si = bp0c->AttackStrength +min_value(bp0c->AttackStrength, RAND()&15) -bp0e;
	if (si <= 1) {
		//^1C9A:174D
		if (RAND01() != 0)
			return 0;
		//^1C9A:175A
		si = RAND02() +2;
	}
	//^1C9A:1763
	si = RAND16(si) +RAND02();
	si = si +RAND16(si);
	si >>= 2;
	si = RAND02() +si +1;
	if (RAND01() != 0) {
		//^1C9A:179A
		si = si -RAND16((si >> 2)+1);
	}
	//^1C9A:17AD
	ATTACK_CREATURE(di, xx, yy, 2, 0x3c, si);
	//^1C9A:17C1
	return si;
}
//^1887:05F3
X16 SkWinCore::CREATURE_ATTACKS_PARTY()
{
	//^1887:05F3
	ENTER(38);
	//^1887:05F9
	CreatureInfoData *bp08 = glbCurrentThinkingCreatureData;
	AIDefinition *bp0c = glbAIDef;
	X16 bp10 = glbCreatureTempTargetX;
	X16 bp12 = glbCreatureTempTargetY;
	X16 bp14 = glbCurrentThinkingCreatureRec->b15_0_1();
	if (bp08->b32 == 6) {
		//^1887:0637
		bp14 += 2;
		bp14 &= 3;
	}
	//^1887:0640
	X16 bp1e = (glbCreatureTimerGetX == bp10 && glbCreatureTimerGetY == bp12) ? 1 : 0;
	if (bp1e == 0) {
		//^1887:0664
		if (ABS16(glbCreatureTimerGetX -bp10) +ABS16(glbCreatureTimerGetY -bp12) > 1)
			return 1;
		//^1887:068E
		if (CALC_VECTOR_DIR(glbCreatureTimerGetX, glbCreatureTimerGetY, bp10, bp12) != bp14 && bp0c->w0_2_2() == 0)
			return 1;
	}
	//^1887:06BA
	if (glbCurrentMapIndex == glbCreatureMap && bp10 == glbCreaturePosX && bp12 == glbCreaturePosY) {
		//^1887:06DE
		_4976_0090 = glbGameTick;
		X16 bp22 = 0;
		X16 bp20 = bp0c->w0_4_4();
		i16 di = 0;
		i16 bp1c = 0;
		i8 bp26[4];
		for (; bp1c < glbChampionsCount; bp1c++) {
			//^1887:0706
			if (glbChampionSquad[bp1c].curHP() != 0) {
				bp26[di++] = U8(bp1c);
			}
			//^1887:071E
		}
		//^1887:072A
		if (di == 0)
			return 1;
		//^1887:0731
		X16 bp18;
		if (bp0c->w0_3_3() != 0) {
			bp18 = (bp20 != 0) ? (RAND16(di) +1) : glbChampionsCount;
		}
		else {
			//^1887:0756
			bp18 = (bp0c->b9_5_5() != 0) ? 2 : 1;
		}
		i16 si;
		//^1887:076C
		if (bp08->b28 == 4) {
			//^1887:0776
			si = _2c1d_028c(glbCreatureTimerGetX, glbCreatureTimerGetY, 0xff);
			if (si != -1) {
				//^1887:0794
				bp08->b28 = glbChampionSquad[si].playerPos();
			}
		}
		//^1887:07A6
		X16 bp16 = bp08->b28;
		bp18 = min_value(bp18, glbChampionsCount);
		//^1887:07C3
		// SPX: bp18 is either
		for (; bp18-- != 0; ) {
			//^1887:07C6
			if (bp20 != 0) {
				//^1887:07CC
				si = RAND16(di);
				if (bp26[si] < 0) {
					for (bp1c = 0; bp1c < di; bp1c++) {
						//^1887:07E2
						if (++si >= di)
							si = 0;
						if (bp26[si] >= 0)
							break;
						//^1887:07F1
					}
				}
				//^1887:07F9
				bp1c = si;
				si = bp26[bp1c];
				bp26[bp1c] = -1;
			}
			else {
				//^1887:0819
				si = GET_PLAYER_AT_POSITION(bp16);
				X16 bp1a = CALC_VECTOR_DIR(bp10, bp12, glbCreatureTimerGetX, glbCreatureTimerGetY);
				(((bp16 +bp1a) & 1) != 0) ? --bp16 : ++bp16;
				bp16 &= 3;
				if (si == -1) {
					//^1887:085E
					si = _2c1d_028c(glbCreatureTimerGetX, glbCreatureTimerGetY, 0xff);
				}
				//^1887:0877
				if (si == -1)
					continue;
			}
			//^1887:087C
			bp22 = 1;
			i16 bp0e = CREATURE_ATTACKS_PLAYER(glbCurrentThinkingCreatureRec, si) +1;
			Champion *champion = &glbChampionSquad[si];
			if (champion->herob41 < bp0e) {
				//^1887:08B4
				champion->herob41 = U8(bp0e);
				champion->direction = (CALC_VECTOR_DIR(glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreaturePosX, glbCreaturePosY) +2)&3;
			}
			//^1887:08E2
		}
		//^1887:08EF
		if (bp22 == 0)
			return 1;
	}
	else {
		//^1887:08F8
		i16 bp0e;
		if ((GET_TILE_VALUE(bp10, bp12) >> 5) == ttDoor) {
			//^1887:090E
			bp0e = RAND16(bp0c->AttackStrength + (bp0c->AttackStrength >> 1));
			if (ATTACK_DOOR(bp10, bp12, bp0e, 0, 0) != 0)
				return 1;
		}
		//^1887:0946
		if (bp1e != 0)
			return 1;
		bp0e = CREATURE_ATTACKS_CREATURE(bp10, bp12);
		if (bp0e < 0)
			return 1;
	}
	//^1887:0960
	if (bp08->Command == ccmPushBack) {
		//^1887:096A
		if ((GET_CREATURE_WEIGHT(glbCurrentThinkingCreatureID) > 100 && (RAND() & 15) != 0) || RAND02() != 0) {
			//^1887:098C
			_12b4_0d75(bp10, bp12, bp14, 0xfe);
		}
	}
	//^1887:09A0
	return 0;
}
//^1887:09AB
// CREATURE_ccmCastSpell1
X16 SkWinCore::CREATURE_CAST_SPELL()
{
	//^1887:09AB
	ENTER(12);
	//^1887:09AF
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	AIDefinition *AIdef = glbAIDef;	//*bp08
	if (bp04->b32 <= 1) {
		_4976_0090 = glbGameTick;
	}
	//^1887:09E1
	if (glbCurrentThinkingCreatureRec->b15_0_1() == bp04->b27 || AIdef->w0_2_2() != 0) {
		//^1887:0A07
		//i16 bp0a = (AIdef->AttackStrength >> 2) +1;
		i16 bp0a = (AIdef->GetShootStrength()) +1;
		bp0a = bp0a +RAND16(bp0a);
		bp0a = bp0a +RAND16(bp0a);
		switch (bp04->ItemToThrow) {
			case -121://^0A52
			case -119://^0A52
			case -118://^0A52
				//^1887:0A52
				bp0a <<= 3;
				break;
			case -122://^0A58
				//^1887:0A58
				bp0a <<= 2;
				break;
			case -120://^0A5C
				break;
		}
		//^1887:0A5C
		bp0a = BETWEEN_VALUE(4, bp0a, 255);
		X16 bp0c;
		if (bp0a <= 8) {
			//^1887:0A75
			bp0c = 1;
		}
		else if (bp0a <= 0x10) {
			//^1887:0A82
			bp0c = 2;
		}
		else if (bp0a <= 0x20) {
			//^1887:0A8F
			bp0c = RAND01() +3;
		}
		else {
			//^1887:0A99
			bp0c = RAND02() +7;
		}
		//^1887:0AA4
		SHOOT_ITEM(ObjectID::Raw(bp04->ItemToThrow), glbCreatureTimerGetX, glbCreatureTimerGetY, bp04->b28, bp04->b27, bp0a, AIdef->Defense, bp0c);

		SkD((DLV_TWEET, "Tweet: %s (a#%3d, x:%d, y:%d, map:%d) has thrown %s by cast! \n"
			, static_cast<LPCSTR>(getRecordNameOf(glbCurrentThinkingCreatureID))
			, glbCurrentThinkingCreatureID.DBIndex()
			, glbPlayerPosX
			, glbPlayerPosY
			, glbCurrentMapIndex
			, static_cast<LPCSTR>(getRecordNameOf(ObjectID::Raw(bp04->ItemToThrow)))
			));

		if (AIdef->b9_4_4() != 0 && WOUND_CREATURE((bp0a >> 1) +RAND01()) != 0) {
			//^1887:0AFF
			return _4976_4ee6 = 1;
		}
		//^1887:0B08
		return 0;
	}
	//^1887:0B0C
	return 1;
}

//^0CEE:2CD2
U16 SkWinCore::QUERY_ITEM_MONEY_VALUE(ObjectID xx)
{
	//^0CEE:2CD2
	ENTER(4);
	//^0CEE:2CD6
	i32 bp04 = QUERY_ITEM_VALUE(xx, 2);
	return (bp04 <= MONEY_MAX_VALUE) ? (U16)bp04 : MONEY_MAX_VALUE;	// 65535
	//^0CEE:2CFD
}

//^1887:0B1B
// SPX: CREATURE_CCM0A
X16 SkWinCore::CREATURE_STEAL_FROM_CHAMPION()
{
	//^1887:0B1B
	ENTER(10);
	//^1887:0B21
	i16 bp08;

	if (false
		|| glbCurrentMapIndex != glbCreatureMap 
		|| glbCreatureTempTargetX != glbCreaturePosX 
		|| glbCreatureTempTargetY != glbCreaturePosY
		|| (bp08 = GET_PLAYER_AT_POSITION(glbCurrentThinkingCreatureData->b28)) == -1
	) {
		//^1887:0B55
		return 1;
	}
	//^1887:0B5B
	Champion *champion = &glbChampionSquad[bp08];
	//^1887:0B6C
	i16 di = 0; // defaulting to 0
	if (true
		&& USE_LUCK_ATTRIBUTE(champion, 100 - USE_DEXTERITY_ATTRIBUTE(bp08)) != 0
		&& (di = i16(RAND())) >= 0
	) {
		//^1887:0B98
		//^1887:0C6F
		return 0;
	}
	//^1887:0B9B
	X16 bp06 = 0;
	ObjectID si = champion->Possess(0);
	ObjectID bp0a = champion->Possess(1);
	if ((((di & 3) != 0) ? ((QUERY_ITEM_MONEY_VALUE(si) < QUERY_ITEM_MONEY_VALUE(bp0a)) ? 1 : 0) : (di & 4)) != 0) {
		//^1887:0BDE
		bp06 = 1;
		si = bp0a;
	}
	//^1887:0BE6
	if (si != OBJECT_NULL) {
		//^1887:0BEE
		if (CREATURE_CAN_HANDLE_IT(si, glbCurrentThinkingCreatureData->ItemToThrow) == 0) {
			//^1887:0C04
			si = REMOVE_POSSESSION(bp08, bp06);
			APPEND_RECORD_TO(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);

			SkD((DLV_CCM,"CCM 0x0A: creature %s stole item %s from champion %d!\n"
			, static_cast<LPCSTR>(getRecordNameOf(glbCurrentThinkingCreatureID))
			, static_cast<LPCSTR>(getRecordNameOf(si))
			, bp08
			));

			//^1887:0C2A
			if (glbIsPlayerSleeping != 0) {
				//^1887:0C31
				glbIsPlayerSleeping = 0;
				di = (((RAND() & 15) + QUERY_PLAYER_SKILL_LV(bp08, 1, 1)) > 7) ? 1 : 0;
				glbIsPlayerSleeping = 1;
				if (di != 0) {
					//^1887:0C6A
					RESUME_FROM_WAKE();
				}
			}
		}
	}
	//^1887:0C6F
	return 0;
	//^1887:0C71
}
//^1887:0C75
X16 SkWinCore::CREATURE_CCM0B()
{
	//^1887:0C75
	ENTER(0);
	//^1887:0C78
	if (true
		&& _19f0_0d10(glbCurrentThinkingCreatureData->b32 | 0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTempTargetX, glbCreatureTempTargetY, glbCurrentThinkingCreatureRec->b15_0_1()) != 0
		&& glbCurrentThinkingCreatureData->Command == ccm0B
	) {
		//^1887:0CBC
		// SPX: Invoke msg X, Y, DIR, ActionType, TICK
		INVOKE_MESSAGE(glbCreatureTempTargetX, glbCreatureTempTargetY, 0, 2, glbGameTick);
		return 0;
	}
	//^1887:0CDC
	return 1;
}
//^1887:0CE1
X16 SkWinCore::CREATURE_CCM0C()
{
	//^1887:0CE1
	ENTER(2);
	//^1887:0CE6
	X16 si = 0;
	X8 bp01;
	switch (glbCurrentThinkingCreatureData->b31) {
		case 0: //^_0cfc
			//^1887:0CFC
			bp01 = glbCurrentThinkingCreatureRec->b15_0_1();
			CREATURE_CCM06();
			glbCurrentThinkingCreatureData->b29 = bp01;
			break;
		case 1: //^_0d1b
			//^1887:0D1B
			CREATURE_CCM06();
			si = CREATURE_TAKES_ITEM();
			break;
	}
	//^1887:0D26
	glbCurrentThinkingCreatureData->b31++;
	//^1887:0D2E
	return si;
}
//^1887:0E19
X16 SkWinCore::CREATURE_TAKES_ITEM()
{
	//^1887:0E19
	ENTER(0);
	//^1887:0E1E
	X16 di = 0;
	ObjectID si;
	for (si = GET_WALL_TILE_ANYITEM_RECORD(glbCreatureTempTargetX, glbCreatureTempTargetY); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^1887:0E32
		if (si.DBType() == dbCreature)
			continue;
		//^1887:0E3F
		if (glbCurrentThinkingCreatureData->b28 != 0xff && si.Dir() != glbCurrentThinkingCreatureData->b28)
			continue;
		//^1887:0E59
		if (CREATURE_CAN_HANDLE_IT(si, glbCurrentThinkingCreatureData->ItemToThrow) == 0)
			continue;
		//^1887:0E6F
		SkD((DLV_TWEET, "Tweet: %s (a#%03d, x:%d, y:%d, map:%d) takes %s! \n"
			, static_cast<LPCSTR>(getRecordNameOf(glbCurrentThinkingCreatureID))
			, glbCurrentThinkingCreatureID.DBIndex()
			, glbCreatureTempTargetX
			, glbCreatureTempTargetY
			, glbCurrentMapIndex
			, static_cast<LPCSTR>(getRecordNameOf(si))
			));
		MOVE_RECORD_TO(si, glbCreatureTempTargetX, glbCreatureTempTargetY, -1, 0);
		APPEND_RECORD_TO(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
		di++;
		if (glbCurrentThinkingCreatureData->b30_6_6() == 0)
			break;
		//^1887:0EAA
	}
	//^1887:0EBB
	return (di == 0) ? 1 : 0;
}
//^1887:0ECA
X16 SkWinCore::CREATURE_SHOOT_ITEM()
{
	//^1887:0ECA
	ENTER(0);
	//^1887:0ECF
	ObjectID di = CREATURE_CAN_HANDLE_ITEM_IN(glbCurrentThinkingCreatureData->ItemToThrow, glbCurrentThinkingCreatureRec->possession, -1);
	if (di == OBJECT_END_MARKER)
		return 1;
	//^1887:0EF9
	CUT_RECORD_FROM(di, &glbCurrentThinkingCreatureRec->possession, -1, 0);
	X16 si = glbAIDef->GetShootStrength() +1;
	si = si +RAND16(si);
	si = si +RAND16(si);
	SHOOT_ITEM(di, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCurrentThinkingCreatureData->b28, glbCurrentThinkingCreatureData->b27, BETWEEN_VALUE(0x14, si, 255), glbAIDef->Defense, 8);
	//^1887:0F7A
	return 0;
}
//^1887:0D33
X16 SkWinCore::CREATURE_PUTS_DOWN_ITEM()
{
	//^1887:0D33
	ENTER(0);
	//^1887:0D38
	X16 di = 0;
	ObjectID si;
	for (; (si = CREATURE_CAN_HANDLE_ITEM_IN(glbCurrentThinkingCreatureData->ItemToThrow, glbCurrentThinkingCreatureRec->possession, -1)) != OBJECT_END_MARKER; ) {
		//^1887:0D3D
		di++;
		CUT_RECORD_FROM(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
		si.Dir(glbCurrentThinkingCreatureData->b28);
		MOVE_RECORD_TO(si, -1, 0, glbCreatureTempTargetX, glbCreatureTempTargetY);
		SkD((DLV_TWEET, "Tweet: %s (a#%03d, x:%d, y:%d, map:%d) put %s! \n"
			, static_cast<LPCSTR>(getRecordNameOf(glbCurrentThinkingCreatureID))
			, glbCurrentThinkingCreatureID.DBIndex()
			, glbCreatureTempTargetX
			, glbCreatureTempTargetY
			, glbCurrentMapIndex
			, static_cast<LPCSTR>(getRecordNameOf(si))
			));
		if (di == 1) {
			//^1887:0D86
			QUEUE_NOISE_GEN2(QUERY_CLS1_FROM_RECORD(si), QUERY_CLS2_FROM_RECORD(si), 
				SOUND_STD_KNOCK, 0xfe, glbCreatureTempTargetX, glbCreatureTempTargetY, 1, 0x3a, 0x80);
		}
		//^1887:0DB3
		if (glbCurrentThinkingCreatureData->b30_6_6() == 0)
			break;
		//^1887:0DC1
	}
	//^1887:0DE8
	return (di == 0) ? 1 : 0;
}
//^1887:0DF7
void SkWinCore::CREATURE_KILL_ON_TIMER_POSITION()	// ccmDestroy
{
	//^1887:0DF7
	ENTER(0);
	//^1887:0DFA
	DELETE_CREATURE_RECORD(glbCreatureTimerGetX, glbCreatureTimerGetY, CREATURE_GENERATED_DROPS, 1);
	_4976_4ee6 = 1;
	//^1887:0E17
	return;
}
//^1887:0F80
X16 SkWinCore::CREATURE_ROTATES_TARGET_CREATURE()
{
	//^1887:0F80
	ENTER(0);
	//^1887:0F84
	ObjectID si = GET_CREATURE_AT(glbCreatureTempTargetX, glbCreatureTempTargetY);
	if (si != OBJECT_NULL) {
		//^1887:0F9A
		ROTATE_CREATURE(si, 0, glbCurrentThinkingCreatureData->b29);
		return 0;
	}
	//^1887:0FB3
	return 1;
}
//^1887:0FB9
X16 SkWinCore::PLACE_MERCHANDISE()
{
	// 0 if not placed.
	// 1 if placed.

	//^1887:0FB9
	ENTER(8);
	//^1887:0FBF
	X16 di = 0;
	X16 bp08 = glbCreatureTempTargetY;
	X16 bp06 = glbCreatureTempTargetX;
	ObjectID bp02 = GET_CREATURE_AT(bp06, bp08);
	if (bp02 != OBJECT_NULL) {
		//^1887:0FE1
		if ((QUERY_CREATURE_AI_SPEC_FLAGS(bp02) & 1) != 0) {
			//^1887:0FEF
			ObjectID si;
			for (; (si = CREATURE_CAN_HANDLE_ITEM_IN(glbCurrentThinkingCreatureData->ItemToThrow, glbCurrentThinkingCreatureRec->GetPossessionObject(), -1)) != OBJECT_END_MARKER; ) {
				//^1887:0FF5
				di++;
				//^1887:0FF6
				CUT_RECORD_FROM(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
				X8 bp03 = (glbCurrentThinkingCreatureData->b28 == 0xff) ? RAND02() : glbCurrentThinkingCreatureData->b28;
				si.Dir(bp03);
				if (IS_CONTAINER_MONEYBOX(si) != 0) {
					//^1887:1044
					GET_ADDRESS_OF_RECORD9(si)->b7_2_2(1);
				}
				//^1887:1054
				MOVE_RECORD_TO(si, -1, -1, bp06, bp08);
				if (di == 1) {
					//^1887:106C
					QUEUE_NOISE_GEN2(QUERY_CLS1_FROM_RECORD(si), QUERY_CLS2_FROM_RECORD(si),
						SOUND_STD_KNOCK, 0xfe, bp06, bp08, 1, 0x3a, 0x80);
				}
				//^1887:1097
				if (glbCurrentThinkingCreatureData->b30_6_6() == 0)
					break;
				//^1887:10A5
			}
		}
	}
	//^1887:10CC
	return (di == 0) ? 1 : 0;
}
//^1887:10DB
X16 SkWinCore::TAKE_MERCHANDISE()
{
	//^1887:10DB
	ENTER(2);
	//^1887:10E1
	X16 di = 0;
	ObjectID bp02 = GET_CREATURE_AT(glbCreatureTempTargetX, glbCreatureTempTargetY);
	if (bp02 != OBJECT_NULL) {
		//^1887:10FD
		if ((QUERY_CREATURE_AI_SPEC_FLAGS(bp02)&1) != 0) {
			//^1887:1109
			ObjectID si;
			for (; (si = CREATURE_CAN_HANDLE_ITEM_IN(glbCurrentThinkingCreatureData->ItemToThrow, GET_ADDRESS_OF_RECORD4(bp02)->GetPossessionObject(), glbCurrentThinkingCreatureData->b28)) != OBJECT_END_MARKER; ) {
				//^1887:110D
				di++;
				MOVE_RECORD_TO(si, glbCreatureTempTargetX, glbCreatureTempTargetY, -1, -1);
				si = si.GetAsNorth();
				APPEND_RECORD_TO(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
				if (glbCurrentThinkingCreatureData->b30_6_6() == 0)
					break;
				//^1887:114F
			}
		}
	}
	//^1887:1182
	return (di == 0) ? 1 : 0;
}
//^1887:1191
X16 SkWinCore::CREATURE_ACTIVATES_WALL()
{
	//^1887:1191
	ENTER(6);
	//^1887:1197
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	i16 di = bp04->ItemToThrow;
	i16 bp06;
	if (_19f0_2813((bp06 = bp04->b32)|0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTempTargetX, glbCreatureTempTargetY, glbCurrentThinkingCreatureRec->b15_0_1(), di) == 0)
		//^1887:11E8
		//^1887:1266
		return 1;
	ObjectID si;
	//^1887:11EA
	if (bp06 == 2 || di == -1) {
		//^1887:11F5
		si = OBJECT_NULL;
	}
	else {
		//^1887:11FA
		si = CREATURE_CAN_HANDLE_ITEM_IN(bp04->ItemToThrow, glbCurrentThinkingCreatureRec->possession, (i8)-1);
		//^1887:1218
		if (si == OBJECT_END_MARKER)
			//^1887:121B
			//^1887:1266
			return 1;
		//^1887:121D
		CUT_RECORD_FROM(si, &glbCurrentThinkingCreatureRec->possession, -1, 0);
	}
	//^1887:1234
	MOVE_RECORD_AT_WALL(bp04->w24.GetX(), bp04->w24.GetY(), (bp04->b29 +2)&3, glbCurrentThinkingCreatureID, si);
	//^1887:1262
	return 0;
	//^1887:1269
}
//^1887:034E
X16 SkWinCore::CREATURE_USES_LADDER_HOLE()
{
	//^1887:034E
	ENTER(18);
	//^1887:0354
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	//^1887:0361
	if (CREATURE_GO_THERE(bp04->b32|0x80, glbCreatureTimerGetX, glbCreatureTimerGetY, glbCreatureTempTargetX, glbCreatureTempTargetY, bp04->b27) == 0)
		//^1887:0393
		//^1887:05A3
		return 1;
	//^1887:0396
	if ((_4976_37a6[RCJ(86,bp04->Command)] & 4) == 0)
		//^1887:03A7
		//^1887:05A3
		return 1;
	//^1887:03AA
	X16 si = glbCurrentThinkingCreatureRec->b15_0_1();
	glbCreatureTempTargetX = bp04->w24.GetX();
	glbCreatureTempTargetY = bp04->w24.GetY();
	//^1887:03D1
	if (bp04->Command == ccm39 || bp04->Command == ccm3A) {
		//^1887:03E2
		Actuator *bp0e;
		i16 di;
		si = FIND_LADDER_AROUND(glbCreatureTimerGetX, glbCreatureTimerGetY, di = (bp04->Command == ccm39) ? -1 : 1, reinterpret_cast<Actuator **>(&bp0e));
		//^1887:0412  
		if (bp0e != NULL) {
			//^1887:041A
			if (bp0e->RevertEffect() != 0) {
				//^1887:042B
				si = bp0e->ActionType();
			}
			else {
				//^1887:0439
				si = (si +bp0e->ActionType()) & 3;
			}
		}
		else {
			//^1887:0452
			i16 bp08;
			i16 bp10, bp12;
			i16 bp0a = LOCATE_OTHER_LEVEL(bp08 = glbCurrentMapIndex, di, &bp10, &bp12, NULL);
			//^1887:0483
			CHANGE_CURRENT_MAP_TO(bp0a);
			//^1887:048C
			si = FIND_LADDER_AROUND(bp10, bp12, -di, reinterpret_cast<Actuator **>(&bp0e));
		}
	}
	//^1887:04AF
	X16 bp06 = glbAIDef->CanActivatePitTeleport(); // actually, 0x40 or 0
	if (bp06 != 0) {
		//^1887:04C2
		OPERATE_PIT_TELE_TILE(glbCreatureTimerGetX, glbCreatureTimerGetY, 1);
	}
	//^1887:04D7
	MOVE_RECORD_TO(glbCurrentThinkingCreatureID, glbCreatureTimerGetX, glbCreatureTimerGetY, -1, 0);
	//^1887:04F3
	_1c9a_0648(bp04->w24.GetMap());
	//^1887:0507
	if (bp04->Command == ccm35 || bp04->Command == ccm36) {
		//^1887:0518
		si = _0cee_06dc(glbCreatureTempTargetX, glbCreatureTempTargetY);
	}
	//^1887:0529
	glbCurrentThinkingCreatureRec->b15_0_1(si);
	//^1887:053B
	if (MOVE_RECORD_TO(glbCurrentThinkingCreatureID, -1, 0, glbCreatureTempTargetX, glbCreatureTempTargetY) != 0) {
		//^1887:0557
		_4976_4ee6 = 1;
		//^1887:059F
		return 0;
	}
	//^1887:055E
	glbCreatureTimer.XcoordB((U8)_4976_5826);//glbCreatureTimerGetX
	glbCreatureTimer.YcoordB((U8)_4976_5828);//glbCreatureTimerGetY
	_1c9a_0648(glbSomeMap_4976_4ee7 = (U8)_4976_581c);
	//^1887:0579
	if (bp06 != 0) {
		//^1887:057F
		OPERATE_PIT_TELE_TILE(glbCreatureTimerGetX, glbCreatureTimerGetY, 0);
	}
	//^1887:0594
	if (_4976_514e.b1 > 0)
		//^1887:059B
		_4976_514e.b1--;
	//^1887:059F
	return 0;
	//^1887:05A6
}

//^1887:126D
// CREATURE_CCM3B renamed CREATURE_TRANSFORM
void SkWinCore::CREATURE_TRANSFORM()
{
	//^1887:126D
	ENTER(8);
	//^1887:1273
	CreatureInfoData *bp04 = glbCurrentThinkingCreatureData;
	U16 di = glbCreatureTimerGetX;
	U16 si = glbCreatureTimerGetY;
	i8 bp07 = bp04->b31;
	if (bp04->Command == ccmTransform) {
		//^1887:12A6
		X16 bp06 = RAND02() +1;
		for (; bp06-- != 0; ) {
			//^1887:12B1
			U8 bp08 = RAND16(5);
			if (bp08 == 4)
				bp08 = 255;
			CREATE_CLOUD(OBJECT_EFFECT_DISPELL, RAND16(156) +100, di, si, bp08);	// oFF83
			//^1887:12E3
		}
		//^1887:12ED
		if (bp07 >= 1) {
			//^1887:12F3
			CREATE_CLOUD(OBJECT_EFFECT_CLOUD, bp07 *85, di, si, 255);	// oFFA8
		}
		//^1887:130C
		if (bp07 < 3) {
			QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0, SOUND_MINION_TRANSFORMS, 0x6C, 0xC8, di, si, 1);
		}
		else {
			//^1887:1321
			bp04->Command = ccmTransform2;
			bp04->b31 = 0;
			glbCurrentThinkingCreatureRec->HP3(0);
			glbCurrentThinkingCreatureRec->CreatureType(bp04->ItemToThrow);
			glbAIDef = QUERY_CREATURE_AI_SPEC_FROM_TYPE(bp04->ItemToThrow);
			//^1887:1355
			bp06 = glbAIDef->BaseHP;
			glbCurrentThinkingCreatureRec->HP1(bp06 + RAND16((bp06 >> 3) +1));
			GET_CREATURE_ANIMATION_FRAME(glbCurrentThinkingCreatureRec->CreatureType(), bp04->Command, &_4976_4ed6->w0, &_4976_4ed6->w2, &glbCreatureAnimationFrame, 0);
			if (IS_CREATURE_ALLOWED_ON_LEVEL(glbCurrentThinkingCreatureID, glbSomeMap_4976_4ee7) == 0) {
				//^1887:13C1
				DELETE_CREATURE_RECORD(di, si, CREATURE_GENERATED_DROPS, 1);
				_4976_4ee6 = 1;
			}
			//^1887:13D4
			QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0, SOUND_STD_EXPLOSION, 0x6C, 0xC8, di, si, 1);
		}
	}
	else {
		//^1887:13EE
		CREATE_CLOUD(OBJECT_EFFECT_CLOUD, 255, di, si, 255);	// oFFA8
		QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0, SOUND_STD_EXPLOSION, 0x6C, 0xC8, di, si, 1);
	}
	//^1887:1418
	return;
}

//^1887:141C
// SPX: Event from Dragoth or Flame Orb
X16 SkWinCore::CREATURE_EXPLODE_OR_SUMMON()
{
	//^1887:141C
	ENTER(2);
	//^1887:1421
	i8 bp01 = glbCurrentThinkingCreatureData->b32;
	if (bp01 == 0) {	// SPX: This happens for the FIRE ORB which explode like a fireball
		//^1887:1430
		X16 si = glbAIDef->GetShootStrength() +1;
		si = RAND16(si) +si;
		si += RAND16(si);
		CREATE_CLOUD(OBJECT_EFFECT_FIREBALL, BETWEEN_VALUE(0x14, si, 255), // 20 to 255
			glbCreatureTimerGetX, glbCreatureTimerGetY, 255);
		
		// SPX: I removed this condition because in case of FLAME ORB, it does not throw anything, but wants to kill itself after one explosion.
		//if (glbCurrentThinkingCreatureData->ItemToThrow != 0)
			//^1887:148E
			CREATURE_KILL_ON_TIMER_POSITION();
	}
	//^1887:1493
	else if (bp01 == 1) {
		//^1887:1499
		// SPX: When dragoth calls a minion. But b30 (ItemToThrow) was badly init to 1 instead of 76 [Dragoth Attack Minion]
		glbCurrentThinkingCreatureData->ItemToThrow = CREATURE_DRAGOTH_ATTACK_MINION;	// 0x4C Dragoth Minion
		if (CREATE_MINION(glbCurrentThinkingCreatureData->ItemToThrow, 7, RAND02(), glbCreatureTimerGetX, glbCreatureTimerGetY, 
			glbSomeMap_4976_4ee7, OBJECT_NULL, glbCurrentThinkingCreatureRec->b15_0_1()) == OBJECT_NULL
		) {
			return 1;
		}
	}
	//^1887:14DD
	return 0;
}

//^1887:150C
U16 SkWinCore::PROCEED_CCM()
{
	//^1887:150C
	ENTER(0);
	//^1887:1510
	X16 si = 0;
	_4976_520e = ALLOC_MEMORY_RAM(0x100, afDefault, 1024);
	glbCreatureTempTargetX = glbCurrentThinkingCreatureData->w24.GetX();
	glbCreatureTempTargetY = glbCurrentThinkingCreatureData->w24.GetY();

	//^1887:1546
	SkD((DLV_CAI, "CAI: T-- a#%03d ccm<%02X> (%2d,%2d) \n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bitu)glbCurrentThinkingCreatureData->Command, (Bitu)glbCreatureTempTargetX, (Bitu)glbCreatureTempTargetY 
		));

	switch (glbCurrentThinkingCreatureData->Command) {
	case ccm01://^155D
	case ccm02://^155D // track objective located at (glbCreatureTempTargetX,glbCreatureTempTargetY)
	case ccm09://^155D
		//^1887:155D
		si = CREATURE_WALK_NOW();
		break;
	case ccm03://^1563 // track you?
	case ccm04://^1563
		//^1887:1563
		si = CREATURE_CCM03();
		break;
	case ccmJump://^1569
		//^1887:1569
		si = CREATURE_JUMPS();
		break;
	case ccm06://^156F
	case ccm07://^156F
		//^1887:156F
		CREATURE_CCM06();
		break;
	case ccmMeleeAttack://^1575 // attack you?
	case ccmPushBack://^1575
		//^1887:1575
		si = CREATURE_ATTACKS_PARTY();
		break;
	case ccmCastSpell1://^157B
	case ccmCastSpell2://^157B // throw you something. poison ball?
		//^1887:157B
		si = CREATURE_CAST_SPELL();
		break;
	case ccmSteal://^1581
		//^1887:1581
		si = CREATURE_STEAL_FROM_CHAMPION();
		break;
	case ccm0B://^1587
		//^1887:1587
		si = CREATURE_CCM0B();
		break;
	case ccm0C://^158D
	case ccm0D://^158D
		//^1887:158D
		si = CREATURE_CCM0C();
		break;
	case ccm1A://^1593
	case ccm2B://^1593
	case ccm2C://^1593
		//^1887:1593
		si = CREATURE_TAKES_ITEM();
		break;
	case ccmShootItem1://^1599
	case ccmShootItem2://^1599
		//^1887:1599
		si = CREATURE_SHOOT_ITEM();
		break;
	case ccm19://^159F
	case ccm29://^159F
	case ccm2A://^159F
	case ccm2D://^159F
	case ccm2E://^159F
		//^1887:159F
		si = CREATURE_PUTS_DOWN_ITEM();
		break;
	case ccmDestroy://^15A5
		//^1887:15A5
		CREATURE_KILL_ON_TIMER_POSITION();
		break;
	case ccm15://^15AB
	case ccm16://^15AB
		//^1887:15AB
		si = CREATURE_ROTATES_TARGET_CREATURE();
		break;
	case ccmPlaceMerchandise://^15B1
		//^1887:15B1
		si = PLACE_MERCHANDISE();
		break;
	case ccmTakeMerchandise://^15B7
		//^1887:15B7
		si = TAKE_MERCHANDISE();
		break;
	case ccm2F://^15BD
	case ccm30://^15BD
	case ccm31://^15BD
		//^1887:15BD
		si = CREATURE_ACTIVATES_WALL();
		break;
	case ccm35://^15C3
	case ccm36://^15C3
	case ccm37://^15C3
	case ccm38://^15C3
	case ccm39://^15C3
	case ccm3A://^15C3
		//^1887:15C3
		si = CREATURE_USES_LADDER_HOLE();
		break;
	case ccmTransform://^15C9	// ccm3B
	case ccmTransform2://^15C9
		//^1887:15C9
		CREATURE_TRANSFORM();
		break;
	case ccmExplode://^15CF
	case ccm3E://^15CF
	case ccm3F://^15CF
	case ccm40://^15CF
		//^1887:15CF
		CREATURE_EXPLODE_OR_SUMMON();
		break;	// SPX: added break here, safer.
	case ccm10://^15D5
	case ccmSpawn://^15D5
	case ccm12://^15D5
	case ccm14://^15D5
	case ccm1B://^15D5
	case ccm1C://^15D5
	case ccm1D://^15D5
	case ccm1E://^15D5
	case ccm1F://^15D5
	case ccm20://^15D5
	case ccm21://^15D5
	case ccm22://^15D5
	case ccm23://^15D5
	case ccm24://^15D5
	case ccm25://^15D5
	case ccm32://^15D5
	case ccm33://^15D5
	case ccm34://^15D5
        break;
	}
	//^1887:15D5
	SkD((DLV_CAI, "CAI: --T a#%03d r %d \n"
		, (Bitu)glbCurrentThinkingCreatureData->CreatureIndex(), (Bits)si
		));

	if (si != 0) {
		_4976_514e.b1 = 0;
	}
	else {
		//^1887:15E0
		if ((_4976_37a6[RCJ(86,glbCurrentThinkingCreatureData->Command)] & 3) != 0) {
			//^1887:15F2
			glbCurrentThinkingCreatureData->b4 = U8(glbGameTick);
		}
	}
	//^1887:15FD
	_4976_520e = NULL;
	DEALLOC_UPPER_MEMORY(0x100);
	//^1887:1615
	return si;
}
//^4937:028A
X16 SkWinCore::_4937_028a(U16 xx, U16 *yy, CreatureAnimationFrame **ref)
{
	//^4937:028A
	ENTER(0);
	//^4937:028F
	X16 cx = xx;
	X16 di;
	if (*yy == 0xffff) {
		//^4937:029B
		*yy = 0;
		goto _02d0;
	}
	//^4937:02A2
	di = tlbCreaturesAnimationSequences[cx +*yy].w2_a_f();
	X16 si;
	if (di == 0) {
		//^4937:02C5
		si = 2;
	}
	else {
		//^4937:02CA
		*yy += di;
		//^4937:02D0
_02d0:
		if (tlbCreaturesAnimationSequences[cx +*yy].w2_0_3() == 0) {
			//^4937:02EB
			si = 0;
		}
		else {
			//^4937:02EB
			si = 1;
		}
	}
	//^4937:02F2
	*ref = &tlbCreaturesAnimationSequences[cx +*yy];
	//^4937:031A
	return si;
}

//^13E4:0982
// SPX: _13e4_0982 renamed CREATURE_THINK_0982
void SkWinCore::CREATURE_THINK_0982()
{
	//^13E4:0982
	ENTER(16);
	//^13E4:0988
	CreatureInfoData *xCreatureInfo = glbCurrentThinkingCreatureData;	// *bp04
	// SPX DEBUG
	if (xCreatureInfo->ItemToThrow != 0)
	{
		//if(SkCodeParam::bUseIngameDebug) printf("BP04 B30 = %04X\n", bp04->ItemToThrow);
		SkD((DLV_TWEET, "Tweet: Item %d flying (x:%d, y:%d, map:%d)\n"
			, xCreatureInfo->ItemToThrow, 0, 0, 0 
			));
		
	}
	sk1c9a02c3 *bp08;
	if (glbGlobalSpellEffects.FreezeCounter != 0 && glbAIDef->w0_c_c() == 0 && xCreatureInfo->Command != ccmDestroy && xCreatureInfo->Command2 != ccmDestroy) {
		//^13E4:09B8
		glbCreatureTimer.dw00 += 4;
		goto _0c47;
	}
	//^13E4:09C5
	bp08 = _4976_4ed6;
	X16 bp0a;
	X16 di;
	if (glbCreatureTimer.TimerType() == tty22) {
        //^13E4:09DC
		bp0a = 1;
		//^13E4:09E1
		//LOGX(("13E4:09E1 ccm%02X", (U8)xCreatureInfo->Command2));
		xCreatureInfo->Command = xCreatureInfo->Command2;
		if (xCreatureInfo->Command != i8(ccmInv)) {
			//^13E4:09F0
			xCreatureInfo->Command2 = ccmInv;
			if (_14cd_062e() != 0 && xCreatureInfo->Command != ccmDestroy) {
				//^13E4:0A08
				xCreatureInfo->Command = ccmInv;
				goto _0a6a;
			}
			//^13E4:0A0F
			if ((_4976_37a6[RCJ(86,xCreatureInfo->Command)] & 4) != 0) {
				//^13E4:0A20
				_4976_514e.b1 = 0;
				_4976_514e.b3 = 0xff;
			}
			//^13E4:0A2A
			switch (xCreatureInfo->Command) {
				case ccm06: //^_0a3e
					//^13E4:0A3E
					xCreatureInfo->b29 = (glbCurrentThinkingCreatureRec->b15_0_1() -1) & 3;
					break;
				case ccm07: //^_0a4d
					//^13E4:0A4D
					xCreatureInfo->b29 = (glbCurrentThinkingCreatureRec->b15_0_1() +1) & 3;
					break;
			}
		}
		else {
			//^13E4:0A65
			CREATURE_THINK_09E2();
		}
		//^13E4:0A6A
_0a6a:
		X16 si;
		if (xCreatureInfo->Command == ccmDestroy) {
			//^13E4:0A74
			xCreatureInfo->w14 = _4937_000f(bp08->w0, &bp08->w2);
			if ((_4976_3752[QUERY_GDAT_CREATURE_WORD_VALUE(glbCurrentThinkingCreatureRec->CreatureType(), 1)] & 8) == 0) {
				X16 iCloudPower = 0;
				//^13E4:0AB0
				switch (glbAIDef->b35) {
					case 1: //^_0aca
						//^13E4:0ACA
						iCloudPower = 0xBE; // si = 0xbe;
						break;
					case 2: //^_0acf
						//^13E4:0ACF
						iCloudPower = 0xFF; // si = 0xff;
						break;
					default://^_0ac5
						//^13E4:0AC5
						iCloudPower = 0x6E; // si = 0x6e;
						break;
				}
				//^13E4:0AD2
				//CREATE_CLOUD(OBJECT_EFFECT_CLOUD, si, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), 0xff);	// oFFA8
				CREATE_CLOUD(OBJECT_EFFECT_CLOUD, iCloudPower, glbCreatureTimer.XcoordB(), glbCreatureTimer.YcoordB(), 0xff);	// oFFA8
			}
		}
		//^13E4:0AEC
		if ((si = xCreatureInfo->Command) >= ccm32 && si <= ccm34) {
			//^13E4:0B00
			glbCreatureTimer.SetMap(glbSomeMap_4976_4ee7);
			glbCreatureTimer.SetTick(glbGameTick +(si -50));
			goto _0c47;
		}
		//^13E4:0B2B
		if (si == ccm55) { // 0x55
			//si = (RAND01() != 0) ? 0x27 : 0x28;
			si = (RAND01() != 0) ? ccmCastSpell1 : ccmCastSpell2;
		}
		//^13E4:0B43
		di = GET_CREATURE_ANIMATION_FRAME(glbCurrentThinkingCreatureRec->CreatureType(), si, &bp08->w0, &bp08->w2, &glbCreatureAnimationFrame, 0);
	}
	else {
		//^13E4:0B6E
		bp0a = 0;
		di = _4937_01a9(bp08->w0, &bp08->w2, &glbCreatureAnimationFrame);
	}
	//^13E4:0B90
_0b90:
	if (bp0a != 0 || xCreatureInfo->b33 == 0 || glbCreatureAnimationFrame->w2_9_9() == 0) {
		if (glbCreatureAnimationFrame->w2_8_8() != 0) {
			//^13E4:0BB8
			_13e4_01a3();
			xCreatureInfo->b33 |= PROCEED_CCM();
		}
	}
	//^13E4:0BCE
	if (xCreatureInfo->b33 != 0 && glbCreatureAnimationFrame->w2_9_9() != 0) {
		//^13E4:0BE4
		di = _4937_028a(bp08->w0, &bp08->w2, &glbCreatureAnimationFrame);
		if (di != 2)
			goto _0b90;
	}
	//^13E4:0C06
	if (di == 1)
		glbCreatureTimer.TimerType(tty21);
	else
		glbCreatureTimer.TimerType(tty22);
	//^13E4:0C17
	if (_4976_4ee6 != 0)
		return;
	//^13E4:0C21
	glbCreatureTimer.SetTick(CREATURE_SOMETHING_1c9a_0a48());
	glbCreatureTimer.SetMap(glbSomeMap_4976_4ee7);
	//^13E4:0C47
_0c47:
	if (_4976_5161 != 0 && (_4976_514e.b0 != 0 || _4976_514e.b3 != 0xff)) {
		//^13E4:0C5C
		U16 bp10;
		U8 *bp0e;
		if (_3e74_5673(0x20000000 | glbCurrentThinkingCreatureID.DBIndex(), &bp10, 1) == 0) {
			//^13E4:0C7E
			bp0e = ALLOC_CPXHEAP_MEM(bp10, sizeof(sk514e)); // sizeof(sk514e) == 14
			_3e74_585a(bp10, 1);
		}
		else {
			//^13E4:0CA1
			bp0e = reinterpret_cast<U8 *>(QUERY_MEMENT_BUFF_FROM_CACHE_INDEX(bp10));
		}
		//^13E4:0CB0
		COPY_MEMORY(&_4976_514e, bp0e, sizeof(sk514e)); // sizeof(sk514e) == 14
	}
	//^13E4:0CC6
	if (glbCurrentThinkingCreatureData->TimerIndex() != 0xffff) {
		RELEASE_CREATURE_TIMER(glbCurrentThinkingCreatureID);
	}
	//^13E4:0CDB
#if UseAltic
	glbCreatureTimer.Value2(0);
	glbCreatureTimer.ActionType(0);
#endif
	glbCurrentThinkingCreatureData->TimerIndex(QUEUE_TIMER(&glbCreatureTimer));
	//^13E4:0CEE
	return;
}
//^13E4:071B
void SkWinCore::_13e4_071b()
{
	//^13E4:071B
	ENTER(10);
	//^13E4:0721
	sk1c9a02c3 *bp08 = _4976_4ed6;
	if ((bp08->w2 & 0xe03f) == 0x8001)
		return;
	//^13E4:0740
	CreatureAnimationFrame *bp04 = &tlbCreaturesAnimationSequences[bp08->w0];
	//^13E4:075B
	i16 si = 1;
	for (; (bp04->w2_0_3() != 0); si++, bp04++);
	//^13E4:0770
	X16 di = (bp08->w2 & 0xfc0);
	X16 bp0a = (X16)((glbGameTick +di) % si);
	if (bp0a == 0) {
		//^13E4:079D
		bp08->w2 = 0x8001|di;
		return;
	}
	//^13E4:07A7
	bp08->w2 = si |di |0xc000;
	RELEASE_CREATURE_TIMER(glbCurrentThinkingCreatureID);
	glbCreatureTimer.SetMap(glbSomeMap_4976_4ee7);
    glbCreatureTimer.SetTick(glbGameTick +si -bp0a);
	glbCurrentThinkingCreatureData->TimerIndex(QUEUE_TIMER(&glbCreatureTimer));
	//^13E4:0802
	return;
}
//^13E4:0806
void SkWinCore::_13e4_0806()
{
	//^13E4:0806
	ENTER(10);
	//^13E4:080C
	sk1c9a02c3 *bp08 = _4976_4ed6;
	if ((bp08->w2 & 0xe000) == 0x8000 && (bp08->w2_0_5() > 1))
		return;
	//^13E4:0837
	CreatureAnimationFrame *bp04 = &tlbCreaturesAnimationSequences[bp08->w0];
	i16 si = 1;
	for (; bp04->w2_0_3() != 0; si++, bp04++);
	//^13E4:0867
	X16 di = bp08->w2 & 0x0fc0;
	X16 bp0a = (X16)((glbGameTick +di) % si);
	if (bp0a == 0) {
		//^13E4:0894
		bp08->w2 = si |di |0x8000;
		return;
	}
	//^13E4:08A0
	bp08->w2 = si |di |0xa000;
	RELEASE_CREATURE_TIMER(glbCurrentThinkingCreatureID);
	glbCreatureTimer.SetMap(glbSomeMap_4976_4ee7);
	glbCreatureTimer.SetTick(glbGameTick +si -bp0a);
	glbCurrentThinkingCreatureData->TimerIndex(QUEUE_TIMER(&glbCreatureTimer));
	//^13E4:08FB
	return;
}

//^13E4:0CF2
void SkWinCore::THINK_CREATURE(X8 xx, X8 yy, X16 timerType)
{
	SkD((DLV_DBG_CAI, "DBM: THINK_CREATURE(x=%d ,y=%d ,TiTy=%d ,z=%d)\n"
		, (Bitu)xx, (Bitu)yy, (Bitu)timerType, (Bitu)glbCurrentMapIndex));

	//^13E4:0CF2
	ENTER(18);
	//^13E4:0CF8
	ObjectID bp10 = GET_CREATURE_AT(xx, yy);
	if (bp10 == OBJECT_NULL)
		return;
	U8 *bp04 = PREPARE_LOCAL_CREATURE_VAR(bp10, xx, yy, timerType);
	CreatureInfoData *bp08 = glbCurrentThinkingCreatureData;
//		AIDefinition *bp0c = glbAIDef;
	AIDefinition *currentAI = glbAIDef;
	bp08->TimerIndex(0xffff);
	if (glbCurrentThinkingCreatureRec->w6 == 0) {
		//^13E4:0D57
		bp08->w20 = 1;
		glbCurrentThinkingCreatureRec->w6 = 1;
	}
	//^13E4:0D69
	i16 bp0e = bp08->w20;
	bp08->w20 = 0;
	i16 di = currentAI->b3;
	if (di != 0) {
		//^13E4:0D8A
		if (di < 0)
			di = -di;
		i16 si = U8(glbGameTick >> 2);
		if (si < bp08->b6_)
			si += 0x100;
		//^13E4:0DB5
		si -= bp08->b6_;
		i16 bp12 = si / di;
		if (bp12 > 0) {
			//^13E4:0DCC
			if (currentAI->b3 < 0) {
				bp0e += bp12;
			}
			else if (glbCurrentThinkingCreatureRec->w6 < currentAI->BaseHP) {
				glbCurrentThinkingCreatureRec->w6 += bp12;
			}
			//^13E4:0DF7
			bp08->b6_ = U8(glbGameTick >> 2) - U8(si % di);
		}
	}
	//^13E4:0E15
	if (bp0e > 0) {
		//^13E4:0E1B
		if (currentAI->IsStaticObject() == 0)
			glbCurrentThinkingCreatureRec->w10_f_f(0);
		//^13E4:0E2F
		if (WOUND_CREATURE(bp0e) != 0)
			goto _0e89;
	}
	//^13E4:0E3C
	if (currentAI->IsStaticObject() == 0) {
		CREATURE_THINK_0982();
	}
	else {
		//^13E4:0E4C
		if (_4976_4ed6->w2_e_e() != 0) {
			_13e4_071b();
		}
		//^13E4:0E5E
		else if (_4976_4ed6->w2_d_d() != 0) {
			_13e4_0806();
		}
		//^13E4:0E6E
		if (bp08->TimerIndex() == 0xffff) {
			//^13E4:0E78
			_1c9a_0fcb(glbCurrentThinkingCreatureRec->b5);
		}
	}
	//^13E4:0E89
_0e89:
	UNPREPARE_LOCAL_CREATURE_VAR(bp04);
	//^13E4:0E95
	return;
}
//^075F:11BA
void SkWinCore::STEP_MISSILE(Timer *ref)
{
	//^075F:11BA
	ENTER(48);
	//^075F:11C0
	Timer bp30;
	COPY_MEMORY(ref, &bp30, 10);
	Timer *bp04 = &bp30;
	ObjectID bp0e = bp04->id6();
	ObjectID bp14 = bp04->id6();
	Missile *bp08 = GET_ADDRESS_OF_RECORDE(bp0e);
	i16 di = bp04->w8_0_4();
	i16 bp10 = bp04->w8_5_9();
	ATLASSERT(OBJECT_END_MARKER != GET_TILE_RECORD_LINK(di, bp10));
	ObjectID bp24;
	X16 si;
	U16 bp12;
	if (bp04->TimerType() == tty1D) {
		//^075F:121C
		bp04->TimerType(tty1E);
	}
	else {
		//^075F:1224
		si = bp0e.Dir();
		bp24 = GET_CREATURE_AT(di, bp10);
		if (bp24 != OBJECT_NULL) {
			//^075F:1242
			Creature *bp0c = GET_ADDRESS_OF_RECORD4(bp24);
			if ((QUERY_CREATURE_AI_SPEC_FLAGS(bp24) & 2) != 0) {
				if (bp08->GetMissileObject().IsMissile()) {
					//^075F:126C
					i16 bp26 = _4976_0094[RCJ(32, bp04->Direction() + (((bp0c->b15_0_1() & 1) << 4) + (si << 2)))];
					if (bp26 < 4) {
						//^075F:12A9
						bp04->Direction(U8(bp26));
						glbTimersTable[bp08->TimerIndex()].Direction(bp26 & 3);
					}
					goto _132b;
				}
			}
		}
		//^075F:12E3
		if (glbCurrentMapIndex == glbMap_4c28) {
			if (di == glbSomePosX_4c2e) {
				if (bp10 == glbSomePosY_4c30) {
					if (_075f_0af9(-3, di, bp10, si, bp0e) != 0) {
						return;
					}
				}
			}
		}
		//^075F:1313
		if (_075f_0af9(-1, di, bp10, si, bp14) != 0)
			return;
		//^075F:132B
_132b:
		if (bp08->EnergyRemaining() <= (bp12 = bp04->b9_4_7())) {
			//^075F:1349
			CUT_RECORD_FROM(bp0e = bp14, NULL, di, bp10);
			DELETE_MISSILE_RECORD(bp0e, NULL, di, bp10);
			return;
		}
		//^075F:1375
		bp08->EnergyRemaining(bp08->EnergyRemaining() -U8(bp12));
		if (bp08->EnergyRemaining2() < bp12) {
			//^075F:1391
			bp08->EnergyRemaining2(0);
		}
		else {
			//^075F:1398
			bp08->EnergyRemaining2(bp08->EnergyRemaining2() -bp12);
		}
	}
	//^075F:13A6
	X16 bp1c = bp04->Direction();
	bp0e = bp04->id6();
	si = bp0e.Dir();
	X16 bp1e = (bp1c == si || ((bp1c +1) & 3) == si) ? 1 : 0;
	X16 bp20;
	X16 bp22;
	if (bp1e != 0) {
		//^075F:13DF
		bp20 = di;
		bp22 = bp10;
		di += glbXAxisDelta[bp1c];
		bp10 += glbYAxisDelta[bp1c];
		bp12 = GET_TILE_VALUE(di, bp10);
		ATLASSERT((bp12 >> 5) != ttMapExit);
		if ((bp12 >> 5) != ttWall) {
			//^075F:1414
			if ((bp12 >> 5) != ttTrickWall || (bp12 & 5) != 0) {
				//^075F:1425
				if ((bp12 >> 5) != ttStairs)
					goto _146e;
				//^075F:142F
				if ((glbCurrentTileMap[bp20][bp22] >> 5) != ttStairs)
					goto _146e;
			}
		}
		//^075F:144D
		if (_075f_0af9(bp12 >> 5, bp20, bp22, si, bp0e) != 0)
			return;
		//^075F:146E
_146e:
		ObjectID bp1a = GET_WALL_TILE_ANYITEM_RECORD(di, bp10);
		for (; bp1a != OBJECT_END_MARKER; bp1a = GET_NEXT_RECORD_LINK(bp1a)) {
			//^075F:147C
			if (bp1a.DBType() == dbCloud) {
				//^075F:148D
				Cloud *bp18 = GET_ADDRESS_OF_RECORDF(bp1a);
				if (bp18->CloudType() == missileTeleporter) {	// missileTeleporter
					//^075F:14AB
					X16 bp26 = ((glbTimersTable[bp08->TimerIndex()].Direction() & 3) +2) & 3;
					bp04->Direction(U8(bp26));
					glbTimersTable[bp08->TimerIndex()].Direction(U8(bp26));
					di = bp20;
					bp10 = bp22;
					bp1e = 0;
					//^075F:1515
					break;
				}
			}
			//^075F:1517
		}
	}
	//^075F:152C
	bp12 = si;
	if ((bp1c & 1) == (si & 1)) {
		si--;
	}
	else {
		si++;
	}
	//^075F:1543
	si &= 3;
	if (bp1e != 0) {
		//^075F:1550
		MOVE_RECORD_TO(ObjectID(bp0e, si), bp20, bp22, di, bp10);
		if (bp08->GetMissileObject() == OBJECT_EFFECT_FIREBALL && glbCurrentMapIndex == glbPlayerMap) {	// oFF80
			glbDoLightCheck = 1;
		}
		//^075F:158A
		bp04->w8_0_4(_4976_5826);
		bp04->w8_5_9(_4976_5828);
		bp04->w8_a_b(_4976_581e);
		bp0e.Dir(_4976_5820);
		bp04->SetMap(_4976_581c);
		di = glbCurrentMapIndex;
		if (di != _4976_581c) {
			CHANGE_CURRENT_MAP_TO(_4976_581c);
		}
		//^075F:1616
		_4976_5826 += glbXAxisDelta[_4976_581e];
		_4976_5828 += glbYAxisDelta[_4976_581e];
		bp24 = GET_CREATURE_AT(_4976_5826, _4976_5828);
		if (bp24 != OBJECT_NULL) {
			//^075F:1649
			ATTACK_CREATURE(bp24, _4976_5826, _4976_5828, 0x2006, 0x64, 0);
		}
		//^075F:1663
		bp12 = GET_TILE_VALUE(_4976_5826, _4976_5828);
		si = bp12 >> 5;
		if (si != ttWall) {
			//^075F:1682
			if (si == ttTrickWall || (bp12 & 4) != 0) {
				//^075F:168E
				if (si == ttDoor || (bp12 &= 7) == 5 || bp12 <= 1) {
					//^075F:16A8
					_4976_5826 += glbXAxisDelta[_4976_581e];
					_4976_5828 += glbYAxisDelta[_4976_581e];
					bp24 = GET_CREATURE_AT(_4976_5826, _4976_5828);
					if (bp24 != OBJECT_NULL) {
						//^075F:16DB
						ATTACK_CREATURE(bp24, _4976_5826, _4976_5828, 0x2006, 0x64, 0);
					}
				}
			}
		}
		//^075F:16F5
		if (_4976_581c != di) {
			CHANGE_CURRENT_MAP_TO(di);
		}
	}
	else {
		//^075F:1704
		if ((GET_TILE_VALUE(di, bp10) >> 5) == ttDoor && _075f_0af9(4, di, bp10, bp12, bp14) != 0)
			return;
		//^075F:172F
		CUT_RECORD_FROM(bp0e, NULL, di, bp10);
		bp0e.Dir(si);
		APPEND_RECORD_TO(bp0e, NULL, di, bp10);
	}
	//^075F:1766
	bp04->dw00 += 1;
	bp04->id6(bp0e);
	bp08->TimerIndex(QUEUE_TIMER(bp04));
	//^075F:178D
	return;
}
//^0CEE:32BA
//X16 SkWinCore::QUERY_DOOR_STRENGTH(X8 cls2)
X16 SkWinCore::QUERY_DOOR_STRENGTH(X8 iDoorType)
{
	//^0CEE:32BA
	ENTER(0);
	//^0CEE:32BD
	return QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_DOORS, iDoorType, dtWordValue, GDAT_DOOR_STRENGTH);
}

//^3A15:07B4
void SkWinCore::STEP_DOOR(Timer *ref)
{
	//^3A15:07B4
	ENTER(26);
	//^3A15:07BA
	X16 bp18 = 0;
	X16 bp1a = 0;
	X16 di = ref->XcoordB();
	X16 si;
	U8 *bp04 = &glbCurrentTileMap[di][si = ref->YcoordB()];
	X16 bp0a = *bp04 & 7;
	if (bp0a == 5)
		return;
	//^3A15:0807
	if (glbCurrentMapIndex == glbPlayerMap)
		glbDoLightCheck = 1;
	//^3A15:0816
	Door *bp08 = GET_ADDRESS_OF_TILE_RECORD(U8(di), U8(si))->castToDoor();
	if (bp08->Bit10() == 0)
		return;
	//^3A15:0839
	ref->SetTick(ref->GetTick() +1);
	if (bp08->Bit09() == 0) {
		//^3A15:0858
		if (bp0a == 4) {
			bp08->Bit10(0);
			return;
		}
		//^3A15:0861
		X16 bp0e = bp08->b2_5_5();
		X16 bp14 = QUERY_DOOR_STRENGTH(GET_GRAPHICS_FOR_DOOR(bp08));
		if (glbCurrentMapIndex == glbMap_4c28 && di == glbSomePosX_4c2e && si == glbSomePosY_4c30 && bp0a != 0) {
			//^3A15:08AF
			bp1a = 1;
			if (glbChampionsCount > 0) {
				//^3A15:08BB
				*bp04 &= 0xf8;
				X16 bp12 = ATTACK_PARTY(bp14, ((8 |bp0e) != 0) ? 4 : 3, 2);
				if (bp12 != 0) {
					//^3A15:08ED
					i16 bp16 = 0;
					for (; bp16 < 4; bp16++) {
						//^3A15:08F4
						if ((bp12 & (1 << bp16)) == 0)
							continue;
						//^3A15:0901
						// SPX: Bump sound when door closing on champions
						QUEUE_NOISE_GEN2(GDAT_CATEGORY_CHAMPIONS, glbChampionSquad[bp16].HeroType(), SOUND_CHAMPION_BUMP, 0xfe, di, si, 1, 0x64, 0xc8);
						//^3A15:0929
					}
				}
			}
		}
		//^3A15:0932
		ObjectID bp0c = GET_CREATURE_AT(di, si);
		if (bp0c != OBJECT_NULL) {
			//^3A15:0946
			X16 bp10 = QUERY_CREATURE_AI_SPEC_FLAGS(bp0c);
			if ((bp10 & 0x20) == 0) {
				//^3A15:095A
				if (((bp0e != 0) ? ((bp10 >> 6)&3) : 1) <= bp0a) {
					//^3A15:0973
					ATTACK_CREATURE(bp0c, di, si, 0x2006, 0x64, (QUERY_CREATURE_AI_SPEC_FROM_RECORD(bp0c)->w24_c_c() != 0) ? 0 : bp14);
					bp0a = (bp0a == 0) ? 0 : (bp0a -1);
					*bp04 = *bp04 & 0xf8 |bp0a;
					QUEUE_NOISE_GEN2(GDAT_CATEGORY_CREATURES, QUERY_CLS2_FROM_RECORD(bp0c), SOUND_OBJECT_GETHIT, 0xfe,
						di, si, 1, 0x46, 0x80);
					QUEUE_NOISE_GEN2(GDAT_CATEGORY_MISCELLANEOUS, 0xfe, SOUND_STD_KNOCK, 0xfe, di, si, 1, 0x46, 0x80);
					bp1a = 1;
				}
			}
		}
		//^3A15:0A05
		if (bp1a != 0) {
			//^3A15:0A0B
			ref->SetTick(ref->GetTick() +1);
			bp18 = 1;
		}
	}
	else {
		//^3A15:0A1E
		if (bp0a == 0) {
			bp08->Bit10(0);
			return;
		}
	}
	//^3A15:0A27
	if (bp18 == 0) {
		//^3A15:0A2D
		bp0a += (bp08->Bit09() != 0) ? -1 : 1;
		*bp04 = (*bp04 & 0xf8)|U8(bp0a);
		// SPX: Door step sound
		QUEUE_NOISE_GEN2(GDAT_CATEGORY_DOORS, GET_GRAPHICS_FOR_DOOR(bp08), SOUND_DOOR_STEP, 0xfe, di, si, 1, 0x5f, 0x80);
		if (SkCodeParam::bUseDM2ExtendedMode && bp0a == 4)
			QUEUE_NOISE_GEN2(GDAT_CATEGORY_DOORS, GET_GRAPHICS_FOR_DOOR(bp08), SOUND_DOOR_CLOSE, 0xfe, di, si, 1, 0x5f, 0x80);
		else if (SkCodeParam::bUseDM2ExtendedMode && bp0a == 0)
			QUEUE_NOISE_GEN2(GDAT_CATEGORY_DOORS, GET_GRAPHICS_FOR_DOOR(bp08), SOUND_DOOR_OPENED, 0xfe, di, si, 1, 0x5f, 0x80);

		if (bp08->Bit09() != 0) {
			if (bp0a != 0)
				bp18 = 1;
		}
		else if (bp0a != 4) {
			bp18 = 1;
		}
		//printf("step : bp0a = %d\n", bp0a);
	}
	//^3A15:0AA5
	if (bp18 != 0) {
		bp08->Bit12(1);
		QUEUE_TIMER(ref);
		return;
	}
	//^3A15:0AC1
	bp08->Bit10(0);
	//^3A15:0AC9
	return;
}
//^075F:18FD
void SkWinCore::PROCESS_CLOUD(Timer *ref)
{
	//^075F:18FD
	ENTER(18);
	//^075F:1903
	X16 di = ref->XcoordB();
	X16 si = ref->YcoordB();
	Cloud *bp04 = GET_ADDRESS_OF_RECORD(ref->id8())->castToCloud();
	if ((GET_TILE_VALUE(di, si) >> 5) == ttDoor) {
		//^075F:1938
		X16 bp06 = CALC_CLOUD_DAMAGE(ref->id8(), GET_TILE_RECORD_LINK(di, si));
		if (bp06 != 0) {
			//^075F:1956
			ATTACK_DOOR(di, si, bp06, 1, 0);
		}
	}
	//^075F:1967
	X16 bp06 = bp04->CloudType();
	if (bp06 != (missileTeleporter) && bp06 != (missileFireball) && bp06 != (missileLightning)) {
		//^075F:198E
		if (glbCurrentMapIndex == glbMap_4c28 && di == glbSomePosX_4c2e && si == glbSomePosY_4c30) {
			//^075F:19A3
			bp06 = CALC_CLOUD_DAMAGE(ref->id8(), OBJECT_NULL);
			if (bp06 != 0) {
				//^075F:19B9
				ATTACK_PARTY(bp06, 0, 0);
			}
		}
		//^075F:19C8
		ObjectID bp08 = GET_CREATURE_AT(di, si);
		if (bp08 != OBJECT_NULL) {
			//^075F:19D9
			if (_1c9a_0958(bp08) == 0) {
				//^075F:19E6
				bp06 = CALC_CLOUD_DAMAGE(ref->id8(), bp08);
				if (bp06 != 0) {
					//^075F:19FD
					ATTACK_CREATURE(bp08, di, si, 0x200d, 0x64, bp06);
				}
			}
		}
		//^075F:1A12
		Timer bp12;
		switch (bp04->CloudType()) {
		case 0x64: //^_1a2e
			//^075F:1A2E
			// SPX: Explosion spell sound
			QUEUE_NOISE_GEN2(GDAT_CATEGORY_SPELL_MISSILES, bp04->CloudType(), SOUND_STD_EXPLOSION, 0xfe, di, si, 1, 0x6c, 0xc8);
			bp04->CloudType(bp04->CloudType() +1);
			goto _1aae;
		case missileDustCloud: // 0x28: //^_1a6b
			//^075F:1A6B
			if (bp04->b3_0_f() <= 55)
				break;
			bp04->b3_0_f(bp04->b3_0_f() -40);
			goto _1aae;
		case missilePoisonCloud: // 7: //^_1a86
			//^075F:1A86
			if (bp04->b3_0_f() >= 6) {
				//^075F:1A95
				bp04->b3_0_f(bp04->b3_0_f() -3);
				//^075F:1AAE
_1aae:
				bp12 = *ref;
				bp12.SetTick(bp12.GetTick() +1);
				QUEUE_TIMER(&bp12);
				return;
			}
			break;
		}
	}
	//^075F:1AD7
	if (glbCurrentMapIndex == glbPlayerMap) {
		if (bp04->CloudType() == (missileLightning) || bp04->CloudType() == (missileFireball) || bp04->CloudType() == (missileThunderBolt)) {
			//^075F:1B06
			glbDoLightCheck = 1;
		}
	}
	//^075F:1B0C
    CUT_RECORD_FROM(ref->id8(), NULL, di, si);
	DEALLOC_RECORD(ref->id8());
	//^075F:1B2E
	return;
}
//^3A15:0D10
// SPX: _3a15_0d10 renamed PROCESS_TIMER_DESTROY_DOOR
void SkWinCore::PROCESS_TIMER_DESTROY_DOOR(Timer *ref)
{
	//^3A15:0D10
	ENTER(4);
	//^3A15:0D14
	U8 *bp04 = &glbCurrentTileMap[ref->Xcoord()][ref->Ycoord()];
	*bp04 = (*bp04 & 0xf8) | 0x05;
	if (glbCurrentMapIndex == glbPlayerMap)
		//^3A15:0D54
		glbDoLightCheck = 1;
	//^3A15:0D5A
	return;
}

//^3A15:1DA8
// SPX: interesting ... If xx = 0 => 1, if xx = 2
X16 SkWinCore::_3a15_1da8(X8 xx, X8 yy)
{
	//^3A15:1DA8
	ENTER(0);
	//^3A15:1DAB
	switch (xx) {
	case 0: //^_1db9
		//^3A15:1DB9
		return 1;
	case 2: //^_1dc2
		//^3A15:1DC2
		return yy ^1;
	}
	//^3A15:1DBE
	return 0;
}
//^3A15:14C0
void SkWinCore::ACTIVATE_RELAY1(Timer *ref, Actuator *pr4, X16 delayAsMult) 
{
	//^3A15:14C0
	ENTER(4);
	//^3A15:14C5
	if (pr4->OnceOnlyActuator() != 0) {
		//^3A15:14D6
		if (pr4->RevertEffect() != 0 || ref->ActionType() != 0) {
			//^3A15:14EE
			if (pr4->RevertEffect() == 0 || ref->ActionType() != 1)
				return;
		}
	}
	//^3A15:150F
	U32 bp04;
	if (delayAsMult != 0) {
		//^3A15:1515
		bp04 = glbGameTick +(U32(pr4->ActuatorData()) << pr4->Delay());
	}
	else {
		//^3A15:154A
		bp04 = pr4->ActuatorData() + glbGameTick +pr4->Delay();
	}
	//^3A15:157C
	INVOKE_MESSAGE(
		pr4->Xcoord(), pr4->Ycoord(), pr4->Direction(), 
		(pr4->OnceOnlyActuator() != 0) ? pr4->ActionType() : ref->ActionType(), bp04);
	//^3A15:15D5
	return;
}
//^3A15:13CB
void SkWinCore::ACTIVATE_RELAY2(Timer *ref, Actuator *pr4, X16 xx)
{
	//^3A15:13CB
	ENTER(0);
	//^3A15:13D0
	X16 di = xx;
	if (pr4->ActionType() == 3) {
		//^3A15:13E8
		if (pr4->RevertEffect() != 0) {
			//^3A15:13F6
			INVOKE_ACTUATOR(pr4, ref->ActionType(), 0);
			if (di == 0) {
				X16 si;
				//^3A15:1417
				switch (ref->ActionType()) {
				case 0: //^_1430
					//^3A15:1430
					si = 1;
					break;
				case 1: //^_1435
					//^3A15:1435
					si = 0;
					break;
				case 2: //^_1439
					//^3A15:1439
					si = 2;
					break;
				}
				//^3A15:143C
				INVOKE_ACTUATOR(pr4, si, di);
			}
			return;
		}
		//^3A15:144E
		INVOKE_ACTUATOR(pr4, ref->ActionType(), di);
		return;
	}
	//^3A15:1469
	if (pr4->RevertEffect() != 0 || ref->ActionType() != 0) {
		//^3A15:1484
		if (pr4->RevertEffect() == 0 || ref->ActionType() != 1)
			return;
	}
	//^3A15:149F
	INVOKE_ACTUATOR(pr4, pr4->ActionType(), di);
	//^3A15:14BC
	return;
}
//^3A15:0D5C
void SkWinCore::_3a15_0d5c(Timer *ref, Actuator *pr4) { // TODO: Unr
	Unr();
}
//^3A15:12B8
void SkWinCore::ACTIVATE_ORNATE_ANIMATOR(Timer *ref, Actuator *pr4, ObjectID rl, X16 isWall)
{
	//^3A15:12B8
	ENTER(12);
	//^3A15:12BE
	X16 di = ref->XcoordB();
	X16 si = ref->YcoordB();
	if (pr4->ActiveStatus() == 0) {
		//^3A15:12E2
		pr4->ActiveStatus(1);
		pr4->ActuatorData(0);
		Timer bp0a;
		bp0a.SetMap(glbCurrentMapIndex);
		bp0a.SetTick(glbGameTick +1);
		bp0a.TimerType(ttyOrnateAnimator);
		bp0a.actor = 0;
		bp0a.id6(rl);
		bp0a.w8 = isWall;
		QUEUE_TIMER(&bp0a);
		//^3A15:132F
		if (pr4->SoundEffect() != 0) {
			//^3A15:1340
			X8 bp0b;
			X8 bp0c;
			if (isWall != 0) {
				//^3A15:1346
				bp0b = GDAT_CATEGORY_WALL_GFX;	// 9
				bp0c = GET_WALL_DECORATION_OF_ACTUATOR(pr4);
			}
			else {
				//^3A15:1357
				bp0b = GDAT_CATEGORY_FLOOR_GFX;	// 10
				bp0c = GET_FLOOR_DECORATION_OF_ACTUATOR(pr4);
			}
			//^3A15:136B
			// SPX: Activation sound (0x88) from wall or floor actuator
			QUEUE_NOISE_GEN2(bp0b, bp0c, SOUND_STD_ACTIVATION, 0xfe, di, si, QUERY_GDAT_ENTRY_DATA_INDEX(bp0b, bp0c, dtWordValue, 0x88) +1,
				0x8c, 0x80
				);
		}
	}
	//^3A15:13A0
	if (pr4->OnceOnlyActuator() != 0) {
		//^3A15:13B1
		ACTIVATE_RELAY2(ref, pr4, 0);
	}
	//^3A15:13C7
	return;
}
//^3A15:10DC
void SkWinCore::ACTIVATE_CONTINUOUS_ORNATE_ANIMATOR(ObjectID rl, Timer *ref, Actuator *pr4, X16 isWall)
{
	//^3A15:10DC
	ENTER(12);
	//^3A15:10E2
	X16 bp02 = pr4->OnceOnlyActuator();
	pr4->OnceOnlyActuator(_3a15_1da8(ref->ActionType(), pr4->OnceOnlyActuator()));
	i16 di;
	if (pr4->OnceOnlyActuator() != bp02) {
		//^3A15:1132
		U16 si = GET_ORNATE_ANIM_LEN(pr4, isWall);
		if (pr4->OnceOnlyActuator() == 1) {
			//^3A15:1159
			if (pr4->ActiveStatus() == 0) {
				//^3A15:1167
				pr4->ActiveStatus(1);
				if (glbCurrentMapIndex == glbPlayerMap)
					glbDoLightCheck = 1;
				//^3A15:117B
				pr4->ActuatorData((pr4->ActuatorData() & 0x100) | (((si -(glbGameTick % si)) % si)&0xff));
				TRY_ORNATE_NOISE(pr4, rl, ref->XcoordB(), ref->YcoordB(), si, isWall);
			}
		}
		else {
			//^3A15:11ED
			di = (X16)(((pr4->ActuatorData() & 0xff) + glbGameTick ) % si);
			if (di == 0) {
				//^3A15:121A
				if (glbCurrentMapIndex == glbPlayerMap)
					glbDoLightCheck = 1;
				pr4->ActiveStatus(0);
			}
			else {
				//^3A15:1233
				di = si -di;
				Timer bp0c;
				bp0c.SetMap(glbCurrentMapIndex);
				bp0c.SetTick(glbGameTick +di);
				bp0c.TimerType(tty59);
				bp0c.actor = 0;
				bp0c.id8(rl);
				QUEUE_TIMER(&bp0c);
			}
		}
	}
	//^3A15:127A
	if (pr4->RevertEffect() != 0 && pr4->ActionType() == 3) {
		//^3A15:129A
		INVOKE_ACTUATOR(pr4, ref->ActionType(), 0);
	}
	//^3A15:12B4
	return;
}

//^2C1D:153F
void SkWinCore::_2c1d_153f(X16 xx)
{
	//^2C1D:153F
	ENTER(6);
	//^2C1D:1544
	Champion *bp04 = &glbChampionSquad[xx];
	i16 si = bp04->curHP();
	U16 bp06 = 0;
	bp04->curHP(0);
	//^2C1D:1562 
	if (bp04->playerPos() != 0xFF) {
		//^2C1D:1569 
		if (GET_PLAYER_AT_POSITION(bp04->playerPos()) == -1)
			goto _15a9;
	}
	//^2C1D:157A
	for (; GET_PLAYER_AT_POSITION((bp06 + glbPlayerDir) & 3) != -1; bp06++) {
		//^2C1D:1584  
	}
	//^2C1D:1599
	bp04->playerPos((bp06 + glbPlayerDir) & 3);
_15a9:
	bp04->playerDir(glbPlayerDir);
	bp04->curHP(si);
	//^2C1D:15B7
	return;
}

//^2F3F:06FE
// SPX: This should correspond to CSBWin [TAG014676] BringCharacterToLife(ui16 chIdx)
// _2f3f_06fe renamed BRING_CHAMPION_TO_LIFE
void SkWinCore::BRING_CHAMPION_TO_LIFE(X16 xx) { // TODO: Unr
//	if (!SkCodeParam::bUseFixedMode) {
		//^2F3F:06FE
		ENTER(4);
		//^2F3F:0703
		Champion *bp04 = &glbChampionSquad[xx];
		_2c1d_153f(xx);
		bp04->curWeight(0);
		//^2F3F:0727
		U16 si;
		for (si = 0; si < INVENTORY_MAX_SLOT; si++) {
			//^2F3F:072B
			bp04->Possess(si, oFFFF);
			//^2F3F:073B
		}
		//^2F3F:0741
		si = bp04->maxHP();
		bp04->maxHP(max_value(25, si - (si >> 6) - 1));
		bp04->curHP(bp04->maxHP() >> 1);
		//^2F3F:0769
		bp04->heroFlag |= 0x4000;
		bp04->enchantmentAura = 0;
		bp04->enchantmentPower = 0;
		_1031_0667();
		_443c_040e();
		//^2F3F:0786
		return;
//	}
//	else if (SkCodeParam::bUseFixedMode)	// 
//	{
//	// SPX: Code added from TAG014676 in CSBWin!!!
//		i16 player = xx;
//		Bit16u hpmax;
//		Bit16u hpnew;
//	  //dReg D0, D7;
//	  //CHARDESC *pcA3;
//		Champion *champion;
//	  //pcA3 = &d.CH16482[chIdx];
//		champion = &glbChampionSquad[player];
//	  //D0L = CharacterAtPosition(pcA3->charPosition);
//	  //if (D0L != -1)
//	  //{ //Find a position to put the character.
//		//for (D7W=0; CharacterAtPosition(D7W)!=-1; D7W++) {};
//	//
//	//
//		//pcA3->charPosition = D7UB;
//	  //};
//	  //D7W = pcA3->MaxHP();
//		hpmax = champion->maxHP();
//	  //D0W = sw(D7W - D7W/64 - 1);
//		hpnew = (hpmax - hpmax/64 - 1);
//	  //pcA3->MaxHP(Larger(25, D0W));
//		champion->maxHP(max_value(25, hpnew));
//	  //pcA3->HP(pcA3->MaxHP() / 2);
//		champion->curHP(champion->maxHP() / 2);
//	  //DrawSpellControls(d.MagicCaster);
//	  //pcA3->facing = (ui8)d.partyFacing;
//		champion->direction = 0;
//	  //pcA3->charFlags |= CHARFLAG_weaponAttack | CHARFLAG_portraitChanged | CHARFLAG_positionChanged;//0x9400;
//		champion->heroFlag |= CHAMPION_FLAG_8000 | CHAMPION_FLAG_1000 | CHAMPION_FLAG_0400 ;	// 0x8000 | 0x1000 | 0x0400 
//	  //DrawCharacterState(chIdx);
//		REFRESH_PLAYER_STAT_DISP(player);
//
//		// Non CSBWin code, is this useful?
//		CHAMPION_SQUAD_RECOMPUTE_POSITION();
//		UPDATE_RIGHT_PANEL(1);
//	}
}
//^3A15:1EA8
void SkWinCore::ACTIVATE_ITEM_TELEPORT(Timer *ref, Actuator *pr4, ObjectID rl, X16 isFloor, X16 recycler, ObjectID *prl, X16 capture, X16 onlyFirstItem)
{
	// (capture != 0) -> capture from actuator's target, then put to actuator's location. (capture)
	// (capture == 0) -> capture from actuator's location, then put to actuator's target. (teleport)

	//^3A15:1EA8
	ENTER(30);
	//^3A15:1EAE
	X16 bp16;
	X16 di;
	X16 bp1c;
	X16 bp18;
	X16 bp1a;
	X16 bp1e;
	if (capture != 0) {
		//^3A15:1EB4
		bp16 = pr4->Xcoord();
		di = pr4->Ycoord();
		bp1c = pr4->Direction();
		bp18 = ref->XcoordB();
		bp1a = ref->YcoordB();
		bp1e = ref->Value2();
	}
	else {
		//^3A15:1EFA
		bp16 = ref->XcoordB();
		di = ref->YcoordB();
		bp1c = ref->Value2();
		bp18 = pr4->Xcoord();
		bp1a = pr4->Ycoord();
		bp1e = pr4->Direction();
	}
	//^3A15:1F41
	if (pr4->RevertEffect() != 0 || ref->ActionType() != 0) {
		//^3A15:1F5C
		if (pr4->RevertEffect() == 0 || ref->ActionType() != 1)
			return;
	}
	//^3A15:1F7D
	if (rl == OBJECT_NULL) {
		//^3A15:1FA5
		rl = GET_TILE_RECORD_LINK(bp16, di);
		if ((GET_TILE_VALUE(bp16, di) >> 5) != ttWall)
			isFloor = 1;
	}
	//^3A15:1FAA
	ObjectID si = rl;
	i16 bp02 = 0;
	//^3A15:1FB2
	for (; si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
		//^3A15:1FB4
		i16 bp04 = si.DBType();
		if (bp04 >= dbWeapon && bp04 <= dbMiscellaneous_item) {
			//^3A15:1FCA
			if (isFloor != 0 || si.Dir() == bp1c) {
				//^3A15:1FDA
				bp02++;
			}
		}
		//^3A15:1FDD
	}
	//^3A15:1FEB
	si = rl;
	U8 *bp0a;
	if (recycler != 0) {
		//^3A15:1FF7
		bp0a = ALLOC_MEMORY_RAM(0x40, afDefault, 0x400);
		QUERY_CREATURES_ITEM_MASK(U8(pr4->ActuatorData()), U8((pr4->ShopItemPoolNo() * 3) +0x10), bp0a, 0);
	}
	//^3A15:203F
	while (si != OBJECT_END_MARKER) {
		//^3A15:2042
		i16 bp04 = si.DBType();
		ObjectID bp10 = GET_NEXT_RECORD_LINK(si);
		if (bp02 > 0 && bp04 >= dbWeapon && bp04 <= dbMiscellaneous_item) {
			//^3A15:2072
			if (isFloor != 0 || si.Dir() == bp1c) {
				//^3A15:2085
				bp02--;
				X16 bp06 = GET_DISTINCTIVE_ITEMTYPE(si);
				X16 bp0c;
				if (recycler != 0) {
					//^3A15:2098
					bp0c = ((bp0a[bp06 >> 3] & (1 << (bp06 & 7))) != 0) ? 1 : 0;
				}
				else {
					//^3A15:20BB
					if (pr4->ActuatorData() == bp06) {
						//^3A15:20CD
						if (pr4->OnceOnlyActuator() == 0) {
							//^3A15:20DB
							if (QUERY_CLS1_FROM_RECORD(si) == GDAT_CATEGORY_MISCELLANEOUS && QUERY_CLS2_FROM_RECORD(si) == 0) {
								//^3A15:20F1
								ObjectID bp0e;
								bp0e = si;
								si = bp10;
								CUT_RECORD_FROM(bp0e, prl, (prl != NULL) ? -1 : bp16, di);
								// SPX: There I wonder why the DEALLOC comes first ? ... I inverted the order in fixed mode
								if (!SkCodeParam::bUseFixedMode) {
									DEALLOC_RECORD(bp0e);
									BRING_CHAMPION_TO_LIFE(ADD_ITEM_CHARGE(bp0e, 0));
								}
								else if (SkCodeParam::bUseFixedMode)
								{
									BRING_CHAMPION_TO_LIFE(ADD_ITEM_CHARGE(bp0e, 0));
									DEALLOC_RECORD(bp0e);
								}
								continue;
							}
						}
						//^3A15:2139
						bp0c = 1;
					}
					else {
						//^3A15:2140
						if (pr4->ActuatorData() != 0x1ff) {
							//^3A15:2155
							bp0c = 0;
						}
						else {
							//^3A15:2152
							bp0c = 1;
						}
					}
				}
				//^3A15:215A
				if (bp0c != 0) {
					//^3A15:2163
					MOVE_ITEM_TO(si, pr4, bp16, di, bp18, bp1a, bp1e, (prl != NULL) ? 1 : 0, pr4->OnceOnlyActuator());
					//^3A15:219C
					if (onlyFirstItem != 0) {
						break;
					}
				}
			}
		}
		else {
			//^3A15:21A4
			if (recycler == 0 && bp04 == dbCreature) {
				//^3A15:21B0
				Creature *bp14 = GET_ADDRESS_OF_RECORD4(si);
				ACTIVATE_ITEM_TELEPORT(ref, pr4, bp14->possession, isFloor, recycler, &bp14->possession, capture, onlyFirstItem);
			}
		}
		//^3A15:21EC
		si = bp10;
		//^3A15:21EF
	}
	//^3A15:21F7
	if (recycler != 0) {
		DEALLOC_UPPER_MEMORY(0x40);
	}
	//^3A15:2208
	return;
}
//^0CEE:0E44
void SkWinCore::SET_ITEM_IMPORTANCE(ObjectID rlItem, X16 isImportant) 
{
	// for potion: important -> power visibility.
	// for creature: ?

	//^0CEE:0E44
	ENTER(4);
	//^0CEE:0E49
	X16 si = isImportant;
	GenericRecord *bp04 = GET_ADDRESS_OF_RECORD(rlItem);
	//^0CEE:0E5A
	switch (rlItem.DBType()) {
	case dbCreature: // 4://^0E73
		//^0CEE:0E73
		bp04->castToCreature()->b15_2_2(si & 1);
		break;
	case dbCloth: // 6://^0E89
		//^0CEE:0E89
		goto _0e8d;
	case dbWeapon: // 5://^0E8B
		//^0CEE:0E8B
		goto _0e8d;
	case dbMiscellaneous_item: // 10://^0E8D
		//^0CEE:0E8D
_0e8d:
		bp04->castToMisc()->Important(si & 1);
		break;
	case dbPotion: // 8://^0EA3
		//^0CEE:0EA3
		bp04->castToPotion()->VisiblePower(si & 1);
		break;
	case dbScroll: // 7://^0EB7
	case dbContainer: // 9://^0EB7
		break;
	}
	//^0CEE:0EB7
	return;
}
//^3A15:1DCA
void SkWinCore::MOVE_ITEM_TO(ObjectID rl, Actuator *pr4, i16 xposFrm, i16 yposFrm, i16 xposTo, i16 yposTo, X16 dir, X16 takeFrmCreature, X16 putToCreature) 
{
	//^3A15:1DCA
	ENTER(0);
	//^3A15:1DCF
	ObjectID si = rl;
	if (QUERY_CLS1_FROM_RECORD(si) != 0x15 || QUERY_CLS2_FROM_RECORD(si) != 0) {
		//^3A15:1DE8
		i16 di;
		switch (pr4->ActionType()) {
			case 0: //^_1e05
				//^3A15:1E05
				di = GET_MAX_CHARGE(si);
				break;
			case 1: //^_1e0d
				//^3A15:1E0D
				di = 0;
				break;
			case 2: //^_1e11
				//^3A15:1E11
				di = RAND16(GET_MAX_CHARGE(si) +1);
				break;
			default: //^_1e22 // di is still uninit. BUG?
				break;
		}
		//^3A15:1E22
		ADD_ITEM_CHARGE(si, di);
	}
	//^3A15:1E2B
	if ((GET_TILE_VALUE(xposTo, yposTo) >> 5) != ttWall) {
		//^3A15:1E41
		dir = RAND16(4);
	}
	//^3A15:1E4C
	if (xposFrm >= 0 && yposFrm >= 0) {
		//^3A15:1E58
		MOVE_RECORD_TO(si, xposFrm, yposFrm, -1, (takeFrmCreature != 0) ? -1 : 0);
	}
	//^3A15:1E77
	MOVE_RECORD_TO(ObjectID(si, dir), -1, (putToCreature != 0) ? -1 : 0, xposTo, yposTo);
	//^3A15:1EA4
	return;
}
//^3A15:15D8
// SPX: _3a15_15d8 renamed ACTIVATE_INVERSE_FLAG
void SkWinCore::ACTIVATE_INVERSE_FLAG(Timer *ref, Actuator *pr4) 
{
	//^3A15:15D8
	ENTER(0);
	//^3A15:15DB
	UPDATE_GLOB_VAR(pr4->ActuatorData(), 1, ((pr4->RevertEffect() != 0) ? 3 : 0) +ref->ActionType());
	INVOKE_ACTUATOR(pr4, (pr4->OnceOnlyActuator() != 0) ? pr4->ActionType() : ref->ActionType(), 0);
	//^3A15:164E
	return;
}
//^3A15:1650
// SPX: _3a15_1650 renamed ACTIVATE_TEST_FLAG. That one was activated just after the Dragon Door.
// This checks the flag value then triggers destination trigger.
void SkWinCore::ACTIVATE_TEST_FLAG(Timer *ref, Actuator *pr4)
{
	//^3A15:1650
	ENTER(0);
	//^3A15:1655
	U16 si = ref->b9_0_0();
	X16 di = (GET_GLOB_VAR(pr4->ActuatorData()) != 0) ? 1 : 0;
	//^3A15:1681
	if (false
		|| ((pr4->RevertEffect() != di) && (si == 0 || si == 2))
		|| ((pr4->RevertEffect() == di) && (si == 1))
	) {
		//^3A15:16B1
		INVOKE_ACTUATOR(pr4, (pr4->OnceOnlyActuator() != 0) ? pr4->ActionType() : ref->ActionType(), 0);
	}
	//^3A15:16E8
	return;
}

//^3A15:1B7F
void SkWinCore::ACTIVATE_SHOOTER(Actuator *pr4, Timer *ref)
{
	//^3A15:1B7F
	ENTER(20);
	//^3A15:1B85
	X16 bp06 = ref->XcoordB();
	X16 bp08 = ref->YcoordB();
	X16 bp02 = ref->Value2();
	X16 bp0e = (bp02 +2)&3;
	X16 bp04 = pr4->ActuatorType();
	X16 bp10 = pr4->ActuatorData();
	X16 bp12 = pr4->w6_4_f()&255;
	X16 bp14 = pr4->w6_4_f() >> 8;
	//^3A15:1BE5
	X16 bp0a = (bp04 == 7 || bp04 == 8 || bp04 == 14) ? 1 : 0;
	ObjectID si = ObjectID::MissileRecord(bp10);
	ObjectID di = si;
	//^3A15:1C0B
	if (false
		|| bp04 == 14 // 0x0e: Item shooter
		|| bp04 == 15 // 0x0f: -
	) {
		//^3A15:1C1A
		for (di = GET_TILE_RECORD_LINK(bp06, bp08); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
			//^3A15:1C29
			X16 bp0c = di.Dir();
			//^3A15:1C33
			if (di.DBType() <= dbActuator)
				continue;
			//^3A15:1C3E
			if (bp0c == bp02 || ((bp02 +1)&3) == bp0c)
				break;
			//^3A15:1C52
		}
		//^3A15:1C60
		if (di == OBJECT_END_MARKER)
			return;
		//^3A15:1C68
		CUT_RECORD_FROM(di, NULL, bp06, bp08);
		if (bp0a == 0) {
			//^3A15:1C84
			for (si = GET_TILE_RECORD_LINK(bp06, bp08); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
				//^3A15:1C93
				X16 bp0c = si.Dir();
				if (si.DBType() <= dbActuator)
					continue;
				if (bp0c == bp02 || ((bp02 +1)&3) == bp0c)
					break;
				//^3A15:1CBC
			}
			//^3A15:1CCA
			if (si == OBJECT_END_MARKER)
				goto _1d1b;
			//^3A15:1CD1
			CUT_RECORD_FROM(si, NULL, bp06, bp08);
		}
	}
	//^3A15:1CE6
	else if (true
		 && bp04 != 8  // 0x08: Trap shooter
		 && bp04 != 10 // 0x0a: Trap shooter 2
	) {
		//^3A15:1CF2
		di = ALLOC_NEW_DBITEM(bp10);
		if (di == OBJECT_NULL)
			return;
		//^3A15:1D05
		if (bp0a == 0) {
			//^3A15:1D0B
			si = ALLOC_NEW_DBITEM(bp10);
			if (si == OBJECT_NULL) {
				//^3A15:1D1B
_1d1b:
				bp0a = 1;
			}
		}
	}
	//^3A15:1D20
	if (bp0a != 0) {
		//^3A15:1D26
		bp0e = (bp0e +RAND01())&3;
	}
	//^3A15:1D37
	bp06 += glbXAxisDelta[bp02];
	bp08 += glbYAxisDelta[bp02];
	_4976_4b7e = 1;
	SHOOT_ITEM(di, bp06, bp08, bp0e, bp02, (U8)bp12, 100, (U8)bp14);
	if (bp0a == 0) {
		//^3A15:1D7A
		SHOOT_ITEM(si, bp06, bp08, (bp0e +1)&3, bp02, (U8)bp12, 100, (U8)bp14);
	}
	//^3A15:1D9E
	_4976_4b7e = 0;
	//^3A15:1DA4
	return;
}

//^3A15:220C
void SkWinCore::ACTUATE_WALL_MECHA(Timer *ref)
{
	// activate wall mechanics (like text/actuators)

	//^3A15:220C
	ENTER(54);
	//^3A15:2212
	ObjectID si;
	for (si = GET_TILE_RECORD_LINK(ref->XcoordB(), ref->YcoordB()); si != OBJECT_END_MARKER && si.DBType() <= dbActuator; si = GET_NEXT_RECORD_LINK(si)) {
		//^3A15:222D
		X16 bp14 = si.DBType();
		if (bp14 == dbText) {
			//^3A15:2240
			if (si.Dir() == ref->Value2()) {
				//^3A15:2255
				Text *bp08 = GET_ADDRESS_OF_RECORD2(si);
				if (bp08->TextMode() != 0 && bp08->TextMode() != 1)
					continue;
				//^3A15:2283
				X16 bp10 = bp08->SimpleTextExtUsage();
				if (bp10 != 5 && bp10 != 7)
					continue;
				//^3A15:22A6
				bp08->TextVisibility((ref->ActionType() == 2) ? !bp08->TextVisibility() : ((ref->ActionType() == 0) ? 1 : 0));
				if (bp10 != 7)
					continue;
				//^3A15:22EA
				i16 bp2e = (QUERY_GDAT_ENTRY_DATA_INDEX(GDAT_CATEGORY_WALL_GFX, bp08->OrnateIndex(), dtWordValue, GDAT_WALL_ORNATE__IS_LADDER_UP) != 0) ? -1 : 1;
				i16 bp2a = ref->XcoordB();
				i16 bp2c = ref->YcoordB();
				bp2e = LOCATE_OTHER_LEVEL(glbPlayerMap, bp2e, &bp2a, &bp2c, NULL);
				if (bp2e < 0)
					continue;
				//^3A15:2354
				X16 bp16 = glbCurrentMapIndex;
				CHANGE_CURRENT_MAP_TO(bp2e);
				//^3A15:2363
				ObjectID di;
				for (di = GET_TILE_RECORD_LINK(bp2a, bp2c); di != OBJECT_END_MARKER; di = GET_NEXT_RECORD_LINK(di)) {
					//^3A15:2372
					if (di.DBType() != dbText || di.Dir() != ref->Value2())
						continue;
					//^3A15:2391
					Text *bp32 = GET_ADDRESS_OF_RECORD2(di);
					if (bp32->TextMode() != 1 || bp32->SimpleTextExtUsage() != 7)
						continue;
					//^3A15:23C4
					bp32->TextVisibility(bp08->TextVisibility());
					//^3A15:23DD
				}
				//^3A15:23EB
				CHANGE_CURRENT_MAP_TO(bp16);
				continue;
			}
		}
		//^3A15:23F7
		if (bp14 == dbActuator) {
			//^3A15:2400
			if (si.Dir() != ref->Value2())
				continue;
			Actuator *bp04 = GET_ADDRESS_OF_ACTU(si);
			X16 bp10 = bp04->ActuatorType();
			X16 bp0a = bp04->ActuatorData();
			Timer bp20;
			X16 bp2a;
			X16 bp2c;
			X16 bp24;
			X16 bp26;
			ObjectID bp28;
			X16 bp0c;
			X16 bp0e;
			X16 bp22;
			X16 bp12;
			ObjectID di;
			Door *door;	//*bp36
			switch (bp10) {
			case ACTUATOR_TYPE_WORK_TIMER://^2451 // 0x31 -> 'Activator, work timer'
				//^3A15:2451
				if (bp04->ActiveStatus() != 0)
					break;
				//^3A15:2462
				bp20.SetMap(glbCurrentMapIndex);
				bp20.SetTick(glbGameTick +bp04->ActuatorData());
				bp20.TimerType(tty5B);
				bp20.actor = 0;
				bp20.id6(si);
				QUEUE_TIMER(&bp20);
				//^3A15:24A9
				bp04->ActiveStatus(1);
				if (bp04->RevertEffect() != 0 || ref->ActionType() != 0) {
					//^3A15:24C9
					if (bp04->RevertEffect() == 0)
						break;
					if (ref->ActionType() != 1)
						break;
				}
				//^3A15:24EA
				INVOKE_ACTUATOR(bp04, (bp04->OnceOnlyActuator() != 0) ? bp04->ActionType() : ref->ActionType(), 0);
				break;
			case ACTUATOR_TYPE_CREATURE_GENERATOR://^2524 // 0x2e -> 'Creature generator'
				//^3A15:2524
				if (ref->ActionType() != 0)
					break;
				//^3A15:2531
				bp2a = bp04->Xcoord();
				bp2c = bp04->Ycoord();
				bp24 = 7;
				bp26 = (bp04->OnceOnlyActuator() == 0) ? RAND02() : (bp04->ActionType());
				bp28 = ALLOC_NEW_CREATURE(bp04->ActuatorData(), bp24, bp26, bp2a, bp2c);
				if (bp04->RevertEffect() != 0 && bp28 != OBJECT_NULL) {
					//^3A15:25B4
					GET_ADDRESS_OF_RECORD(bp28)->castToCreature()->w8 = bp04->Delay();
				}
				//^3A15:25D3
				if (bp04->SoundEffect() == 0)
					break;
				//^3A15:25E7
				QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0, SOUND_STD_TELEPORT_MESSAGE, 0x61, 0x80, bp2a, bp2c, 1);
				break;
			case ACTUATOR_TYPE_DM1_COUNTER: // SPX: retrocompatibility, DM1 counter
				// DM1 counter does not work the same as DM2 counter
				printf("COUNTER VALUE = %d with EFFECT %d\n", bp04->ActuatorData(), ref->ActionType());
				bp0c = (bp04->ActuatorData() == 0 || (bp04->ActuatorData() & 256) != 0) ? 1 : 0;
				if (ref->ActionType() == 1) { // close
					bp04->ActuatorData(bp04->ActuatorData()  - 1);
				}
				else if (ref->ActionType() == 0) { // open
					if (bp04->OnceOnlyActuator() == 0 || bp04->ActuatorData() != 0) {
						bp04->ActuatorData(bp04->ActuatorData() + 1);
					}
				}
				printf("COUNTER VALUE NEW = %d\n", bp04->ActuatorData());
				// then test if the counter equals 0, if so, trigger the counter actuator action
				bp0e = (bp04->ActuatorData() == 0 || (bp04->ActuatorData() & 256) != 0) ? 1 : 0;
				if (bp0e != 0)
					break;
				INVOKE_ACTUATOR(bp04, bp04->ActionType(), 0);
				break;
			case ACTUATOR_TYPE_COUNTER://^2606 // 0x1d -> 'Activator, counter'
				//^3A15:2606
				bp0c = (bp04->ActuatorData() == 0 || (bp04->ActuatorData() & 256) != 0) ? 1 : 0;
				//^3A15:2630
				if (ref->ActionType() == 1) { // close
					//^3A15:263A
					bp04->ActuatorData(bp04->ActuatorData() +1);
				}
				else if (ref->ActionType() == 0) { // open
					//^3A15:2654
					if (bp04->OnceOnlyActuator() == 0 || bp04->ActuatorData() != 0) {
						//^3A15:2673
						//^3A15:2681
						bp04->ActuatorData(bp04->ActuatorData() -1);
					}
				}
				//^3A15:2694
				bp0e = (bp04->ActuatorData() == 0 || (bp04->ActuatorData() & 256) != 0) ? 1 : 0;
				if (bp0e == bp0c)
					break;
				//^3A15:26C6
				if (bp04->ActionType() == 3) { // step in : open / step out : close
					//^3A15:26D8
					INVOKE_ACTUATOR(bp04, (bp04->RevertEffect() == bp0e) ? 1 : 0, 0);
				}
				else if (bp0e != 0){
					//^3A15:2707
					INVOKE_ACTUATOR(bp04, bp04->ActionType(), 0);
				}
				break;
			case ACTUATOR_TYPE_FINITE_ACTIVATOR_RELAY://^2728 // 0x2d -> 'Activator, finite activator relay'
				//^3A15:2728
				bp22 = 0;
				if (bp04->ActuatorData() > 0 && bp04->ActuatorData() <= 400) {
					//^3A15:274D
					bp04->ActuatorData(bp04->ActuatorData() -1);
					INVOKE_ACTUATOR(bp04, ref->ActionType(), 0);
					break;
				}
				//^3A15:2776
				if (bp04->ActuatorData() > 400 && bp04->ActuatorData() < 500) {
					//^3A15:279D
					bp22 = (RAND16(0x64) < bp04->ActuatorData() -400) ? 1 : 0;
					if (bp04->ActionType() == 3) {
						//^3A15:27D7
						INVOKE_ACTUATOR(bp04, (bp22 != 0) ? 0 : 1, 0);
						break;
					}
					//^3A15:27EA
					if (bp22 != 0) {
						//^3A15:27EA
						INVOKE_ACTUATOR(bp04, ref->ActionType(), 0);
					}
				}
				break;
			case ACTUATOR_TYPE_TICK_GENERATOR://^2810 // 0x1e -> 'Activator, tick generator'
			case ACTUATOR_TYPE_X33_V008://^2810 // 0x33 -> '-'
			case ACTUATOR_TYPE_X34_V016://^2810 // 0x34 -> '-'
			case ACTUATOR_TYPE_X35_V032://^2810 // 0x35 -> '-'
			case ACTUATOR_TYPE_X36_V064://^2810 // 0x36 -> '-'
			case ACTUATOR_TYPE_X37_V128://^2810 // 0x37 -> '-'
				//^3A15:2810
				bp04->OnceOnlyActuator(_3a15_1da8(ref->ActionType(), bp04->OnceOnlyActuator()));
				if (bp04->ActiveStatus() != 0 || bp04->OnceOnlyActuator() == 0)
					break;
				//^3A15:285F
				ACTIVATE_TICK_GENERATOR(bp04, si);
				break;
			case ACTUATOR_TYPE_RELAY_1://^2871 // 0x20 -> 'Activator, relay 1'
			case ACTUATOR_TYPE_RELAY_3://^2871 // 0x45 -> 'Activator, relay 3'
				//^3A15:2871
				ACTIVATE_RELAY1(ref, bp04, (bp10 == 0x45) ? 1 : 0);
				break;
			case ACTUATOR_TYPE_RELAY_2://^2891 // 0x3d -> 'Activator, relay 2'
				//^3A15:2891
				ACTIVATE_RELAY2(ref, bp04, bp04->ActuatorData());
				break;
			case ACTUATOR_TYPE_SOME_SHOOTER://^28B5 // 0x07 -> 'Activator, trap floor'
			case ACTUATOR_TYPE_MISSILE_SHOOTER://^28B5 // 0x08 -> 'Trap shooter' or 'Activator, trap floor'
			case ACTUATOR_TYPE_WEAPON_SHOOTER://^28B5 // 0x09 -> '-'
			case ACTUATOR_TYPE_MISSILE_SHOOTER_2://^28B5 // 0x0a -> 'Trap shooter 2'
			case ACTUATOR_TYPE_ITEM_SHOOTER://^28B5 // 0x0e -> 'Item shooter'
			case ACTUATOR_TYPE_ITEM_SHOOTER_X2://^28B5 // 0x0f -> '-'
				//^3A15:28B5
				ACTIVATE_SHOOTER(bp04, ref);
				break;
			case ACTUATOR_TYPE_CROSS_MAP://^28C8 // 0x16 -> 'Activator, cross map'
				//^3A15:28C8
				bp20.SetMap(bp0a & 63);
				bp20.SetTick(glbGameTick);
				bp20.actor = ref->actor;
				bp20.XcoordB(bp04->Xcoord());
				bp20.YcoordB(bp04->Ycoord());
				bp12 = glbMapTileValue[bp0a & 63][bp20.XcoordB()][bp20.YcoordB()] >> 5;
				bp20.Value2((bp12 == 0) ? ((bp0a >> 6)&3) : 0);
				bp20.TimerType(tty04);
				bp20.ActionType(ref->ActionType());
				QUEUE_TIMER(&bp20);
				break;
			case ACTUATOR_TYPE_THE_END://^2976 // 0x12 -> 'The END'
				//^3A15:2976
				FIRE_SELECT_PALETTE_SET(0);
				_4976_4c26 = 1;
				SK_PREPARE_EXIT();
				break;
			case ACTUATOR_TYPE_ORNATE_ANIMATOR_2://^298C // 0x32 -> 'Activator, ornate animator'
				//^3A15:298C
				ACTIVATE_ORNATE_ANIMATOR(ref, bp04, si, 1);
				break;
			case ACTUATOR_TYPE_ORNATE_STEP_ANIMATOR://^29A1 // 0x41 -> 'Ornate step animator'
				//^3A15:29A1
				(ref->ActionType() == 0) ? bp0a++ : bp0a--;
				//^3A15:29B3
				bp04->ActuatorData((bp0a % GET_ORNATE_ANIM_LEN(bp04, 1)) & 511);
				break;
			case ACTUATOR_TYPE_ORNATE_ANIMATOR://^29E2 // 0x2c -> 'Continuous ornate animator'
				//^3A15:29E2
				ACTIVATE_CONTINUOUS_ORNATE_ANIMATOR(si, ref, bp04, 1);
				break;
			case ACTUATOR_TYPE_SWITCH_SIGN_FOR_CREATURE://^29FB // 0x26 -> 'Switch sign for creature' or 'Activator, missile explosion'
				//^3A15:29FB
				bp04->OnceOnlyActuator(_3a15_1da8(ref->ActionType(), bp04->OnceOnlyActuator()));
				break;
			case ACTUATOR_TYPE_PLACED_ITEM_TELEPORTER://^2A2E // 0x3b -> 'Item teleporter (placed item)'
				//^3A15:2A2E
				ACTIVATE_ITEM_TELEPORT(ref, bp04, si, 0, 0, NULL, 0, 0);
				break;
			case ACTUATOR_TYPE_ITEM_CAPTURE://^2A3D // 0x47 -> 'Item capture'
				//^3A15:2A3D
				ACTIVATE_ITEM_TELEPORT(ref, bp04, OBJECT_NULL, 0, 0, NULL, 1, 0);
				break;
			case ACTUATOR_TYPE_ITEM_RECYCLER://^2A41 // 0x40 -> 'Item recycler'
				//^3A15:2A41
				ACTIVATE_ITEM_TELEPORT(ref, bp04, si, 0, 1, NULL, 0, 0);
				break;
			case ACTUATOR_TYPE_ITEM_TELEPORT_UNKNOWN://^2A4D // 0x48 -> '-'
				//^3A15:2A4D
				ACTIVATE_ITEM_TELEPORT(ref, bp04, si, 0, 0, NULL, 0, 1);
				break;
			case ACTUATOR_FLOOR_TYPE__ITEM_CAPTURE_FROM_CREATURE://^2A51 // 0x49 -> 'Item capture from creature'
				//^3A15:2A51
				ACTIVATE_ITEM_TELEPORT(ref, bp04, OBJECT_NULL, 0, 0, NULL, 1, 1);
				break;
			case ACTUATOR_TYPE_ITEM_GENERATOR://^2A75 // 0x3c -> 'Item generator'
				//^3A15:2A75
				if (bp04->RevertEffect() != 0 || ref->ActionType() != 0) {
					//^3A15:2A90
					if (bp04->RevertEffect() == 0 || ref->ActionType() != 0)
						break;
				}
				//^3A15:2AB1
				di = ALLOC_NEW_RECORD(GET_ITEMDB_OF_ITEMSPEC_ACTUATOR(bp04->ActuatorData()));
				if (di == OBJECT_NULL)
					break;
				//^3A15:2AD6
				SET_ITEMTYPE(di, GET_ITEMTYPE_OF_ITEMSPEC_ACTUATOR(bp04->ActuatorData()));
				if (bp04->ActionType() == 3) {
					//^3A15:2B05
					SET_ITEM_IMPORTANCE(di, 1);
				}
				//^3A15:2B0F
				MOVE_ITEM_TO(di, bp04, -1, -1, bp04->Xcoord(), bp04->Ycoord(), bp04->Direction(), 0, bp04->OnceOnlyActuator());
				break;
			case ACTUATOR_FLOOR_TYPE__CREATURE_DIRECTION://^2B55 // 0x42 -> 'Change creature facing direction'
				//^3A15:2B55
				_3a15_0d5c(ref, bp04);
				break;
			case ACTUATOR_TYPE_INVERSE_FLAG://^2B67 // 0x43 -> 'Activator, inverse flag'
				//^3A15:2B67
				ACTIVATE_INVERSE_FLAG(ref, bp04);
				break;
			case ACTUATOR_TYPE_TEST_FLAG://^2B79 // 0x44 -> 'Activator, test flag'
				//^3A15:2B79
				ACTIVATE_TEST_FLAG(ref, bp04);
				break;
			case ACTUATOR_TYPE_PUSH_BUTTON_WALL_SWITCH://^2B8E // 0x46 -> 'Activator, seal-able push button wall switch'
				//^3A15:2B8E
				// SPX: these actions work for door!
				door = GET_ADDRESS_OF_TILE_RECORD(bp04->Xcoord(), bp04->Ycoord())->castToDoor();
				switch (ref->ActionType()) {
				case 0: //^_2bcd
					//^3A15:2BCD
                    door->Bit13B(1);
					break;
				case 1: //^_2bd7
					//^3A15:2BD7
					door->Bit13B(0);
					break;
				case 2: //^_2be1
					//^3A15:2BE1
					door->Bit13B(door->Bit13() ^ 1);
					break;
				}
				break;
			case 11://^2C00
			case 12://^2C00
			case 13://^2C00
			case 16://^2C00
			case 17://^2C00
			case 19://^2C00
			case 20://^2C00
			case 21://^2C00
			case 23://^2C00
			case 24://^2C00
			case 25://^2C00
			case 26://^2C00
			case 27://^2C00
			case 28://^2C00
			case 31://^2C00
			case 33://^2C00
			case 34://^2C00
			case 35://^2C00
			case 36://^2C00
			case 37://^2C00
			case 39://^2C00
			case 40://^2C00
			case 41://^2C00
			case 42://^2C00
			case 43://^2C00
			case 47://^2C00
			case 48://^2C00
			case 56://^2C00
			case 57://^2C00
			case 58://^2C00
			case 62://^2C00
			case 63://^2C00
				break;
			}
		}
		//^3A15:2C00
	}
	//^3A15:2C1E
	return;
}

//^1C9A:09B9
X16 SkWinCore::_1c9a_09b9(ObjectID rlCreature, X16 xx)
{
	//^1C9A:09B9
	ENTER(0);
	//^1C9A:09BC
	return (GET_ADDRESS_OF_RECORD4(rlCreature)->w8 == xx) ? 1 : 0;
}

//^3A15:0DDC
void SkWinCore::ACTIVATE_CREATURE_KILLER(X16 argLo, X16 argHi, X16 srcx, X16 srcy, X16 tarx, X16 tary, X16 actuatorType, X16 actionType) 
{
	// ACTIVATE_CREATURE_KILLER:
	// - kill the void door.
	// - 

	//^3A15:0DDC
	ENTER(4);
	//^3A15:0DE2
	X16 si = ABS16(srcx -tarx);
	X16 di = ABS16(srcy -tary);
	tarx = srcx -si;
	tary = srcy -di;
	si = (si << 1) +1;
	X16 bp04 = si;
	di = (di << 1) +1;
	for (; (di--) != 0; ) {
		//^3A15:0E24
		for (si = bp04; (si--) != 0; ) {
			//^3A15:0E2A
			if (tarx +si < 0 || tarx +si >= glbCurrentMapWidth || tary +di < 0 || tary +di >= glbCurrentMapHeight)
				continue;
			//^3A15:0E5A
			ObjectID bp02 = GET_CREATURE_AT(tarx +si, tary +di);
			if (bp02 == OBJECT_NULL)
				continue;
			//^3A15:0E75
			if (_1c9a_09b9(bp02, argHi) == 0)
				continue;
			//^3A15:0E86
			if (actuatorType == 0xb) { // 0x0B -> 'Creature killer'
				//^3A15:0E8C
				switch (argLo) {
					case 0:
					case 1:
						continue;
					case 2:
						//^3A15:0E9F
						_13e4_0360(bp02, tarx +si, tary +di, 0x13, 1);
						continue;
					default:
						return;
				}
			}
			//^3A15:0EBC
			if (actuatorType == 0x28) {
				//^3A15:0EC2
				ATTACK_CREATURE(bp02, tarx +si, tary +di, (actionType != 0) ? (argLo |0x8000) : argLo, 0x64, 0);
			}
			//^3A15:0EEF
		}
		//^3A15:0EF9
	}
	//^3A15:0F03
	return;
}
//^13E4:08FF
// SPX: _13e4_08ff renamed ANIMATE_CREATURE
void SkWinCore::ANIMATE_CREATURE(X16 xx, X16 yy, X16 ww)
{
	//^13E4:08FF
	ENTER(4);
	//^13E4:0905
	X16 di = yy;
	ObjectID si = GET_CREATURE_AT(xx, di);
	if (si == OBJECT_NULL)
		return;
	//^13E4:091A
	if ((QUERY_CREATURE_AI_SPEC_FLAGS(si)&1) != 0 && GET_ADDRESS_OF_RECORD4(si)->b5_0_7() == 0xff) {
		//^13E4:0938
		ALLOC_CAII_TO_CREATURE(si, xx, di);
	}
	//^13E4:0945
	U8 *bp04 = PREPARE_LOCAL_CREATURE_VAR(si, xx, di, 0x21);
	if (glbCurrentThinkingCreatureData != NULL) {
		if (ww == 0) {
			//^13E4:0968
			_13e4_071b();
		}
		else {
			//^13E4:096E
			_13e4_0806();
		}
		//^13E4:0972
		UNPREPARE_LOCAL_CREATURE_VAR(bp04);
	}
	//^13E4:097E
	return;
}
//^3A15:16EC
void SkWinCore::ACTUATE_FLOOR_MECHA(Timer *ref)
{
	// activate floor mechanics

	//^3A15:16EC
	ENTER(220);
	//^3A15:16F2
	X16 di;
	X16 bp0a;
	ObjectID si;
	for (si = GET_TILE_RECORD_LINK(bp0a = ref->XcoordB(), di = ref->YcoordB()); si != OBJECT_END_MARKER && si.DBType() <= dbActuator; si = GET_NEXT_RECORD_LINK(si)) {
		//^3A15:1712
		X16 bp0e = si.DBType();
		if (bp0e == dbText) {
			//^3A15:1725
			Text *bp08 = GET_ADDRESS_OF_RECORD2(si);
			if (bp08->TextMode() != 0) {
				if ((bp08->TextMode() != 1 || bp08->SimpleTextExtUsage() != 5) && (bp08->TextMode() != 2 || bp08->w2_c_f() != 2))
					continue;
			}
			//^3A15:1791
			X16 bp0c = bp08->TextVisibility();
			bp08->TextVisibility((ref->ActionType() == 2) ? !bp0c : ((ref->ActionType() == 0) ? 1 : 0));
			if (bp08->TextMode() != 0 || bp0c != 0 || bp08->TextVisibility() == 0 || glbCurrentMapIndex != glbMap_4c28 || bp0a != glbSomePosX_4c2e || di != glbSomePosY_4c30)
				continue;
			//^3A15:181A
			U8 bp00dc[206];
			QUERY_MESSAGE_TEXT(bp00dc, si, 1);
			DISPLAY_HINT_TEXT(COLOR_WHITE, bp00dc);
			continue;
		}
		//^3A15:183E
		if (bp0e == dbActuator) {
			//^3A15:1847
			Actuator *bp04 = GET_ADDRESS_OF_ACTU(si);
			X16 bp10;
			X16 bp14;
			bp10 = bp14 = bp04->ActuatorType();
			X16 bp12;
			switch (bp14) {
			case ACTUATOR_FLOOR_TYPE__CROSS_SCENE://^187D // 0x27 -> 'Cross scene'
				//^3A15:187D
				bp04->b4_0_0(U8(_3a15_1da8(ref->ActionType(), bp04->b4_0_0())));
				break;
			case ACTUATOR_FLOOR_TYPE__INFINITE_ORNATE_ANIMATOR://^18AB // 0x2c -> 'Continuous ornate animator'
				//^3A15:18AB
				ACTIVATE_CONTINUOUS_ORNATE_ANIMATOR(si, ref, bp04, 0);
				break;
			case ACTUATOR_FLOOR_TYPE__RELAY_1://^18C1 // 0x20 -> 'Activator, relay 1'
			case ACTUATOR_FLOOR_TYPE__RELAY_3://^18C1 // 0x45 -> 'Activator, relay 3'
				//^3A15:18C1
				ACTIVATE_RELAY1(ref, bp04, (bp10 == 0x45) ? 1 : 0);
				break;
			case ACTUATOR_FLOOR_TYPE__RELAY_2://^18E1 // 0x3D -> 'Activator, relay 2'
				//^3A15:18E1
				ACTIVATE_RELAY2(ref, bp04, bp04->ActuatorData());
				break;
			case ACTUATOR_FLOOR_TYPE__CREATURE_KILLER://^1905 // 0x0B -> 'Creature killer'
			case ACTUATOR_FLOOR_TYPE__CREATURE_AI_STATE://^1905 // 0x28 -> '?'
				//^3A15:1905
				ACTIVATE_CREATURE_KILLER(bp04->ActuatorData()&15, 
					(bp04->ActuatorData()>>4)&0x1f, 
					bp0a, 
					di, 
					bp04->Xcoord(),
					bp04->Ycoord(), 
					bp10, 
					ref->ActionType());
				break;

			// SPX : DM1 retrocompatibility : Creature generator
			case ACTUATOR_FLOOR_TYPE__DM1_CREATURE_GENERATOR:
				{
					int iLocationX = 0;
					int iLocationY = 0;
					U16 iDirection = 0;
					U16 iHealthMultiplier = 7;
					ObjectID oNewCreature = OBJECT_NULL;
					//if (ref->ActionType() != 0)
					//	break;
//					iLocationX = bp04->Xcoord();
//					iLocationY = bp04->Ycoord();
					// location of creature to generate does not come from actuator data, but from current actuator location
					iLocationX = bp0a;
					iLocationY = di;
					iDirection = (bp04->OnceOnlyActuator() == 0) ? RAND02() : (bp04->ActionType());
					oNewCreature = ALLOC_NEW_CREATURE(bp04->ActuatorData(), iHealthMultiplier, iDirection, iLocationX, iLocationY);
					if (bp04->RevertEffect() != 0 && oNewCreature != OBJECT_NULL) {
						//^3A15:25B4
						GET_ADDRESS_OF_RECORD(oNewCreature)->castToCreature()->w8 = bp04->Delay();
					}
					//^3A15:25D3
					if (bp04->SoundEffect() == 0)
						break;
					//^3A15:25E7
					QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0, SOUND_STD_TELEPORT_MESSAGE, 0x61, 0x80, iLocationX, iLocationY, 1);
					break;
				}
			case ACTUATOR_FLOOR_TYPE__PARTY_TELEPORTER://^1958 // 0x2E -> '-'
				//^3A15:1958
				bp12 = glbCurrentMapIndex;
				if (bp12 != glbPlayerMap) {
					//^3A15:1964
					CHANGE_CURRENT_MAP_TO(glbPlayerMap);
					MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, -1, 0);
					LOAD_NEWMAP(U8(bp12));
					if (bp04->OnceOnlyActuator() != 0) {
						//^3A15:199E
						MOVE_RECORD_TO(OBJECT_NULL, -1, 0, bp04->Xcoord(), bp04->Ycoord());
					}
					else {
						//^3A15:19BA
						MOVE_RECORD_TO(OBJECT_NULL, -1, 0, bp0a, di);
					}
				}
				//^3A15:19CE
				else if (bp04->OnceOnlyActuator() != 0) {
					//^3A15:19DF
					MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, bp04->Xcoord(), bp04->Ycoord());
				}
				else {
					//^3A15:19F7
					MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, bp0a, di);
				}
				//^3A15:1A0D
				if (bp04->RevertEffect() != 0) {
					//^3A15:1A1E
					ROTATE_SQUAD(bp04->ActionType());
				}
				else {
					//^3A15:1A32
					ROTATE_SQUAD((bp04->ActionType() +glbPlayerDir) & 3);
				}
				break;
			case ACTUATOR_FLOOR_TYPE__ORNATE_ANIMATOR://^1A53 // 0x32 -> 'Activator, ornate animator'
				//^3A15:1A55
				ACTIVATE_ORNATE_ANIMATOR(ref, bp04, si, 0);
				break;
			case ACTUATOR_FLOOR_TYPE__CREATURE_ANIMATOR://^1A6C // 0x3a -> 'Creature animator'
				//^3A15:1A6C
				ANIMATE_CREATURE(bp0a, di, (ref->ActionType() == 0) ? 1 : 0);
				break;
			case ACTUATOR_FLOOR_TYPE__ITEM_TELEPORTER://^1A8D // 0x3b -> 'Item teleporter (placed item)'
				//^3A15:1A8D
				ACTIVATE_ITEM_TELEPORT(ref, bp04, si, 1, 0, NULL, 0, 0);
				break;
			case ACTUATOR_TYPE_ITEM_CAPTURE://^1A9C // 0x47 -> 'Item capture'
				//^3A15:1A9C
				ACTIVATE_ITEM_TELEPORT(ref, bp04, OBJECT_NULL, 0, 0, NULL, 1, 0);
				break;
			case ACTUATOR_FLOOR_TYPE__ITEM_RECYCLER://^1AA0 // 0x40 -> 'Item recycler'
				//^3A15:1AA0
				ACTIVATE_ITEM_TELEPORT(ref, bp04, si, 1, 1, NULL, 0, 0);
				break;
			case ACTUATOR_TYPE_ITEM_TELEPORT_UNKNOWN://^1AAC // 0x48 -> '-'
				//^3A15:1AAC
				ACTIVATE_ITEM_TELEPORT(ref, bp04, si, 0, 0, NULL, 0, 1);
				break;
			case ACTUATOR_FLOOR_TYPE__ITEM_CAPTURE_FROM_CREATURE://^1ABA // 0x49 -> 'Item capture from creature'
				//^3A15:1ABA
				ACTIVATE_ITEM_TELEPORT(ref, bp04, OBJECT_NULL, 0, 0, NULL, 1, 1);
				break;
			case ACTUATOR_FLOOR_TYPE__CREATURE_DIRECTION://^1ADE // 0x42 -> 'Change creature facing direction'
				//^3A15:1ADE
				_3a15_0d5c(ref, bp04);
				break;
			case ACTUATOR_TYPE_INVERSE_FLAG://^1AF0 // 0x43 -> 'Activator, inverse flag'
				//^3A15:1AF0
				ACTIVATE_INVERSE_FLAG(ref, bp04);
				break;
			case ACTUATOR_TYPE_TEST_FLAG://^1B02 // 0x44 -> 'Activator, test flag'
				//^3A15:1B02
				ACTIVATE_TEST_FLAG(ref, bp04);
				break;
			}
		}
		//^3A15:1B15
	}
	//^3A15:1B33
	return;
}
//^3A15:2F61
void SkWinCore::ACTUATE_PITFALL(Timer *ref) 
{
	//^3A15:2F61
	ENTER(6);
	//^3A15:2F67
	X16 bp06 = ref->XcoordB();
	X16 di;
	U8 *bp04 = &glbCurrentTileMap[bp06][di = ref->YcoordB()];
	X16 si = ref->ActionType();
	if (si == 2) {
		//^3A15:2FA6
		si = ((bp04[0] & 8) != 0) ? 1 : 0;
	}
	//^3A15:2FB9
	if (si == 0) {
		//^3A15:2FBD
		*bp04 |= 8;
		ADVANCE_TILES_TIME(bp06, di);
	}
	else {
		//^3A15:2FD0
		*bp04 &= 0xf7;
	}
	//^3A15:2FDB
	ACTUATE_FLOOR_MECHA(ref);
	//^3A15:2FE7
	return;
}
//^3A15:0ACD
void SkWinCore::ACTUATE_DOOR(Timer *ref)
{
	//^3A15:0ACD
	ENTER(4);
	//^3A15:0AD3
	X16 di = glbCurrentTileMap[ref->XcoordB()][ref->YcoordB()] & 7;
	if (di == ttTeleporter)
		return;
	//^3A15:0B0B
	Door *door = GET_ADDRESS_OF_TILE_RECORD(ref->XcoordB(), ref->YcoordB())->castToDoor();	//*bp04
	if (door->Bit10() != 0) {
		//^3A15:0B3A
		door->Bit10(U8(_3a15_1da8(ref->ActionType(), door->Bit09())));
		if (door->Bit10() != 0)
			return;
		//^3A15:0B6F
		door->Bit12(0);
		return;
	}
	//^3A15:0B77
	X16 si = 0;
	if (di == 0) {
		//^3A15:0B7D
		if (ref->ActionType() == 1 || ref->ActionType() == 2) {
			//^3A15:0B8E
			door->Bit09(0);
			si = 1;
		}
	}
	//^3A15:0B9B
	else if (di == 4) {
		//^3A15:0BA0
		if (ref->ActionType() == 0 || ref->ActionType() == 2) {
			door->Bit09(1);
			si = 1;
		}
	}
	else {
		//^3A15:0BBE
		door->Bit09((ref->ActionType() == 0) ? 1 : 0);
		si = 1;
	}
	//^3A15:0BE3
	door->Bit10(U8(si));
	if (door->Bit10() == 0)
		return;
	//^3A15:0BFD
	if (door->Bit09() == 0)
		door->Bit12(0);
	//^3A15:0C0F
	ref->TimerType(ttyDoorStep);
	QUEUE_TIMER(ref);
	//^3A15:0C23
	return;
}
//^3A15:2EB5
void SkWinCore::ACTUATE_TELEPORTER(Timer *ref)
{
	//^3A15:2EB5
	ENTER(10);
	//^3A15:2EBB
	X16 bp06 = ref->XcoordB();
	X16 di;
	U8 *bp04 = &glbCurrentTileMap[bp06][di = ref->YcoordB()];
	Teleporter *bp0a = GET_ADDRESS_OF_TILE_RECORD(U8(bp06), U8(di))->castToTeleporter();
	if (bp0a->b4_1_2() != 3) {
		X16 si = ref->ActionType();
		if (si == 2) {
			si = ((*bp04 & 8) != 0) ? 1 : 0;
		}
		//^3A15:2F2F
		if (si == 0) {
			//^3A15:2F33
			*bp04 |= 8;
			ADVANCE_TILES_TIME(bp06, di);
		}
		else {
			//^3A15:2F46
			*bp04 &= 0xf7;
		}
	}
	//^3A15:2F51
	ACTUATE_FLOOR_MECHA(ref);
	//^3A15:2F5D
	return;
}
//^3A15:0C27
void SkWinCore::ACTUATE_TRICKWALL(Timer *ref)
{
	//^3A15:0C27
	ENTER(10);
	//^3A15:0C2D
	X16 si = 0;
	X16 bp06 = ref->XcoordB();
	X16 bp08;
	U8 *bp04 = &glbCurrentTileMap[bp06][bp08 = ref->YcoordB()];
	X16 di = ref->ActionType();
	if (di == 2) {
		di = ((*bp04 & 4) != 0) ? 1 : 0;
	}
	//^3A15:0C82
	if (di == 1) {
		if (glbCurrentMapIndex == glbMap_4c28 && bp06 == glbSomePosX_4c2e && bp08 == glbSomePosY_4c30)
			si = 1;
		//^3A15:0CA5
		ObjectID bp0a = GET_CREATURE_AT(bp06, bp08);
		if (bp0a != OBJECT_NULL && (QUERY_CREATURE_AI_SPEC_FLAGS(bp0a) & 0x20) == 0)
			si = 1;
		//^3A15:0CCB
		if (si != 0) {
			//^3A15:0CCF
			ref->SetTick(ref->GetTick() +1);
			QUEUE_TIMER(ref);
		}
		else {
			//^3A15:0CE9
			*bp04 &= 0xfb;
		}
	}
	else {
		//^3A15:0CF6
		*bp04 |= 4;
	}
	//^3A15:0CFD
	if (glbCurrentMapIndex == glbPlayerMap)
		glbDoLightCheck = 1;
	//^3A15:0D0C
	return;
}
//^3A15:2FEB
// SPX: _3a15_2feb renamed PROCESS_TIMER_3D
void SkWinCore::PROCESS_TIMER_3D(Timer *ref)
{
	//^3A15:2FEB
	ENTER(0);
	//^3A15:2FF0
	U16 x = ref->XcoordB();
	U16 y = ref->YcoordB();
	//^3A15:3003
	if (MOVE_RECORD_TO(ref->id8(), -3, 0, x, y) == 0) {
		//^3A15:3019
		if (ref->TimerType() == tty3D) {
			//^3A15:3023
			QUEUE_NOISE_GEN1(GDAT_CATEGORY_MESSAGES, 0, SOUND_STD_TELEPORT_MESSAGE, 0x61, 0x80, x, y, 1); // teleport noise
		}
	}
	//^3A15:303B
	return;
}
//^482B:04E9
// SPX: _482b_04e9 renamed PROCESS_SOUND
void SkWinCore::PROCESS_SOUND(U8 xx)
{
	//^482B:04E9
	ENTER(0);
	//^482B:04ED
	X16 si = xx;
	if (glbSoundList[si].b5 == glbMap_4c28 || glbSoundList[si].b5 == _4976_4c12) {
		//^482B:0523
		QUEUE_NOISE_GEN1(
			glbSoundList[si].category,
			glbSoundList[si].index,
			glbSoundList[si].entry,
			U8(glbSoundList[si].w8),
			U8(glbSoundList[si].w10),
			glbSoundList[si].b6,
			glbSoundList[si].b7,
			1
			);
	}
	//^482B:05AA
	glbSoundList[si].w0 = 0;
	//^482B:05BC
	return;
}
//^3A15:303F
// SPX: _3a15_303f renamed PROCESS_TIMER_0C
void SkWinCore::PROCESS_TIMER_0C(U8 player)
{
	//^3A15:303F
	ENTER(4);
	//^3A15:3043
	Champion *champion = &glbChampionSquad[player];
	champion->timerIndex = TIMER_NONE;
	if (champion->curHP() != 0)
		champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x800
	//^3A15:306A
	return;
}
//^3A15:316C
// SPX: _3a15_316c renamed PROCESS_TIMER_LIGHT
// CSBWin: Timer.cpp TAG0114fa ProcessLightLevelTimer
void SkWinCore::PROCESS_TIMER_LIGHT(Timer *ref)
{
	//^3A15:316C
	ENTER(12);
	//^3A15:3172
	i16 si = ref->value;	// si
	if (si == 0)
		return;
	//^3A15:3182
	X16 isNegative = (si < 0) ? 1 : 0; // bp02
	if (isNegative) //if (bp02 != 0)
		si = -si;
	//^3A15:319A
	i16 di;	// di
	
	si = tLightLevelItem[RCJ(16,si)] - tLightLevelItem[RCJ(16,di = si -1)];
	//di = si - 1;
	//si = tLightLevelItem[RCJ(16,si)] - tLightLevelItem[RCJ(16,di)];
	

	if (isNegative) // if (bp02 != 0) 
	{
		//^3A15:31B7
		si = -si;
		di = -di;
	}
	else {
		//^3A15:31C5
		si <<= 1;
	}
	//^3A15:31C7
	glbGlobalSpellEffects.Light += si;
	if (di == 0)
		return;
	//^3A15:31CF
	Timer newTimer; // bp0c
	newTimer.TimerType(ttyLight);
	newTimer.value = di;
	newTimer.SetMap(glbPlayerMap);
	newTimer.SetTick(glbGameTick +8);
	newTimer.actor = 0;
	QUEUE_TIMER(&newTimer);
	//^3A15:3208
	return;
}
//^3A15:306C
// SPX: _3a15_306c renamed PROCESS_TIMER_RESURRECTION
// Check CSBWin::ProcessTT_ViAltar
void SkWinCore::PROCESS_TIMER_RESURRECTION(Timer *ref)
{
	//^3A15:306C
	ENTER(8);
	//^3A15:3072
	X16 bonesX = ref->XcoordB();	// bp02
	X16 bonesY = ref->YcoordB();	// bp04
	X16 bonesPos = ref->Value2();	// bp06
	X16 championNo = ref->actor;		// bp08
	//X16 di = ref->b9_0_0();
	X16 VIState = ref->ActionType(); // di / SPX: I think this is action rather than b9_0_0 which is only 1 bit, and Action is set when the timer is created ...
	ObjectID si;
	switch (VIState) {
		case 2:
			//^3A15:30B5
			CREATE_CLOUD(OBJECT_EFFECT_CLOUD_REBIRTH, 0, bonesX, bonesY, bonesPos);	// oFFE4
			ref->SetTick(ref->GetTick() +5);
			//^3A15:30D6
			VIState--;
			//ref->b9_0_0(U8(di));
			ref->ActionType(U8(VIState)); // SPX: fix
			QUEUE_TIMER(ref);
			break;
		case 1:
			//^3A15:30EE
			for (si = GET_TILE_RECORD_LINK(bonesX, bonesY); si != OBJECT_END_MARKER; si = GET_NEXT_RECORD_LINK(si)) {
				//^3A15:30FD
				if (true
					&& si.Dir() == bonesPos 
					&& QUERY_CLS1_FROM_RECORD(si) == GDAT_CATEGORY_MISCELLANEOUS
					&& QUERY_CLS2_FROM_RECORD(si) == 0	// bones item
					&& ADD_ITEM_CHARGE(si, 0) == championNo
				) {
					//^3A15:312C
					CUT_RECORD_FROM(si, NULL, bonesX, bonesY);
					DEALLOC_RECORD(si);
					ref->SetTick(ref->GetTick() +1);
					//^3A15:314D
					//^3A15:30D6
					VIState--;
//						ref->b9_0_0(U8(di));
					ref->ActionType(U8(VIState)); // SPX: fix
					QUEUE_TIMER(ref);
					break;
				}
				//^3A15:314F
			}
			//^3A15:315D
			break;
		case 0:
			//^3A15:315F
			BRING_CHAMPION_TO_LIFE(championNo);
			break;
		default:
			//^3A15:30B2
			break;
	}
	//^3A15:3168
	return;
}
//^3A15:32BC
void SkWinCore::CONTINUE_ORNATE_ANIMATOR(Timer *ref)
{
	//^3A15:32BC
	ENTER(4);
	//^3A15:32C1
	ref->SetTick(ref->GetTick() +1);
	Actuator *bp04 = GET_ADDRESS_OF_ACTU(ref->id6());
	X16 si = GET_ORNATE_ANIM_LEN(bp04, ref->w8);
	bp04->ActuatorData(bp04->ActuatorData() +1);
	if ((bp04->ActuatorData() % si) == 0) {
		bp04->ActiveStatus(0);
	}
	else {
		//^3A15:3322
		QUEUE_TIMER(ref);
	}
	//^3A15:332E
	return;
}
//^3A15:341C
void SkWinCore::CONTINUE_TICK_GENERATOR(Timer *ref)
{
	//^3A15:341C
	ENTER(4);
	//^3A15:3422
	Actuator *bp04 = GET_ADDRESS_OF_ACTU(ref->id6());
	X16 si;
	if (bp04->ActionType() == 3) {
		//^3A15:3447
		ref->b9_0_0(ref->b9_0_0() ^ 1);
		si = ref->b9_0_0() | bp04->OnceOnlyActuator();
		INVOKE_ACTUATOR(bp04, (ref->b9_0_0() != 0) ? 0 : 1, 0);
	}
	//^3A15:348C
	else if ((si = bp04->OnceOnlyActuator()) != 0) {
		//^3A15:349F
		INVOKE_ACTUATOR(bp04, bp04->ActionType(), 0);
	}
	//^3A15:34BA
	if (si != 0) {
		//^3A15:34BE
		ref->SetTick(ref->GetTick() + ref->Value2() * bp04->ActuatorData());
		QUEUE_TIMER(ref);
	}
	else {
		//^3A15:3505
		bp04->b4_0_0(0);
	}
	//^3A15:350D
	return;
}
//^3A15:374B
// SPX: _3a15_374b renamed PROCESS_TIMER_RELEASE_DOOR_BUTTON
void SkWinCore::PROCESS_TIMER_RELEASE_DOOR_BUTTON(Timer *ref) 
{
	//^3A15:374B
	ENTER(0);
	//^3A15:374E
	GET_ADDRESS_OF_RECORD0(ref->id6())->SetButtonState(0);
	//^3A15:3764
	return;
}
//^3A15:3766
// SPX: _3a15_3766 renamed PROCESS_TIMER_59 
// I hit this one in starting cave, after reviving some champions
void SkWinCore::PROCESS_TIMER_59(Timer *ref) 
{
	//^3A15:3766
	ENTER(4);
	//^3A15:376A
	Actuator *bp04 = GET_ADDRESS_OF_ACTU(ref->id8());
	if (bp04->OnceOnlyActuator() == 0) {
		//^3A15:378E
		if (glbCurrentMapIndex == glbPlayerMap) {
			//^3A15:3797
			glbDoLightCheck = 1;
		}
		//^3A15:379D
		bp04->ActiveStatus(0);
	}
	//^3A15:37A5
	return;
}
//^3A15:37A7
void SkWinCore::CONTINUE_ORNATE_NOISE(Timer *ref) 
{
	//^3A15:37A7
	ENTER(6);
	//^3A15:37AC
	Actuator *pActuator = GET_ADDRESS_OF_ACTU(ref->id8());	// bp04
	if (pActuator->ActiveStatus() != 0 && ref->GetMap() == glbPlayerMap) {
		//^3A15:37EA
		X16 si = ((GET_TILE_VALUE(ref->XcoordB(), ref->YcoordB()) >> 5) == ttWall) ? 1 : 0;
		U8 iCategory = 0;	// bp05
		U8 iItemNumber = 0;	// bp06
		if (si != 0) {
			//^3A15:3818
			iCategory = GDAT_CATEGORY_WALL_GFX;	// 09
			iItemNumber = GET_WALL_DECORATION_OF_ACTUATOR(pActuator);
		}
		else {
			//^3A15:3829
			iCategory = GDAT_CATEGORY_FLOOR_GFX;	// 10
			iItemNumber = GET_FLOOR_DECORATION_OF_ACTUATOR(pActuator);
		}
		//^3A15:383D
		ref->SetTick(ref->GetTick() + GET_ORNATE_ANIM_LEN(pActuator, si));
		QUEUE_TIMER(ref);
		// SPX: Wall or floor activation sound
		QUEUE_NOISE_GEN2(iCategory, iItemNumber, SOUND_STD_ACTIVATION, 0xfe, ref->XcoordB(), ref->YcoordB(), 1, 0x8c, 0x80);
		
		
		// SPX special block to try amplifier/fireball activation over lava crater 
		if (SkCodeParam::bUseFixedMode)
		{
			// Is the ornate a lava crater ?
			if (iCategory == GDAT_CATEGORY_FLOOR_GFX &&
				iItemNumber == 0x08) // lava crater
			{
				X16 iSpellPower = 128;
				X16 iPosX = ref->Xcoord();
				X16 iPosY = ref->Ycoord();
				// Get the creature info on top of the crater if any
				ObjectID xObject = GET_CREATURE_AT(iPosX, iPosY);
				Creature *xCreature = GET_ADDRESS_OF_RECORD4(xObject);
				if (xObject != OBJECT_NULL)
				{
					// Note: PREPARE/UNPREPARE can't be used for static variables
					//U8 *bp04 = PREPARE_LOCAL_CREATURE_VAR(xCreature,iPosX,iPosY,0x22);
					//UNPREPARE_LOCAL_CREATURE_VAR(bp04);
					X16 iMissileSpell = i16(OBJECT_EFFECT_FIREBALL);	// May take this effect from AI spell flags
					X16 iSpellPower = 128;
					U16 iDirection = xCreature->b15_0_1();
					iPosX += glbXAxisDelta[iDirection];
					iPosY += glbYAxisDelta[iDirection];
					SHOOT_ITEM(iMissileSpell, 
						iPosX, iPosY, 
						0, iDirection, iSpellPower, iSpellPower, 0);
				}
			} // End block / Amplifier
			if (iCategory == GDAT_CATEGORY_FLOOR_GFX &&
				iItemNumber == 0x0D) // poison rift
			{
				X16 iSpellPower = 128;
				X16 iPosX = ref->Xcoord();
				X16 iPosY = ref->Ycoord();

				CREATE_CLOUD(OBJECT_EFFECT_POISON_CLOUD, iSpellPower, iPosX, iPosY, 255);
			} // end poison rift

		}
		// SPX End block / Amplifier / Poison Rift
	}
	else {
		//^3A15:3893
		pActuator->ActuatorData(pActuator->ActuatorData() & 255);
	}
	//^3A15:38B3
	return;
}

#if DM2_EXTENDED_MODE == 1
void SkWinCore::PROCESS_TIMER_AMBIENT_SOUND(Timer *ref)
{
	ENTER(0);
	// Play sound for rain ! 
	SkD((1, "Process Timer Ambient Sound >> \n"));
	

	U16 rainLevel = 0;
	U16 iSoundID = 0x80;
	if (glbRainStrength >= RAIN_THRESHOLD_LEVEL_3) {
		rainLevel = 4;
	}
	else if (glbRainStrength >= RAIN_THRESHOLD_LEVEL_2) {
		rainLevel = 3;
	}
	else if (glbRainStrength >= RAIN_THRESHOLD_LEVEL_1) {
		rainLevel = 2;
	}
	else if (glbRainStrength > RAIN_THRESHOLD_LEVEL_0 && glbRainStrength < RAIN_THRESHOLD_LEVEL_1) {
		rainLevel = 1;
	}
	iSoundID = 0x70 + rainLevel;

	if (rainLevel == 0)	// If there is no rain, we get another ambient sound, like random wind
	{
		int iRandomValue = rand()%5;
		iSoundID = 0x80 + iRandomValue;
	}

	//static int iRainSoundCount = 0;
	SkD((1, "Tick %d / Playing Rain sound %02x ! (rain level = %d, rain strength = %d) | Map: %d / GfxSet: %d\n",
		glbGameTick, iSoundID, rainLevel, glbRainStrength, glbPlayerMap, glbMapGraphicsSet));
	
	// Generate sound
	if (SkCodeParam::bUseExtendedSound)
		QUEUE_NOISE_GEN1(GDAT_CATEGORY_ENVIRONMENT, glbMapGraphicsSet, iSoundID, 0x96, 0x80, glbPlayerPosX, glbPlayerPosY, 0);
	//iRainSoundCount = (iRainSoundCount+1)%20;
	
	// Issue a new timer
	U8 iDeltaTick = 32;
	switch (skwin.spfact)
	{
		case 0: iDeltaTick = 32; break;
		case 1: iDeltaTick = 16; break;
		case 2: iDeltaTick = 8; break;
		case 3: iDeltaTick = 6; break;
		case 4: iDeltaTick = 4; break;
		case 5: iDeltaTick = 3; break;
	}
	Timer xTimerRef;
	xTimerRef.SetMap(glbPlayerMap);
	xTimerRef.SetTick(glbGameTick + iDeltaTick);
	xTimerRef.TimerType(ttyAmbientSound);
	xTimerRef.actor = 0;
	xTimerRef.value = 0;
	QUEUE_TIMER(&xTimerRef);

	return;
}
#endif

//^3A15:3A9E
void SkWinCore::PROCEED_TIMERS()
{
#if DLV_DBC
	{
		for (Bitu x=0; x<glbCreaturesCount; x++) {
			sk4ebe &a = glbTabCreaturesInfo[x];
			if (a.w0 != -1) {
				SkD((DLV_DBC, 
					"#%03u. " "%04X,"   "%04X,"   "__%02X," "%02X," "%02X," "__%02X," "%02X,%02X,%02X,%02X," "%04X,"   "%04X,"   "%04X,"   "\n"
					"--    "  "__%02X," "__%02X," "%04X,"   "%02X," "%02X," "%04X,"   "%02X,%02X,%02X,%02X," "__%02X," "__%02X," "__%02X," "%02X" "\n"
					, (Bitu)x
					, (Bitu)a.w0, (Bitu)a.w2, (Bitu)a.b4, (Bitu)a.b5_, (Bitu)a.b6_, (Bitu)a.b7, (Bitu)a.b8_, (Bitu)a.b9_, (Bitu)a.b10_, (Bitu)a.b11_
					, (Bitu)a.w12.w0, (Bitu)a.w14, (Bitu)a.w16

					, (Bitu)(Bit8u)a.b18, (Bitu)(Bit8u)a.b19, (Bitu)a.w20, (Bitu)a.b22, (Bitu)a.b23, (Bitu)a.w24.w0, (Bitu)a.b26, (Bitu)a.b27, (Bitu)a.b28, (Bitu)a.b29
					, (Bitu)a.b30, (Bitu)a.b31, (Bitu)a.b32, (Bitu)a.b33
					));
				Creature &db = reinterpret_cast<Creature *>(glbDBObjectData[dbCreature])[+a.w0];
				SkD((DLV_DBC,
					"-- db " "%04X,%04X,%02X,%02X,{%04X,%04X,%04X,%04X},%02X,%02X \n"
					"\n"
					, (Bitu)db.w0, (Bitu)db.w2, (Bitu)db.b4, (Bitu)db.b5, (Bitu)db.w6, (Bitu)db.w8, (Bitu)db.w10, (Bitu)db.w12, (Bitu)db.b14, (Bitu)db.b15
					));
			}
		}
	}
#endif

#if 0
	{
		printf("-- %6u \n", glbGameTick);
		for (int x = 0; x < glbTimersCount; x++) {
			Timer &r = glbTimersTable[glbTimerNextEntries[x]];
			printf("%2d %6u %2u %02X %02X %04X %04X \n", x, r.GetTick(), r.GetMap(), r.TimerType(), r.b5, r.w6, r.w8);
		}
	}
#endif

	//^3A15:3A9E
	ENTER(16);
	//^3A15:3AA4
	Timer timer;	//bp10
	Timer *bp04 = &timer;
	U16 bp06;
	for (; IS_TIMER_TO_PROCEED() != 0; ) {
		//^3A15:3AB0
		//LOGX(("3A15:3AB0 %u %u %u %d", (U32)_4976_4e46, (U32)glbAbsoluteTickCounter, (U32)_4976_19a9, (i16)_4976_4e62, (U16)_4976_4e48, (U16)_4976_4e64));
		IBMIO_USER_INPUT_CHECK();
		GET_AND_DELETE_NEXT_TIMER(bp04);
		CHANGE_CURRENT_MAP_TO(timer.GetMap());
		X16 si = timer.TimerType();
		X16 di = si;
#if UseAltic
		SkD((DLV_DBG_TIMER, "DBG: Timer#xx (%6u,%2u,%02X,%02X,%04X,%04X)\n"
			, (Bitu)bp04->GetTick(), (Bitu)bp04->GetMap(), (Bitu)bp04->TimerType()
			, (Bitu)bp04->actor, (Bitu)bp04->value, (Bitu)bp04->w8
			));
#endif
		//^3A15:3ADE
		switch (di) {
			case tty21://^3AF4
			case tty22://^3AF4 // TiTy22: 'think creature'
				//^3A15:3AF4
				THINK_CREATURE(timer.XcoordB(), timer.YcoordB(), si);
				break;
			case tty1D://^3B09
			case tty1E://^3B09
				STEP_MISSILE(bp04);
				break;
			case ttyDoorStep://^3B17
				//^3A15:3B17
				STEP_DOOR(bp04);
				break;

			case ttyCloud://^3B24
				//^3A15:3B24
				PROCESS_CLOUD(bp04);
				break;

			case ttyDoorDestroy://^3B32
				//^3A15:3B32
				PROCESS_TIMER_DESTROY_DOOR(bp04);
				break;

			case tty04://^3B3F // TiTy04: 'launch actuator'
				//^3A15:3B3F
				switch (glbCurrentTileMap[timer.XcoordB()][timer.YcoordB()] >> 5) {
					case ttWall://^3B72
						//^3A15:3B72
						ACTUATE_WALL_MECHA(bp04);
						break;
					case ttFloor://^3B7F
						//^3A15:3B7F
						ACTUATE_FLOOR_MECHA(bp04);
						break;
					case ttPit://^3B8C
						//^3A15:3B8C
						ACTUATE_PITFALL(bp04);
						break;
					case ttDoor://^3B99
						//^3A15:3B99
						ACTUATE_DOOR(bp04);
						break;
					case ttTeleporter://^3BA6
						//^3A15:3BA6
						ACTUATE_TELEPORTER(bp04);
						break;
					case ttTrickWall://^3BB3
						//^3A15:3BB3
						ACTUATE_TRICKWALL(bp04);
						break;
					case ttStairs://^3D93
						goto _3d93;
				}
				break;
			case tty3C://^3BC0
			case tty3D://^3BC0
				//^3A15:3BC0
				PROCESS_TIMER_3D(bp04);
				break;
			case ttySound://^3BCD
				//^3A15:3BCD
				PROCESS_SOUND(timer.XcoordB());
				break;
			case tty0C://^3BD8
				//^3A15:3BD8
				PROCESS_TIMER_0C(timer.actor);
				break;
			case ttyLight://^3BE5
				//^3A15:3BE5
				CHANGE_CURRENT_MAP_TO(glbPlayerMap);
				PROCESS_TIMER_LIGHT(bp04);
				RECALC_LIGHT_LEVEL();
				break;
			case ttyInvisibility: //^3C03	(0x47 / 71)		// SPX: decrease invisibility value
				//^3A15:3C03
				glbGlobalSpellEffects.Invisibility = glbGlobalSpellEffects.Invisibility -1;
				if (glbGlobalSpellEffects.Invisibility != 0 || glbChampionInventory == 0)
					break;
				//^3A15:3C1E
				glbChampionTable[glbChampionInventory].heroFlag |= CHAMPION_FLAG_4000;	// 0x4000
				break;
			case ttyEnchantment://^3C31		(0x48 / 72)
				//^3A15:3C31
				for (bp06 = 0; bp06 < glbChampionsCount; bp06++) {
					//^3A15:3C38
					if (((1 << bp06) & timer.actor) != 0 && glbChampionSquad[bp06].curHP() != 0) {
						//^3A15:3C5A
						glbChampionSquad[bp06].enchantmentPower -= bp04->value; 
					}
					//^3A15:3C71
					if (glbChampionSquad[bp06].enchantmentPower < 0) {
						//^3A15:3C82
						glbChampionSquad[bp06].enchantmentPower = 0;
					}
					//^3A15:3C92
				}
				//^3A15:3C9E
				break;
#if (DM2_EXTENDED_MODE == 1)
			case ttySeeThruWalls:	// (0x49 / 73)		// SPX: decrease see_thru_walls value
				//^3A15:3C03
				glbGlobalSpellEffects.SeeThruWalls = glbGlobalSpellEffects.SeeThruWalls -1;
				break;
#endif
			case ttyPoison://^3CA1	(0x4B / 75)
				//^3A15:3CA1
				glbChampionSquad[si = timer.actor].PoisonValue--;
				PROCESS_POISON(si, timer.value);
				break;
#if (DM2_EXTENDED_MODE == 1)
			case ttyPlague:
				glbChampionSquad[si = timer.actor].PlagueValue--;
				PROCESS_PLAGUE(si, timer.value);
				break;
#endif
			case ttyResurrect://^3CBE
				//^3A15:3CBE
				PROCESS_TIMER_RESURRECTION(bp04);
			case ttyItemBonus://^3CCA
				//^3A15:3CCA
				PROCESS_TIMER_0E(bp04, 0xfffe);
				break;
			case ttyWeather://^3CDC
				//^3A15:3CDC
				UPDATE_WEATHER(1);
				break;
			case ttyOrnateAnimator://^3CE7
				//^3A15:3CE7
				CONTINUE_ORNATE_ANIMATOR(bp04);
				break;
			case ttyTickGenerator://^3CF3
				//^3A15:3CF3
				CONTINUE_TICK_GENERATOR(bp04);
				break;
			case ttyDoorButton://^3CFF
				//^3A15:3CFF
				PROCESS_TIMER_RELEASE_DOOR_BUTTON(bp04);
				break;
			case tty59://^3D0B
				//^3A15:3D0B
				PROCESS_TIMER_59(bp04);
				break;
			case tty5A://^3D17
				//^3A15:3D17
				CONTINUE_ORNATE_NOISE(bp04);
				break;
			case ttyWallButton://^3D25
			case tty5B://^3D25
				//^3A15:3D25
				// when door opens/closes by actuator?
				GET_ADDRESS_OF_ACTU(bp04->id6())->ActiveStatus(0);
				break;
			case ttySimpleActuTurnOn://^3D3D
				//^3A15:3D3D
				// when acquire mineral?
				GET_ADDRESS_OF_RECORD2(bp04->id6())->TextVisibility(1);
				break;
			case tty5D://^3D55
				//^3A15:3D55
				if (timer.Value2() == glbPlayerMap) {
					//^3A15:3D60
					MOVE_RECORD_TO(OBJECT_NULL, glbPlayerPosX, glbPlayerPosY, timer.b6_0_4(), timer.w6_5_9());
					ROTATE_SQUAD(timer.w6_a_b());
				}
				break;
#if (DM2_EXTENDED_MODE == 1)

			case ttyAmbientSound:
				{
					PROCESS_TIMER_AMBIENT_SOUND(bp04);
				}
				break;
#endif
		}
		//^3A15:3D93
_3d93:
		;
	}
	//^3A15:3D9E
	CHANGE_CURRENT_MAP_TO(glbPlayerMap);
	//^3A15:3DA8
	return;
}

//^2C1D:14DE
void SkWinCore::DROP_PLAYER_ITEMS(U16 player)
{
	//^2C1D:14DE
	ENTER(2);
	//^2C1D:14E4
	X16 di = glbChampionSquad[player].playerPos();
	X16 si;
	for (si = 0; si < INVENTORY_MAX_SLOT; si++) {
		//^2C1D:14FA
		ObjectID bp02 = REMOVE_POSSESSION(player, _4976_3fce[si]);
		if (bp02 != OBJECT_NULL) {
			//^2C1D:1512
			MOVE_RECORD_TO(ObjectID(bp02, di), -1, 0, glbPlayerPosX, glbPlayerPosY);
		}
		//^2C1D:1535
	}
	//^2C1D:153B
	return;
}

//^2C1D:15BA
// SPX: PLAYER_DEFEATED renamed CHAMPION_DEFEATED
void SkWinCore::CHAMPION_DEFEATED(X16 player)
{
	// CSBwinSimilarity: TAG016c5a,KillCharacter

	//^2C1D:15BA
	ENTER(12);
	//^2C1D:15C0
	X16 di;
	Champion *champion = &glbChampionSquad[di = player];

#if (DM2_EXTENDED_MODE == 1)
	if (SkCodeParam::bUseExtendedSound == true) {	// SPX: Play the champion own scream sound if dead
		printf("champion dead: %d\n", champion->HeroType());
		QUEUE_NOISE_GEN1(GDAT_CATEGORY_CHAMPIONS, champion->HeroType(), SOUND_CHAMPION_SCREAM, 0x61, 0x80, glbPlayerPosX, glbPlayerPosY, 1);
	}
#endif

	if (glbChampionIndex -1 == di)
		//^2C1D:15DB
		DISPLAY_RIGHT_PANEL_SQUAD_HANDS();
	//^2C1D:15E0
	champion->curHP(0);
	champion->herob44 = champion->handCooldown[INVENTORY_HAND_LEFT] = champion->handCooldown[INVENTORY_HAND_RIGHT] = 0;
	champion->heroFlag |= CHAMPION_FLAG_4000;	// 0x4000
	if (di +1 == glbChampionInventory) {
		//^2C1D:1606
		if (glbShowItemStats != 0) {
			//^2C1D:160D
			glbShowItemStats = 0;
			FIRE_MOUSE_RELEASE_CAPTURE();
			if (glbLeaderHandPossession.object != OBJECT_NULL)
				//^2C1D:161F
				DISPLAY_TAKEN_ITEM_NAME(glbLeaderHandPossession.object);
			//^2C1D:1629
			glbMouseVisibility = 1;
		}
		//^2C1D:1634
		if (_4976_4bfe != 0) {
			//^2C1D:163B
			_4976_4bfe = 0;
			FIRE_MOUSE_RELEASE_CAPTURE();
			glbMouseVisibility = 1;
			FIRE_SHOW_MOUSE_CURSOR();
		}
		//^2C1D:1651
		INTERFACE_CHAMPION(4);
	}
	//^2C1D:1659
	if (di == glbChampionLeader && _4976_4c3e != 0) {
		//^2C1D:1666
		_4976_4c3e = 0;
		FIRE_MOUSE_RELEASE_CAPTURE();
		glbMouseVisibility = 1;
		FIRE_SHOW_MOUSE_CURSOR();
	}
	//^2C1D:167C
	DROP_PLAYER_ITEMS(di);
	X16 bp0a = champion->playerPos();
	ObjectID bp0c = ALLOC_NEW_RECORD(0x800a);
	if (bp0c != OBJECT_NULL) {
		//^2C1D:16A0
		Miscellaneous_item *bp08 = GET_ADDRESS_OF_RECORDA(bp0c);
		bp08->ItemType(0);
		bp08->Important(1);
		bp08->Bone(di);
		MOVE_RECORD_TO(ObjectID(bp0c, bp0a), -1, 0, glbPlayerPosX, glbPlayerPosY);
	}
	//^2C1D:16F1
	FIRE_HIDE_MOUSE_CURSOR();
	champion->RuneCnt(0);
	champion->GetRunes()[0] = 0;
	champion->playerDir(U8(glbPlayerDir));
	champion->herob41 = 0;
	if (((bp0a +4 - glbPlayerDir) & 3) == _4976_5dbc)
		//^2C1D:1723
		CHAMPION_SQUAD_RECOMPUTE_POSITION();
	//^2C1D:1728
	if (champion->PoisonValue != 0)
		//^2C1D:1732
		CURE_POISON(di);
#if (DM2_EXTENDED_MODE == 1)
	if (champion->PlagueValue != 0)
		CURE_PLAGUE(di);
#endif
	//^2C1D:1739
	X16 si;
	for (si = 0; si < glbChampionsCount && glbChampionSquad[si].curHP() == 0; si++);
	//^2C1D:1754
	if (si == glbChampionsCount) {
		//^2C1D:175A
		glbPlayerDefeated = 1;
		_1031_098e();
	}
	//^2C1D:1767
	else if (di == glbChampionLeader) {
		//^2C1D:176D
		SELECT_CHAMPION_LEADER(si);
	}
	//^2C1D:1774
	_1031_0667();
	FIRE_SHOW_MOUSE_CURSOR();
	//^2C1D:177E
	return;
}
//^3A15:05F7
void SkWinCore::_3a15_05f7(X16 xx)
{
	//^3A15:05F7
	ENTER(0);
	//^3A15:05FA
	if (_4976_4762 >= 0) 
		_3a15_0486(_4976_4762);
	//^3A15:060A
	_3a15_0486(GET_TIMER_NEW_INDEX(xx));
	//^3A15:0618
	return;
}
//^2C1D:1782
void SkWinCore::PROCESS_PLAYERS_DAMAGE()
{
	// CSBwinSimilarity: TAG016e54,DisplayCharacterDamage

	//^2C1D:1782
	ENTER(16);
	//^2C1D:1788
	Champion *champion = glbChampionSquad;
	for (U16 championIndex = 0; championIndex < glbChampionsCount; championIndex++, champion++) {
		//^2C1D:1798
		champion->bodyFlag = glbChampionsBodyFlags[championIndex];
		glbChampionsBodyFlags[championIndex] = 0;
		X16 di = glbChampionsPendingDamage[championIndex];
		if (di == 0)
			continue;
		//^2C1D:17C5
		glbChampionsPendingDamage[championIndex] = 0;
		i16 si = champion->curHP();
		if (si == 0)
			continue;
		//^2C1D:17E0
		si = si -di;
		if (si <= 0) {
			CHAMPION_DEFEATED(championIndex);
			continue;
		}
		//^2C1D:17F4
		champion->curHP(si);
		champion->damageSuffered = di;
		champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x800
		si = champion->timerIndex;
		//if (si == -1) {	// SPX: or == 0xFFFF ....
		if (champion->timerIndex == TIMER_NONE) {
			//^2C1D:1810
			Timer bp10;
			bp10.TimerType(tty0C);
			bp10.SetMap(glbPlayerMap);
			bp10.SetTick(glbGameTick +5);
			bp10.actor = U8(championIndex);
			champion->timerIndex = QUEUE_TIMER(&bp10);
		}
		else {
			//^2C1D:1852
			glbTimersTable[si].SetMap(glbPlayerMap);
			glbTimersTable[si].SetTick(glbGameTick +5);
			_3a15_05f7(si);
		}
		//^2C1D:1892
	}
	//^2C1D:18A6
	return;
}
//^2C1D:210A
// SPX: _2c1d_210a renamed UPDATE_CHAMPIONS_STATS
void SkWinCore::UPDATE_CHAMPIONS_STATS()
{
	//^2C1D:210A
	ENTER(14);
	//^2C1D:2110
	if (glbChampionsCount == 0)
		return;
	//^2C1D:211A
	glbChampionTable[0].enchantmentPower += 0x38;
	if (glbChampionTable[0].enchantmentPower > 0x80U)
		glbChampionTable[0].enchantmentPower -= 0x80;
	//^2C1D:212D
	U16 bp0e = 0;	
	Champion *champion = glbChampionSquad;
	X16 bp0c;
	U16 bp0a;
	for (; bp0e < glbChampionsCount; bp0e++, champion++) {
		//^2C1D:213D
		if (champion->curHP() == 0 || bp0e +1 == glbNextChampionNumber)
			continue;
		if (champion->curMP() < champion->maxMP()) {
			//^2C1D:2164
			bp0a = QUERY_PLAYER_SKILL_LV(bp0e, SKILL_WIZARD_GLOBAL, 1) + QUERY_PLAYER_SKILL_LV(bp0e, SKILL_PRIEST_GLOBAL, 1);
			if (GET_PLAYER_ABILITY(champion, abWiz, 0) +bp0a > glbChampionTable[0].enchantmentPower) {
				//^2C1D:21A4
				X16 si = champion->maxMP() / 40;
				si++;
				if (glbIsPlayerSleeping != 0)
					si <<= 1;
				//^2C1D:21BD
				ADJUST_STAMINA(bp0e, si * max_value(7, 0x10 -bp0a));
				champion->curMP(champion->curMP() +min_value(si, champion->maxMP() -champion->curMP()));
			}
		}
		//^2C1D:21FA
		// SPX: Decrease of current mana if it exceed maximum mana
		else if (champion->curMP() > champion->maxMP()) {
			champion->curMP(champion->curMP() -1);
		}
		//^2C1D:220B
		bp0c = 4;
		i16 si = champion->maxStamina();
		for (; champion->curStamina() < (si >>= 1); bp0c += 2);
		//^2C1D:222A
		si = 0;
		X16 di = BETWEEN_VALUE(1, (champion->maxStamina() >> 8) -1, 6);
		bp0a = U16(glbGameTick) -U16(_4976_4b80);
		if (bp0a > 0x50) {
			//^2C1D:2252
			di++;
			if (bp0a > 0xfa)
				di++;
		}
		//^2C1D:225B
		if (glbIsPlayerSleeping != 0)
			di <<= 1;
		//^2C1D:2264
		do {
			bp0a = (bp0c <= 4) ? 1 : 0;
			if (champion->curFood() < FOOD_WARNING) {
				//^2C1D:227F
				if (bp0a != 0) {
					si += di;
					champion->curFood(champion->curFood() -2);
				}
			}
			else {
				//^2C1D:228E
				if (champion->curFood() >= 0)
					si -= di;
				//^2C1D:229A
				champion->curFood(champion->curFood() -((bp0a != 0) ? 2 : (bp0c >> 1)));
			}
			//^2C1D:22BC
			if (champion->curWater() < WATER_WARNING) {
				if (bp0a != 0) {
					si += di;
					champion->curWater(champion->curWater() -1);
				}
			}
			else {
				//^2C1D:22D5
				if (champion->curWater() >= 0)
					si -= di;
				//^2C1D:22E1
				champion->curWater(champion->curWater() -((bp0a != 0) ? 1 : (bp0c >> 2)));
			}
			//^2C1D:2304
		} while (--bp0c != 0 && champion->curStamina() < champion->maxStamina());

		//^2C1D:2320
		ADJUST_STAMINA(bp0e, si);
		if (champion->curFood() < FOOD_MIN)
			champion->curFood(FOOD_MIN);
		if (champion->curWater() < WATER_MIN)
			champion->curWater(WATER_MIN);
		//^2C1D:234C
		if (champion->curHP() < champion->maxHP() && champion->curStamina() >= (champion->maxStamina() >> 2) && GET_PLAYER_ABILITY(champion, abVit, 0) > glbChampionTable[0].enchantmentPower) {
			//^2C1D:2384
			di = (champion->maxHP() >> 7) +1;
			if (glbIsPlayerSleeping != 0)
				di <<= 1;
			//^2C1D:239A
			// SPX : This is the regeneration function
			champion->curHP(champion->curHP() +min_value(di, champion->maxHP() -champion->curHP()));
		}
		//^2C1D:23B5
		if ((glbGameTick & ((glbIsPlayerSleeping != 0) ? 0x3f : 0xff)) == 0) {
			//^2C1D:23CA
			for (si = ATTRIBUTE_FIRST; si <= ATTRIBUTE_LAST; si++) {	// (si = 0; si <= 6; si++)
				//^2C1D:23CE
				U8 *attributes = champion->attributes[si];	// *bp08
                U16 attrMax = attributes[ATTRIBUTE_MAX];	// bp0a
				if (attributes[ATTRIBUTE_CURRENT] < attrMax) {
					attributes[ATTRIBUTE_CURRENT]++;
				}
				else if (attributes[ATTRIBUTE_CURRENT] > attrMax) {
					attributes[ATTRIBUTE_CURRENT] -= attributes[ATTRIBUTE_CURRENT] / attrMax;
				}
				//^2C1D:241D
			}
		}
		//^2C1D:2423
		champion->heroFlag |= CHAMPION_FLAG_0800;	// 0x800
		if (bp0e +1 == glbChampionInventory)
			champion->heroFlag |= CHAMPION_FLAG_3000;	// 0x3000
		//^2C1D:243C
	}
	//^2C1D:2450
	return;
}
//^2E62:0D82
// SPX: _2e62_0d82 renamed GLOBAL_UPDATE_UNKNOW1
void SkWinCore::GLOBAL_UPDATE_UNKNOW1()
{
	//^2E62:0D82
	ENTER(2);
	//^2E62:0D86
	U8 bp01;
	if (glbLeaderHandPossession.object != OBJECT_NULL && (QUERY_GDAT_DBSPEC_WORD_VALUE(glbLeaderHandPossession.object, 0)&0x8000) != 0 && (bp01 = _2405_014a(glbLeaderHandPossession.object, -1, 1)) != _4976_57de) {
		//^2E62:0DB8
		DRAW_ITEM_IN_HAND(&glbLeaderHandPossession);
		_443c_0434();
		_4976_57de = bp01;
	}
	//^2E62:0DCE
	return;
}
//^24A5:069B
// SPX: _24a5_069b renamed BURN_PLAYER_LIGHTING_ITEMS
void SkWinCore::BURN_PLAYER_LIGHTING_ITEMS()
{
	//^24A5:069B
	ENTER(8);
	//^24A5:06A1
	X16 bRecomputeLight = 0;
	X16 iLocalChampionCount = glbChampionsCount;
	if (glbNextChampionNumber != 0)
		--iLocalChampionCount;
	Champion *xChampion = glbChampionSquad;	//*bp04
	for (; iLocalChampionCount-- != 0; xChampion++) {
		//^24A5:06BC
		X16 iInventorySlot = 2;
		for (; iInventorySlot-- != 0; ) { // go from inventory position 2 to 0 (hands)
			//^24A5:06C3
			ObjectID oItem = OBJECT_NULL; // SPX: add default init
			if ((QUERY_GDAT_DBSPEC_WORD_VALUE(oItem = xChampion->Possess(iInventorySlot), 0) & ITEM_FLAG_PRODUCE_LIGHT) == 0) // if item does not have 0x10 flag, then it does not produces light.
				continue;
			if (ADD_ITEM_CHARGE(oItem, 0) == 0)	// get current charge, if = 0, then do nothing
				continue;
			if (ADD_ITEM_CHARGE(oItem, -1) == 0) // decrease one charge
				SET_ITEM_IMPORTANCE(oItem, 0);
			//^24A5:0709
			bRecomputeLight = 1;	// Item charge has been changed
			//^24A5:070E
		}
		//^24A5:0718
	}
	//^24A5:0724
	if (bRecomputeLight != 0)
		RECALC_LIGHT_LEVEL();
	//^24A5:072E
	return;
}
//^44C8:1DFC
void SkWinCore::_44c8_1dfc(SRECT *prc, U8 colorkey)
{
	//^44C8:1DFC
	ENTER(0);
	//^44C8:1DFF
	FIRE_FILL_RECT_ANY(NULL, prc, colorkey, 0x140, 8);
	//^44C8:1E18
	return;
}
//^3929:086F
void SkWinCore::_3929_086f()
{
	//^3929:086F
	ENTER(12);
	//^3929:0875
	SRECT bp0c;
	QUERY_EXPANDED_RECT(15, &bp0c);
	X16 di = bp0c.y;
	U16 si = 0;
	for (; si < 1; si++) {
		//^3929:088B
		U32 bp04 = _4976_5c02[si];
		if (bp04 == 0xffffffff)
			continue;
		//^3929:08AA
		if (bp04 > glbGameTick)
			continue;
		//^3929:08BE
		X16 bp0a = di +(si * _4976_013a) + _4976_5c12;
		X16 bp06 = _4976_0130;
		FIRE_HIDE_MOUSE_CURSOR();
		_44c8_1dfc(&bp0c, glbPaletteT16[COLOR_BLACK]);	// SPX: Fill low text panel with BLACK
		FIRE_SHOW_MOUSE_CURSOR();
		_4976_5c02[si] = 0xffffffff;
		//^3929:0907
	}
	//^3929:0910
	return;
}
//^0CEE:04E5
X16 SkWinCore::_0cee_04e5(X16 xx, X16 yy, X16 zz, i16 ss, i16 tt)
{
	//^0CEE:04E5
	ENTER(0);
	//^0CEE:04E8
	CALC_VECTOR_W_DIR(xx, yy, zz, &ss, &tt);
	//^0CEE:0502
	return GET_TILE_VALUE(ss, tt);
}
//^2759:12E6
void SkWinCore::_2759_12e6()
{
	//^2759:12E6
	ENTER(10);
	//^2759:12EC
	i16 bp0a = -1;
	U16 si = 0;
	for (; si < glbChampionsCount; si++) {
		//^2759:12F6
		i16 di = 0;
		for (; di <= 1; di++) {
			//^2759:12FB
			sk536e *bp04 = &glbChampionEngagingHandCommand[si][di];
			if (bp04->w0 == 0)
				continue;
			//^2759:1323
			Champion *bp08 = &glbChampionSquad[si];
			if (bp08->curHP() == 0 || bp04->id4 != bp08->Possess(di)) {
				//^2759:1354
				bp04->w0 = 0;
				continue;
			}
			//^2759:135E
			if (bp04->b2 != 0) {
				bp04->b2 = 0;
				continue;
			}
			//^2759:136F
			bp04->w0--;
			bp0a = glbSelectedHandAction;
			glbSelectedHandAction = di;
			IS_ITEM_HAND_ACTIVABLE(si, bp04->id4, di);
			ENGAGE_COMMAND(si, bp04->b3|0x8000);
			glbSelectedHandAction = bp0a;
			//^2759:13A7
		}
		//^2759:13B0
	}
	//^2759:13BA
	si = glbChampionIndex;
	if (si != 0 && bp0a >= 0 && bp0a <= 1) {
		//^2759:13CF
		si--;
		IS_ITEM_HAND_ACTIVABLE(si, glbChampionSquad[si].Possess(glbSelectedHandAction), glbSelectedHandAction);
	}
	//^2759:13F1
	return;
}

//^13AE:005C
void SkWinCore::GAME_LOOP()
{
	if (SkCodeParam::bUseIngameDebug)
	{
		U8 message[64];
		sprintf((char*)message, "RAM = %08d / EMS = %08d\n", glbFreeRAMMemPool, glbFreeEMSMemPool);
		DISPLAY_HINT_TEXT(COLOR_YELLOW, message);
	}
	//^13AE:005C
	ENTER(0);
	//^13AE:0061
	glbTickSpeed = stdTickBalance;
	glbGameHasEnded = 0;
	FILL_ORPHAN_CAII();
	X16 si;
	while (true)
	{
		// SPX get speed from window menu
		stdTickBalance = skwin.spfact*4;
		glbTickSpeed = stdTickBalance;
		// SPX

		//^13AE:0072
		glbIntermediateTickCounter = 0;
		if (glbMapToLoad == 0xffff)
			goto _00a4;
		while (true)
		{
			//^13AE:007F
			LOAD_NEWMAP(U8(glbMapToLoad));
			MOVE_RECORD_TO(OBJECT_NULL, -1, 0, glbPlayerPosX, glbPlayerPosY);
			glbMapToLoad = 0xffff;
			//^13AE:00A4
_00a4:
			PROCEED_TIMERS();
			if (glbMapToLoad != 0xffff)
				continue;
			break;
		}
		//^13AE:00B0
		UPDATE_WEATHER(0);
		
		SkD((DLV_DBG_RAIN, "Loop (Rain) >> lvl=%03d / strm=%03d / wet=%03d (r2:%d r3:%d mlt:%d) / tick=%d\n"
			, glbRainStrength, glbRainStormController
			, glbRainLevelForGround
			, glbRainRelated2, glbRainRelated3, glbRainMultiplicator
			, glbGameTick
			));

		if (glbIsPlayerSleeping == 0) {
			//^13AE:00C2
			if (glbNextChampionNumber == 0)
				//^13AE:00C9
				_38c8_0060();
			//^13AE:00CE
			if (glbChampionInventory == 0) {
				//^13AE:00D5
				if (glbDoLightCheck != 0)
					//^13AE:00DC
					CHECK_RECOMPUTE_LIGHT(glbPlayerPosX, glbPlayerPosY);
				//^13AE:00EB
				if (glbIsPlayerMoving != 0)
					//^13AE:00F2
					DISPLAY_VIEWPORT(_4976_4c40, _4976_4c32, _4976_4c34);
				else
					//^13AE:0100
					DISPLAY_VIEWPORT(glbPlayerDir, glbPlayerPosX, glbPlayerPosY);
				//^13AE:0114
				CHANGE_VIEWPORT_TO_INVENTORY(1);
				_4976_4bc8 = 0;
			}
			//^13AE:0122
			if (glbIsPlayerMoving != 0) {
				//^13AE:0129
				if (glbIsPlayerMoving == 1) {
					//^13AE:0130
					printf("Pending PERFORM MOVE\n");
					PERFORM_MOVE(glbPlayerLastMove);
				}
				//^13AE:013A
				glbIsPlayerMoving--;
			}
			//^13AE:013E
			_4976_4e64 = 0;
			if (glbShowMousePointer != 0) {
				//^13AE:014B
				glbShowMousePointer = 0;
				_443c_0434();
			}
			//^13AE:0156
			IBMIO_USER_INPUT_CHECK();
		}
		//^13AE:015B
		_12b4_0092();
		_482b_05bf(0);
		PROCESS_PLAYERS_DAMAGE();
		if (glbGlobalSpellEffects.AuraOfSpeed != 0)
			//^13AE:0174
			glbGlobalSpellEffects.AuraOfSpeed--;
		/// SPX: glbGameTick is a general tick counter : each 16 or 64 then do update
		if ((X16(glbGameTick) & ((glbIsPlayerSleeping != 0) ? 15 : 0x3f)) == 0)
			//^13AE:018D
			UPDATE_CHAMPIONS_STATS();
		//^13AE:0192
		GLOBAL_UPDATE_UNKNOW1();
		_2e62_0cfa(1);
		if (glbPlayerDefeated != 0)
			return;
		glbGameTick++;
		ATLASSERT(ValidateMements());
		PROCESS_QUEUED_DEALLOC_RECORD();
		//^13AE:01B3
		SkD((DLV_SYS,"SYS: Tick increased to %u ------------------------------\n", (Bitu)glbGameTick));
		SkD((DLV_DBG_SEED,"DBG: t %08X Seed %08X \n", (Bitu)glbGameTick, (Bitu)glbRandomSeed));
		SkD((DLV_DBG_SED3,"DBG: v %02X,%02X,%02X,%02X,%02X,%02X,%02X,%02X \n"
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].Command
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].b27
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].b28
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].b29
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].ItemToThrow
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].b31
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].b32
			, (Bitu)(Bit8u)glbTabCreaturesInfo[1].b33
			));
		if ((X16(glbGameTick) & 0x1ff) == 0)	// every 511 tick, burn lighting items
			//^13AE:01BB
			BURN_PLAYER_LIGHTING_ITEMS();
		//^13AE:01C0
		// SPX: This is the freeze value
		if (glbGlobalSpellEffects.FreezeCounter != 0)
		{
			//^13AE:01C7
			glbGlobalSpellEffects.FreezeCounter = glbGlobalSpellEffects.FreezeCounter -1;
		}
		//^13AE:01CF
		if (_4976_4c00 != 0)
			_4976_4c00--;
		//^13AE:01DA
		if (glbPlayerThrowCounter != 0)
			glbPlayerThrowCounter--;
		//^13AE:01E5
		_3929_086f();
		glbTickStepReached = 0;
		_12b4_0092();
		if (false) {
			//^13AE:01F7
_01f7:
			_1031_0d36(0x20, _476d_050e());
		}
		MessageLoop(true); // in game
		do {
			//^13AE:0206
			if (_476d_05a9() != 0) {
				//^13AE:020D
				goto _01f7;
			}
			//^13AE:020F
			if (_4976_4c3e != 0) {
				//^13AE:0216
				X16 di;
				di = _0cee_04e5(glbPlayerDir, 1, 0, glbPlayerPosX, glbPlayerPosY);
				if ((di >> 5) != 6 || (di & 1) == 0 || (di & 4) != 0) {
					//^13AE:0247
					_4976_4c3e = 0;
					FIRE_MOUSE_RELEASE_CAPTURE();
					glbMouseVisibility = 1;
					FIRE_SHOW_MOUSE_CURSOR();
				}
			}
			//^13AE:025D
			MAIN_LOOP();
			//^13AE:0262

			MessageLoop(false); // in game

		} while (glbTickStepReached == 0 || _4976_4c02 == 0);
		//^13AE:0270
		si = glbMapToLoad;
		if (si != 0xffff) {
			//^13AE:027A
			si = glbCurrentMapIndex;
			CHANGE_CURRENT_MAP_TO(glbMapToLoad);
		}
		//^13AE:0288
		_2759_12e6();
		//^13AE:028D
		if (si != 0xffff) {
			//^13AE:0295
			CHANGE_CURRENT_MAP_TO(si);
		}
		//DM2DOS_R_BA7(ddata.v1e0266);
		//if (si != 0xFFFF)
			skmidi->REQUEST_PLAY_MUSIC(glbPlayerMap);
		continue;
	}
	//^13AE:029F
	return;
}

//^13AE:02A3
// SPX: _13ae_02a3 renamed FIRE_MAIN
i16 SkWinCore::FIRE_MAIN(i16 argc, char **argv, char **env) //#DS=4976
{
	//^13AE:02A3
	ENTER(0);
	//^13AE:02A7
#if UseAltic
	;
#else
	i16 si;
	for (si = 1; si < argc; si++) {
		//^13AE:02AD
		if (argv[si][0] == '+') {
			//^13AE:02C0
			if (_069a_035b(argv[si][1]) == 'G') {
				//^13AE:02DE
				if (_069a_035b(argv[si][2]) == 'L') {
					//^13AE:02FE
					switch (_069a_035b(argv[si][3])) {
						case 'C': //^_0323
							_4976_4806 = 0x60;
							break;
						case 'K': //^_032a
							_4976_4806 = 0x50;
							break;
					}
				}
			}
		}
		//^13AE:032F
	}
	//^13AE:0338
	if (_sk_setjmp(_4976_4de0) == 0) {
	    _4726_03b2();
		_38c8_04aa();
		while (true) {
			GAME_LOOP();
			END_GAME(glbPlayerDefeated);
		}
	}
	//^13AE:0361
#endif

	//^13AE:0338
    _4726_03b2();	// _4726_03b2
	INIT();	// _38c8_04aa

	// SPX: Add some more init here, just before starting the GAME_LOOP
	al_init();
	al_install_audio();
	al_init_acodec_addon();
	EXTENDED_LOAD_SPELLS_DEFINITION();
	EXTENDED_LOAD_DM1_ITEM_CONVERSION_LIST();

	while (true) {
		GAME_LOOP();
		END_GAME(glbPlayerDefeated);
	}
	//^13AE:0361
	return 0;
}


//^069A:0000
int SkWinCore::FIRE_BOOTSTRAP() //#DS=089C
{
	//^069A:0000
	// 4F75:0FE8  F8 0F 75 4F/04 10 75 4F/08 10 75 4F/00 00 00 00  EuO..uO..uO....
	// 4F75:0FF8  43 3A 5C 46 49 52 45 2E 45 58 45 00 2B 70 6D 00  C:\FIRE.EXE.+pm.
	// 4F75:1008  2B 73 62 00 75 49 00 00 5A 00 00 88 4F 00 00 00  +sb.uI..Z..E...
	skmidi = new SkWinMIDI(skwin.dung);
	char *argv[] = {"FIRE.exe", "+pm", "+sb"};
	return (FIRE_MAIN(3, argv, NULL));
}

//^0088:0230
i16 SkWinCore::SK88_TOUPPER(i16 c)
{
	//^0088:0230
	ENTER(0);
	//^0088:0233
    i16 dx = c;
	if (dx == -1)
		return -1;
	//^0088:0240
	U8 dl = U8(dx);
	if ((_04bf_067f[dl] & 8) != 0)
		//^0088:024D
		return dl -0x20;
	//^0088:0256
	return dl;
}
//^0088:02BB
U8* SkWinCore::SK88_STRCPY(U8 *strDestination, const U8 *strSource) {
	return reinterpret_cast<U8 *>(strcpy(
		reinterpret_cast<char *>(strDestination), 
		reinterpret_cast<const char *>(strSource)
		));
}
//^0088:027C
U8* SkWinCore::SK88_STRCAT(U8 *strDestination, const U8 *strSource) {
	return reinterpret_cast<U8 *>(strcat(
		reinterpret_cast<char *>(strDestination), 
		reinterpret_cast<const char *>(strSource)
		));
}
//^01B0:2B27
i16 SkWinCore::IBMIO_EXEC(const U8 *exe, const U8 *arg) {
	SkD((DLV_FYI, "EXEC: %s %s\n", exe, arg));
	if (_stricmp(reinterpret_cast<const char *>(exe), "FIRE.exe") == 0) {
		return FIRE_BOOTSTRAP();
	}
	if (_stricmp(reinterpret_cast<const char *>(exe), "anim") == 0) {
		if (_stricmp(reinterpret_cast<const char *>(arg), "swoosh +pm +sb") == 0) {
			return ANIM_BOOTSTRAP_SWOOSH();
		}
		else if (_stricmp(reinterpret_cast<const char *>(arg), "title +ah +as +ab +pm +sb") == 0) {
			return ANIM_BOOTSTRAP_TITLE();
		}
	}
	return 0;
}
//^01B0:2C1C
void SkWinCore::IBMIO_PRINT_ERROR(const U8 *str) //#DS=04BF
{
#if UseAltic
	fputs(reinterpret_cast<const char *>(str), stdout);
#else
	//^01B0:2C1C
	ENTER(2);
	//^01B0:2C20
	LOADDS(0x3083);

	// int 10h
	// http://hp.vector.co.jp/authors/VA003720/lpproj/int10h/int10h.htm

	// int 21h
	// http://www2.neweb.ne.jp/wd/wonder/codea.htm

	//^01B0:2C26
	__asm mov ah,0x00
	__asm mov al,0x13
	__asm int 0x10
	//^01B0:2C2C
	U8 bp01;
	while ((bp01 = *(str++)) != 0) {
		//^01B0:2C2E
		__asm mov dl,[bp01]
		__asm mov ah,2
		__asm int 0x21
	}
	//^01B0:2C46
	return;
#endif
}
void SkWinCore::_0088_020b(X16 xx) { // TODO: Unr
	Unr();
}
//^01B0:2BE0
U16 SkWinCore::IBMIO_CHECK_CPU_ERA() {
	return 386;
}

void SkWinCore::_sys_setvect(i16 interruptno, void (SkWinCore::*isr)()) {
	intrvect[interruptno & 255] = isr;
}

//	void (SkWinCore::*_089c_0340)();
//void (sksave_converter::*_sys_getvect(U16 interruptno))() {
//void (SkWinCore::*_sys_getvect(U16 interruptno))() {
//void (SkWinCore::*pfn)() SkWinCore::_sys_getvect(U16 interruptno) {
void (SkWinCore::*SkWinCore::_sys_getvect(U16 interruptno))() {
	return intrvect[interruptno & 255];
}

//^0088:026B
void SkWinCore::_crt88_setvect(i16 interruptno, void (SkWinCore::*isr)()) {
#if UseAltic
	_sys_setvect(interruptno, isr);
#else
#error	Unr
#endif
}
//^01B0:1F3D
U16 SkWinCore::IBMIO_DETECT_SBLASTER()
{
#if UseAltic
	return 1;
#else
	//^01B0:1F3D
	ENTER(2);
	//^01B0:1F41
	U16 bp02 = 0x210;
	for (; bp02 < 0x260; bp02 += 16) {
		//^01B0:1F49

		xxx;
		//^01B0:1FE3
	}
	//^01B0:1FF1
	return 0;
#endif
}
//^00EB:0C21
void SkWinCore::IBMIO_INIT_VID()
{
#if UseAltic
	_04bf_09de = 0;
#else
	//^00EB:0C21
	ENTER(0);
	//^00EB:0C24
	_crt88_setvect(255, _04bf_0090);
	__asm mov ah,0xf
	__asm int 0x10
	__asm mov _04bf_09de, al
	__asm mov ah,0
	__asm mov al,0x13
	__asm int 0x10
	//^00EB:0C4A
	return;
#endif
}
//^01B0:0A6A
X16 SkWinCore::IBMIO_INIT_MOUSE()
{
#if UseAltic
	return _04bf_18b2 = 1;
#else
	//^01B0:0A6A
	ENTER(0);
	//^01B0:0A6D

	// int 33h
	// http://www2.muroran-it.ac.jp/circle/mpc/old/pc98dos/mouse/mouse.html

	__asm mov ax,0
	__asm int 0x33
	__asm mov _04bf_18b2, ax
	if (_04bf_18b2 == 1) {
		__asm mov cx,0
		__asm mov dx,0
		__asm int 0x33
		__asm mov cx,0
		__asm mov dx,0x27f
		__asm mov ax,0x7
		__asm int 0x33
		__asm mov cx,0
		__asm mov dx,0xc7
		__asm mov ax,0x8
		__asm int 0x33
	}
	//^01B0:0AA3
	return _04bf_18b2;
#endif
}
void SkWinCore::_04bf_0090() { // TODO: Unr
	Unr();
}
//^01B0:08D8
void SkWinCore::_01b0_08d8()
{
	//^01B0:08D8
	ENTER(0);
	//^01B0:08DB
	_04bf_17a2 = 1;
	_04bf_03c6 = 0;
	_04bf_17a8 = 0;
	_04bf_1850 = 0;
	sysMousePositionCaptured = 0;
	_04bf_0e7a = 0;
	_04bf_179c = _04bf_0e50 = 0;
	_04bf_17a4 = 0;
	_04bf_1934 = 0;
	_04bf_1938 = 0;
	//^01B0:091C
	return;
}
//^01B0:091E
void SkWinCore::IBMIO_SET_MOUSE_HANDLER()
{
#if UseAltic
	//^01B0:091E
	ENTER(0);
	//^01B0:0923
	if (_04bf_18b2 == 0)
		return;
	//^01B0:0935
	_01b0_092d = _int33_mouse_callback;
	glbMouseXPos = mice_x;
	glbMouseYPos = mice_y;
	_int33_mouse_callback = &SkWinCore::IBMIO_MOUSE_HANDLER;
	//^01B0:0982
	//^01B0:0A2F
	_04bf_03d4 = 1;
	//^01B0:0A35
	return;
#else
#error	Unr
#endif
}

//^01B0:0985
void SkWinCore::IBMIO_MOUSE_HANDLER()
{
	X16 bx = mice_btn; // buttons
	X16 cx = mice_x; // x
	X16 dx = mice_y; // y

	// SkD((DLV_BUGHERE,"DBG: M(%3d,%3d) C(%3d,%3d) P(%3d,%3d)\n", glbMouseXPos, glbMouseYPos, cx, dx, glbMousePreviousXPos, glbMousePreviousYPos));

	//^01B0:0985
	if (_01b0_0933 == 0) {
		//^01B0:0990
		bx &= 3;
		if (sysMousePositionCaptured != 0) {
			cx = glbMouseXPos;
			dx = glbMouseYPos;
		}
		//^01B0:09B3
		if (_04bf_0e7a == 0) {
			//^01B0:09BE
			IBMIO_MOUSE_EVENT_RECEIVER(cx, dx, bx);
		}
		//^01B0:09CC
		else if (_04bf_17a4 < 10) {
			//^01B0:09D3
			X16 di;
			if (_04bf_17a4 != 0 && _04bf_17ac[di = _04bf_0e50].w0 == bx) {
				//^01B0:09EC
				_04bf_17ac[di].w2 = cx;
				_04bf_17ac[di].w4 = dx;
			}
			else {
				//^01B0:09F7
				_04bf_17a4++;
				X16 di = _04bf_0e50 +1;
				//^01B0:0A00
				if (di == 10)
					di = 0;
				//^01B0:0A08
				_04bf_0e50 = di;
				_04bf_17ac[_04bf_0e50].w0 = bx;
				_04bf_17ac[_04bf_0e50].w2 = cx;
				_04bf_17ac[_04bf_0e50].w4 = dx;
			}
		}
		//^01B0:0A23
		//^01B0:0A24
	}
	//^01B0:0A2E
}
//^01B0:0426
void SkWinCore::INIT_KBOARD_HOOK() //#DS=04BF
{
#if UseAltic
	//^01B0:0426
	ENTER(0);
	//^01B0:042B
	_04bf_1886 = 0;
	_04bf_1864 = 0;
	_04bf_185a = 0;
	_04bf_0e7e = 0;
	_04bf_185c = 0;
	_04bf_18a8 = 0;
	_04bf_1862 = 0;
	//^01B0:0457
	_01b0_0453 = _sys_getvect(0x09);
	_sys_setvect(0x09, &SkWinCore::IBMIO_KBOARD_HANDLER);
	//^01B0:0475
	//^01B0:04B5
	_04bf_02bc = 1;
	//^01B0:04BB
	return;
#else
#error	Unr
#endif
}
//^01B0:0478
void SkWinCore::IBMIO_KBOARD_HANDLER() { //#DS=04BF
#if UseAltic
	//^01B0:0478
	//^01B0:0482
	LOADDS(0x3083);
	_01b0_00fc();
	if (glbDMode == 0) {
		//^01B0:0499
		// MessageBeep(-1);
		return;
	}
	return;
#else
#error	Unr
#endif
}

//^01B0:00CE
void SkWinCore::_01b0_00ce(X16 xx)
{
	//^01B0:00CE
	ENTER(0);
	//^01B0:00D1
	if (_04bf_1886 < 10) {
		//^01B0:00DA
		_04bf_188e[_04bf_185a] = xx;
		_04bf_185a = (_04bf_185a +1) % 10;
		_04bf_1886++;
	}
	//^01B0:00F9
	//^01B0:00FA
	return;
}

//^01B0:00FC
void SkWinCore::_01b0_00fc()
{
	//^01B0:00FC
	ENTER(6);
	//^01B0:0102
	do {
		U16 bp06 = inportb(0x60);
		if (bp06 == 0xe0) {
			//^01B0:0110
			_04bf_0e7e |= 0x1000;
			continue;
		}
		//^01B0:0119
		X16 si = 0;
		U16 *bp04;
		if ((_04bf_0e7e & 0x1000) != 0) {
			//^01B0:0123
			bp04 = _04bf_0e6a;
			si = 1;
		}
		else {
			//^01B0:0130
			bp04 = _04bf_0e54;
			if ((_04bf_0e7e & 0x800) != 0) {
				//^01B0:0140
				_04bf_1862 = 1;
				switch (bp06) {
				case 72://^0158
					//^01B0:0158
					_04bf_18a8 |= 1; break;
				case 75://^015F
					//^01B0:015F
					_04bf_18a8 |= 4; break;
				case 77://^0166
					//^01B0:0166
					_04bf_18a8 |= 8; break;
				case 80://^016D
					//^01B0:016D
					_04bf_18a8 |= 2; break;
				case 71://^0174
					//^01B0:0174
					_04bf_18a8 |= 0x20; break;
				case 73://^017B
					//^01B0:017B
					_04bf_18a8 |= 0x40; break;
				case 79://^0182
					//^01B0:0182
					_04bf_18a8 |= 0x80; break;
				case 81://^018A
					//^01B0:018A
					_04bf_18a8 |= 0x100; break;
				case 78://^0192
					//^01B0:0192
					_04bf_18a8 |= 0x10; break;
				case 74://^0199
				case 76://^0199
				default:
					//^01B0:0199
					_04bf_1862 = 0; break;
				}
			}
		}
		//^01B0:019F
		if (_04bf_1862 == 0) {
			//^01B0:01AB
			if ((_04bf_0e7e & 0x1000) == 0) {
				//^01B0:01B8
				X16 di = bp06;
				switch (di) {
				case 0x2A://^01D1
					//^01B0:01D1
					_04bf_0e7e = _04bf_0e7e|0x8000; break;
				case 0x36://^01DD
					//^01B0:01DD
					_04bf_0e7e |= 0x4000; break;
				case 0x1D://^01E5
					//^01B0:01E5
					_04bf_0e7e |= 0x400; break;
				case 0x38://^01ED
					//^01B0:01ED
					_04bf_0e7e |= 0x800; break;
				case 0xAA://^01F5
					//^01B0:01F5
					_04bf_0e7e = _04bf_0e7e & 0x7fff; break;
				case 0xB6://^01FD
					//^01B0:01FD
					_04bf_0e7e &= 0xbfff; break;
				case 0x9D://^0205
					//^01B0:0205
					_04bf_0e7e &= 0xfbff; break;
				case 0xB8://^020D
					//^01B0:020D
					_04bf_0e7e &= 0xf7ff; break;
				case 0xC8://^0215
					//^01B0:0215
					_04bf_18a8 &= 0xfffe; break;
				case 0xCB://^021D
					//^01B0:021D
					_04bf_18a8 &= 0xfffb; break;
				case 0xCD://^0225
					//^01B0:0225
					_04bf_18a8 &= 0xfff7; break;
				case 0xD0://^022D
					//^01B0:022D
					_04bf_18a8 &= 0xfffd; break;
				case 0xC7://^0235
					//^01B0:0235
					_04bf_18a8 &= 0xffdf; break;
				case 0xC9://^023D
					//^01B0:023D
					_04bf_18a8 &= 0xffbf; break;
				case 0xCF://^0245
					//^01B0:0245
					_04bf_18a8 &= 0xff7f; break;
				case 0xD1://^024D
					//^01B0:024D
					_04bf_18a8 &= 0xfeff; break;
				case 0xCE://^0255
					//^01B0:0255
					_04bf_18a8 &= 0xffef; break;
				default:
					//^01B0:025D
					si = 1; break;
				}
			}
			//^01B0:0260
			if (si != 0 && (bp06 & 0x80) == 0) {
				//^01B0:0275
				switch (bp06) {
					case 0x3b://^_0284
						//^01B0:0284
						if (_04bf_0296 > 0)
							_04bf_0296--;
						//^01B0:028F
		_028f:
						_04bf_0298 = _04bf_029c[RCJ(8,_04bf_0296)];
						_04bf_029a = _04bf_02ac[RCJ(8,_04bf_0298)];
						break;
					case 0x3c://^_02ab
						//^01B0:02AB
						if (_04bf_0296 < 7)
							_04bf_0296++;
						goto _028f;
					default: //^_02ba
						//^01B0:02BA
						if ((bp04[(bp06 >> 4)&7] & (1 << (bp06&15))) == 0) {
							//^01B0:02DA
							_01b0_00ce((_04bf_0e7e & 0x1e00)|bp06);
							break;
						}
				}
			}
		}
		//^01B0:02EB
		if ((bp06 & 0x80) != 0) {
			//^01B0:02F2
			bp04[(bp06 >> 4)&7] &= ~(1 << (bp06&15));
		}
		else {
			//^01B0:0314
			bp04[(bp06 >> 4)&7] |=   1 << (bp06&15);
		}
		//^01B0:0332
		if ((_04bf_0e7e & 0x8000) != 0 || (_04bf_0e7e & 0x4000) != 0) {
			//^01B0:0342
			_04bf_0e7e |= 0x200;
		}
		else {
			//^01B0:034A
			_04bf_0e7e &= 0xfdff;
		}
		//^01B0:0350
		if ((_04bf_18a8 & 0x61) != 0) {
			//^01B0:0358
			_04bf_185c |= 1;
		}
		else {
			//^01B0:035F
			_04bf_185c &= 0xfffe;
		}
		//^01B0:0365
		if ((_04bf_18a8 & 0x182) != 0) {
			//^01B0:036D
			_04bf_185c |= 2;
		}
		else {
			//^01B0:0374
			_04bf_185c &= 0xfffd;
		}
		//^01B0:037A
		if ((_04bf_18a8 & 0x148) != 0) {
			//^01B0:0382
			_04bf_185c |= 8;
		}
		else {
			//^01B0:0389
			_04bf_185c &= 0xfff7;
		}
		//^01B0:038F
		if ((_04bf_18a8 & 0xa4) != 0) {
			//^01B0:0397
			_04bf_185c |= 4;
		}
		else {
			//^01B0:039E
			_04bf_185c &= 0xfffb;
		}
		//^01B0:03A4
		if ((_04bf_18a8 & 0x10) != 0) {
			//^01B0:03AC
			_04bf_185c |= 0x10;
		}
		else {
			_04bf_185c &= 0xffef;
		}
		//^01B0:03B9
		_04bf_0e7e &= 0xefff;
		//^01B0:03BF
	} while ((inportb(0x64) & 2) != 0);
	//^01B0:03C8
	return;
}

void SkWinCore::_01b0_18ae() { // TODO: Unr
	Unr();
}
X16 SkWinCore::_01b0_292b() { // TODO: Unr
	Unr(); return 0;
}
void SkWinCore::_01b0_237f() { // TODO: Unr
	Unr();
}
//^01B0:20FF
void SkWinCore::_01b0_20ff()
{
	//^01B0:20FF
	ENTER(0);
	//^01B0:2102
    if (glbCounterZero_0517 == 0)
		return;
	if (glbSomeCounter_0519 <= 0) {
		do {
			//^01B0:2119
			glbSomeCounter_0519 += _01b0_292b() * 240;
			//^01B0:212C
		} while (glbSomeCounter_0519 <= 0);
		//^01B0:213C
		if (_04bf_0e64 != 0) {
			//^01B0:2143
			_04bf_18a4 = 0;
			_01b0_237f();
			glbCounterZero_0517 = 0;
		}
	}
	else {
		//^01B0:2156
		glbSomeCounter_0519 -= glbDecreasing120;
	}
	//^01B0:2162
	return;
}

//^01B0:0E2C
U16 SkWinCore::_01b0_0e2c()
{
	//^01B0:0E2C
	ENTER(0);
	//^01B0:0E2C
	outportb(0x43,0x80);
	U8 al = inportb(0x42);
	U8 ah = inportb(0x42);
	return (ah<<8)|al;
	//^01B0:0E43
}

//^01B0:0E27
X16 SkWinCore::_01b0_0e27(X16 xx) 
{
	//^01B0:0E27
	ENTER(0);
	//^01B0:0E2A
	while ((inportb(0x0201) & 3) != 0) {
	}
	U16 tmp0 = _01b0_0e2c();
	outportb(0x0201, U8(tmp0));
	U8 al;
	U8 bl = U8(xx);
	while ((bl & (al = inportb(0x0201))) != 0) {
	}
	if (bl >= al) {
		U16 tmp1 = _01b0_0e2c();
		if (tmp0 < tmp1) {
			return 0xffff -tmp1 +tmp0;
		}
		else {
			return tmp1 -tmp0;
		}
	}
	else {
		return 0;//unstable value
	}
	//^01B0:0E7E
}

//^01B0:0FA3
void SkWinCore::_01b0_0fa3()
{
	//^01B0:0FA3
	ENTER(0);
	//^01B0:0FA7
	if (glbPType == 1 && sysMousePositionCaptured == 0 && sysSomeSemaphore == 0) {
		//^01B0:0FCB
		sysSomeSemaphore = 1;
		outportb(0x20,0x20);
		if ((_04bf_0e4c++ & 1) != 0) {
			//^01B0:0FE2
			_04bf_1798 = (_01b0_0e27(1) -100) / _04bf_0298;
		}
		else {
			//^01B0:0FF6
			_04bf_03c8 = _04bf_1798;
			if (_04bf_03c8 > 0x13f) {
				//^01B0:1004
				_04bf_03c8 = 0x13f;
			}
			//^01B0:100C
			else if (_04bf_03c8 < 0) {
				//^01B0:1013
				_04bf_03c8 = 0;
			}
			//^01B0:1019
			_04bf_03ca = (_01b0_0e27(2) -100) / _04bf_029a;
			if (_04bf_03ca > 0xc7) {
				//^01B0:1033
				_04bf_03ca = 0xc7;
			}
			//^01B0:103B
			else if (_04bf_03ca < 0) {
				//^01B0:1042
				_04bf_03ca = 0;
			}
		}
		//^01B0:1048
		_04bf_03d0 = inportb(0x201);
		_04bf_03d0 = ((_04bf_03d0 >> 4) ^ 3)&3;
		sysSomeSemaphore = 0;
	}
	else {
		//^01B0:1067
		if (glbPType != 2 && glbPType != 3)
			return;
		//^01B0:107A
		_04bf_179a = (glbSoundBlasterBasePort != 0 && glbPType == 2) ? (inportb(_01b0_3378 +1)) : 0x78;
		//^01B0:109B
		if (_04bf_03d2 == 1) {
			if ((_04bf_179a & 0x80) == 0) {
				//^01B0:10A9
				_04bf_03d2 = 0;
			}
			//^01B0:10B1
			else if (((_04bf_179a ^ _04bf_0e4a)&0x78) != 0) {
				//^01B0:10BC
				if ((_04bf_179a & 8) == 0) {
					//^01B0:10C3
					_01b0_00ce(0x48);
				}
				else if ((_04bf_179a & 16) == 0) {
					//^01B0:10CE
					_01b0_00ce(0x50);
				}
				else if ((_04bf_179a & 32) == 0) {
					//^01B0:10D9
					_01b0_00ce(0x47);
				}
				else if ((_04bf_179a & 64) == 0) {
					//^01B0:10E4
					_01b0_00ce(0x49);
				}
			}
		}
		//^01B0:10EB
		if (_04bf_03d2 == 0) {
			//^01B0:10F7
			if (sysMousePositionCaptured == 0) {
				//^01B0:1103
				if ((_04bf_179a & 0x78) != 0x78 || (_04bf_185c & 15) != 0) {
					//^01B0:111D
					if ((_04bf_179a & 8) == 0 || (_04bf_185c & 1) != 0) {
						//^01B0:112C
						_04bf_03ca -= ((++_04bf_03ce +1) / 3) +1;
					}
					//^01B0:113F
					if ((_04bf_179a & 0x10) == 0 || (_04bf_185c & 2) != 0) {
						//^01B0:114E
						_04bf_03ca += ((++_04bf_03ce +1) / 3) +1;
					}
					//^01B0:1161
					if ((_04bf_179a & 0x40) == 0 || (_04bf_185c & 8) != 0) {
						//^01B0:1170
						_04bf_03c8 += ((++_04bf_03cc +1) / 3) +1;
					}
					//^01B0:1183
					if ((_04bf_179a & 0x20) == 0 || (_04bf_185c & 4) != 0) {
						//^01B0:1192
						_04bf_03c8 -= ((++_04bf_03cc +1) / 3) +1;
					}
				}
				//^01B0:11A5
				if (_04bf_03cc > 0x64)
					//^01B0:11AC
					_04bf_03cc = 0x64;
				//^01B0:11B2
				if (_04bf_03ce > 0x64)
					//^01B0:11B9
					_04bf_03ce = 0x64;
				//^01B0:11BF
				if (_04bf_03c8 < 0)
					//^01B0:11C6
					_04bf_03c8 = 0;
				//^01B0:11CC
				if (_04bf_03c8 > 0x13f)
					//^01B0:11D4
					_04bf_03c8 = 0x13f;
				//^01B0:11DA
				if (_04bf_03ca < 0)
					//^01B0:11E1
					_04bf_03ca = 0;
				//^01B0:11E7
				if (_04bf_03ca > 0xc7)
					//^01B0:11EF
					_04bf_03ca = 0xc7;
			}
			//^01B0:11F5
			if (((_04bf_179a ^ _04bf_0e4a)&0x18) != 0)
				//^01B0:1200
				_04bf_03ce = 0;
			//^01B0:1206
			if (((_04bf_179a ^ _04bf_0e4a)&0x60) != 0)
				//^01B0:1211
				_04bf_03cc = 0;
			//^01B0:1217
			if (((_04bf_185c ^ _04bf_18a6)&3) != 0)
				//^01B0:1223
				_04bf_03ce = 0;
			//^01B0:1229
			if (((_04bf_185c ^ _04bf_18a6)&12) != 0)
				//^01B0:1235
				_04bf_03cc = 0;
			//^01B0:123B
			_04bf_03d0 = ((_04bf_179a >> 7) & 1) | ((_04bf_185c >> 4) & 1);
			if ((_04bf_179a & 0x80) != 0) {
				//^01B0:125C
				if ((_04bf_03c8 >= 0xe8 && _04bf_03c8 <= 0x13f && _04bf_03ca >= 0x7b && _04bf_03ca <= 0xa8) || _04bf_03ca > 0xa8)
					//^01B0:1283
					_04bf_03d2 = 1;
			}
		}
		//^01B0:1289
		_04bf_0e4a = _04bf_179a;
		_04bf_18a6 = _04bf_185c;
	}
	//^01B0:1295
	X16 cx = _04bf_03c8;
	X16 dx = _04bf_03ca;
	X16 bx = _04bf_03d0;
	if (_04bf_0e7a == 0) {
		//^01B0:12AC
		IBMIO_MOUSE_EVENT_RECEIVER(cx, dx, bx);
		return;
	}
	//^01B0:12BA
	if (_04bf_17a4 < 10) {
		//^01B0:12C1
		X16 di;
		if (_04bf_17a4 != 0) {
			//^01B0:12C8
			di = _04bf_0e50;
			if (_04bf_17ac[di].w0 == bx) {
				//^01B0:12DA
				_04bf_17ac[di].w2 = cx;
				_04bf_17ac[di].w4 = dx;
				return;
			}
		}
		//^01B0:12E5
		_04bf_17a4++;
		di = _04bf_0e50 +1;
		//^01B0:12EE
		if (di == 10)
			di = 0;
		//^01B0:12F6
		_04bf_0e50 = di;
		_04bf_17ac[di].w0 = bx;
		_04bf_17ac[di].w2 = cx;
		_04bf_17ac[di].w4 = dx;
		return;
	}
	//^01B0:1312
	return;
}

//^01B0:180C
void SkWinCore::_01b0_180c() {
	//^01B0:180C
	LOADDS(0x3083);
	if (glbDMode == 0 || _04bf_0284 != 0) {
		//^01B0:1823
		_01b0_14d8++;
		if ((_01b0_14d8 & 3) == 0) {
			//^01B0:1830
			(this->*_04bf_18ae)(); INDIRECT_CALL
		}
	}
	//^01B0:1834
	_01b0_20ff();
	//^01B0:183D
	bool carry = U16(_01b0_13c6) < U16(_01b0_13ca);
	_01b0_13c6 -= _01b0_13ca;
	//^01B0:1846
	U16 bx = _01b0_13c8;
	if (bx != _01b0_13ca) {
		//^01B0:1854
		// __asm mov al,0x36
		// __asm out 0x43,al
		// __asm mov al,bl
		// __asm out 0x40,al
		// __asm mov al,bh
		// __asm out 0x40,al
		//^01B0:1861
		_01b0_13ca = bx;
		glbSoundFreq_13cc = glbSoundFreq_13ce;
	}
	//^01B0:186E
	if (!carry) {
		//^01B0:1872
		// __asm mov al,0x20
		// __asm out 0x20,al
		return;
	}
	//^01B0:1878
	LOADDS(0x3083);
	_01b0_0fa3();
	(this->*_01b0_13be)();
}

//^01B0:14EB
void SkWinCore::_INT08_HANDLER() {
	//^01B0:14EB
	_01b0_180c();
}

//^01B0:1315
void SkWinCore::IBMIO_INIT_TIMER()
{
	//^01B0:1315
	ENTER(2);
	//^01B0:131B
	if (glbPType == 1) {
		//^01B0:1322
		// __asm mov al,0xb6
		// __asm out 0x43,al
		// __asm mov al,0
		// __asm out 0x42,al
		// __asm out 0x42,al
		// __asm in al,0x61
		// __asm or al,0x1
		// __asm out 0x61,al
		//^01B0:1335
	}
	else if (glbPType == 2 && glbSoundBlasterBasePort != 0) {
		//^01B0:1345
		// __asm mov dx,glbSoundBlasterBasePort
		// __asm add dx,0x2
		// __asm mov al,4
		// __asm out dx,al
	}
	//^01B0:134F
	_01b0_14db = glbSoundBlasterBasePort;
	if (glbSoundBlasterBasePort != 0 && (glbSoundCardType == 3 || glbSoundCardType == 5)) {
		//^01B0:136D
	}
	//^01B0:1383
	_01b0_13be = _sys_getvect(0x08);
	_sys_setvect(0x08, &SkWinCore::_INT08_HANDLER);
	//^01B0:13A3
	X16 bp02 = 0x136b;
	_01b0_13c2 = _01b0_13c8 = bp02;
	glbSoundFreq_13ce = 0x180c;	// 0x180c = 6156
	//^01B0:13BB
	//^01B0:188F
	return;
}
//^01B0:1893
void SkWinCore::IBMIO_UNINIT_TIMER()
{
	//^01B0:1893
	ENTER(0);
	//^01B0:1896
	_04bf_0284 = 0;
	//^01B0:189C
	while (sndLockSoundBuffer != 0) {
#if UseAltic
		sndLockSoundBuffer = 0;
#endif
	}
	//^01B0:18A4
	outportb(0x43,0x36);
	outportb(0x40,0);
	outportb(0x40,0);
	_sys_setvect(0x08, _01b0_13be);
	_01b0_13ca = 0;
	outportb(0x61,inport(0x61) & 0xfc);
	//^01B0:18D1
	return;
}
//^01B0:0A39
void SkWinCore::IBMIO_UNINIT_MOUSE()
{
	//^01B0:0A39
	ENTER(0);
	//^01B0:0A3C
	if (_04bf_03d4 != 0) {
		//^01B0:0A45
		_04bf_03d4 = 0;
		_04bf_03c6 = 0;
		_int33_mouse_callback = _01b0_092d;
		//^01B0:0A65
	}
	//^01B0:0A68
	return;
}
//^01B0:04BF
void SkWinCore::IBMIO_UNINIT_KBOARD_HOOK()
{
	//^01B0:04BF
	ENTER(0);
	//^01B0:04C2
	if (_04bf_02bc != 0) {
		//^01B0:04C9
		_04bf_02bc = 0;
		_sys_setvect(0x09, _01b0_0453);
	}
	//^01B0:04E2
	return;
}
//^00EB:0C4C
i16 SkWinCore::IBMIO_UNINIT_VID()
{
#if UseAltic
	return 0;
#else
	//^00EB:0C4C
	ENTER(0);
	//^00EB:0C4F
	__asm mov al,_04bf_09de
	__asm int 0x10
	//^00EB:0C56
	return;
#endif
}

void SkWinCore::zeroMem(void *pv, size_t cb) {
	memset(pv, 0, cb);
}

void SkWinCore::_04bf_0102() { // TODO: Unr
	Unr();
}

//^01B0:2C48
// SPX: _01b0_2c48 replaced by IBMIO_MAIN
i16 SkWinCore::IBMIO_MAIN(i16 argc, char **argv, char **env) //#DS=04BF
{
	// IBMIO_main

	//^01B0:2C48
	ENTER(172);
	//^01B0:2C4E
	U8 bp5c[80] = {0};
	_04bf_17aa = IBMIO_CHECK_CPU_ERA();
	if (_04bf_17aa < 286) {
		//^01B0:2C71
		IBMIO_PRINT_ERROR(strPC286Required);
		_0088_020b(0);
	}
	//^01B0:2C83
	i16 si;
	for (si = 1; si < argc; si++) {
		//^01B0:2C89
		if (argv[si][0] == '+') {
			//^01B0:2C9F
			X16 bp0a;
			X16 bp06;
			X16 bp0c;
			switch (bp0a = SK88_TOUPPER(U8(argv[si][1]))) {
			case 'S'://^2CD5
				//^01B0:2CD5
				switch (SK88_TOUPPER(U8(argv[si][2]))) {
				case 'I'://^2D03
					//^01B0:2D03
					glbSoundCardType = ScardTandy;
					break;
				case 'N'://^2D0C
					//^01B0:2D0C
					glbSoundCardType = 1;
					break;
				case 'T'://^2D15
					//^01B0:2D15
					glbSoundCardType = 4;
					break;
				case 'D'://^2D1E
					//^01B0:2D1E
					glbSoundCardType = 5;
					bp06 = SK88_TOUPPER(argv[si][3]);
					if (bp06 >= '1' && bp06 <= '3') {
						//^01B0:2D4D
						glbSoundBlasterBasePort = _04bf_05f9[RCJ(18,bp06)];
					}
					//^01B0:2D59
					outportb(glbSoundBlasterBasePort +2, inportb(glbSoundBlasterBasePort +2));
					break;
				case 'B'://^2D67
					//^01B0:2D67
					glbSoundBlasterBasePort = IBMIO_DETECT_SBLASTER();
					if (glbSoundBlasterBasePort != 0)
						//^01B0:2D75
						glbSoundCardType = ScardSBlaster;
					break;
				case 'A'://^2D7E
					//^01B0:2D7E
					glbSoundBlasterBasePort = 0x388;
					_04bf_0e4e = 0x388;
					glbSoundCardType = 7;
					break;
				case 'F'://^2D90
					//^01B0:2D90
					glbSoundCardType = 3;
					bp06 = SK88_TOUPPER(argv[si][3]);
					if (bp06 >= '1' && bp06 <= '3')
						//^01B0:2DC5
						glbSoundBlasterBasePort = _04bf_05f9[RCJ(18,bp06)];
					break;
				case 67://^2EAF
				case 69://^2EAF
				case 71://^2EAF
				case 72://^2EAF
				case 74://^2EAF
				case 75://^2EAF
				case 76://^2EAF
				case 77://^2EAF
				case 79://^2EAF
				case 80://^2EAF
				case 81://^2EAF
				case 82://^2EAF
				case 83://^2EAF
					break;
				}
				break;
			case 'P'://^2DD4
				//^01B0:2DD4
				switch (bp0c = SK88_TOUPPER(argv[si][2])) {
				case 'P'://^2E0A
					//^01B0:2E0A
					glbPType = 2;
					break;
				case 'A'://^2E12
					//^01B0:2E12
					glbPType = 1;
					if (argv[si][3] != 0) {
						//^01B0:2E2C
						_04bf_0296 = argv[si][3] -0x30;
						if (_04bf_0296 >= 0 && _04bf_0296 <= 7) {
							//^01B0:2E53
							_04bf_0298 = _04bf_029c[RCJ(8,_04bf_0296)];
							_04bf_029a = _04bf_02ac[RCJ(8,_04bf_0296)];
							break;
						}
						//^01B0:2E6F
						_04bf_0296 = 0;
						break;
					}
					break;
				case 'K'://^2E77
					//^01B0:2E77
					glbPType = 3;
					break;
				case 'M'://^2E7F
					//^01B0:2E7F
					glbPType = 4;
					break;
				}
				goto _2e85;
			case 'M'://^2E85
				//^01B0:2E85
_2e85:
				SK88_TOUPPER(argv[si][2]);
				break;
			case 'Z'://^2EA1
				//^01B0:2EA1
				glbZMode = 0;
				break;
			case 'D'://^2EA9
				//^01B0:2EA9
				glbDMode = 1;
				break;
			}
		}
		//^01B0:2EAF
	}
	//^01B0:2EB8
	IBMIO_INIT_VID();
	_crt88_setvect(0xfe, &SkWinCore::_04bf_0102);
	si = 2;
	i16 di = 0;
	for (; si < argc; bp5c[di] = 0, si++) {
		//^01B0:2ED3
		if (di > 1) {
			//^01B0:2ED8
			bp5c[di++] = 0x20;
		}
		//^01B0:2EDD
		i16 bp04 = 0;
		X8 bp01;
		for (; bp04 < 0x50; bp5c[di] = bp01, di++, bp04++) {
			//^01B0:2EE4
			bp01 = argv[si][bp04];
			if (bp01 == 0)
				break;
			//^01B0:2EFE
		}
		//^01B0:2F0E
	}
	//^01B0:2F18
	X16 bp08;
	if (glbPType == 0 || glbPType == 4) {
		//^01B0:2F26
		bp08 = IBMIO_INIT_MOUSE();
		if (bp08 != 0) {
			//^01B0:2F31
			glbPType = 4;
		}
		else {
			//^01B0:2F39
			glbPType = 3;
		}
	}
	do {
		//^01B0:2F3F
		INIT_KBOARD_HOOK();
		_01b0_08d8();
		if (glbPType == 4 && bp08 != 0)
			IBMIO_SET_MOUSE_HANDLER();
		//^01B0:2F58
		IBMIO_INIT_TIMER();
		if (glbZMode != 0) {
			//^01B0:2F66
			U8 bp00ac[80];
			SK88_STRCPY(bp00ac, _04bf_01b2[RCJ(4,_04bf_0280)].b14);
			SK88_STRCAT(bp00ac, _04bf_067a);
			SK88_STRCAT(bp00ac, bp5c);
			if (_04bf_01b2[RCJ(4,_04bf_0280)].b0[0] == '@') {
				//^01B0:2FB7
				si = IBMIO_EXEC(reinterpret_cast<U8 *>(argv[_04bf_01b2[RCJ(4,_04bf_0280)].b0[1] -'0']), bp00ac);
			}
			else {
				//^01B0:2FE1
				si = IBMIO_EXEC(&_04bf_01b2[RCJ(4,_04bf_0280)].b0[0], bp00ac);
			}
			//^01B0:2FFD
			if (_04bf_01b2[RCJ(4,_04bf_0280)].b46 < si)
				si = 0;
			//^01B0:3013
			_04bf_0280 = _04bf_01b2[RCJ(4,_04bf_0280)].b47 -1;
		}
		else {
			//^01B0:3029
			IBMIO_EXEC(reinterpret_cast<U8 *>(argv[1]), bp5c);
		}
		//^01B0:3040
		_01b0_18d3(0);
		if (glbSoundCardType == 5) {
			//^01B0:304E
			outportb(glbSoundBlasterBasePort +2, inportb(glbSoundBlasterBasePort +2) | 8);
		}
		//^01B0:3059
		IBMIO_UNINIT_TIMER();
		if (glbPType == 4 && bp08 != 0)
			//^01B0:306A
			IBMIO_UNINIT_MOUSE();
		//^01B0:306E
		IBMIO_UNINIT_KBOARD_HOOK();
		//^01B0:3072
	} while (_04bf_0280 > 0);
	//^01B0:307C
	return IBMIO_UNINIT_VID();
}

//^0088:0000
int SkWinCore::IBMIO_BOOTSTRAP()
{
	//^0088:0000
	// 065B:01DA  EE 01 5B 06/FB 01 5B 06/04 02 5B 06/08 02 5B 06  E[.E[...[...[.
	// 065B:01EA  00 00 00 00 43 3A 5C 49 42 4D 49 4F 2E 45 58 45  ....C:\IBMIO.EXE
	// 065B:01FA  00 46 49 52 45 2E 45 58 45 00 2B 70 6D 00 2B 73  .FIRE.EXE.+pm.+s
	// 065B:020A  62 00 BE 04 00 00 5A 00 00 82 99 00 00 00 44 4D  b....Z.....DM
	char *argv[] = {"IBMIO.exe", "FIRE.exe", "+pm", "+sb"};
	try {
		return (IBMIO_MAIN(4, argv, NULL));
	}
	catch (i8) { // termination request at message loop
		return 1;
	}
	//^0088:0215
}

void SkWinCore::_sys_intr() {
}

//}}SKSAVE_PUB_PROC





SkWinCore::SkWinCore() 
{
	//{{INIT_SKVAL1
#include "skval1.h"
	//}}INIT_SKVAL1

#pragma warning(push)
#pragma warning(disable: 4309)
#include "skval2.h"
#pragma warning(pop)

	//{{INIT_INSORTED
	__vram = pbVram = vram;
	for (int x=0; x<256; x++)
		intrvect[x] = &SkWinCore::_sys_intr;
	_int33_mouse_callback = &SkWinCore::_sys_intr;

	_4976_0cba[ 0] = &SkWinCore::RETURN_1;
	_4976_0cba[ 1] = &SkWinCore::IS_GAME_ENDED;
	_4976_0cba[ 2] = &SkWinCore::_1031_0023;
	_4976_0cba[ 3] = &SkWinCore::_1031_003e;
	_4976_0cba[ 4] = &SkWinCore::_1031_007b;
	_4976_0cba[ 5] = &SkWinCore::_1031_009e;
	_4976_0cba[ 6] = &SkWinCore::_1031_00c5;
	_4976_0cba[ 7] = &SkWinCore::_1031_00f3;
	_4976_0cba[ 8] = &SkWinCore::_1031_012d;
	_4976_0cba[ 9] = &SkWinCore::_1031_014f;
	_4976_0cba[10] = &SkWinCore::_1031_0184;
	_4976_0cba[11] = &SkWinCore::_1031_01ba;

	_4976_38a4[ 0] = &SkWinCore::_14cd_18cc;
	_4976_38a4[ 1] = &SkWinCore::_14cd_19a4;
	_4976_38a4[ 2] = &SkWinCore::_14cd_1a3c;
	_4976_38a4[ 3] = &SkWinCore::_14cd_1a5a;
	_4976_38a4[ 4] = &SkWinCore::_14cd_1b74;
	_4976_38a4[ 5] = &SkWinCore::_14cd_1b90;
	_4976_38a4[ 6] = &SkWinCore::_14cd_1c27;
	_4976_38a4[ 7] = &SkWinCore::_14cd_1c45;
	_4976_38a4[ 8] = &SkWinCore::_14cd_1c63;
	_4976_38a4[ 9] = &SkWinCore::_14cd_1c8d;
	_4976_38a4[10] = &SkWinCore::_14cd_1cec;
	_4976_38a4[11] = &SkWinCore::_14cd_1d42;
	_4976_38a4[12] = &SkWinCore::_14cd_1e36;
	_4976_38a4[13] = &SkWinCore::_14cd_1e52;
	_4976_38a4[14] = &SkWinCore::_14cd_1e6e;
	_4976_38a4[15] = &SkWinCore::_14cd_1f8b;
	_4976_38a4[16] = &SkWinCore::_14cd_1fa7;
	//}}INIT_INSORTED

	_4976_5d00 = NULL;
	_4976_5ea0 = NULL;
	glbLangageLetterIndex = 0;
	_4976_5c9c = 0;
	_4976_5ca8 = 0;
	_4976_4839 = 0;
	_4976_483b = 0;
	zeroMem(&glbGDatEntries, sizeof(glbGDatEntries));
	_4976_480d = 0;
	_4976_5d34 = 0;
	_4976_5d58 = 0;
	_4976_5cae = 0;
	zeroMem(&glbRectNoTable, sizeof(glbRectNoTable));
	_4976_4ba4	 = 0;
	_4976_4968 = 1; // EMS is always avail.
	_4976_00f6 = 224;
	_4976_00f8 = 136;
	_4976_0126 = 6;
	_4976_013e = 320;
	_4976_0140 = 15;
	_4976_0198 = 0; // temp index always 0 (_4976_4b84)
	zeroMem(&_4976_4bca, sizeof(_4976_4bca));
	_4976_4bc8 = 0;
	_4976_0106 = 16; // cx
	_4976_0108 = 16; // cy
	_04bf_0e7a = 0; //?
	_04bf_17a4 = 0; //?
	_04bf_09e0.x = 0; _04bf_09e0.y = 0; _04bf_09e0.cx = 0xc; _04bf_09e0.cy = 0x10;
	_04bf_09e8.x = 0; _04bf_09e8.y = 0; _04bf_09e8.cx = 0xc; _04bf_09e8.cy = 0x10;
	_4976_19ad = 0; //?
	glbGameTick = 0;
	_4976_5d2a = -1;
	_4976_5d76 = 0; //?
	_4976_5cfc.pv0 = NULL; //?
	_4976_5cf8 = 0;
	_4976_4ba6 = 0; // temp idx be 0
	glbScreenWidth = 320;	// Screen width
	glbScreenHeight = 200;	// Screen height
	_4976_4964 = NULL;
	glbMouseVisibility = 1;	// (_4976_4860)
	_04bf_0e7a = 0;
	glbMouseXPos = glbMouseYPos = 0;
	zeroMem(&_04bf_1852, sizeof(_04bf_1852));
	_04bf_17a8 = 0;
	glbMouseCursorVisible = 0;
	_04bf_1886 = 0; //?
	glbDMode = 0;
	_04bf_0284 = 0;
	_04bf_0280 = 0;
	_04bf_03d4 = 0;
	_01b0_0933 = 0;
	_01b0_14d8 = 0;
	glbZMode = 1;
	_4976_04ee = 0;
	sndSoundInBuffer = 0;		// (_01b0_13d6)
	sndLockSoundBuffer = 0;
	sndSoundBufferSize = 0;
	sndSoundBuffer = NULL;
	_04bf_17e8 = 0;
	_4976_19a5 = 10;
	glbCounterZero_0517 = 0;
	glbSomeCounter_0519 = 0;
	_01b0_13c6 = 0;
	_04bf_18ae = NULL;
	_04bf_179e = NULL;
	_4976_4ea6 = 0;
	_4976_4e00 = 0;
	_4976_4dfe = 0;
	_4976_4e46 = 0;
	glbAbsoluteTickCounter = 0;
	_4976_19a9 = -1;
	_4976_4e64 = 0;
	_4976_4e96 = NULL;
	glbHoldedContainerType = 0;
	_4976_53a4 = 0;
	zeroMem(glbItemSelected, sizeof(glbItemSelected));
	glbMagicalMapFlags = 0;
	_4976_4e96 = NULL;
	zeroMem(&glbMousePosition, sizeof(glbMousePosition));
	glbMousePosition.XPos = -1;
	zeroMem(&_4976_4e9e, sizeof(_4976_4e9e));
	zeroMem(_4976_4e6c, sizeof(_4976_4e6c));
	_4976_4ddc = 0;
	_4976_5efa = NULL;
	zeroMem(&_4976_5dae, sizeof(_4976_5dae));
	_4976_5bf2 = 0;
	_4976_3b5d = 1;
	zeroMem(glbIngameGlobVarFlags, sizeof(glbIngameGlobVarFlags));
	zeroMem(glbIngameGlobVarBytes, sizeof(glbIngameGlobVarBytes));
	zeroMem(glbIngameGlobVarWords, sizeof(glbIngameGlobVarWords));
	_4976_47fc = 1;
	_4976_4762 = -1;
	_4976_4c08 = 0;
	_4976_4c12 = 0;
	glbCurrentMapIndex = -1;
	_4976_4c04 = 0;
	_4976_4c1e = 0;
	_4976_4c12 = 0;
	_4976_4c10 = 0;
	_4976_0118 = 0x11;
	_4976_011a = 0x11;
	glbChampionsCount = 0;
	_4976_0124 = 1;
	_4976_00f4 = 0x7700;
	glbFreeRAMMemPool = 0;
	_4976_0132 = 1;
	zeroMem(_4976_5bf8, sizeof(_4976_5bf8));
	zeroMem(_4976_5bfa, sizeof(_4976_5bfa));
	_4976_0120 = 1;
	_4976_011e = 6;
	_4976_475e = 0xff;
	glbPanelStatsYDelta = 7;
	zeroMem(_4976_4c42, sizeof(_4976_4c42));
	zeroMem(glbMoneyItemsValueTable, sizeof(glbMoneyItemsValueTable));
	zeroMem(glbMoneyItemsIDTable, sizeof(glbMoneyItemsIDTable));
	zeroMem(&_4976_5d12, sizeof(_4976_5d12));
	zeroMem(&_4976_5d7e, sizeof(_4976_5d7e));
	zeroMem(&_4976_5bee, sizeof(_4976_5bee));
	zeroMem(glbMapDoorType, sizeof(glbMapDoorType));
	zeroMem(&_4976_3f6c, sizeof(_4976_3f6c)); _4976_3f6c.w0 = -1;
	_04bf_1938 = 0;
	zeroMem(glbChampionTable, sizeof(glbChampionTable));
	zeroMem(&glbMousePosition, sizeof(glbMousePosition));
	zeroMem(&glbTempPicture, sizeof(glbTempPicture));
	zeroMem(&_4976_3ff0, sizeof(_4976_3ff0)); _4976_3ff0.w0 = -1;
	zeroMem(_04bf_0e80, sizeof(_04bf_0e80));
	_04bf_17a2 = 0;
	_4976_5da4 = NULL;
	zeroMem(_4976_4e02, sizeof(_4976_4e02));
	zeroMem(_4976_4d1a, sizeof(_4976_4d1a));
	glbSquadInterfaceMapGfxSet = -1;
	glbMapGraphicsSet = -1;
	_4976_532c = 0;
	zeroMem(&_4976_495c, sizeof(_4976_495c));
	zeroMem(_4976_4df6, sizeof(_4976_4df6));
	zeroMem(&glbLeaderHandPossession, sizeof(glbLeaderHandPossession));
	zeroMem(glbChampionsPendingDamage, sizeof(glbChampionsPendingDamage));
	_4976_4942.x = 2; _4976_4942.y = 2; _4976_4942.cx = 16; _4976_4942.cy = 16;
	_4976_494a.x = 0; _4976_494a.y = 0; _4976_494a.cx = 16; _4976_494a.cy = 16;
	_4976_0ce0[0].pv6(NULL);
	zeroMem(_4976_4954, sizeof(_4976_4954));
	glbMemWalkPath = NULL;
	zeroMem(_4976_4fee, sizeof(_4976_4fee));
	_4976_00fe.x = 21; _4976_00fe.y = 8; _4976_00fe.cx = 182; _4976_00fe.cy = 110;

	// SPX : Default champion colors are : 7 (green), 11 (yellow), 8 (red), 14 (blue)
	glbChampionColor[0] = COLOR_LIGHT_GREEN;
	glbChampionColor[1] = COLOR_YELLOW;
	glbChampionColor[2] = COLOR_RED;
	glbChampionColor[3] = COLOR_BLUE;

	mice_x = mice_y = mice_btn = 0;
	_01b0_3378 = 0;
	glbItemStatBarPos.pos[0] = 0x270; glbItemStatBarPos.pos[1] = 0x271;
	zeroMem(&_4976_514e, sizeof(_4976_514e));
	zeroMem(_4976_522e, sizeof(_4976_522e));
	zeroMem(glbCurrentContainerItems, sizeof(glbCurrentContainerItems));
	zeroMem(glbChampionHandCoolingDown, sizeof(glbChampionHandCoolingDown));
	zeroMem(glbChampionAlive, sizeof(glbChampionAlive));
	zeroMem(&_4976_53a6, sizeof(_4976_53a6));
	zeroMem(glbChampionsBodyFlags, sizeof(glbChampionsBodyFlags));
	zeroMem(_4976_4fd8, sizeof(_4976_4fd8));
	zeroMem(&glbGlobalSpellEffects, sizeof(glbGlobalSpellEffects));
	zeroMem(&_4976_5c2a, sizeof(_4976_5c2a));
	zeroMem(_089c_02c0, sizeof(_089c_02c0));
	zeroMem(_089c_025a, sizeof(_089c_025a));
	zeroMem(_089c_0090, sizeof(_089c_0090)); _089c_0090[0] = -1;
	_089c_00d0.x = 0; _089c_00d0.y = 0; _089c_00d0.cx = 320; _089c_00d0.y = 200;
	tickThen = -1;
}




//SPX: move this to SkWinMain
#if defined(_USE_MFC80) || defined(_USE_MFC60)
int main(int argc, char **argv)
{
	int r = 1;
	HRESULT hr;
	if (AfxWinInit(GetModuleHandle(NULL), NULL, GetCommandLine(), SW_SHOW)) {
		if (SUCCEEDED(hr = CoInitialize(NULL))) {
			int f = skwin.sxfact;
			CRect rc(0, 0, 320 * f, 200 * f);
			AdjustWindowRectEx(&rc, WS_OVERLAPPEDWINDOW, true, 0);
			rc.OffsetRect(-rc.left, -rc.top);
			if (skwin.CreateEx(0, AfxRegisterWndClass(0, AfxGetApp()->LoadCursor(IDC_POINTER), (HBRUSH)GetStockObject(BLACK_BRUSH), NULL), "skwin", WS_OVERLAPPEDWINDOW, rc, NULL, 0, NULL)) {
				skwin.ShowWindow(SW_SHOWDEFAULT);

				SkWinCore a;
				skwin.ProcessArgs(argc, argv);
				r = a.IBMIO_BOOTSTRAP();

				skwin.DestroyWindow();
			}
		}
	}
	return r;
}
#endif // defined(_USE_MFC80) || defined(_USE_MFC60)

#ifdef _USE_SDL
int main(int argc, char **argv)
{
	if (SDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO) < 0)
		return 1;

	if (!skwin.CreateSurface())
		return 1;
	skwin.OpenAudio();

	SkWinCore a;
	int r = a.IBMIO_BOOTSTRAP();

	skwin.CloseAudio();
	SDL_Quit();
	return r;
}
#endif // _USE_SDL
